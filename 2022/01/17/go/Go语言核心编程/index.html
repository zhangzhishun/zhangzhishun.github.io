<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>《Go语言核心编程》笔记</title><meta name="description" content="Blockchain knowledge record blog"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + 'e574a92bc4bac2e317309d7ea1dfcb71';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="/images/system/head_portrait.jpg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="第 1 章 基础知识1.1 语言简介1.1.1 Go语言的诞生背景
当前编程语言对并发的支持不是很好，不能很好地发挥多核CPU的威力
程序规模越来越大，编译速度越来越慢
现有的编程语言设计越来越复杂，某些特性的实现不怎么优雅

1.1.3 Go语言的特性

1.3 Go词法单元1.3.1 tokentoken是构成源程序的基本不可再分割的单元。
编译器编译源程序的第一步就是将源程序分割成一个个独立的token，这个过程就是词法分析。
Go语言的token可以分为关键字、标识符、操作符、分隔符和字面常量

1.3.2 标识符
标识符用来标识变量、类型、常量等语法对象的符号名称，其在语法分析时作为一个token存在。
标识符分为两类：
语言设计者预留的标识符：语言设计者确定，包括语言的预声明标识符及保留字
编程.."><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Sugar's blog" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Sugar's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">《Go语言核心编程》笔记</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/works">Works</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/works">Works</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">第 1 章 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B"><span class="toc-text">1.1 语言简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-Go%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%9E%E7%94%9F%E8%83%8C%E6%99%AF"><span class="toc-text">1.1.1 Go语言的诞生背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-Go%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">1.1.3 Go语言的特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Go%E8%AF%8D%E6%B3%95%E5%8D%95%E5%85%83"><span class="toc-text">1.3 Go词法单元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-token"><span class="toc-text">1.3.1 token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">1.3.2 标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88operators%EF%BC%89%E5%92%8C%E5%88%86%E9%9A%94%E7%AC%A6%EF%BC%88delimiters%EF%BC%89"><span class="toc-text">1.3.3 操作符（operators）和分隔符（delimiters）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F"><span class="toc-text">1.3.4 字面常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="toc-text">1.4 变量和常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E5%8F%98%E9%87%8F"><span class="toc-text">1.4.1 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E5%B8%B8%E9%87%8F"><span class="toc-text">1.4.2 常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.5 基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-4-%E5%A4%8D%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.5.4 复数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-6-rune%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.5.6 rune类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.6 复合数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E6%8C%87%E9%92%88"><span class="toc-text">1.6.1 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E6%95%B0%E7%BB%84"><span class="toc-text">1.6.2 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-3-%E5%88%87%E7%89%87"><span class="toc-text">1.6.3 切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-4-map"><span class="toc-text">1.6.4 map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-5-struct"><span class="toc-text">1.6.5 struct</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-text">1.7 控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-1-if-%E8%AF%AD%E5%8F%A5"><span class="toc-text">1.7.1 if 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-2-switch-%E8%AF%AD%E5%8F%A5"><span class="toc-text">1.7.2 switch 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-3-for-%E8%AF%AD%E5%8F%A5"><span class="toc-text">1.7.3 for 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-4-%E6%A0%87%E7%AD%BE%E5%92%8C%E8%B7%B3%E8%BD%AC"><span class="toc-text">1.7.4 标签和跳转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="toc-text">第 2 章 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">2.1 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1.1 函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E5%A4%9A%E5%80%BC%E8%BF%94%E5%9B%9E"><span class="toc-text">2.1.2 多值返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E5%AE%9E%E5%8F%82%E5%88%B0%E5%BD%A2%E5%8F%82%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">2.1.3 实参到形参的传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0"><span class="toc-text">2.1.4 不定参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E5%92%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">2.2 函数签名和匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D"><span class="toc-text">2.2.1 函数签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">2.2.2 匿名函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-defer"><span class="toc-text">2.3 defer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E9%97%AD%E5%8C%85"><span class="toc-text">2.4 闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E9%97%AD%E5%8C%85%E7%9A%84%E4%BB%B7%E5%80%BC"><span class="toc-text">2.4.2 闭包的价值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-panic%E5%92%8Crecover"><span class="toc-text">2.5 panic和recover</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">2.5.1 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.5.2 使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">2.6 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-error"><span class="toc-text">2.6.1 error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-text">2.6.2 错误和异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.7 底层实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-text">第 3 章 类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="toc-text">3.1 类型简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%91%BD%E5%90%8D%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%9C%AA%E5%91%BD%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.1.1 命名类型和未命名类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E5%BA%95%E5%B1%82%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.1.2 底层类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%90%8C%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%B5%8B%E5%80%BC"><span class="toc-text">3.1.3 类型相同和类型赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.1.4 类型强制转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">3.2 类型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.2.1 自定义类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E6%96%B9%E6%B3%95"><span class="toc-text">3.2.2 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-text">3.3 方法调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E4%B8%80%E8%88%AC%E8%B0%83%E7%94%A8"><span class="toc-text">3.3.1 一般调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%96%B9%E6%B3%95%E5%80%BC"><span class="toc-text">3.3.2 方法值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E6%96%B9%E6%B3%95%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">3.3.3 方法表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E6%96%B9%E6%B3%95%E9%9B%86"><span class="toc-text">3.3.4 方法集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-5-%E5%80%BC%E8%B0%83%E7%94%A8%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E9%9B%86"><span class="toc-text">3.3.5 值调用和表达式调用的方法集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%BB%84%E5%90%88%E5%92%8C%E6%96%B9%E6%B3%95%E9%9B%86"><span class="toc-text">3.4 组合和方法集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E7%BB%84%E5%90%88"><span class="toc-text">3.4.1 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E7%BB%84%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95%E9%9B%86"><span class="toc-text">3.4.2 组合的方法集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.5 函数类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E6%8E%A5%E5%8F%A3%EF%BC%88%E6%9C%AA%E7%9C%8B%EF%BC%89"><span class="toc-text">第 4 章 接口（未看）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E5%B9%B6%E5%8F%91"><span class="toc-text">第 5 章 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="toc-text">5.1 并发基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-text">5.1.1 并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-goroutine"><span class="toc-text">5.1.2 goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-chan"><span class="toc-text">5.1.3 chan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-WaitGroup"><span class="toc-text">5.1.4 WaitGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-5-select"><span class="toc-text">5.1.5 select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-6-%E6%89%87%E5%85%A5%EF%BC%88Fan-in%EF%BC%89%E5%92%8C%E6%89%87%E5%87%BA%EF%BC%88Fan-out%EF%BC%89"><span class="toc-text">5.1.6 扇入（Fan in）和扇出（Fan out）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-7-%E9%80%9A%E7%9F%A5%E9%80%80%E5%87%BA%E6%9C%BA%E5%88%B6"><span class="toc-text">5.1.7 通知退出机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%B9%B6%E5%8F%91%E8%8C%83%E5%BC%8F"><span class="toc-text">5.2 并发范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">5.2.1 生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E7%AE%A1%E9%81%93"><span class="toc-text">5.2.2 管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E6%AF%8F%E4%B8%AA%E8%AF%B7%E6%B1%82%E4%B8%80%E4%B8%AAgoroutine"><span class="toc-text">5.2.3 每个请求一个goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E5%9B%BA%E5%AE%9Aworker%E5%B7%A5%E4%BD%9C%E6%B1%A0"><span class="toc-text">5.2.4 固定worker工作池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5-future%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.2.5 future模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-context%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-text">5.3 context标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-context%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84"><span class="toc-text">5.3.1 context的设计目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">5.3.2 基本数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-API%E5%87%BD%E6%95%B0"><span class="toc-text">5.3.3 API函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-6-%E4%BD%BF%E7%94%A8Context%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%89%E8%AE%AE"><span class="toc-text">5.3.6 使用Context传递数据的争议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-text">5.4 并发模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-CSP%E7%AE%80%E4%BB%8B"><span class="toc-text">5.4.1 CSP简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-text">5.4.2 调度模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E5%B9%B6%E5%8F%91%E5%92%8C%E8%B0%83%E5%BA%A6"><span class="toc-text">5.4.3 并发和调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E8%AF%AD%E8%A8%80%E9%99%B7%E9%98%B1"><span class="toc-text">第 7 章 语言陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%A4%9A%E5%80%BC%E8%B5%8B%E5%80%BC%E5%92%8C%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">7.1 多值赋值和短变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E5%A4%9A%E5%80%BC%E8%B5%8B%E5%80%BC"><span class="toc-text">7.1.1 多值赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E7%9F%AD%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-text">7.1.2 短变量的声明和赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-range%E5%A4%8D%E7%94%A8%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F"><span class="toc-text">7.2 range复用临时变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-defer%E9%99%B7%E9%98%B1"><span class="toc-text">7.3 defer陷阱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E5%88%87%E7%89%87%E5%9B%B0%E6%83%91"><span class="toc-text">7.4 切片困惑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-%E6%95%B0%E7%BB%84"><span class="toc-text">7.4.1 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-%E5%88%87%E7%89%87"><span class="toc-text">7.4.2 切片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E5%80%BC%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-text">7.5 值、指针和引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8"><span class="toc-text">7.5.1 传值还是传引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-%E5%87%BD%E6%95%B0%E5%90%8D%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">7.5.2 函数名的意义</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Go"><i class="tag post-item-tag">Go</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">《Go语言核心编程》笔记</h1><time class="has-text-grey" datetime="2022-01-17T02:29:15.000Z">2022-01-17</time><article class="mt-2 post-content"><h1 id="第-1-章-基础知识"><a href="#第-1-章-基础知识" class="headerlink" title="第 1 章 基础知识"></a>第 1 章 基础知识</h1><h2 id="1-1-语言简介"><a href="#1-1-语言简介" class="headerlink" title="1.1 语言简介"></a>1.1 语言简介</h2><h3 id="1-1-1-Go语言的诞生背景"><a href="#1-1-1-Go语言的诞生背景" class="headerlink" title="1.1.1 Go语言的诞生背景"></a>1.1.1 Go语言的诞生背景</h3><ul>
<li><strong>当前编程语言对并发的支持不是很好</strong>，不能很好地发挥多核CPU的威力</li>
<li>程序规模越来越大，<strong>编译速度越来越慢</strong></li>
<li>现有的<strong>编程语言设计越来越复杂</strong>，某些特性的实现不怎么优雅</li>
</ul>
<h3 id="1-1-3-Go语言的特性"><a href="#1-1-3-Go语言的特性" class="headerlink" title="1.1.3 Go语言的特性"></a>1.1.3 Go语言的特性</h3><p><img src="/images/go_core_programming/Untitled.png" alt="Untitled"></p>
<p><img src="/images/go_core_programming/Untitled%201.png" alt="Untitled"></p>
<h2 id="1-3-Go词法单元"><a href="#1-3-Go词法单元" class="headerlink" title="1.3 Go词法单元"></a>1.3 Go词法单元</h2><h3 id="1-3-1-token"><a href="#1-3-1-token" class="headerlink" title="1.3.1 token"></a>1.3.1 token</h3><p>token是构成源程序的基本不可再分割的单元。</p>
<p>编译器编译源程序的第一步就是将源程序分割成一个个独立的token，这个过程就是词法分析。</p>
<p>Go语言的token可以分为关键字、标识符、操作符、分隔符和字面常量</p>
<p><img src="/images/go_core_programming/Untitled%202.png" alt="Untitled"></p>
<h3 id="1-3-2-标识符"><a href="#1-3-2-标识符" class="headerlink" title="1.3.2 标识符"></a>1.3.2 标识符</h3><ol>
<li>标识符用来标识变量、类型、常量等语法对象的符号名称，其在语法分析时作为一个token存在。</li>
<li>标识符分为两类：<ul>
<li>语言设计者预留的标识符：语言设计者确定，包括语言的预声明标识符及保留字</li>
<li>编程者可以自定义的标识符：用户定义的变量名、常量名、函数名等</li>
</ul>
</li>
<li>标识符规则：开头一个字符必须是字母或下划线，区分大小写</li>
<li><strong>关键字（keywords，25个）</strong></li>
</ol>
<p><img src="/images/go_core_programming/Untitled%203.png" alt="Untitled"></p>
<ol>
<li><strong>内置数据类型标识符（20个）</strong></li>
</ol>
<p><img src="/images/go_core_programming/Untitled%204.png" alt="Untitled"></p>
<ol>
<li><strong>内置函数（15个）</strong></li>
</ol>
<p><img src="/images/go_core_programming/Untitled%205.png" alt="Untitled"></p>
<ol>
<li><strong>常量值标识符（4个）</strong></li>
</ol>
<p><img src="/images/go_core_programming/Untitled%206.png" alt="Untitled"></p>
<p>空白标识符： <code>_</code></p>
<h3 id="1-3-3-操作符（operators）和分隔符（delimiters）"><a href="#1-3-3-操作符（operators）和分隔符（delimiters）" class="headerlink" title="1.3.3 操作符（operators）和分隔符（delimiters）"></a>1.3.3 操作符（operators）和分隔符（delimiters）</h3><p>操作符包括运算符、现式的分隔符、其他语法辅助符号</p>
<h3 id="1-3-4-字面常量"><a href="#1-3-4-字面常量" class="headerlink" title="1.3.4 字面常量"></a>1.3.4 字面常量</h3><ol>
<li>Go的字面量出现在两个地方：<ul>
<li>用于常量和变量的初始化</li>
<li>用在表达式里或函数调用实参</li>
</ul>
</li>
<li>字面量分类：<ul>
<li>整型字面量</li>
<li>浮点型字面量</li>
<li>复数类型字面量</li>
<li>字符型字面量</li>
<li>字符串字面量</li>
</ul>
</li>
</ol>
<h2 id="1-4-变量和常量"><a href="#1-4-变量和常量" class="headerlink" title="1.4 变量和常量"></a>1.4 变量和常量</h2><h3 id="1-4-1-变量"><a href="#1-4-1-变量" class="headerlink" title="1.4.1 变量"></a>1.4.1 变量</h3><h3 id="1-4-2-常量"><a href="#1-4-2-常量" class="headerlink" title="1.4.2 常量"></a>1.4.2 常量</h3><h2 id="1-5-基本数据类型"><a href="#1-5-基本数据类型" class="headerlink" title="1.5 基本数据类型"></a>1.5 基本数据类型</h2><p>Go内置七类基本数据类型：</p>
<p><img src="/images/go_core_programming/Untitled%207.png" alt="Untitled"></p>
<p><img src="/images/go_core_programming/Untitled%208.png" alt="Untitled"></p>
<h2 id="1-5-4-复数类型"><a href="#1-5-4-复数类型" class="headerlink" title="1.5.4 复数类型"></a>1.5.4 复数类型</h2><p>Go语言内置的复数类型有两种，分别是complex64和complex128。复数的字面量表示和数学表示法一样。</p>
<p><img src="/images/go_core_programming/Untitled%209.png" alt="Untitled"></p>
<p><img src="/images/go_core_programming/Untitled%2010.png" alt="Untitled"></p>
<h3 id="1-5-6-rune类型"><a href="#1-5-6-rune类型" class="headerlink" title="1.5.6 rune类型"></a>1.5.6 rune类型</h3><p>Go内置两种字符类型：</p>
<ul>
<li>bute的字节类类型（byte是uint的别名）</li>
<li>表示Uniocode编码的字符rune（rune是int32类型的别名）</li>
</ul>
<h2 id="1-6-复合数据类型"><a href="#1-6-复合数据类型" class="headerlink" title="1.6 复合数据类型"></a>1.6 复合数据类型</h2><ol>
<li>复合数据类型就是由其他类型组合而成的类型。</li>
<li>Go基本的复合数据类型有：<ul>
<li><p>指针</p>
</li>
<li><p>数据</p>
</li>
<li><p>切片</p>
</li>
<li><p>字典（map）</p>
</li>
<li><p>通道</p>
</li>
<li><p>结构</p>
</li>
<li><p>接口</p>
<p><img src="/images/go_core_programming/Untitled%2011.png" alt="Untitled"></p>
</li>
</ul>
</li>
</ol>
<h3 id="1-6-1-指针"><a href="#1-6-1-指针" class="headerlink" title="1.6.1 指针"></a>1.6.1 指针</h3><ol>
<li>Go支持指针，声明类型为 <code>*T</code> ，Go支持多级指针 <code>**T</code> 。通过在变量名前加 <code>&amp;</code> 获取变量的地址。</li>
<li>指针的特点：<ul>
<li>在赋值语句中，<code>*T</code> 出现在 <code>=</code> 左边表示指针声明，<code>*T</code> 出现在 <code>=</code> 右边表示取指针指向的值（varName为变量名）。示例：<pre><code class="go">var a = 11
p := &amp;a // *p和a的值都是11
</code></pre>
</li>
<li>结构体指针访问结构体字段仍然使用 <code>.</code> 点操作符，Go语言没有 <code>-&gt;</code> 操作符，例如：<pre><code class="go">type User struct {
    name string
    age int
}
andes := User {
    name: "andes",
    age: 10,
}
p := &amp;andes

fmt.Println(p.name) // p.name通过"."操作符访问成员变量
</code></pre>
</li>
<li>Go不支持指针的运算  Go由于支持垃圾回收，如果支持指针运算则会给垃圾回收的实现带来很多不便。例如：  <img src="/images/go_core_programming/Untitled%2012.png" alt="Untitled"></li>
<li>函数中允许返回局部变量的地址  Go编译器使用”栈逃逸“机制将这种局部变量的空间分配在堆上，例如：  <img src="/images/go_core_programming/Untitled%2013.png" alt="Untitled"></li>
</ul>
</li>
</ol>
<h3 id="1-6-2-数组"><a href="#1-6-2-数组" class="headerlink" title="1.6.2 数组"></a>1.6.2 数组</h3><ol>
<li>数组的类型名是<code>[n]elementType</code>，n是数组长度，elementType是数组元素类型。</li>
</ol>
<p><img src="/images/go_core_programming/Untitled%2014.png" alt="Untitled"></p>
<ol>
<li>数组的特点：<ul>
<li>数组创建完长度就固定了，不可以再追加元素了</li>
<li>数组是值类型的，数组赋值或作为函数参数都是值拷贝</li>
<li>数组长度是数组类型的组成部分，<code>[10]int</code>和<code>[20]int</code>是不同的类型</li>
<li>可以根据数组创建切片</li>
</ul>
</li>
<li>数组相关操作：<ul>
<li><p>数组元素访问</p>
<p><img src="/images/go_core_programming/Untitled%2015.png" alt="Untitled"></p>
</li>
<li><p>数组长度</p>
<p><img src="/images/go_core_programming/Untitled%2016.png" alt="Untitled"></p>
</li>
</ul>
</li>
</ol>
<h3 id="1-6-3-切片"><a href="#1-6-3-切片" class="headerlink" title="1.6.3 切片"></a>1.6.3 切片</h3><p>Go语言的数组的定长性和值拷贝限制了其使用场景，Gp提供了另一种数据类型slice（切片），这是一种变长数组，其数据结构中有指向数组的指针，所以是一种引用类型。</p>
<p>例如：</p>
<pre><code class="go">type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
</code></pre>
<p>Go为切片维护三个元素：</p>
<ul>
<li>指向底层数组的指针</li>
<li>切片的元素数量</li>
<li>底层数组的容量</li>
</ul>
<p><img src="/images/go_core_programming/Untitled%2017.png" alt="Untitled"></p>
<ol>
<li>切片的创建<ul>
<li>由数组创建：创建语法<code>array[b:e]</code> ，表示创建一个包含e-b各元素额的切片，第一个元素是<code>array[b]</code>，最后一个元素是<code>array[e-1]</code> 。例如：  <img src="/images/go_core_programming/Untitled%2018.png" alt="Untitled"></li>
<li>通过内置函数<code>make</code>创建切片。<code>make</code>创建的切片各元素被默认为输出华为切片元素类型的零值。  <img src="/images/go_core_programming/Untitled%2019.png" alt="Untitled">  <img src="/images/go_core_programming/Untitled%2020.png" alt="Untitled"></li>
</ul>
<ol>
<li>切片支持的操作<ul>
<li>内置函数<code>len()</code>返回切片长度</li>
<li>内置函数<code>cap()</code>返回切片底层数组容量</li>
<li>内置函数<code>append()</code>对切片追加元素</li>
<li>内置函数<code>copy()</code>用于复制一个切片</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="1-6-4-map"><a href="#1-6-4-map" class="headerlink" title="1.6.4 map"></a>1.6.4 map</h3><p>Go语言内置的字典类型叫map。</p>
<p><code>map</code>类型的格式是：<code>map[K]T</code> ，其中K可以是任意可以进行比较的类型，T是值类型。</p>
<p><code>map</code>也是一种引用类型。</p>
<ol>
<li><code>map</code>的创建<ul>
<li>使用字面量创建，例如：  <img src="/images/go_core_programming/Untitled%2021.png" alt="Untitled"></li>
<li>使用内置的make函数创建，例如  <img src="/images/go_core_programming/Untitled%2022.png" alt="Untitled">  <img src="/images/go_core_programming/Untitled%2023.png" alt="Untitled"></li>
</ul>
</li>
<li><code>map</code>支持的操作<ul>
<li><p><code>map</code>的单个键值访问格式为<code>mapName[key]</code></p>
</li>
<li><p>可以使用<code>range</code>遍历一个<code>map</code>类型的变量，但不能保证每次迭代元素的顺序</p>
</li>
<li><p>删除<code>map</code>中的某个键值，<code>delete(mapName,key)</code> 。<code>delete</code>是内置函数，用来删除<code>map</code>中的某个键值对</p>
</li>
<li><p>可以使用内置的<code>len()</code> 函数返回<code>map</code>中的键值对数量</p>
<p>注意：</p>
</li>
<li><p>Go内置的<code>map</code>不是并发安全的，并发安全的<code>map</code>可以使用标准包<code>sync</code>中的map</p>
</li>
<li><p>不要直接修改<code>map value</code>内某个元素的值，如果想修改<code>map</code>的某个键值，则必须整理赋值</p>
</li>
</ul>
</li>
</ol>
<h3 id="1-6-5-struct"><a href="#1-6-5-struct" class="headerlink" title="1.6.5 struct"></a>1.6.5 struct</h3><p>Go中的struct类型和C类似，中文翻译为结构，由多个不同类型元素组合而成。</p>
<ul>
<li>struct结构中的类型可以是任意类型</li>
<li>struct的存储空间是连续的，其字段按照声明时的顺序存放（注意字段值之间有对齐要求）</li>
</ul>
<p>struct有两种形式：</p>
<ul>
<li>struct类型字面量</li>
<li>使用type声明的自定义struct类型</li>
</ul>
<ol>
<li>strct类型字面量 struct类型字面量的声明格式如下： <img src="/images/go_core_programming/Untitled%2024.png" alt="Untitled"></li>
<li>自定义struct类型 自定义struct类型声明格式如下： <img src="/images/go_core_programming/Untitled%2025.png" alt="Untitled"></li>
<li>struct类型变量的初始化，示例： <img src="/images/go_core_programming/Untitled%2026.png" alt="Untitled"></li>
<li>其他复合类型<ul>
<li>接口（Interface）</li>
<li>通道（chan）</li>
</ul>
</li>
</ol>
<h2 id="1-7-控制结构"><a href="#1-7-控制结构" class="headerlink" title="1.7 控制结构"></a>1.7 控制结构</h2><p>程序执行从本质上来说就是两种模式：顺序和跳转</p>
<h3 id="1-7-1-if-语句"><a href="#1-7-1-if-语句" class="headerlink" title="1.7.1 if 语句"></a>1.7.1 if 语句</h3><h3 id="1-7-2-switch-语句"><a href="#1-7-2-switch-语句" class="headerlink" title="1.7.2 switch 语句"></a>1.7.2 switch 语句</h3><h3 id="1-7-3-for-语句"><a href="#1-7-3-for-语句" class="headerlink" title="1.7.3 for 语句"></a>1.7.3 for 语句</h3><h3 id="1-7-4-标签和跳转"><a href="#1-7-4-标签和跳转" class="headerlink" title="1.7.4 标签和跳转"></a>1.7.4 标签和跳转</h3><ol>
<li>标签 Go语言使用标签（Lable）来标识一个语句的位置，用于goto、break、continue语句的跳转。标签的语法是： <img src="/images/go_core_programming/Untitled%2027.png" alt="Untitled"></li>
<li>goto goto语句用于函数的内部跳转，需要配合标签一起使用： <img src="/images/go_core_programming/Untitled%2028.png" alt="Untitled"> goto特点：<ul>
<li>goto语句只能在函数内跳转</li>
<li>goto语句不能跳过内部变量声明语句，这些变量在goto语句的标签语句处有事可见的</li>
<li>goto语句只能调到同级作用域或者上层作用域，不能跳到内部作用域</li>
</ul>
</li>
<li>break break用于函数内跳出for、switch、select语句的执行，有两种使用格式：<ul>
<li>单独使用：用于跳出break当前所在的for、switch、select语句的执行</li>
<li>和标签一起使用：用于跳出标签所标识的for、switch、select语句的执行，可用于跳出多重循环，但标签和break必须在同一个函数内，例如：  <img src="/images/go_core_programming/Untitled%2029.png" alt="Untitled"></li>
</ul>
</li>
<li>continue continue用于跳出for循环的本次迭代，跳到for循环的下一次迭代的post语句处执行，有两种使用格式：<ul>
<li><p>单独使用：跳出continue当前所在的for循环的本次迭代</p>
</li>
<li><p>和标签一起使用：跳出标签所标示的for语句的本次迭代，但标签和continue必须在同一个函数内，例如：</p>
<p><img src="/images/go_core_programming/Untitled%2030.png" alt="Untitled"></p>
</li>
</ul>
</li>
<li>return和函数调用 return语句也能引发控制流程的跳转，用于函数和方法的退出。</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p><code>slice</code> 和 <code>array</code> 区别</p>
<ul>
<li>创建方式不同：数组<code>var identifier [len]type</code> ；切片<code>var slice3 = []int{}</code></li>
<li><code>slice</code>的<code>array</code>实际上是数组的指针，所以作为函数参数传递时不同：数组传递的是数组的副本；<code>slice</code>传递的是数组的指针</li>
<li>长度是否固定：数组长度固定；切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大</li>
</ul>
</li>
<li><p>struct能不能比较？<a target="_blank" rel="noopener" href="https://juejin.cn/post/6881912621616857102">https://juejin.cn/post/6881912621616857102</a> </p>
</li>
<li><p>slice，len，cap，共享，扩容</p>
</li>
<li><p>for 循环遍历 slice 有什么问题</p>
<ul>
<li>for rang A，是对A的值拷贝，问题代码：<pre><code class="go">func TestName(t *testing.T) {
    s :=[]int{1,2,3,4}
    m :=make(map[int]*int)

    for k,v:=range s{
        m[k]= &amp;v
    }
    for key, value := range m {
        fmt.Printf("map[%v]=%v\n", key, *value)
    }

    fmt.Println(m)
}
</code></pre>
  改正：<pre><code class="go">func TestName(t *testing.T) {
    s := []int{1, 2, 3, 4}
    m := make(map[int]*int)

    for k, v := range s {
        // 这里变动
        n := v
        m[k] = &amp;n
    }
    for key, value := range m {
        fmt.Printf("map[%v]=%v\n", key, *value)
    }

    fmt.Println(m)
}
</code></pre>
</li>
</ul>
</li>
<li><p>请你说说golang的CSP思想</p>
</li>
<li><p>进程，协程，线程各自的优缺点</p>
</li>
</ol>
<h1 id="第-2-章-函数"><a href="#第-2-章-函数" class="headerlink" title="第 2 章 函数"></a>第 2 章 函数</h1><p>Go中的函数：</p>
<ul>
<li>函数是一种类型，函数类型变量可以向其他类型变量一样使用，可以作为其它函数的参数或返回值，也可以直接调用执行</li>
<li>函数支持多值返回</li>
<li>支持闭包</li>
<li>函数支持可变参数</li>
</ul>
<h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><h3 id="2-1-1-函数定义"><a href="#2-1-1-函数定义" class="headerlink" title="2.1.1 函数定义"></a>2.1.1 函数定义</h3><p>包括如下几个部分：</p>
<ul>
<li>函数声明关键字func</li>
<li>函数名</li>
<li>参数列表</li>
<li>返回列表和函数体</li>
</ul>
<p>函数的特点：</p>
<ul>
<li>函数可以没有输入参数，也可以没有返回值（默认返回0）</li>
<li>多个相邻的相同类型的参数可以使用简写模式</li>
<li>支持有名的返回值，参数名就相当于函数体内最外层的局部变量，命名返回值变量会被初始化成类型零值</li>
<li>不支持默认值参数</li>
<li>不支持函数重载</li>
<li>不支持函数嵌套，严格的说是不支持命名函数的嵌套定义，但支持嵌套匿名函数</li>
</ul>
<h3 id="2-1-2-多值返回"><a href="#2-1-2-多值返回" class="headerlink" title="2.1.2 多值返回"></a>2.1.2 多值返回</h3><p>习惯用法：如果多值返回之有错误类型，则一般将错误类型作为最后一个返回值</p>
<h3 id="2-1-3-实参到形参的传递"><a href="#2-1-3-实参到形参的传递" class="headerlink" title="2.1.3 实参到形参的传递"></a>2.1.3 实参到形参的传递</h3><p>Go函数实参到形参的传递永远是值拷贝。有时函数调用后实参指向的值发生了变化，那是因为参数传递的是指针值的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本，二者指向同一地址。</p>
<h3 id="2-1-4-不定参数"><a href="#2-1-4-不定参数" class="headerlink" title="2.1.4 不定参数"></a>2.1.4 不定参数</h3><p>Go支持不定数据的形式参数，声明使用<code>param ...type</code> .</p>
<p>不定参数特点：</p>
<ul>
<li>所有的不定参数类型必须是相同的</li>
<li>不定参数必须是函数的最后一个参数</li>
<li>不定参数在函数体内相当于切片，对切片的操作同样适合对不定参数的操作</li>
<li>切片可以作为参数传递给不定参数，切片名后要加上”…”</li>
<li>形参为不定参数的函数和形参为切片的函数类型不相同</li>
</ul>
<h2 id="2-2-函数签名和匿名函数"><a href="#2-2-函数签名和匿名函数" class="headerlink" title="2.2 函数签名和匿名函数"></a>2.2 函数签名和匿名函数</h2><h3 id="2-2-1-函数签名"><a href="#2-2-1-函数签名" class="headerlink" title="2.2.1 函数签名"></a>2.2.1 函数签名</h3><p>函数类型又叫函数签名，可以使用fmt.Printf的%T格式化参数打印函数的类型</p>
<h3 id="2-2-2-匿名函数"><a href="#2-2-2-匿名函数" class="headerlink" title="2.2.2 匿名函数"></a>2.2.2 匿名函数</h3><p>Go提供两种函数：有名函数和匿名函数</p>
<p>匿名函数可以直接复制给函数变量，可以当做实参，也可以作为返回值，还可以直接被调用。</p>
<h2 id="2-3-defer"><a href="#2-3-defer" class="headerlink" title="2.3 defer"></a>2.3 defer</h2><p>Go提供了defer关键字，可以注册多个延迟调用，这些调用以先进后出的顺序在函数返回前被执行。这有点类似于Java语言中异常处理的finaly语句。</p>
<p>defer常用语保证一些资源最终一定能够得到回收和释放。</p>
<p>特点：</p>
<ul>
<li>defer后面必须是函数或方法的调用，不能是语句</li>
<li>defer函数的实参在注册时通过值拷贝传递进去</li>
<li>defer语句必须先注册后才能执行</li>
</ul>
<p>优势：可以在一定程度上避免资源泄露</p>
<p>缺点：</p>
<ul>
<li>defer会推迟资源的释放</li>
<li>defer不要写在循环语句里面</li>
<li>defer最好不要对有名返回值参数进行操作</li>
</ul>
<h2 id="2-4-闭包"><a href="#2-4-闭包" class="headerlink" title="2.4 闭包"></a>2.4 闭包</h2><p>闭包是由函数及其相关引用环境组合而成的实体。</p>
<p><code>闭包 = 函数 + 引用环境</code></p>
<ol>
<li>闭包对闭包外的环境引入是直接引用，编译器检测到闭包会将闭包引用的外部变量分配到堆上</li>
<li>如果函数返回的闭包引用了该函数的局部变量（参数或函数内部变量）<ol>
<li>多次调用该函数返回的多个闭包所引用的外部变量是多个副本，原因是每次调用函数都会为局部变量分配内存</li>
<li>用一个闭包函数多次，如果该闭包修改了其引用的外部变量，则每一次调用该闭包对该外包变量都有影响，因为闭包函数共享外部引用</li>
</ol>
</li>
</ol>
<h3 id="2-4-2-闭包的价值"><a href="#2-4-2-闭包的价值" class="headerlink" title="2.4.2 闭包的价值"></a>2.4.2 闭包的价值</h3><p>对象是附有行为的数据，闭包是附有数据的行为。</p>
<h2 id="2-5-panic和recover"><a href="#2-5-panic和recover" class="headerlink" title="2.5 panic和recover"></a>2.5 panic和recover</h2><p>panic用来主动抛出错误</p>
<p>recover用来捕获panic抛出的错误</p>
<h3 id="2-5-1-基本概念"><a href="#2-5-1-基本概念" class="headerlink" title="2.5.1 基本概念"></a>2.5.1 基本概念</h3><p><img src="/images/go_core_programming/Untitled%2031.png" alt="Untitled"></p>
<p>引发panic的情况：</p>
<ul>
<li>程序主动调用panic函数</li>
<li>程序产生运行时错误，由运行时检测并抛出</li>
</ul>
<p>recover用来捕获panic，阻止panic继续向上传递</p>
<h3 id="2-5-2-使用场景"><a href="#2-5-2-使用场景" class="headerlink" title="2.5.2 使用场景"></a>2.5.2 使用场景</h3><ul>
<li>程序遇到了无法正常执行下去的错误，主动调用panic函数结束程序运行</li>
<li>在调试程序时，通过主动调用panic实现快速退出，panic打印出的堆栈能够更快的定位错误</li>
</ul>
<h2 id="2-6-错误处理"><a href="#2-6-错误处理" class="headerlink" title="2.6 错误处理"></a>2.6 错误处理</h2><h3 id="2-6-1-error"><a href="#2-6-1-error" class="headerlink" title="2.6.1 error"></a>2.6.1 error</h3><p>Go语言内置错误接口类型error</p>
<p>错误处理的最佳实践：</p>
<ul>
<li>在多个返回值的函数中，error通常作为函数最后一个返回值</li>
<li>如果一个函数返回error类型变量，则先用if语句处理<code>error != nil</code> 的异常场景，正常逻辑放到if语句块后面保持代码平坦</li>
<li>defer语句应该放到err判断的后面，不然有可能产生panic</li>
<li>在错误逐级向上传递的过程中，错误信息应该不断地丰富和完善，而不是简单抛出下层调用的错误</li>
</ul>
<pre><code class="go">func deferDemo() error {
    err := createResource1()
    if err != nil {
        return ERR_CREATE_RESOURCE1_FAILED
    }
    defer func() {
        if err != nil {
            destroyResource1()
        }
    }()
}
</code></pre>
<h3 id="2-6-2-错误和异常"><a href="#2-6-2-错误和异常" class="headerlink" title="2.6.2 错误和异常"></a>2.6.2 错误和异常</h3><p>Go程序需要处理的错误类型：</p>
<ul>
<li>运行时错误：无法避免，可以recover这些panic</li>
<li>程序逻辑错误</li>
</ul>
<p>error和panic应该遵循如下原则：</p>
<ul>
<li>程序发生的错误导致程序不能容错继续执行，此时程序应该主动调用panic或由运行时抛出panic</li>
<li>程序虽然发生错误，但是程序能够容错继续执行，此时应该使用错误返回值的方式处理错误，或者在可能发生运行时错误的非关键分支上使用recover捕获panic</li>
</ul>
<pre><code class="go">func TestName(t *testing.T) {
    height := []int{2,3,4,5,18,17,6}
    defer func() {
        if err := recover(); err != nil {
            fmt.Println(err)
        }
    }()
    print(height[10])
}
</code></pre>
<h2 id="2-7-底层实现"><a href="#2-7-底层实现" class="headerlink" title="2.7 底层实现"></a>2.7 底层实现</h2><h1 id="第-3-章-类型系统"><a href="#第-3-章-类型系统" class="headerlink" title="第 3 章 类型系统"></a>第 3 章 类型系统</h1><h2 id="3-1-类型简介"><a href="#3-1-类型简介" class="headerlink" title="3.1 类型简介"></a>3.1 类型简介</h2><h3 id="3-1-1-命名类型和未命名类型"><a href="#3-1-1-命名类型和未命名类型" class="headerlink" title="3.1.1 命名类型和未命名类型"></a>3.1.1 命名类型和未命名类型</h3><p>命名类型：可以通过标识符来表示（3.2节详细介绍）</p>
<p>未命名类型：一个类型由预声明类型、关键字和操作符组合而成，又称为类型字面量。例如：数组（array）、切片（slice）、字典（map）、通道（channel）、指针（pointer）、函数字面量（function）、结构（struct）和接口（interface）都属于类型字面量</p>
<h3 id="3-1-2-底层类型"><a href="#3-1-2-底层类型" class="headerlink" title="3.1.2 底层类型"></a>3.1.2 底层类型</h3><p>所有“类型”都有一个underlying type（底层类型）。底层类型的规则如下：</p>
<ul>
<li>预声明类型（Pre-declared types）和类型字面量（type literals）的底层类型是他们自身</li>
<li>自定义类型type newtype oldtype中的newtype的底层是逐层递归向下查找的，知道查到的oldtype是预声明类型（Pre-declared types）或类型字面量（type literals）为止。</li>
</ul>
<h3 id="3-1-3-类型相同和类型赋值"><a href="#3-1-3-类型相同和类型赋值" class="headerlink" title="3.1.3 类型相同和类型赋值"></a>3.1.3 类型相同和类型赋值</h3><p><strong>类型相同</strong></p>
<p>Go是强类型的语言，编译器在编译时会进行严格的类型校验。两个命名类型是否相同的判断：</p>
<ul>
<li>两个命名类型相同的条件是两个类型声明的语句完全相同</li>
<li>命名类型和未命令类型永远不相同</li>
<li>两个未命名类型相同的条件是他们的类型声明字面量的结构相同，并且内部元素的类型相同</li>
<li>通过类型别名语句声明的两个类型相同</li>
</ul>
<p><strong>类型可直接赋值</strong></p>
<p>类型为T1的变量a可以赋值给类型为T2的变量b，称为类型T1可以赋值给类型T2，伪代码：</p>
<pre><code class="go">var b T2 = a
</code></pre>
<p>a可以赋值给变量b必须要满足如下条件中的一个：</p>
<ul>
<li>T1和T2的类型相同</li>
<li>T1和T2具有相同的底层类型，并且T1和T2里面至少有一个是未命名类型</li>
<li>T2是接口类型，T1是具体类型，T1的方法集是T2方法集的超级</li>
<li>T1和T2都是通道类型，他们拥有相同的元素类型，并且T1和T2至少有一个是未命名类型</li>
<li>a是预声明标识符nil，T2是pointer、function、slice、map、channel、interface类型中的一个</li>
<li>a是一个字面常量值，可以用来表示类型T的值</li>
</ul>
<h3 id="3-1-4-类型强制转换"><a href="#3-1-4-类型强制转换" class="headerlink" title="3.1.4 类型强制转换"></a>3.1.4 类型强制转换</h3><p>由于Go是强类型的语言，如果不满足自动转换的条件，则必须进行强制类型转换。</p>
<p>非常量类型的变量x可以强制转化并传递给类型T，需要满足如下任一条件：</p>
<ul>
<li>x可以直接赋值给T类型变量</li>
<li>x类型和T具有相同的底层类型</li>
<li>x的类型和T都是未命名的指针类型，并且指针指向的类型具有相同的底层类型</li>
<li>x的类型和T都是整型或者都是浮点型</li>
<li>x的类型和T都是复数类型</li>
<li>x是整数值或[]byte类型的值，T是string类型</li>
<li>x是一个字符串，T是[]byte或[]rune</li>
</ul>
<h2 id="3-2-类型方法"><a href="#3-2-类型方法" class="headerlink" title="3.2 类型方法"></a>3.2 类型方法</h2><h3 id="3-2-1-自定义类型"><a href="#3-2-1-自定义类型" class="headerlink" title="3.2.1 自定义类型"></a>3.2.1 自定义类型</h3><p>自定义类型都是命名类型</p>
<p><img src="/images/go_core_programming/Untitled%2032.png" alt="Untitled"></p>
<p>自定义struct类型</p>
<h3 id="3-2-2-方法"><a href="#3-2-2-方法" class="headerlink" title="3.2.2 方法"></a>3.2.2 方法</h3><p><img src="/images/go_core_programming/Untitled%2033.png" alt="Untitled"></p>
<p>类型方法有如下特点：</p>
<ul>
<li>可以为命名类型增加方法（除了接口），非命名类型不能自定义方法</li>
<li>为类型增加方法有一个限制，就是方法的定义必须和类型的定义在同一个包中</li>
<li>方法的命名空间可见性和变量一样，大写开头的方法可也在包外被访问，否则只能在包内可见</li>
<li>使用type定义的自定义类型是一个新类型，新类型不能调用原有类型的方法，但是底层类型支持的运算可以被新类型继承</li>
</ul>
<p><img src="/images/go_core_programming/Untitled%2034.png" alt="Untitled"></p>
<p><img src="/images/go_core_programming/Untitled%2035.png" alt="Untitled"></p>
<h2 id="3-3-方法调用"><a href="#3-3-方法调用" class="headerlink" title="3.3 方法调用"></a>3.3 方法调用</h2><h3 id="3-3-1-一般调用"><a href="#3-3-1-一般调用" class="headerlink" title="3.3.1 一般调用"></a>3.3.1 一般调用</h3><p><img src="/images/go_core_programming/Untitled%2036.png" alt="Untitled"></p>
<h3 id="3-3-2-方法值"><a href="#3-3-2-方法值" class="headerlink" title="3.3.2 方法值"></a>3.3.2 方法值</h3><p><img src="/images/go_core_programming/Untitled%2037.png" alt="Untitled"></p>
<h3 id="3-3-3-方法表达式"><a href="#3-3-3-方法表达式" class="headerlink" title="3.3.3 方法表达式"></a>3.3.3 方法表达式</h3><p>方法表达式相当于提供一种语法将类型方法调用显示第转换为函数调用，接受者必须显示地传递进去。</p>
<h3 id="3-3-4-方法集"><a href="#3-3-4-方法集" class="headerlink" title="3.3.4 方法集"></a>3.3.4 方法集</h3><p>命名类型方法接受者有两种类型，一个是值类型，另一个是指针类型，这个和函数是一样的，前者的形参是值类型，后者的形参是指针类型。</p>
<p>无论接受者是什么类型，方法和函数的实参传递都是值拷贝，如果接受者是值类型，则传递的是值的副本；如果接受者是指针类型，则传递的是指针的副本</p>
<h3 id="3-3-5-值调用和表达式调用的方法集"><a href="#3-3-5-值调用和表达式调用的方法集" class="headerlink" title="3.3.5 值调用和表达式调用的方法集"></a>3.3.5 值调用和表达式调用的方法集</h3><h2 id="3-4-组合和方法集"><a href="#3-4-组合和方法集" class="headerlink" title="3.4 组合和方法集"></a>3.4 组合和方法集</h2><p>结构类型为Go提供了强大的类型扩展，主要体现在两个方面：</p>
<ul>
<li>struct可以嵌入任意其他类型的字段</li>
<li>struct可以嵌套自身的指针类型的字段</li>
</ul>
<h3 id="3-4-1-组合"><a href="#3-4-1-组合" class="headerlink" title="3.4.1 组合"></a>3.4.1 组合</h3><p>因为Go没有继承的语义，结构和字段之间是“has a”的关系而不是“is a”的关系，没有父子概念，仅仅是整体和局部的概念，所以后续统称这种嵌套的结构和字段的关系为组合</p>
<h3 id="3-4-2-组合的方法集"><a href="#3-4-2-组合的方法集" class="headerlink" title="3.4.2 组合的方法集"></a>3.4.2 组合的方法集</h3><h2 id="3-5-函数类型"><a href="#3-5-函数类型" class="headerlink" title="3.5 函数类型"></a>3.5 函数类型</h2><h1 id="第-4-章-接口（未看）"><a href="#第-4-章-接口（未看）" class="headerlink" title="第 4 章 接口（未看）"></a>第 4 章 接口（未看）</h1><h1 id="第-5-章-并发"><a href="#第-5-章-并发" class="headerlink" title="第 5 章 并发"></a>第 5 章 并发</h1><h2 id="5-1-并发基础"><a href="#5-1-并发基础" class="headerlink" title="5.1 并发基础"></a>5.1 并发基础</h2><h3 id="5-1-1-并发和并行"><a href="#5-1-1-并发和并行" class="headerlink" title="5.1.1 并发和并行"></a>5.1.1 并发和并行</h3><ol>
<li>并行就是在任一粒度的时间内都具备同时执行的能力：例如多机</li>
<li>并发是在规定的时间内多个请求都得到执行和处理，强调的是给外界的感受，实际上内部可能是分时操作的</li>
</ol>
<h3 id="5-1-2-goroutine"><a href="#5-1-2-goroutine" class="headerlink" title="5.1.2 goroutine"></a>5.1.2 goroutine</h3><p>Go语言的并发执行体称为goroutine，通过go关键字来启动一个goroutine。</p>
<p>goroutine特性：</p>
<ul>
<li>go的执行是非阻塞的，不会等待</li>
<li>go后面的函数的返回值会被忽略</li>
<li>调度器不能保证多个goroutine的执行次序</li>
<li>没有父子goroutine的概念，所有goroutne是平等地被调用和执行的</li>
<li>Go程序在执行时会单独为main函数创建一个goroutine，遇到其他go关键字时再去创建其他的goroutinue</li>
<li>Go没有暴露goroutine id给用户，所以不能在一个goroutine里面显式地操作另一个goroutine，不过runtime包提供了一些函数访问和设置goroutine的相关信息</li>
</ul>
<ol>
<li>func GOMAXPROCS</li>
</ol>
<p>设置或查询可以并发执行的goroutine数目</p>
<pre><code class="go">package goroutine_test

import (
    "runtime"
    "testing"
)

func TestName(t *testing.T) {
    // 获取GOMAXPROCS
    println("GOMAXPROCS=",runtime.GOMAXPROCS(0))
    // 设置GOMAXPROCS
    runtime.GOMAXPROCS(2)
    // 获取GOMAXPROCS
    println("GOMAXPROCS=",runtime.GOMAXPROCS(0))
}
</code></pre>
<ol>
<li>func Goexit</li>
</ol>
<p>结束当前goroutinue的运行。Goexit不会产生panic。</p>
<ol>
<li>fun Gosched</li>
</ol>
<p>放弃当前调度执行机会，将当前goroutinue放到队列中等待下次被调度</p>
<h3 id="5-1-3-chan"><a href="#5-1-3-chan" class="headerlink" title="5.1.3 chan"></a>5.1.3 chan</h3><ol>
<li>chan是Go语言里面的一个关键字，是channel的简写，通道。通道是Go通过通信来共享内容的载体。</li>
<li>通道类型：<ul>
<li><p>有缓冲的通道：主要用于通信</p>
</li>
<li><p>无缓冲的通道：既可以用于通信，也可以用于两个goroutinue的同步</p>
<p><img src="/images/go_core_programming/Untitled%2038.png" alt="Untitled"></p>
<pre><code class="go">func TestName(t *testing.T) {
  println("NumGoroutinue=", runtime.NumGoroutine())
  c := make(chan struct{})
  ci := make(chan int, 100)
  go func(i chan struct{}, j chan int) {
      for i := 0; i &lt; 10; i++ {
          ci &lt;- i
      }
      close(ci)
      // 写通道
      c &lt;- struct{}{}
  }(c, ci)
  // NumGoroutinue可以返回当前程序的goroutinue数目
  println("NumGoroutinue=", runtime.NumGoroutine())
  // 读通道c，通过通道进行同步等待
  &lt;-c
  // 此时ci通道已经关闭，匿名函数启动的goroutinue已经退出
  println("NumGoroutinue=", runtime.NumGoroutine())
  for v := range ci {
      println(v)
  }
}
</code></pre>
</li>
</ul>
</li>
<li>操作不同状态的chan会引发三种行为<ul>
<li>panic<ul>
<li>向已经关闭的通道写数据会导致panic。由写入者关闭通道能最大程度地避免向已经关闭的通道写数据而导致panic</li>
<li>重复关闭的通道会导致panic</li>
</ul>
</li>
<li>阻塞<ul>
<li>向未初始化的通道写数据或读数据都会导致当前goroutine的永久阻塞</li>
<li>向缓冲区已满的通道写入数据会导致goroutinue阻塞</li>
<li>通道中没有数据，读取该通道会导致goroutinue阻塞</li>
</ul>
</li>
<li>非阻塞<ul>
<li>读者已经关闭的通道不会引发阻塞而是立即返回通道元素类型的零值，可以使用comma，ok语法判断通道是否已经关闭</li>
<li>向有缓冲且没有满的通道读/写不会引发阻塞</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="5-1-4-WaitGroup"><a href="#5-1-4-WaitGroup" class="headerlink" title="5.1.4 WaitGroup"></a>5.1.4 WaitGroup</h3><p>sync包提供了多个goroutine同步的机制，主要是通过WaitGroup实现的。</p>
<h3 id="5-1-5-select"><a href="#5-1-5-select" class="headerlink" title="5.1.5 select"></a>5.1.5 select</h3><p>select用于多路监听多个通道</p>
<ul>
<li>当监听的通道没有状态是可读或可写的，select是阻塞的</li>
<li>监听的通道中有一个状态是可读或可写的，则select就不会阻塞，而是进入处理就绪通道的分支流程</li>
<li>如果监听的通道有多个可读或可写的状态，则select随机选取一个处理</li>
</ul>
<pre><code class="go">import "testing"

func TestName(t *testing.T) {
    ch := make(chan int, 2)
    go func(chan int) {
        for {
            select {
            case ch &lt;- 0:
            case ch &lt;- 1:
            }
        }
    }(ch)
    for i := 0; i &lt; 10; i++ {
        println(&lt;-ch)
    }
}
</code></pre>
<h3 id="5-1-6-扇入（Fan-in）和扇出（Fan-out）"><a href="#5-1-6-扇入（Fan-in）和扇出（Fan-out）" class="headerlink" title="5.1.6 扇入（Fan in）和扇出（Fan out）"></a>5.1.6 扇入（Fan in）和扇出（Fan out）</h3><p>扇入：将多路通道聚合到一条通道中处理，Go最简单的扇入就是使用select聚合多条通道服务</p>
<p>扇出：将一条通道发散到多条通道中处理，Go语言里面具体实现就是使用go关键字启动多个goroutine并发处理 </p>
<pre><code class="go">import (
    "fmt"
    "sync"
    "testing"
)

var wg sync.WaitGroup

func TestWaitGroup(t *testing.T) {
    for i := 0; i &lt; 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            fmt.Printf("go func: %d\n", i)
        }(i)
    }
    wg.Wait()
    println("success!")
}
</code></pre>
<h3 id="5-1-7-通知退出机制"><a href="#5-1-7-通知退出机制" class="headerlink" title="5.1.7 通知退出机制"></a>5.1.7 通知退出机制</h3><p>读取已经关闭的通道不会引起阻塞，也不会导致panic，而是立即返回该通道存储类型的零值。</p>
<p>关闭select监听的某个通道能使select立即感知这种通知，然后进行相应的处理，这就是所谓的退出通知机制。</p>
<p>下面通过一个随机数生成器的示例掩饰退出通知机制，下游的消费者不需要随机数时显式地通知生产者停止生产：</p>
<pre><code class="go">import (
    "fmt"
    "math/rand"
    "runtime"
    "testing"
)

func GenerateIntA(done chan struct{}) chan int {
    ch := make(chan int)
    go func() {
    Lable:
        for {
            select {
            case ch &lt;- rand.Int():
            case &lt;-done:
                break Lable
            }
        }
        close(ch)
    }()
    return ch
}

func TestNotiExit(t *testing.T) {
    println("NumGoroutine=", runtime.NumGoroutine())
    done := make(chan struct{})
    ch := GenerateIntA(done)
    println("NumGoroutine=", runtime.NumGoroutine())
    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
    close(done)
    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
    println("NumGoroutine=", runtime.NumGoroutine())
}
</code></pre>
<h2 id="5-2-并发范式"><a href="#5-2-并发范式" class="headerlink" title="5.2 并发范式"></a>5.2 并发范式</h2><h3 id="5-2-1-生成器"><a href="#5-2-1-生成器" class="headerlink" title="5.2.1 生成器"></a>5.2.1 生成器</h3><ol>
<li>最简单的带缓冲的生成器</li>
</ol>
<pre><code class="go">import (
    "fmt"
    "math/rand"
    "testing"
)

func GenerateInt() chan int {
    ch := make(chan int, 3)
    go func() {
        for {
            ch &lt;- rand.Int()
        }
    }()
    return ch
}

func TestGenerateInt(t *testing.T) {
    ch := GenerateInt()
    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
}
</code></pre>
<ol>
<li>多个goroutinue增强型生成器</li>
</ol>
<p><img src="/images/go_core_programming/Untitled%2039.png" alt="Untitled"></p>
<ol>
<li>有时希望生成器能够自动退出，可以借助Go通道的退出通知机制实现，例如：</li>
</ol>
<p><img src="/images/go_core_programming/Untitled%2040.png" alt="Untitled"></p>
<p><img src="/images/go_core_programming/Untitled%2041.png" alt="Untitled"></p>
<ol>
<li>融合并发、缓冲、退出通知等多重特性的生成器</li>
</ol>
<pre><code class="go">package generic

import (
    "fmt"
    "math/rand"
    "testing"
)

func GenerateIntA(done chan struct{}) chan int {
    fmt.Println("GenerateIntA")
    ch := make(chan int, 5)

    go func() {
    Lable:
        for {
            select {
            case ch &lt;- rand.Int():
            case &lt;-done:
                break Lable
            }
        }
        close(ch)
    }()
    return ch
}

func GenerateIntB(done chan struct{}) chan int {
    fmt.Println("GenerateIntB")
    ch := make(chan int, 5)

    go func() {
    Lable:
        for {
            select {
            case ch &lt;- rand.Int():
            case &lt;-done:
                break Lable
            }
        }
        close(ch)
    }()
    return ch
}

func GenerateInt(done chan struct{}) chan int {
    ch := make(chan int)
    send := make(chan struct{})
    go func() {
    Lable:
        for {
            select {
            case ch &lt;- &lt;-GenerateIntA(send):
            case ch &lt;- &lt;-GenerateIntB(send):
            case &lt;-done:
                send &lt;- struct{}{}
                send &lt;- struct{}{}
                break Lable
            }
        }
        close(ch)
    }()
    return ch
}

func Test(t *testing.T)  {
    done := make(chan struct{})

    ch := GenerateInt(done)

    for i := 0; i &lt; 10; i++ {
        fmt.Println(&lt;-ch)
    }

    done &lt;- struct{}{}
    fmt.Println("stop generate")
}
</code></pre>
<h3 id="5-2-2-管道"><a href="#5-2-2-管道" class="headerlink" title="5.2.2 管道"></a>5.2.2 管道</h3><p>通道可以分为两个方向，一个是读另一个是写，加入一个函数的输入参数和输出参数都是相同的chan类型，则该函数可以调用自己，最终形成一个调用链。这很像UNIX系统的管道，是一个有类型的管道</p>
<h3 id="5-2-3-每个请求一个goroutine"><a href="#5-2-3-每个请求一个goroutine" class="headerlink" title="5.2.3 每个请求一个goroutine"></a>5.2.3 每个请求一个goroutine</h3><p>来一个请求或任务就启动一个goroutine去处理，典型的就是Go中的HTTP server服务。</p>
<h3 id="5-2-4-固定worker工作池"><a href="#5-2-4-固定worker工作池" class="headerlink" title="5.2.4 固定worker工作池"></a>5.2.4 固定worker工作池</h3><p>程序中除了主要的main goroutine，还开启了如下几类goroutine：</p>
<ul>
<li>初始化任务的goroutine</li>
<li>分发任务的goroutine</li>
<li>等待所有worker结束通知，然后关闭结果通道的goroutine</li>
</ul>
<p>程序采用三个通道，分别是：</p>
<ul>
<li>传递task任务的通道</li>
<li>传递task结果的通道</li>
<li>接收worker处理完任务后所发送通知的通道</li>
</ul>
<p>计算多个整数的和样例代码：</p>
<pre><code class="go">package main

import (
    "fmt"
    "math/rand"
    "time"
)

// 工作池的goroutine数目
const NUMBER = 10

// 工作任务
type task struct {
    // 存放数据
    data int
    // 任务结果
    result chan&lt;- int
}

// 任务处理：计算begin和end的和
// 执行结果写入结果chan result
func (t *task) do() {
    // 模拟计算耗时
    r := rand.Intn(1000)
    fmt.Println("Sleep:", r, "ms")
    time.Sleep(time.Duration(r) * time.Millisecond)
    // 模拟任务结果就是任务数据
    t.result &lt;- t.data
}

func main() {
    workers := NUMBER
    taskChan := make(chan task, 10)
    resultChan := make(chan int, 10)
    done := make(chan struct{}, 10)
    // 初始化task的goroutine
    go InitTask(taskChan, resultChan, 100)
    // 分发任务到NUMBER个goroutine池
    DistributeTask(taskChan, workers, done)
    // 获取各个goroutine处理完任务的通知并关闭结果通道
    go CloseResult(done, resultChan, workers)
    // 通过结果通道获取结果并汇总
    sum := ProcessResult(resultChan)
    fmt.Println("sum=", sum)
}

// 初始化待处理task chan
func InitTask(taskChan chan&lt;- task, r chan int, p int) {
    for i := 0; i &lt;= p; i++ {
        taskChan &lt;- task{
            data:   i,
            result: r,
        }
    }
    close(taskChan)
}

// 读取task chan并分发到worker goroutine处理，总的数量是workers
func DistributeTask(taskChan &lt;-chan task, works int, done chan struct{}) {
    for i := 0; i &lt; works; i++ {
        go ProcessTask(taskChan, done)
    }
}

// 工作goroutine处理具体工作，并将处理结果发送到结果chan
func ProcessTask(taskChan &lt;-chan task, done chan struct{}) {
    for t := range taskChan {
        t.do()
    }
    done &lt;- struct{}{}
}

// 通过done channel同步等待所有工作goroutine的结束，然后关闭结果chan
func CloseResult(done chan struct{}, resultChan chan int, workers int) {
    for i := 0; i &lt; workers; i++ {
        &lt;-done
    }
    close(done)
    close(resultChan)
}

// 读取结果通道，汇总结果
func ProcessResult(resultChan chan int) int {
    sum := 0
    for r := range resultChan {
        sum += r
    }
    return sum
}
</code></pre>
<p><img src="/images/go_core_programming/Untitled%2042.png" alt="Untitled"></p>
<p><img src="/images/go_core_programming/Untitled%2043.png" alt="Untitled"></p>
<h3 id="5-2-5-future模式"><a href="#5-2-5-future模式" class="headerlink" title="5.2.5 future模式"></a>5.2.5 future模式</h3><p>用处：子调用相互之间没有依赖，如果串行调用则耗时会很长，此时可以使用Go并发编程中的future模式</p>
<p>工作原理：</p>
<ol>
<li>使用chan作为函数参数</li>
<li>启动goroutine调用安徽省农户</li>
<li>通过chan传递如参数</li>
<li>做其他可以并行处理的事情</li>
<li>通过chan异步获取结果</li>
</ol>
<pre><code class="go">package main

import (
    "fmt"
    "time"
)

// 一个查询结构体
// 这里的sql和result是一个简单的抽象，具体的应用可能是更复杂的数据类型
type query struct {
    // 参数Channel
    sql chan string
    // 结果Channel
    result chan string
}

// 执行Query
func execQuery(q query) {
    // 启动协程
    go func() {
        // 获取输入
        sql := &lt;-q.sql
        // 访问数据库
        // 输出结果通道
        q.result &lt;- "result from " + sql
    }()
}

func main() {
    // 初始化Query
    q := query{make(chan string, 1), make(chan string, 1)}
    // 执行Query，注意执行的时候无需准备参数
    go execQuery(q)
    // 发送参数
    q.sql &lt;- "select * from table"
    // 做其他事情
    time.Sleep(1 * time.Second)
    // 获取结果
    fmt.Println(&lt;-q.result)
}
</code></pre>
<p><img src="/images/go_core_programming/Untitled%2044.png" alt="Untitled"></p>
<h2 id="5-3-context标准库"><a href="#5-3-context标准库" class="headerlink" title="5.3 context标准库"></a>5.3 context标准库</h2><p>Go中的goroutine之间没有父与子的关系，没有所谓的子进程退出后的通知机制，goroutine之间平行地被调度，多个goroutine如何协作工作设计通信、同步、通知和退出四个方面</p>
<ul>
<li>通信：chan通道是goroutine之间通信的基础（通信指程序的数据通道）</li>
<li>同步：不带缓冲的chan提供了一个天然的同步等待机制；sync.WaitGroup也为多个goroutine协同工作提供一种同步等待机制</li>
<li>通知：这个通知和上面通信的数据不一样，通知不是业务数据，而是管理、控制流数据。在输入端绑定两个chan，一个用于业务流数据，另一个用于异常通知数据，然后使用select收敛进行处理</li>
<li>退出：借助通道和select的广播机制实现退出</li>
</ul>
<h3 id="5-3-1-context的设计目的"><a href="#5-3-1-context的设计目的" class="headerlink" title="5.3.1 context的设计目的"></a>5.3.1 context的设计目的</h3><ul>
<li>退出通知机制：通知可以传递给整个goroutine调用树上的每一个goroutine</li>
<li>数据传递：数据可以传递给整个goroutine调用树上的每一个goroutine</li>
</ul>
<h3 id="5-3-2-基本数据结构"><a href="#5-3-2-基本数据结构" class="headerlink" title="5.3.2 基本数据结构"></a>5.3.2 基本数据结构</h3><p>context工作机制：第一个创建 Context goroutine被称为 root 节点。 root 节点负责创建一个实现context接口的具体对象，并将该对象作为参数传递到其新拉起的goroutine，下游的 goroutine 继续封装该对象，再传递到更下游的goroutine，Context 对象在传递的过程中最终形成一个树状的数据结构，这样通过位于 root 节点（树的根节点） Context 对象就能遍历整个 Context 对象树，通知和消息就可以通过 root 节点传递出去，实现了上游 goroutine 下游 goroutine 的消息传递。</p>
<p><strong>Context接口</strong></p>
<p>Context作为参数传递</p>
<p><img src="/images/go_core_programming/Untitled%2045.png" alt="Untitled"></p>
<p><img src="/images/go_core_programming/Untitled%2046.png" alt="Untitled"></p>
<p><strong>canceler接口</strong></p>
<p>conceler规定了取消通知的Context具体类型需要实现的接口</p>
<p><img src="/images/go_core_programming/Untitled%2047.png" alt="Untitled"></p>
<p><strong>empty Context结构</strong></p>
<p>实现了Context接口但不具备任何功能，其存在的目的是作为Context对象树的根（root节点）</p>
<p><strong>cancelCtx</strong></p>
<p>cancelCtx是一个实现了Context耳机口的具体类型，同时实现了conceler接口</p>
<p><strong>timerCtx</strong></p>
<p>timerCtx是一个实现了Context接口的具体类型，内部封装cancelCtx类型实例，同时有一个deadlinebianl,yonglaishixian定时退出通知</p>
<p><strong>valueCtx</strong></p>
<p>valueCtx是一个实现了Context接口的具体类型，内部封装了Context接口类型，同时封装了一个k/v的存储遍历，valueCtx可以用来传递通知信息</p>
<p><img src="/images/go_core_programming/Untitled%2048.png" alt="Untitled"></p>
<h3 id="5-3-3-API函数"><a href="#5-3-3-API函数" class="headerlink" title="5.3.3 API函数"></a>5.3.3 API函数</h3><p>以下两个函数是构造Context取消树的根节点对象，根节点对象用作后续With包装函数的实参：</p>
<ul>
<li>func Background() Context</li>
<li>func TODO() Context</li>
</ul>
<h3 id="5-3-6-使用Context传递数据的争议"><a href="#5-3-6-使用Context传递数据的争议" class="headerlink" title="5.3.6 使用Context传递数据的争议"></a>5.3.6 使用Context传递数据的争议</h3><p>使用context传递数据的坏处：</p>
<ul>
<li>传递的都是interface{}类型的值，编译器不能进行严格的类型校验</li>
<li>从interface{}到具体类型需要使用类型断言和接口查询，有一定的运行期开销和性能损失</li>
<li>值在传递过程中有可能被后续的服务覆盖且不易被发现</li>
<li>传递信息不简明。较晦涩；不能通过代码或文档一眼看到传递的是什么，不利于后续维护</li>
</ul>
<p>context应该传递什么数据：</p>
<ul>
<li>日志信息</li>
<li>调低是信息</li>
<li>不影响业务主逻辑的可选数据</li>
</ul>
<h2 id="5-4-并发模型"><a href="#5-4-并发模型" class="headerlink" title="5.4 并发模型"></a>5.4 并发模型</h2><h3 id="5-4-1-CSP简介"><a href="#5-4-1-CSP简介" class="headerlink" title="5.4.1 CSP简介"></a>5.4.1 CSP简介</h3><p>CSP基本思想：将并发系统抽象为Channel和Process两部分，Channel用来传递消息，Process用于执行，Channel和Process之间相互独立，没有从属关系，消息的发送和接收有严格的时序限制。</p>
<p>Go中Channel就是通道，Process就是goroutine</p>
<h3 id="5-4-2-调度模型"><a href="#5-4-2-调度模型" class="headerlink" title="5.4.2 调度模型"></a>5.4.2 调度模型</h3><p>协程是一种用户态的轻量级线程，写成的调度完全由用户态程序控制，协程拥有自己的寄存器上下文和栈。</p>
<p>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候恢复先前保存的寄存器上下文和栈，每个内核线程可以对应多个用户协程，当一个协程执行体阻塞了，调度器会调度另一个携程执行，最大效率地利用操作系统分给系统线程的时间片。</p>
<p>好处：</p>
<ul>
<li>控制了系统线程数，保证每个线程的运行时间片充足</li>
<li>调度层能进行用户态的切换，不会导致单个协程阻塞整个程序的情况，尽量减少上下文切换，提升运行效率</li>
</ul>
<p>由此可见，协程是一种非常高效、理想的执行模型。Go的并发执行模型就是一种变种的协程模型。</p>
<h3 id="5-4-3-并发和调度"><a href="#5-4-3-并发和调度" class="headerlink" title="5.4.3 并发和调度"></a>5.4.3 并发和调度</h3><p>goroutine好处：</p>
<ul>
<li>goroutine可以在用户空间调度，避免了内核态和用户态的切换导致的成本</li>
<li>goroutine是语言原生支持的，提供了非常简洁的语法，屏蔽了大部分复杂底层实现</li>
<li>goroutine更小的占空间允许用户创建成千上万的实例</li>
</ul>
<p>goroutinue调度模型：</p>
<ol>
<li>实体G（Goroutine）</li>
</ol>
<p>G是Go运行时对goroutine的抽象描述，G中存放并发执行的代码入口地址、上下文、运行环境（关联的P和M）、运行栈等执行相关的元信息</p>
<ol>
<li>实体M（Machine）</li>
</ol>
<p>M代表OS内核线程，是操作系统层面调度和执行的实体。M仅负责执行，M不停地被唤醒或创建，然后执行。M启动时进入的是运行时的管理代码，有这段代码获取G和P资源，然后执行调度。另外Go</p>
<p>语言运行时会单独创建一个监控线程，负责对程序的内存、调度等信息进行监控和控制</p>
<ol>
<li>实体P（Processor）</li>
</ol>
<p>P代表M运行G所需的资源，是对资源的一种抽象和管理，P不是一段代码实体，而是一个管理的数据结构，P主要是降低M管理调度G的复杂性，增加一个简洁的控制层数据结构。</p>
<p><img src="/images/go_core_programming/Untitled%2049.png" alt="Untitled"></p>
<p><strong>m0和g0</strong></p>
<p>m0和g0是启动程序后的主线程，这个m对应的信息会存放在全局变量m0种，m0负责执行初始化操作和启动第一个g，之后m0就和其他m一样了。</p>
<p><img src="/images/go_core_programming/Untitled%2050.png" alt="Untitled"></p>
<h1 id="第-7-章-语言陷阱"><a href="#第-7-章-语言陷阱" class="headerlink" title="第 7 章 语言陷阱"></a>第 7 章 语言陷阱</h1><h2 id="7-1-多值赋值和短变量声明"><a href="#7-1-多值赋值和短变量声明" class="headerlink" title="7.1 多值赋值和短变量声明"></a>7.1 多值赋值和短变量声明</h2><h3 id="7-1-1-多值赋值"><a href="#7-1-1-多值赋值" class="headerlink" title="7.1.1 多值赋值"></a>7.1.1 多值赋值</h3><p>非法：</p>
<p><img src="/images/go_core_programming/Untitled%2051.png" alt="Untitled"></p>
<p>多值赋值语义：</p>
<ul>
<li>对左侧操作数中的表达式、索引值进行计算和确定，首先确定左侧的操作数的地址，然后对右侧的赋值表达式进行计算，如果发现右侧的表达式计算引用了左侧的变量，则创建临时变量进行值拷贝，最后完成计算</li>
<li>从左到右的顺序依次赋值</li>
</ul>
<p>示例：</p>
<pre><code class="go">import (
    "fmt"
    "testing"
)

func Test(t *testing.T) {
    x := []int{1, 2, 3}
    i := 0
    i, x[i] = 1, 2
    fmt.Println(i, x) // 1 [2 2 3]

    x = []int{1, 2, 3}
    i = 0
    x[i], i = 2, 1
    fmt.Println(i, x) // 1 [2 2 3]

    x = []int{1, 2, 3}
    i = 0
    x[i], i = 2, x[i] // set tmp=x[0],x[0]=2,i=tmp ==&gt; i=1
    fmt.Println(i, x) // 1 [2 2 3]

    x[0], x[0] = 1, 2
    fmt.Println(x[0]) // 2
}
</code></pre>
<h3 id="7-1-2-短变量的声明和赋值"><a href="#7-1-2-短变量的声明和赋值" class="headerlink" title="7.1.2 短变量的声明和赋值"></a>7.1.2 短变量的声明和赋值</h3><p>约定：</p>
<ul>
<li>使用“:=”操作符，变量的定义和初始化同时完成</li>
<li>变量名后不要跟任何类型名，Go编译器完全靠右边的值进行推导</li>
<li>支持多值短变量声明赋值</li>
<li>只能用在函数和类型方法的内部</li>
</ul>
<p><img src="/images/go_core_programming/Untitled%2052.png" alt="Untitled"></p>
<p><img src="/images/go_core_programming/Untitled%2053.png" alt="Untitled"></p>
<h2 id="7-2-range复用临时变量"><a href="#7-2-range复用临时变量" class="headerlink" title="7.2 range复用临时变量"></a>7.2 range复用临时变量</h2><p><img src="/images/go_core_programming/Untitled%2054.png" alt="Untitled"></p>
<p>结果打印的都是9，原因：</p>
<ul>
<li>for range下的迭代变量i的值是共用的</li>
<li>main函数所在的goiroutinue和后续启动的goroutines存在竞争关系</li>
</ul>
<p>正确写法：</p>
<p><img src="/images/go_core_programming/Untitled%2055.png" alt="Untitled"></p>
<h2 id="7-3-defer陷阱"><a href="#7-3-defer陷阱" class="headerlink" title="7.3 defer陷阱"></a>7.3 defer陷阱</h2><p>对带defer的函数返回整体上有三个步骤</p>
<ul>
<li>执行return的值拷贝，将return语句返回的值复制到函数返回值栈区（如果只有一个return，不带任何变量或值，则此步骤不做任何动作）</li>
<li>执行defer语句，多个defer按照FILO顺序执行</li>
<li>执行调整RET指令</li>
</ul>
<h2 id="7-4-切片困惑"><a href="#7-4-切片困惑" class="headerlink" title="7.4 切片困惑"></a>7.4 切片困惑</h2><h3 id="7-4-1-数组"><a href="#7-4-1-数组" class="headerlink" title="7.4.1 数组"></a>7.4.1 数组</h3><p>Go的数组是有固定个相同类型元素的数据结构，底层采用连续的内存空间存放，数组一旦声明后大小就不可改变了。</p>
<p>Go中的数组是一种基本类型。数组的类型不仅包括其元素类型，也包括其大小，[2]int和[5]int是两个完全不同的数组类型</p>
<p><img src="/images/go_core_programming/Untitled%2056.png" alt="Untitled"></p>
<p>数组名无论作为函数实参还是作为struct嵌入字段，或者数组之间的直接赋值都是值拷贝</p>
<h3 id="7-4-2-切片"><a href="#7-4-2-切片" class="headerlink" title="7.4.2 切片"></a>7.4.2 切片</h3><p><strong>切片创建</strong></p>
<ol>
<li>通过数组创建</li>
</ol>
<p>array[b:e]创建一个包括e-b个元素的切片，包含b，不包含e</p>
<ol>
<li>make</li>
</ol>
<p>make([]T, len, cap)中的T是切片元素类型，len是长度，cap是底层数组的容量。cap是可选参数</p>
<ol>
<li>直接声明</li>
</ol>
<p><img src="/images/go_core_programming/Untitled%2057.png" alt="Untitled"></p>
<p>切片数据结构</p>
<p><img src="/images/go_core_programming/Untitled%2058.png" alt="Untitled"></p>
<p>多个切片共享一个底层数组，其中一个切片的append操作可能引发如下两种情况：</p>
<ul>
<li>append追加的元素没有超过底层数组的容量，此种append操作会直接操作共享的底层数组，如果其他切片有引用数组被覆盖的原色，则会导致其他切片的值也会隐式地发生变化</li>
<li>append追加的元素加上原来的元素如果超出底层数组的容量，则此种append操作会重新申请新数组，并将原来数组的值复制到新数组</li>
</ul>
<p>由于有这种二义性，所以在使用切片过程中应该尽量避免多个切面共享底层数组，可以使用copy进行显式的复制</p>
<h2 id="7-5-值、指针和引用"><a href="#7-5-值、指针和引用" class="headerlink" title="7.5 值、指针和引用"></a>7.5 值、指针和引用</h2><h3 id="7-5-1-传值还是传引用"><a href="#7-5-1-传值还是传引用" class="headerlink" title="7.5.1 传值还是传引用"></a>7.5.1 传值还是传引用</h3><p>Go只有一种参数传递规则：值拷贝，含义：</p>
<ul>
<li>函数参数传递时使用的是值拷贝</li>
<li>实例赋值给接口变量，接口对实例的引用是值拷贝</li>
</ul>
<p>有时在明明是值拷贝的地方结果却修改了变量的内容，有以下两种情况：</p>
<ul>
<li>直接传递的是指针，指针传递同样是值拷贝，但指针和指针副本的值指向的地址是同一地方，所以能修改实参值</li>
<li>参数是负荷数据类型，这些复合数据类型内部有指针类型的元素，此时参数的值bi拷贝并不影响指针的指向</li>
</ul>
<h3 id="7-5-2-函数名的意义"><a href="#7-5-2-函数名的意义" class="headerlink" title="7.5.2 函数名的意义"></a>7.5.2 函数名的意义</h3><ul>
<li>类型信息</li>
<li>函数的执行代码的起始位置</li>
<li>可以通过函数名进行函数调用</li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/01/18/distributed_storage/IPFS%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/" title="IPFS原理深入分析"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: IPFS原理深入分析</span></a><a class="button is-default" href="/2022/01/12/other/%E8%AE%BA%E6%96%87%E5%B7%A5%E5%85%B7/" title="论文工具"><span class="has-text-weight-semibold">Next: 论文工具</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="zhangzhishun/blockchain-blog-comment" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/zhang_zhishun"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/zhangzhishun"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Sugar 2022</span></p><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>