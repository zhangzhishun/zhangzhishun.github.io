<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>《数据结构与算法分析》笔记</title><meta name="description" content="Blockchain knowledge record blog"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + 'e574a92bc4bac2e317309d7ea1dfcb71';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="/images/system/head_portrait.jpg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="目标
了解算法分析方法（第二章-13）
精通表、栈和队列（第三章-27）、树（第四章-40）、散列（第五章-36）、优先队列、堆（第六章-28）、排序（第七章-50）、不相交集类（第八章-17）
精通图论（第九章-38）、算法设计技巧（第十章-50）、红黑树（第十二章第二节-5）

第 2 章 算法分析方法2.4 运行时间计算2.4.1 一般法则
法则1 —— for循环

一个for循环的运行时间至多是该for循环内部那些语句（包括测试）的运行时间乘以迭代的次数

法则2 —— 嵌套的for循环

在一组嵌套循环内部的一条语句的运行时间为该语句的运行时间乘以该组所有的for循环的大小的乘积

法则3 —— 顺序语句

将各个语句的运行时间求和即可。这意味着其中的最大值就是所得的运行时间。


法则4 ——.."><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Sugar's blog" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Sugar's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">《数据结构与算法分析》笔记</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/works">Works</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/works">Works</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-text">第 2 章 算法分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="toc-text">2.4 运行时间计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E4%B8%80%E8%88%AC%E6%B3%95%E5%88%99"><span class="toc-text">2.4.1 一般法则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-text">第 3 章 表、栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.1 抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%A1%A8ADT"><span class="toc-text">3.2 表ADT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2.1 表的简单数组实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E7%AE%80%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">3.2.2 简单链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E6%A0%88ADT"><span class="toc-text">3.6 栈ADT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E6%A0%88%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.6.1 栈模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-3-%E5%BA%94%E7%94%A8"><span class="toc-text">3.6.3 应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E9%98%9F%E5%88%97ADT"><span class="toc-text">3.7 队列ADT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.7.1 队列模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E6%A0%91"><span class="toc-text">第 4 章 树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-text">4.1 预备知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">4.2 二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%9F%A5%E6%89%BE%E6%A0%91ADT-%E2%80%94%E2%80%94-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text">4.3 查找树ADT ——  二叉查找树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-AVL%E6%A0%91"><span class="toc-text">4.4 AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E5%8D%95%E6%97%8B%E8%BD%AC"><span class="toc-text">4.4.1 单旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%8F%8C%E6%97%8B%E8%BD%AC"><span class="toc-text">4.4.2 双旋转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E4%BC%B8%E5%B1%95%E6%A0%91"><span class="toc-text">4.5 伸展树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">4.6 树的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-B-%E6%A0%91"><span class="toc-text">4.7 B+树**</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E6%95%A3%E5%88%97"><span class="toc-text">第 5 章 散列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%B8%80%E8%88%AC%E6%83%B3%E6%B3%95"><span class="toc-text">5.1 一般想法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-text">5.2 散列函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-text">5.3 分离链接法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E4%B8%8D%E5%90%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-text">5.4 不同链表的散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-text">5.4.1 线性探测法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-text">5.4.2 平方探测法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E5%8F%8C%E6%95%A3%E5%88%97"><span class="toc-text">5.4.3 双散列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%86%8D%E6%95%A3%E5%88%97"><span class="toc-text">5.5 再散列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-text">5.6 标准库中的散列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E6%9C%80%E5%9D%8F%E6%83%85%E5%BD%A2%E4%B8%8BO-1-%E8%AE%BF%E9%97%AE%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-text">5.7 最坏情形下O(1)访问的散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-1-%E5%AE%8C%E7%BE%8E%E6%95%A3%E5%88%97"><span class="toc-text">5.7.1 完美散列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-2-%E5%B8%83%E8%B0%B7%E9%B8%9F%E6%95%A3%E5%88%97"><span class="toc-text">5.7.2 布谷鸟散列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-3-%E8%B7%B3%E6%88%BF%E5%AD%90%E6%95%A3%E5%88%97"><span class="toc-text">5.7.3 跳房子散列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E9%80%9A%E7%94%A8%E6%95%A3%E5%88%97%E6%B3%95"><span class="toc-text">5.8 通用散列法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E5%A0%86%EF%BC%89"><span class="toc-text">第 6 章 优先队列（堆）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.1 模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.2 一些简单的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="toc-text">6.3 二叉堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8"><span class="toc-text">6.3.1 结构性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">6.4 优先队列的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-d-%E5%A0%86"><span class="toc-text">6.5 d-堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E5%B7%A6%E5%BC%8F%E5%A0%86"><span class="toc-text">6.6 左式堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E6%96%9C%E5%A0%86"><span class="toc-text">6.7 斜堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E4%BA%8C%E9%A1%B9%E9%98%9F%E5%88%97"><span class="toc-text">6.8 二项队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-1-%E4%BA%8C%E9%A1%B9%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84"><span class="toc-text">6.8.1 二项队列结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E6%8E%92%E5%BA%8F"><span class="toc-text">第 7 章 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">7.2 插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">7.4 希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">7.5 堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">7.6 归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">7.7 快速排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-9-%E7%AB%A0-%E5%9B%BE%E8%AE%BA"><span class="toc-text">第 9 章 图论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">9.1 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">9.2 拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-text">9.3 最短路径算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-%E6%97%A0%E6%9D%83%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">9.3.1 无权最短路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E5%AE%8C"><span class="toc-text">未完</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-9-%E7%AB%A0-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7"><span class="toc-text">第 9 章 算法设计技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95"><span class="toc-text">10.1 贪婪算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-text">10.2 分治算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">10.3 动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">10.4 随机数算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">10.5 回溯算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-12-%E7%AB%A0-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="toc-text">第 12 章 高级数据结构及其实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">12.2 红黑树</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><i class="tag post-item-tag">数据结构与算法</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">《数据结构与算法分析》笔记</h1><time class="has-text-grey" datetime="2022-01-18T02:29:15.000Z">2022-01-18</time><article class="mt-2 post-content"><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul>
<li>了解算法分析方法（第二章-13）</li>
<li>精通表、栈和队列（第三章-27）、树（第四章-40）、散列（第五章-36）、优先队列、堆（第六章-28）、排序（第七章-50）、不相交集类（第八章-17）</li>
<li>精通图论（第九章-38）、算法设计技巧（第十章-50）、红黑树（第十二章第二节-5）</li>
</ul>
<h1 id="第-2-章-算法分析方法"><a href="#第-2-章-算法分析方法" class="headerlink" title="第 2 章 算法分析方法"></a>第 2 章 算法分析方法</h1><h2 id="2-4-运行时间计算"><a href="#2-4-运行时间计算" class="headerlink" title="2.4 运行时间计算"></a>2.4 运行时间计算</h2><h3 id="2-4-1-一般法则"><a href="#2-4-1-一般法则" class="headerlink" title="2.4.1 一般法则"></a>2.4.1 一般法则</h3><ol>
<li>法则1 —— for循环</li>
</ol>
<p>一个for循环的运行时间至多是该for循环内部那些语句（包括测试）的运行时间乘以迭代的次数</p>
<ol>
<li>法则2 —— 嵌套的for循环</li>
</ol>
<p>在一组嵌套循环内部的一条语句的运行时间为该语句的运行时间乘以该组所有的for循环的大小的乘积</p>
<ol>
<li>法则3 —— 顺序语句</li>
</ol>
<p>将各个语句的运行时间求和即可。这意味着其中的最大值就是所得的运行时间。</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled.png" alt="Untitled"></p>
<ol>
<li>法则4 —— if/else语句</li>
</ol>
<p>一个if/else语句的运行时间从不超过判断的运行时间再加上S1和S2中运行时间长者的总的运行时间。</p>
<h1 id="第-3-章-表、栈和队列"><a href="#第-3-章-表、栈和队列" class="headerlink" title="第 3 章 表、栈和队列"></a>第 3 章 表、栈和队列</h1><h2 id="3-1-抽象数据类型"><a href="#3-1-抽象数据类型" class="headerlink" title="3.1 抽象数据类型"></a>3.1 抽象数据类型</h2><p>抽象数据类型（ADT）是带有一组操作的一些对象的集合。</p>
<h2 id="3-2-表ADT"><a href="#3-2-表ADT" class="headerlink" title="3.2 表ADT"></a>3.2 表ADT</h2><p>我们称形如$A_0$$,A_1,A_2,…,A_{N-1}$的为表，该表大小为N</p>
<h3 id="3-2-1-表的简单数组实现"><a href="#3-2-1-表的简单数组实现" class="headerlink" title="3.2.1 表的简单数组实现"></a>3.2.1 表的简单数组实现</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%201.png" alt="Untitled"></p>
<h3 id="3-2-2-简单链表"><a href="#3-2-2-简单链表" class="headerlink" title="3.2.2 简单链表"></a>3.2.2 简单链表</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%202.png" alt="Untitled"></p>
<h2 id="3-6-栈ADT"><a href="#3-6-栈ADT" class="headerlink" title="3.6 栈ADT"></a>3.6 栈ADT</h2><h3 id="3-6-1-栈模型"><a href="#3-6-1-栈模型" class="headerlink" title="3.6.1 栈模型"></a>3.6.1 栈模型</h3><p>栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做站的顶（top）。</p>
<p>栈的基本操作有push（进栈）、pop（出栈）</p>
<p>栈有时又叫LIFO（后进先出）表</p>
<h3 id="3-6-3-应用"><a href="#3-6-3-应用" class="headerlink" title="3.6.3 应用"></a>3.6.3 应用</h3><ul>
<li>平衡符号</li>
<li>后缀表达式</li>
<li>方法调用</li>
</ul>
<h2 id="3-7-队列ADT"><a href="#3-7-队列ADT" class="headerlink" title="3.7 队列ADT"></a>3.7 队列ADT</h2><h3 id="3-7-1-队列模型"><a href="#3-7-1-队列模型" class="headerlink" title="3.7.1 队列模型"></a>3.7.1 队列模型</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%203.png" alt="Untitled"></p>
<h1 id="第-4-章-树"><a href="#第-4-章-树" class="headerlink" title="第 4 章 树"></a>第 4 章 树</h1><h2 id="4-1-预备知识"><a href="#4-1-预备知识" class="headerlink" title="4.1 预备知识"></a>4.1 预备知识</h2><h2 id="4-2-二叉树"><a href="#4-2-二叉树" class="headerlink" title="4.2 二叉树"></a>4.2 二叉树</h2><h2 id="4-3-查找树ADT-——-二叉查找树"><a href="#4-3-查找树ADT-——-二叉查找树" class="headerlink" title="4.3 查找树ADT ——  二叉查找树"></a>4.3 查找树ADT ——  二叉查找树</h2><h2 id="4-4-AVL树"><a href="#4-4-AVL树" class="headerlink" title="4.4 AVL树"></a>4.4 AVL树</h2><p>AVL树是带有平衡条件的二叉查找树</p>
<p>特点：</p>
<ul>
<li>本身首先是一棵二叉搜索树。</li>
<li>每个节点的左右子树的高度之差的绝对值（平衡因子）最多为1</li>
</ul>
<h3 id="4-4-1-单旋转"><a href="#4-4-1-单旋转" class="headerlink" title="4.4.1 单旋转"></a>4.4.1 单旋转</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%204.png" alt="Untitled"></p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%205.png" alt="Untitled"></p>
<h3 id="4-4-2-双旋转"><a href="#4-4-2-双旋转" class="headerlink" title="4.4.2 双旋转"></a>4.4.2 双旋转</h3><h2 id="4-5-伸展树"><a href="#4-5-伸展树" class="headerlink" title="4.5 伸展树"></a>4.5 伸展树</h2><p>伸展树保证从空树开始连续M次对树的操作最多花费*O(M log N)*时间</p>
<p>伸展树基于这样的事实：对于二叉查找树来说，每次操作最坏情形时间*O(N)*并不坏，只要它相对不常发生就行。</p>
<h2 id="4-6-树的遍历"><a href="#4-6-树的遍历" class="headerlink" title="4.6 树的遍历"></a>4.6 树的遍历</h2><ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
<h2 id="4-7-B-树"><a href="#4-7-B-树" class="headerlink" title="4.7 B+树**"></a>4.7 B+树**</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%206.png" alt="Untitled"></p>
<p>阶为M的B+树的特性：</p>
<ul>
<li>数据项存储在树叶上</li>
<li>非叶子节点存储直到M-1个关键字以指示搜索的方向；关键字i代表子树i+1中的最小的关键字</li>
<li>树的根或者是一片树叶，或者其儿子数在2和M之间</li>
<li>除根外，所有非树叶节点的儿子数在<code>⌈M/2⌉</code>和<code>M</code>之间</li>
<li>所有的树叶都在相同的深度上并有<code>⌈L/2⌉</code>和<code>L</code> 之间个数据项</li>
</ul>
<p>B树与B+树不同点：</p>
<ul>
<li>单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。</li>
<li>所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。</li>
<li>所有的叶子节点形成了一个有序链表，更加便于查找。</li>
</ul>
<h1 id="第-5-章-散列"><a href="#第-5-章-散列" class="headerlink" title="第 5 章 散列"></a>第 5 章 散列</h1><h2 id="5-1-一般想法"><a href="#5-1-一般想法" class="headerlink" title="5.1 一般想法"></a>5.1 一般想法</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%207.png" alt="Untitled"></p>
<h2 id="5-2-散列函数"><a href="#5-2-散列函数" class="headerlink" title="5.2 散列函数"></a>5.2 散列函数</h2><p>如果关键字是整数一般合理的方法就是直接返回<em>key mod Tablesize</em></p>
<p>如果关键字是字符串，</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%208.png" alt="Untitled"></p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%209.png" alt="Untitled"></p>
<h2 id="5-3-分离链接法"><a href="#5-3-分离链接法" class="headerlink" title="5.3 分离链接法"></a>5.3 分离链接法</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2010.png" alt="Untitled"></p>
<p>分离链接法：其做法是将散列到同一个值的所有元素保留到一个表中</p>
<h2 id="5-4-不同链表的散列表"><a href="#5-4-不同链表的散列表" class="headerlink" title="5.4 不同链表的散列表"></a>5.4 不同链表的散列表</h2><h3 id="5-4-1-线性探测法"><a href="#5-4-1-线性探测法" class="headerlink" title="5.4.1 线性探测法"></a>5.4.1 线性探测法</h3><p>在线性探测法中，函数f是i的线性函数，典型情形是$f(i) = i$</p>
<h3 id="5-4-2-平方探测法"><a href="#5-4-2-平方探测法" class="headerlink" title="5.4.2 平方探测法"></a>5.4.2 平方探测法</h3><p>平方探测是消除线性探测中一次聚集问题的冲突解决方法。</p>
<p>平方探测就是冲突函数为二次的探测方法，流行的选择是$f(i)=i^2$</p>
<p>定理：如果使用平方探测，且表的大小是素数，那么当表至少有一半是空的时候总能够插入一个新元素</p>
<h3 id="5-4-3-双散列"><a href="#5-4-3-双散列" class="headerlink" title="5.4.3 双散列"></a>5.4.3 双散列</h3><p>对于双散列，一种流行的选择是$f(i)=i*hash_2(x)$</p>
<h2 id="5-5-再散列"><a href="#5-5-再散列" class="headerlink" title="5.5 再散列"></a>5.5 再散列</h2><p>建立另外一个大约两倍大的表（而且使用一个相关的新散列函数），扫描整个原始散列表，计算每个（未删除的）元素的新散列值并将其插入到新表中</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2011.png" alt="Untitled"></p>
<h2 id="5-6-标准库中的散列表"><a href="#5-6-标准库中的散列表" class="headerlink" title="5.6 标准库中的散列表"></a>5.6 标准库中的散列表</h2><h2 id="5-7-最坏情形下O-1-访问的散列表"><a href="#5-7-最坏情形下O-1-访问的散列表" class="headerlink" title="5.7 最坏情形下O(1)访问的散列表"></a>5.7 最坏情形下O(1)访问的散列表</h2><h3 id="5-7-1-完美散列"><a href="#5-7-1-完美散列" class="headerlink" title="5.7.1 完美散列"></a>5.7.1 完美散列</h3><h3 id="5-7-2-布谷鸟散列"><a href="#5-7-2-布谷鸟散列" class="headerlink" title="5.7.2 布谷鸟散列"></a>5.7.2 布谷鸟散列</h3><p>在布谷鸟散列中，假设有N个项。我们维护两个分别超过半空的表，且有两个独立的散列函数，可以把每个项分配到每个表中的一个位置。布谷鸟散列保持不变的是一个项总会被存储在这两个位置之一。</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2012.png" alt="Untitled"></p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2013.png" alt="Untitled"></p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2014.png" alt="Untitled"></p>
<h3 id="5-7-3-跳房子散列"><a href="#5-7-3-跳房子散列" class="headerlink" title="5.7.3 跳房子散列"></a>5.7.3 跳房子散列</h3><p>跳房子散列的思路是用事先确定的、对计算机的底层体系结构而言是最优的一个常数，给探测序列的最大长度加个上界。这样做可以给出常数集的最坏查询时间，并且与布谷鸟散列一样，查询可以并行化，以同时检查可用位置的有限集。</p>
<h2 id="5-8-通用散列法"><a href="#5-8-通用散列法" class="headerlink" title="5.8 通用散列法"></a>5.8 通用散列法</h2><h1 id="第-6-章-优先队列（堆）"><a href="#第-6-章-优先队列（堆）" class="headerlink" title="第 6 章 优先队列（堆）"></a>第 6 章 优先队列（堆）</h1><h2 id="6-1-模型"><a href="#6-1-模型" class="headerlink" title="6.1 模型"></a>6.1 模型</h2><p>优先队列是允许至少下列两种操作的数据结构：插入和删除最小者。</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2015.png" alt="Untitled"></p>
<h2 id="6-2-一些简单的实现"><a href="#6-2-一些简单的实现" class="headerlink" title="6.2 一些简单的实现"></a>6.2 一些简单的实现</h2><ol>
<li>使用简单链表</li>
<li>使用二叉查找树</li>
</ol>
<h2 id="6-3-二叉堆"><a href="#6-3-二叉堆" class="headerlink" title="6.3 二叉堆"></a>6.3 二叉堆</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2016.png" alt="Untitled"></p>
<h3 id="6-3-1-结构性质"><a href="#6-3-1-结构性质" class="headerlink" title="6.3.1 结构性质"></a>6.3.1 结构性质</h3><p>堆是一个完全二叉树</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2017.png" alt="Untitled"></p>
<ol>
<li>插入</li>
</ol>
<p>为将一个元素X插入到堆中，我们在一个可用位置创建一个空穴，否则该堆将不是完全熟，如果可以放在该空穴中而不破坏堆的序，那么插入完成。否则我们把空穴的父节点上的元素移入该空穴中，这样空穴就朝着根的方向上冒一步。继续该过程直到X能被放入空穴中为止。</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2018.png" alt="Untitled"></p>
<ol>
<li>删除最小元</li>
</ol>
<p>删除最小元以类似于插入的方式处理。当删除一个最小元时，要在跟节点建立一个空穴。由于现在堆少了一个元素，因此堆中最后一个元素X必须移动到该堆的某个地方。如果X可以被放倒空穴中，那么deleteMin完成，否则我们将空穴的两个儿子中较小者移入空穴，这样就把空穴向下推了一层，重复该步骤直到X可以被放入空穴中。</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2019.png" alt="Untitled"></p>
<h2 id="6-4-优先队列的应用"><a href="#6-4-优先队列的应用" class="headerlink" title="6.4 优先队列的应用"></a>6.4 优先队列的应用</h2><h2 id="6-5-d-堆"><a href="#6-5-d-堆" class="headerlink" title="6.5 d-堆"></a>6.5 d-堆</h2><p>d-堆是二叉堆的简单推广，就像一个二叉堆，只是所有的节点都有d个儿子（因此，二叉堆是2-堆）</p>
<h2 id="6-6-左式堆"><a href="#6-6-左式堆" class="headerlink" title="6.6 左式堆"></a>6.6 左式堆</h2><p>左式堆像二叉堆那样也具有结构性和有序性。左式堆具有相同的堆序性质，左式堆也是二叉树，左式堆和叉二树唯一的区别是：左式堆不是理想平衡的，而实际上趋向于非常不平衡。</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2020.png" alt="Untitled"></p>
<h2 id="6-7-斜堆"><a href="#6-7-斜堆" class="headerlink" title="6.7 斜堆"></a>6.7 斜堆</h2><p>斜堆是左式堆的自调节形式，实现起来极其简单。</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2021.png" alt="Untitled"></p>
<h2 id="6-8-二项队列"><a href="#6-8-二项队列" class="headerlink" title="6.8 二项队列"></a>6.8 二项队列</h2><h3 id="6-8-1-二项队列结构"><a href="#6-8-1-二项队列结构" class="headerlink" title="6.8.1 二项队列结构"></a>6.8.1 二项队列结构</h3><p>一个二项队列不是一颗堆序的树，而是堆序的树的集合，称为森林。</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2022.png" alt="Untitled"></p>
<h1 id="第-7-章-排序"><a href="#第-7-章-排序" class="headerlink" title="第 7 章 排序"></a>第 7 章 排序</h1><h2 id="7-2-插入排序"><a href="#7-2-插入排序" class="headerlink" title="7.2 插入排序"></a>7.2 插入排序</h2><p>插入排序由N-1趟排序组成。对于p=1到N-1趟，插入排序保证从位置0到位置p上的元素为已排序状态。</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2023.png" alt="Untitled"></p>
<p>时间复杂度：$O(N^2)$</p>
<p>定理：通过交换相邻元素进行排序的任何算法平均都需要$Ω(N^2)$时间</p>
<h2 id="7-4-希尔排序"><a href="#7-4-希尔排序" class="headerlink" title="7.4 希尔排序"></a>7.4 希尔排序</h2><p>定理：使用希尔排序最坏情形运行时间为$O(N^2)$</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2024.png" alt="Untitled"></p>
<h2 id="7-5-堆排序"><a href="#7-5-堆排序" class="headerlink" title="7.5 堆排序"></a>7.5 堆排序</h2><p>优先队列可以用以$O(NlogN)$时间的排序。基于该思想的算法叫做堆排序。</p>
<h2 id="7-6-归并排序"><a href="#7-6-归并排序" class="headerlink" title="7.6 归并排序"></a>7.6 归并排序</h2><p>归并排序以O(NlogN)最坏情形时间运行。它是递归算法一个好的实例。</p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2025.png" alt="Untitled"></p>
<h2 id="7-7-快速排序"><a href="#7-7-快速排序" class="headerlink" title="7.7 快速排序"></a>7.7 快速排序</h2><p>快速排序是事件中一种快速的排序算法，在C++或对Java基本类型的排序汇总特别有用。平均运行时间是$O(NlogN)$。</p>
<h1 id="第-9-章-图论"><a href="#第-9-章-图论" class="headerlink" title="第 9 章 图论"></a>第 9 章 图论</h1><h2 id="9-1-定义"><a href="#9-1-定义" class="headerlink" title="9.1 定义"></a>9.1 定义</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2026.png" alt="Untitled"></p>
<p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2027.png" alt="Untitled"></p>
<h2 id="9-2-拓扑排序"><a href="#9-2-拓扑排序" class="headerlink" title="9.2 拓扑排序"></a>9.2 拓扑排序</h2><h2 id="9-3-最短路径算法"><a href="#9-3-最短路径算法" class="headerlink" title="9.3 最短路径算法"></a>9.3 最短路径算法</h2><h3 id="9-3-1-无权最短路径"><a href="#9-3-1-无权最短路径" class="headerlink" title="9.3.1 无权最短路径"></a>9.3.1 无权最短路径</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2028.png" alt="Untitled"></p>
<h2 id="未完"><a href="#未完" class="headerlink" title="未完"></a>未完</h2><h1 id="第-9-章-算法设计技巧"><a href="#第-9-章-算法设计技巧" class="headerlink" title="第 9 章 算法设计技巧"></a>第 9 章 算法设计技巧</h1><h2 id="10-1-贪婪算法"><a href="#10-1-贪婪算法" class="headerlink" title="10.1 贪婪算法"></a>10.1 贪婪算法</h2><p>贪婪算法分阶段地工作，在每一个阶段可以认为所做决定是好的。而不考虑将来的后果。</p>
<h2 id="10-2-分治算法"><a href="#10-2-分治算法" class="headerlink" title="10.2 分治算法"></a>10.2 分治算法</h2><p>分治算法由两部分组成：</p>
<ul>
<li>分：递归解决较小的问题</li>
<li>治：然后从子问题的解构建原问题的解</li>
</ul>
<h2 id="10-3-动态规划"><a href="#10-3-动态规划" class="headerlink" title="10.3 动态规划"></a>10.3 动态规划</h2><p>将递归算法重新写成非递归算法，让后者把那些子问题的答案系统第记录在一个表内，利用这种方法的一种技巧叫做动态规划</p>
<h2 id="10-4-随机数算法"><a href="#10-4-随机数算法" class="headerlink" title="10.4 随机数算法"></a>10.4 随机数算法</h2><h2 id="10-5-回溯算法"><a href="#10-5-回溯算法" class="headerlink" title="10.5 回溯算法"></a>10.5 回溯算法</h2><h1 id="第-12-章-高级数据结构及其实现"><a href="#第-12-章-高级数据结构及其实现" class="headerlink" title="第 12 章 高级数据结构及其实现"></a>第 12 章 高级数据结构及其实现</h1><h2 id="12-2-红黑树"><a href="#12-2-红黑树" class="headerlink" title="12.2 红黑树"></a>12.2 红黑树</h2><p>对红黑树的操作在最坏情形下花费O(logN)时间</p>
<p>红黑树是具有下列着色性质的二叉查找树：</p>
<ul>
<li>每一个节点或者着成红色，或者着成黑色</li>
<li>根是黑色的</li>
<li>如果一个节点是红色，那么它的子节点必须是黑色的</li>
<li>从一个节点到一个null引用的每一条路径必须包含相同数目的黑色节点</li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/01/29/blockchain/ethereum/Docker%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A---%E7%A7%81%E6%9C%89%E9%93%BE/" title="Docker方式搭建以太坊网络-私有链"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Docker方式搭建以太坊网络-私有链</span></a><a class="button is-default" href="/2022/01/18/distributed_storage/IPFS%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/" title="IPFS原理深入分析"><span class="has-text-weight-semibold">Next: IPFS原理深入分析</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="zhangzhishun/blockchain-blog-comment" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/zhang_zhishun"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/zhangzhishun"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Sugar 2022</span></p><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>