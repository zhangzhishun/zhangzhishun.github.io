<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Go面试题</title><meta name="description" content="Blockchain knowledge record blog"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + 'e574a92bc4bac2e317309d7ea1dfcb71';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="/images/system/head_portrait.jpg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="参考链接
一、Go 语言笔试面试题(基础语法)1. = 和 := 的区别？答案:= 声明+赋值= 仅赋值
var foo int
foo = 10
// 等价于
foo := 10

2. 指针的作用？答案指针用来保存变量的地址。例如
var x =  5
var p *int = &amp;amp;x
fmt.Printf(&quot;x = %d&quot;,  *p) // x 可以用 *p 访问


运算符，也称为解引用运算符，用于访问地址中的值。＆运算符，也称为地址运算符，用于返回变量的地址。Q3 Go 允许多个返回值吗？答案允许func swap(x, y string) (string, string) {
 return y, x
}



func main() {   a, b := swap(“A”, “B”) .."><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Sugar's blog" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Sugar's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Go面试题</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/works">Works</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/works">Works</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Go-%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">一、Go 语言笔试面试题(基础语法)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1. &#x3D; 和 :&#x3D; 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">2. 指针的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%EF%BC%88Goroutine%EF%BC%89"><span class="toc-text">5. 什么是协程（Goroutine）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">6. 如何高效地拼接字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF-rune-%E7%B1%BB%E5%9E%8B"><span class="toc-text">7. 什么是 rune 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-map-%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA-key-%EF%BC%9F"><span class="toc-text">8. 如何判断 map 中是否包含某个 key ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Go-%E6%94%AF%E6%8C%81%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E6%88%96%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-text">9. Go 支持默认参数或可选参数吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-defer-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">10. defer 的执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Go-%E8%AF%AD%E8%A8%80-tag-%E7%9A%84%E7%94%A8%E5%A4%84%EF%BC%9F"><span class="toc-text">12. Go 语言 tag 的用处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-2-%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87%EF%BC%88slice-%E6%98%AF%E7%9B%B8%E7%AD%89%E7%9A%84%EF%BC%9F"><span class="toc-text">13. 如何判断 2 个字符串切片（slice) 是相等的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%93%E5%8D%B0%E6%97%B6%EF%BC%8C-v-%E5%92%8C-v-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">14. 字符串打印时，%v 和 %+v 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E6%9E%9A%E4%B8%BE%E5%80%BC-enums"><span class="toc-text">15. Go 语言中如何表示枚举值(enums)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E7%A9%BA-struct-%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-text">16. 空 struct{} 的用途</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Go-%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">二、Go 语言笔试面试题(实现原理)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-init-%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="toc-text">1. init() 函数是什么时候执行的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%88%86%E9%85%8D%E5%9C%A8%E6%A0%88%E4%B8%8A%E8%BF%98%E6%98%AF%E5%A0%86%E4%B8%8A%EF%BC%9F"><span class="toc-text">2. Go 语言的局部变量分配在栈上还是堆上？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%B8%AA-interface-%E5%8F%AF%E4%BB%A5%E6%AF%94%E8%BE%83%E5%90%97%EF%BC%9F"><span class="toc-text">3. 2 个 interface 可以比较吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%A4%E4%B8%AA-nil-%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9B%B8%E7%AD%89%E5%90%97%EF%BC%9F"><span class="toc-text">4. 两个 nil 可能不相等吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%80%E8%BF%B0-Go-%E8%AF%AD%E8%A8%80GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">5. 简述 Go 语言GC(垃圾回收)的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">6. 函数返回局部变量的指针是否安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%9D%9E%E6%8E%A5%E5%8F%A3%E9%9D%9E%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B-T-%E9%83%BD%E8%83%BD%E5%A4%9F%E8%B0%83%E7%94%A8-T-%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F%E5%8F%8D%E8%BF%87%E6%9D%A5%E5%91%A2%EF%BC%9F"><span class="toc-text">7. 非接口非接口的任意类型 T() 都能够调用 *T 的方法吗？反过来呢？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Go-%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">三、Go 语言笔试面试题(并发编程)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84-channel-%E5%92%8C-%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84-channel-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1. 无缓冲的 channel 和 有缓冲的 channel 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%E6%B3%84%E9%9C%B2-Goroutine-Leak-%EF%BC%9F"><span class="toc-text">2. 什么是协程泄露(Goroutine Leak)？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Go-%E5%8F%AF%E4%BB%A5%E9%99%90%E5%88%B6%E8%BF%90%E8%A1%8C%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F%E5%90%97%EF%BC%9F"><span class="toc-text">3. Go 可以限制运行时操作系统线程的数量吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Go-%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA"><span class="toc-text">三、Go 语言笔试面试题(代码输出)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="toc-text">1. 常量与变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%EF%BC%9A"><span class="toc-text">1.1 下列代码的输出是：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%EF%BC%9A"><span class="toc-text">1.2 下列代码的输出是：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%EF%BC%9A"><span class="toc-text">1.3 下列代码的输出是：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%EF%BC%9A"><span class="toc-text">1.4 下列代码的输出是：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">2. 作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%EF%BC%9A"><span class="toc-text">2.1 下列代码的输出是：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-defer-%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8"><span class="toc-text">3. defer 延迟调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%EF%BC%9A"><span class="toc-text">3.1 下列代码的输出是：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%EF%BC%9A"><span class="toc-text">3.2 下列代码的输出是：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%EF%BC%9A"><span class="toc-text">3.3 下列代码的输出是：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%EF%BC%9A"><span class="toc-text">3.4 下列代码的输出是：</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Go"><i class="tag post-item-tag">Go</i></a><a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98"><i class="tag post-item-tag">面试题</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Go面试题</h1><time class="has-text-grey" datetime="2022-01-16T02:29:15.000Z">2022-01-16</time><article class="mt-2 post-content"><p><a target="_blank" rel="noopener" href="https://geektutu.com/post/qa-golang.html">参考链接</a></p>
<h1 id="一、Go-语言笔试面试题-基础语法"><a href="#一、Go-语言笔试面试题-基础语法" class="headerlink" title="一、Go 语言笔试面试题(基础语法)"></a>一、Go 语言笔试面试题(基础语法)</h1><h2 id="1-和-的区别？"><a href="#1-和-的区别？" class="headerlink" title="1. = 和 := 的区别？"></a>1. = 和 := 的区别？</h2><p>答案<br>:= 声明+赋值<br>= 仅赋值</p>
<pre><code class="go">var foo int
foo = 10
// 等价于
foo := 10
</code></pre>
<h2 id="2-指针的作用？"><a href="#2-指针的作用？" class="headerlink" title="2. 指针的作用？"></a>2. 指针的作用？</h2><p>答案<br>指针用来保存变量的地址。<br>例如</p>
<pre><code class="go">var x =  5
var p *int = &amp;x
fmt.Printf("x = %d",  *p) // x 可以用 *p 访问
</code></pre>
<ul>
<li>运算符，也称为解引用运算符，用于访问地址中的值。<br>＆运算符，也称为地址运算符，用于返回变量的地址。<br>Q3 Go 允许多个返回值吗？<br>答案<br>允许<pre><code>func swap(x, y string) (string, string) {
 return y, x
}
</code></pre>
</li>
</ul>
<p>func main() {<br>   a, b := swap(“A”, “B”)<br>   fmt.Println(a, b) // B A<br>}</p>
<pre><code>## 4. Go 有异常类型吗？
答案
Go 没有异常类型，只有错误类型（Error），通常使用返回值来表示异常状态。
```go
f, err := os.Open("test.txt")
if err != nil {
    log.Fatal(err)
}
</code></pre>
<h2 id="5-什么是协程（Goroutine）"><a href="#5-什么是协程（Goroutine）" class="headerlink" title="5. 什么是协程（Goroutine）"></a>5. 什么是协程（Goroutine）</h2><p>答案<br>Goroutine 是与其他函数或方法同时运行的函数或方法。 Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p>
<h2 id="6-如何高效地拼接字符串"><a href="#6-如何高效地拼接字符串" class="headerlink" title="6. 如何高效地拼接字符串"></a>6. 如何高效地拼接字符串</h2><p>答案<br>Go 语言中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。如果需要拼接多次，应使用 strings.Builder，最小化内存拷贝次数。</p>
<pre><code class="go">var str strings.Builder
for i := 0; i &lt; 1000; i++ {
    str.WriteString("a")
}
fmt.Println(str.String())
</code></pre>
<h2 id="7-什么是-rune-类型"><a href="#7-什么是-rune-类型" class="headerlink" title="7. 什么是 rune 类型"></a>7. 什么是 rune 类型</h2><p>答案<br>ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。<br>Go 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。例如下面的例子中 语 和 言 使用 UTF-8 编码后各占 3 个 byte，因此 len(“Go语言”) 等于 8，当然我们也可以将字符串转换为 rune 序列。</p>
<pre><code class="go">fmt.Println(len("Go语言")) // 8
fmt.Println(len([]rune("Go语言"))) // 4
</code></pre>
<h2 id="8-如何判断-map-中是否包含某个-key-？"><a href="#8-如何判断-map-中是否包含某个-key-？" class="headerlink" title="8. 如何判断 map 中是否包含某个 key ？"></a>8. 如何判断 map 中是否包含某个 key ？</h2><p>答案</p>
<pre><code class="go">if val, ok := dict["foo"]; ok {
    //do something here
}
</code></pre>
<p>dict[“foo”] 有 2 个返回值，val 和 ok，如果 ok 等于 true，则说明 dict 包含 key “foo”，val 将被赋予 “foo” 对应的值。</p>
<h2 id="9-Go-支持默认参数或可选参数吗？"><a href="#9-Go-支持默认参数或可选参数吗？" class="headerlink" title="9. Go 支持默认参数或可选参数吗？"></a>9. Go 支持默认参数或可选参数吗？</h2><p>答案<br>Go 语言不支持可选参数（python 支持），也不支持方法重载（java支持）。</p>
<h2 id="10-defer-的执行顺序"><a href="#10-defer-的执行顺序" class="headerlink" title="10. defer 的执行顺序"></a>10. defer 的执行顺序</h2><p>答案<br>多个 defer 语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的 defer 语句，最先得到执行。<br>defer 在 return 语句之后执行，但在函数退出之前，defer 可以修改返回值。<br>例如：</p>
<pre><code class="go">func test() int {
    i := 0
    defer func() {
        fmt.Println("defer1")
    }()
    defer func() {
        i += 1
        fmt.Println("defer2")
    }()
    return i
}

func main() {
    fmt.Println("return", test())
}
// defer2
// defer1
// return 0
</code></pre>
<p>这个例子中，可以看到 defer 的执行顺序：后进先出。但是返回值并没有被修改，这是由于 Go 的返回机制决定的，执行 return 语句后，Go 会创建一个临时变量保存返回值，因此，defer 语句修改了局部变量 i，并没有修改返回值。那如果是有名的返回值呢？</p>
<pre><code class="go">func test() (i int) {
    i = 0
    defer func() {
        i += 1
        fmt.Println("defer2")
    }()
    return i
}

func main() {
    fmt.Println("return", test())
}
// defer2
// return 1
</code></pre>
<p>这个例子中，返回值被修改了。对于有名返回值的函数，执行 return 语句时，并不会再创建临时变量保存，因此，defer 语句修改了 i，即对返回值产生了影响。<br>Q11 如何交换 2 个变量的值？<br>答案</p>
<pre><code class="go">a, b := "A", "B"
a, b = b, a
fmt.Println(a, b) // B A
</code></pre>
<h2 id="12-Go-语言-tag-的用处？"><a href="#12-Go-语言-tag-的用处？" class="headerlink" title="12. Go 语言 tag 的用处？"></a>12. Go 语言 tag 的用处？</h2><p>答案<br>tag 可以理解为 struct 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性。<br>例如：</p>
<pre><code class="go">package main

import "fmt"
import "encoding/json"

type Stu struct {
    Name string `json:"stu_name"`
    ID   string `json:"stu_id"`
    Age  int    `json:"-"`
}

func main() {
    buf, _ := json.Marshal(Stu{"Tom", "t001", 18})
    fmt.Printf("%s\n", buf)
}
</code></pre>
<p>这个例子使用 tag 定义了结构体字段与 json 字段的转换关系，Name -&gt; stu_name, ID -&gt; stu_id，忽略 Age 字段。很方便地实现了 Go 结构体与不同规范的 json 文本之间的转换。</p>
<h2 id="13-如何判断-2-个字符串切片（slice-是相等的？"><a href="#13-如何判断-2-个字符串切片（slice-是相等的？" class="headerlink" title="13. 如何判断 2 个字符串切片（slice) 是相等的？"></a>13. 如何判断 2 个字符串切片（slice) 是相等的？</h2><p>答案<br>go 语言中可以使用反射 reflect.DeepEqual(a, b) 判断 a、b 两个切片是否相等，但是通常不推荐这么做，使用反射非常影响性能。<br>通常采用的方式如下，遍历比较切片中的每一个元素（注意处理越界的情况）。</p>
<pre><code class="go">func StringSliceEqualBCE(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }

    if (a == nil) != (b == nil) {
        return false
    }

    b = b[:len(a)]
    for i, v := range a {
        if v != b[i] {
            return false
        }
    }

    return true
}
</code></pre>
<h2 id="14-字符串打印时，-v-和-v-的区别"><a href="#14-字符串打印时，-v-和-v-的区别" class="headerlink" title="14. 字符串打印时，%v 和 %+v 的区别"></a>14. 字符串打印时，%v 和 %+v 的区别</h2><p>答案<br>%v 和 %+v 都可以用来打印 struct 的值，区别在于 %v 仅打印各个字段的值，%+v 还会打印各个字段的名称。</p>
<pre><code class="go">type Stu struct {
    Name string
}

func main() {
    fmt.Printf("%v\n", Stu{"Tom"}) // {Tom}
    fmt.Printf("%+v\n", Stu{"Tom"}) // {Name:Tom}
}
</code></pre>
<p>但如果结构体定义了 String() 方法，%v 和 %+v 都会调用 String() 覆盖默认值。</p>
<h2 id="15-Go-语言中如何表示枚举值-enums"><a href="#15-Go-语言中如何表示枚举值-enums" class="headerlink" title="15. Go 语言中如何表示枚举值(enums)"></a>15. Go 语言中如何表示枚举值(enums)</h2><p>答案<br>通常使用常量(const) 来表示枚举值。</p>
<pre><code class="go">type StuType int32

const (
    Type1 StuType = iota
    Type2
    Type3
    Type4
)

func main() {
    fmt.Println(Type1, Type2, Type3, Type4) // 0, 1, 2, 3
}
</code></pre>
<p>参考 What is an idiomatic way of representing enums in Go? - StackOverflow</p>
<h2 id="16-空-struct-的用途"><a href="#16-空-struct-的用途" class="headerlink" title="16. 空 struct{} 的用途"></a>16. 空 struct{} 的用途</h2><p>答案<br>使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。</p>
<pre><code class="go">fmt.Println(unsafe.Sizeof(struct{}{})) // 0
</code></pre>
<p>比如使用 map 表示集合时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。</p>
<pre><code class="go">type Set map[string]struct{}

func main() {
    set := make(Set)

    for _, item := range []string{"A", "A", "B", "C"} {
        set[item] = struct{}{}
    }
    fmt.Println(len(set)) // 3
    if _, ok := set["A"]; ok {
        fmt.Println("A exists") // A exists
    }
}
</code></pre>
<p>再比如，使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。</p>
<pre><code class="go">func main() {
    ch := make(chan struct{}, 1)
    go func() {
        &lt;-ch
        // do something
    }()
    ch &lt;- struct{}{}
    // ...
}
</code></pre>
<p>再比如，声明只包含方法的结构体。</p>
<pre><code class="go">type Lamp struct{}

func (l Lamp) On() {
        println("On")

}
func (l Lamp) Off() {
        println("Off")
}
</code></pre>
<h1 id="二、Go-语言笔试面试题-实现原理"><a href="#二、Go-语言笔试面试题-实现原理" class="headerlink" title="二、Go 语言笔试面试题(实现原理)"></a>二、Go 语言笔试面试题(实现原理)</h1><h2 id="1-init-函数是什么时候执行的？"><a href="#1-init-函数是什么时候执行的？" class="headerlink" title="1. init() 函数是什么时候执行的？"></a>1. init() 函数是什么时候执行的？</h2><p>答案<br>init() 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。<br>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 init() 函数。同一个包，甚至是同一个源文件可以有多个 init() 函数。init() 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 init() 函数的执行顺序不作保证。<br>一句话总结： import –&gt; const –&gt; var –&gt; init() –&gt; main()<br>示例：</p>
<pre><code class="go">package main

import "fmt"

func init()  {
    fmt.Println("init1:", a)
}

func init()  {
    fmt.Println("init2:", a)
}

var a = 10
const b = 100

func main() {
    fmt.Println("main:", a)
}

// 执行结果
// init1: 10
// init2: 10
// main: 10
</code></pre>
<h2 id="2-Go-语言的局部变量分配在栈上还是堆上？"><a href="#2-Go-语言的局部变量分配在栈上还是堆上？" class="headerlink" title="2. Go 语言的局部变量分配在栈上还是堆上？"></a>2. Go 语言的局部变量分配在栈上还是堆上？</h2><p>答案<br>由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。</p>
<pre><code class="go">func foo() *int {
    v := 11
    return &amp;v
}

func main() {
    m := foo()
    println(*m) // 11
}
</code></pre>
<p>foo() 函数中，如果 v 分配在栈上，foo 函数返回时，&amp;v 就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 foo 的作用域，会将其分配在堆上。因此，main 函数中仍能够正常访问该值。</p>
<h2 id="3-2-个-interface-可以比较吗？"><a href="#3-2-个-interface-可以比较吗？" class="headerlink" title="3. 2 个 interface 可以比较吗？"></a>3. 2 个 interface 可以比较吗？</h2><p>答案<br>Go 语言中，interface 的内部实现包含了 2 个字段，类型 T 和 值 V，interface 可以使用 == 或 != 比较。2 个 interface 相等有以下 2 种情况<br>两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）<br>类型 T 相同，且对应的值 V 相等。<br>看下面的例子：</p>
<pre><code class="go">type Stu struct {
    Name string
}

type StuInt interface{}

func main() {
    var stu1, stu2 StuInt = &amp;Stu{"Tom"}, &amp;Stu{"Tom"}
    var stu3, stu4 StuInt = Stu{"Tom"}, Stu{"Tom"}
    fmt.Println(stu1 == stu2) // false
    fmt.Println(stu3 == stu4) // true
}
</code></pre>
<p>stu1 和 stu2 对应的类型是 *Stu，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。<br>stu3 和 stu4 对应的类型是 Stu，值是 Stu 结构体，且各字段相等，因此结果为 true。</p>
<h2 id="4-两个-nil-可能不相等吗？"><a href="#4-两个-nil-可能不相等吗？" class="headerlink" title="4. 两个 nil 可能不相等吗？"></a>4. 两个 nil 可能不相等吗？</h2><p>答案<br>可能。<br>接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 T 和 值 V。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。<br>两个接口值比较时，会先比较 T，再比较 V。<br>接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。</p>
<pre><code class="go">func main() {
    var p *int = nil
    var i interface{} = p
    fmt.Println(i == p) // true
    fmt.Println(p == nil) // true
    fmt.Println(i == nil) // false
}
</code></pre>
<p>上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为(T=*int, V=nil)，i 与 p 作比较时，将 p 转换为接口后再比较，因此 i == p，p 与 nil 比较，直接比较值，所以 p == nil。<br>但是当 i 与 nil 比较时，会将 nil 转换为接口 (T=nil, V=nil)，与i (T=*int, V=nil) 不相等，因此 i != nil。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。</p>
<h2 id="5-简述-Go-语言GC-垃圾回收-的工作原理"><a href="#5-简述-Go-语言GC-垃圾回收-的工作原理" class="headerlink" title="5. 简述 Go 语言GC(垃圾回收)的工作原理"></a>5. 简述 Go 语言GC(垃圾回收)的工作原理</h2><p>答案<br>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。<br>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：<br>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；<br>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。<br>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。<br>三色标记算法将程序中的对象分成白色、黑色和灰色三类。<br>白色：不确定对象。<br>灰色：存活对象，子对象待处理。<br>黑色：存活对象。<br>标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。<br>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。<br>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p>
<pre><code>A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)
</code></pre>
<p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p>
<pre><code>A (黑) -&gt; B (灰) -&gt; C (白) 
  ↓
 D (白)
</code></pre>
<p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。<br>一次完整的 GC 分为四个阶段：<br>1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)<br>2）使用三色标记法标记（Marking, 并发）<br>3）标记结束(Mark Termination，需 STW)，关闭写屏障。<br>4）清理(Sweeping, 并发)<br>参考 fullstack</p>
<h2 id="6-函数返回局部变量的指针是否安全？"><a href="#6-函数返回局部变量的指针是否安全？" class="headerlink" title="6. 函数返回局部变量的指针是否安全？"></a>6. 函数返回局部变量的指针是否安全？</h2><p>答案<br>这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。</p>
<h2 id="7-非接口非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？"><a href="#7-非接口非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？" class="headerlink" title="7. 非接口非接口的任意类型 T() 都能够调用 *T 的方法吗？反过来呢？"></a>7. 非接口非接口的任意类型 T() 都能够调用 *T 的方法吗？反过来呢？</h2><p>答案<br>一个T类型的值可以调用为<em>T类型声明的方法，但是仅当此T的值是可寻址(addressable) 的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型</em>T声明的方法。<br>反过来，一个<em>T类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 T 声明的方法，编译器都会为类型</em>T自动隐式声明一个同名和同签名的方法。<br>哪些值是不可寻址的呢？<br>字符串中的字节；<br>map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）；<br>常量；<br>包级别的函数等。<br>举一个例子，定义类型 T，并为类型 *T 声明一个方法 hello()，变量 t1 可以调用该方法，但是常量 t2 调用该方法时，会产生编译错误。</p>
<pre><code class="go">type T string

func (t *T) hello() {
    fmt.Println("hello")
}

func main() {
    var t1 T = "ABC"
    t1.hello() // hello
    const t2 T = "ABC"
    t2.hello() // error: cannot call pointer method on t
}
</code></pre>
<h1 id="三、Go-语言笔试面试题-并发编程"><a href="#三、Go-语言笔试面试题-并发编程" class="headerlink" title="三、Go 语言笔试面试题(并发编程)"></a>三、Go 语言笔试面试题(并发编程)</h1><h2 id="1-无缓冲的-channel-和-有缓冲的-channel-的区别？"><a href="#1-无缓冲的-channel-和-有缓冲的-channel-的区别？" class="headerlink" title="1. 无缓冲的 channel 和 有缓冲的 channel 的区别？"></a>1. 无缓冲的 channel 和 有缓冲的 channel 的区别？</h2><p>答案<br>对于无缓冲的 channel，发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。<br>对于有缓存的 channel，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。<br>例如:</p>
<pre><code class="go">func main() {
    st := time.Now()
    ch := make(chan bool)
    go func ()  {
        time.Sleep(time.Second * 2)
        &lt;-ch
    }()
    ch &lt;- true  // 无缓冲，发送方阻塞直到接收方接收到数据。
    fmt.Printf("cost %.1f s\n", time.Now().Sub(st).Seconds())
    time.Sleep(time.Second * 5)
}
</code></pre>
<pre><code class="go">func main() {
    st := time.Now()
    ch := make(chan bool, 2)
    go func ()  {
        time.Sleep(time.Second * 2)
        &lt;-ch
    }()
    ch &lt;- true
    ch &lt;- true // 缓冲区为 2，发送方不阻塞，继续往下执行
    fmt.Printf("cost %.1f s\n", time.Now().Sub(st).Seconds()) // cost 0.0 s
    ch &lt;- true // 缓冲区使用完，发送方阻塞，2s 后接收方接收到数据，释放一个插槽，继续往下执行
    fmt.Printf("cost %.1f s\n", time.Now().Sub(st).Seconds()) // cost 2.0 s
    time.Sleep(time.Second * 5)
}
</code></pre>
<h2 id="2-什么是协程泄露-Goroutine-Leak-？"><a href="#2-什么是协程泄露-Goroutine-Leak-？" class="headerlink" title="2. 什么是协程泄露(Goroutine Leak)？"></a>2. 什么是协程泄露(Goroutine Leak)？</h2><p>答案<br>协程泄露是指协程创建后，长时间得不到释放，并且还在不断地创建新的协程，最终导致内存耗尽，程序崩溃。常见的导致协程泄露的场景有以下几种：<br>缺少接收器，导致发送阻塞<br>这个例子中，每执行一次 query，则启动1000个协程向信道 ch 发送数字 0，但只接收了一次，导致 999 个协程被阻塞，不能退出。</p>
<pre><code class="go">func query() int {
    ch := make(chan int)
    for i := 0; i &lt; 1000; i++ {
        go func() { ch &lt;- 0 }()
    }
    return &lt;-ch
}

func main() {
    for i := 0; i &lt; 4; i++ {
        query()
        fmt.Printf("goroutines: %d\n", runtime.NumGoroutine())
    }
}
// goroutines: 1001
// goroutines: 2000
// goroutines: 2999
// goroutines: 3998
</code></pre>
<p>缺少发送器，导致接收阻塞<br>那同样的，如果启动 1000 个协程接收信道的信息，但信道并不会发送那么多次的信息，也会导致接收协程被阻塞，不能退出。<br>死锁(dead lock)<br>两个或两个以上的协程在执行过程中，由于竞争资源或者由于彼此通信而造成阻塞，这种情况下，也会导致协程被阻塞，不能退出。<br>无限循环(infinite loops)<br>这个例子中，为了避免网络等问题，采用了无限重试的方式，发送 HTTP 请求，直到获取到数据。那如果 HTTP 服务宕机，永远不可达，导致协程不能退出，发生泄漏。</p>
<pre><code class="go">func request(url string, wg *sync.WaitGroup) {
    i := 0
    for {
        if _, err := http.Get(url); err == nil {
            // write to db
            break
        }
        i++
        if i &gt;= 3 {
            break
        }
        time.Sleep(time.Second)
    }
    wg.Done()
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go request(fmt.Sprintf("https://127.0.0.1:8080/%d", i), &amp;wg)
    }
    wg.Wait()
}
</code></pre>
<h2 id="3-Go-可以限制运行时操作系统线程的数量吗？"><a href="#3-Go-可以限制运行时操作系统线程的数量吗？" class="headerlink" title="3. Go 可以限制运行时操作系统线程的数量吗？"></a>3. Go 可以限制运行时操作系统线程的数量吗？</h2><p>答案<br>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit.<br>可以使用环境变量 GOMAXPROCS 或 runtime.GOMAXPROCS(num int) 设置，例如：</p>
<pre><code class="go">runtime.GOMAXPROCS(1) // 限制同时执行Go代码的操作系统线程数为 1
</code></pre>
<p>从官方文档的解释可以看到，GOMAXPROCS 限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。GOMAXPROCS 的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I/O 密集型应用，适当地调大该值，可以提高 I/O 吞吐率。</p>
<h1 id="三、Go-语言笔试面试题-代码输出"><a href="#三、Go-语言笔试面试题-代码输出" class="headerlink" title="三、Go 语言笔试面试题(代码输出)"></a>三、Go 语言笔试面试题(代码输出)</h1><h2 id="1-常量与变量"><a href="#1-常量与变量" class="headerlink" title="1. 常量与变量"></a>1. 常量与变量</h2><h3 id="1-1-下列代码的输出是："><a href="#1-1-下列代码的输出是：" class="headerlink" title="1.1 下列代码的输出是："></a>1.1 下列代码的输出是：</h3><pre><code class="go">func main() {
    const (
        a, b = "golang", 100
        d, e
        f bool = true
        g
    )
    fmt.Println(d, e, g)
}
</code></pre>
<p>答案<br>golang 100 true<br>在同一个 const group 中，如果常量定义与前一行的定义一致，则可以省略类型和值。编译时，会按照前一行的定义自动补全。即等价于</p>
<pre><code class="go">func main() {
    const (
        a, b = "golang", 100
        d, e = "golang", 100
        f bool = true
        g bool = true
    )
    fmt.Println(d, e, g)
}
</code></pre>
<h3 id="1-2-下列代码的输出是："><a href="#1-2-下列代码的输出是：" class="headerlink" title="1.2 下列代码的输出是："></a>1.2 下列代码的输出是：</h3><pre><code class="go">func main() {
    const N = 100
    var x int = N

    const M int32 = 100
    var y int = M
    fmt.Println(x, y)
}
</code></pre>
<p>答案<br>编译失败：cannot use M (type int32) as type int in assignment<br>Go 语言中，常量分为无类型常量和有类型常量两种，const N = 100，属于无类型常量，赋值给其他变量时，如果字面量能够转换为对应类型的变量，则赋值成功，例如，var x int = N。但是对于有类型的常量 const M int32 = 100，赋值给其他变量时，需要类型匹配才能成功，所以显示地类型转换：</p>
<pre><code class="go">var y int = int(M)
</code></pre>
<h3 id="1-3-下列代码的输出是："><a href="#1-3-下列代码的输出是：" class="headerlink" title="1.3 下列代码的输出是："></a>1.3 下列代码的输出是：</h3><pre><code class="go">func main() {
    var a int8 = -1
    var b int8 = -128 / a
    fmt.Println(b)
}
</code></pre>
<p>答案<br>-128<br>int8 能表示的数字的范围是 [-2^7, 2^7-1]，即 [-128, 127]。-128 是无类型常量，转换为 int8，再除以变量 -1，结果为 128，常量除以变量，结果是一个变量。变量转换时允许溢出，符号位变为1，转为补码后恰好等于 -128。<br>对于有符号整型，最高位是是符号位，计算机用补码表示负数。补码 = 原码取反加一。<br>例如：</p>
<pre><code>-1 :  11111111
00000001(原码)    11111110(取反)    11111111(加一)
-128：    
10000000(原码)    01111111(取反)    10000000(加一)

-1 + 1 = 0
11111111 + 00000001 = 00000000(最高位溢出省略)
-128 + 127 = -1
10000000 + 01111111 = 11111111
</code></pre>
<h3 id="1-4-下列代码的输出是："><a href="#1-4-下列代码的输出是：" class="headerlink" title="1.4 下列代码的输出是："></a>1.4 下列代码的输出是：</h3><pre><code class="go">func main() {
    const a int8 = -1
    var b int8 = -128 / a
    fmt.Println(b)
}
</code></pre>
<p>答案<br>编译失败：constant 128 overflows int8<br>-128 和 a 都是常量，在编译时求值，-128 / a = 128，两个常量相除，结果也是一个常量，常量类型转换时不允许溢出，因而编译失败。</p>
<h2 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h2><h3 id="2-1-下列代码的输出是："><a href="#2-1-下列代码的输出是：" class="headerlink" title="2.1 下列代码的输出是："></a>2.1 下列代码的输出是：</h3><pre><code class="go">func main() {
    var err error
    if err == nil {
        err := fmt.Errorf("err")
        fmt.Println(1, err)
    }
    if err != nil {
        fmt.Println(2, err)
    }
}
</code></pre>
<p>答案<br>1 err<br>:= 表示声明并赋值，= 表示仅赋值。<br>变量的作用域是大括号，因此在第一个 if 语句 if err == nil 内部重新声明且赋值了与外部变量同名的局部变量 err。对该局部变量的赋值不会影响到外部的 err。因此第二个 if 语句 if err != nil 不成立。所以只打印了 1 err。</p>
<h2 id="3-defer-延迟调用"><a href="#3-defer-延迟调用" class="headerlink" title="3. defer 延迟调用"></a>3. defer 延迟调用</h2><h3 id="3-1-下列代码的输出是："><a href="#3-1-下列代码的输出是：" class="headerlink" title="3.1 下列代码的输出是："></a>3.1 下列代码的输出是：</h3><pre><code class="go">type T struct{}

func (t T) f(n int) T {
    fmt.Print(n)
    return t
}

func main() {
    var t T
    defer t.f(1).f(2)
    fmt.Print(3)
}
</code></pre>
<p>答案<br>132<br>defer 延迟调用时，需要保存函数指针和参数，因此链式调用的情况下，除了最后一个函数/方法外的函数/方法都会在调用时直接执行。也就是说 t.f(1) 直接执行，然后执行 fmt.Print(3)，最后函数返回时再执行 .f(2)，因此输出是 132。</p>
<h3 id="3-2-下列代码的输出是："><a href="#3-2-下列代码的输出是：" class="headerlink" title="3.2 下列代码的输出是："></a>3.2 下列代码的输出是：</h3><pre><code class="go">func f(n int) {
    defer fmt.Println(n)
    n += 100
}

func main() {
    f(1)
}
</code></pre>
<p>答案<br>1<br>打印 1 而不是 101。defer 语句执行时，会将需要延迟调用的函数和参数保存起来，也就是说，执行到 defer 时，参数 n(此时等于1) 已经被保存了。因此后面对 n 的改动并不会影响延迟函数调用的结果。</p>
<h3 id="3-3-下列代码的输出是："><a href="#3-3-下列代码的输出是：" class="headerlink" title="3.3 下列代码的输出是："></a>3.3 下列代码的输出是：</h3><pre><code class="go">func main() {
    n := 1
    defer func() {
        fmt.Println(n)
    }()
    n += 100
}
</code></pre>
<p>答案<br>101<br>匿名函数没有通过传参的方式将 n 传入，因此匿名函数内的 n 和函数外部的 n 是同一个，延迟执行时，已经被改变为 101。</p>
<h3 id="3-4-下列代码的输出是："><a href="#3-4-下列代码的输出是：" class="headerlink" title="3.4 下列代码的输出是："></a>3.4 下列代码的输出是：</h3><pre><code class="go">func main() {
    n := 1
    if n == 1 {
        defer fmt.Println(n)
        n += 100
    }
    fmt.Println(n)
}
</code></pre>
<p>答案<br>1<br>2<br>101<br>1<br>先打印 101，再打印 1。defer 的作用域是函数，而不是代码块，因此 if 语句退出时，defer 不会执行，而是等 101 打印后，整个函数返回时，才会执行。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/01/16/go/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%8B%E5%86%99/" title="Go面试题手写内容"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Go面试题手写内容</span></a><a class="button is-default" href="/2022/01/12/other/%E8%AE%BA%E6%96%87%E4%B8%8B%E8%BD%BD/" title="论文下载"><span class="has-text-weight-semibold">Next: 论文下载</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="zhangzhishun/blockchain-blog-comment" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/zhang_zhishun"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/zhangzhishun"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Sugar 2022</span></p><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>