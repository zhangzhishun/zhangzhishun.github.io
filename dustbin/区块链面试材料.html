<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>区块链面试材料</title><meta name="description" content="Blockchain knowledge record blog"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + 'e574a92bc4bac2e317309d7ea1dfcb71';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="/images/system/head_portrait.jpg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Sugar's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Sugar's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/works">Works</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/works">Works</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></header><main><article id="page"><h1>区块链面试材料</h1><h1 id="一、区块链面试题"><a href="#一、区块链面试题" class="headerlink" title="一、区块链面试题"></a>一、区块链面试题</h1><p><a target="_blank" rel="noopener" href="http://www.mianshigee.com/article/10021isp">参考链接</a></p>
<h2 id="1-什么是区块链？"><a href="#1-什么是区块链？" class="headerlink" title="1. 什么是区块链？"></a>1. 什么是区块链？</h2><p>回答：区块链是不间断的经济交易数字分类帐，可以进行编程，以记录不仅是金融交易，还可以记录几乎所有有价值的东西。简单来说，它是一个不可变记录的分散式分布式数据库，该数据库由计算机集群管理，但不属于任何单个实体。区块链存储为数据库或平面文件。</p>
<h2 id="2-流行的区块链平台有哪些。"><a href="#2-流行的区块链平台有哪些。" class="headerlink" title="2. 流行的区块链平台有哪些。"></a>2. 流行的区块链平台有哪些。</h2><p>回答： 流行的区块链平台如下：</p>
<p>区块链平台    共识算法    分类帐类型    管治<br>以太坊    工作证明    不允许    以太坊开发人员<br>超级账本锯齿    可插拔框架    允许的    Linux基金会<br>超级账本面料    可插拔框架    允许的    Linux基金会<br>超级账本Iroha    基于链的拜占庭容错    允许的    Linux基金会<br>开放链    分割共识    允许的    Linux基金会<br>恒星    恒星共识协议    公共和私人    恒星发展基金会<br>NEO    委派拜占庭式容错    允许的    通过NEO持有者的投票进行链上治理，并通过NEO Foundation支持进行链下治理。<br>EOS    委托权益证明    允许的    EOSIO核心仲裁论坛（ECAF）<br>赫德拉Hashgraph    异步拜占庭容错    允许的    Hedera哈希图委员会<br>R3 Corda    异步拜占庭容错    允许的    Hedera哈希图委员会<br>法定人数    多数投票    允许的    以太坊开发者和JP Morgan Chase<br>波纹         允许的    涟漪实验室</p>
<h2 id="3-区块链是如何工作的？"><a href="#3-区块链是如何工作的？" class="headerlink" title="3. 区块链是如何工作的？"></a>3. 区块链是如何工作的？</h2><p>回答：区块链由不可变的数据记录（称为数据块）组成，这些数据使用密码学进行链接。密码学不过是在读取私人消息时对第三方进行加密和保护数据通信的过程。在区块链中，一旦记录了数据，就不会更改。区块链就像带有时间戳的数字公证人一样工作，以避免篡改信息。<br><img src="https://img-blog.csdnimg.cn/20210618094137652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4-为什么区块链是一种值得信赖的方法？"><a href="#4-为什么区块链是一种值得信赖的方法？" class="headerlink" title="4. 为什么区块链是一种值得信赖的方法？"></a>4. 为什么区块链是一种值得信赖的方法？</h2><p>回答：以下原因将帮助您了解为什么区块链是受信任的方法：</p>
<p>它具有开源特性，因此与其他业务应用程序兼容。<br>其透明度和安全性几乎是空前的。<br>提高效率和速度。<br>这是安全且防黑客的。<br>您无需依赖任何中央权威，这种不信任使Blockchain成为受信任的技术。</p>
<h2 id="5-什么是区块链中的区块，如何识别？"><a href="#5-什么是区块链中的区块，如何识别？" class="headerlink" title="5. 什么是区块链中的区块，如何识别？"></a>5. 什么是区块链中的区块，如何识别？</h2><p>回答：区块链中的区块不过是数字保险箱，用于存储数据并永久锁定。添加在块上的数据是不可变的，即，不能更改或删除数据。可以通过块的高度和块头哈希来识别块。块中的数据通过称为哈希函数的计算机算法进行检测。它不仅锁定了区块链参与者可以看到的数据，而且使数据不可变。每个块都有其哈希函数。</p>
<h2 id="6-块的主要元素是什么？"><a href="#6-块的主要元素是什么？" class="headerlink" title="6. 块的主要元素是什么？"></a>6. 块的主要元素是什么？</h2><p>回答：以下是块的主要元素：</p>
<p>指向上一个块的哈希指针<br>时间戳记<br>交易清单</p>
<h2 id="7-是否可以从区块链的网络中删除一个或多个块？"><a href="#7-是否可以从区块链的网络中删除一个或多个块？" class="headerlink" title="7. 是否可以从区块链的网络中删除一个或多个块？"></a>7. 是否可以从区块链的网络中删除一个或多个块？</h2><p>回答：对的，这是可能的。有时，只需要考虑此在线分类账的特定部分。通过使用默认过滤器和选项，我们可以删除这些块。</p>
<h2 id="8-将数据写入块后是否可以更改数据？"><a href="#8-将数据写入块后是否可以更改数据？" class="headerlink" title="8. 将数据写入块后是否可以更改数据？"></a>8. 将数据写入块后是否可以更改数据？</h2><p>回答：不，这是不可能的。如果需要进行任何修改，组织也必须从所有其他模块中删除信息。</p>
<h2 id="9-区块链数据库中可用的记录类型是什么？"><a href="#9-区块链数据库中可用的记录类型是什么？" class="headerlink" title="9. 区块链数据库中可用的记录类型是什么？"></a>9. 区块链数据库中可用的记录类型是什么？</h2><p>回答：区块链数据库中有两种类型的记录。他们是：</p>
<p>交易记录<br>阻止记录<br>无需遵循任何复杂的算法，即可轻松访问和集成这两个记录。</p>
<h2 id="10-哪种类型的记录可以保存在区块链中？"><a href="#10-哪种类型的记录可以保存在区块链中？" class="headerlink" title="10. 哪种类型的记录可以保存在区块链中？"></a>10. 哪种类型的记录可以保存在区块链中？</h2><p>回答：我们可以将任何记录放入区块链中。下面列出了一些常见的记录类型：</p>
<p>事务处理<br>身份管理<br>与组织有关的活动<br>管理活动<br>文献资料<br>医疗交易记录</p>
<h2 id="11-有哪些不同类型的区块链？"><a href="#11-有哪些不同类型的区块链？" class="headerlink" title="11. 有哪些不同类型的区块链？"></a>11. 有哪些不同类型的区块链？</h2><p>回答：下面列出了三种主要的区块链类型：</p>
<p>公共区块链：顾名思义，这里没有人负责，任何人都可以读/写/审核区块链。<br>私有区块链：顾名思义，它是个人或组织的私有财产。<br>财团或联合区块链：财团的选定成员可以读取/写入/审核区块链</p>
<h2 id="12-什么是分类账，并命名区块链中用户考虑的常见分类账类型？"><a href="#12-什么是分类账，并命名区块链中用户考虑的常见分类账类型？" class="headerlink" title="12. 什么是分类账，并命名区块链中用户考虑的常见分类账类型？"></a>12. 什么是分类账，并命名区块链中用户考虑的常见分类账类型？</h2><p>回答：分类帐是一个不断增长的文件。它存储了在区块链网络上两方之间发生的所有交易的永久记录。</p>
<p>用户在区块链中考虑的常见分类账类型如下：</p>
<p>集中式分类帐<br>分散的分类帐<br>分布式分类帐</p>
<h2 id="13-公钥和私钥有什么区别？"><a href="#13-公钥和私钥有什么区别？" class="headerlink" title="13. 公钥和私钥有什么区别？"></a>13. 公钥和私钥有什么区别？</h2><p>回答：在区块链中，需要使用公钥进行标识，而使用私钥进行加密和身份验证。发送方可以使用接收方的公钥发送消息，而接收方可以使用私钥对消息或交易进行解密。通过同时使用两个密钥，可以确保通信或交易的安全和防篡改。</p>
<h2 id="14-区块链的主要特征是什么？"><a href="#14-区块链的主要特征是什么？" class="headerlink" title="14. 区块链的主要特征是什么？"></a>14. 区块链的主要特征是什么？</h2><p>回答：区块链的主要功能如下：</p>
<p>分散系统<br>容量增加<br>造币厂<br>更快的解决<br>不变性<br>安全有保障的生态系统</p>
<h2 id="15-区块链以什么顺序链接？"><a href="#15-区块链以什么顺序链接？" class="headerlink" title="15. 区块链以什么顺序链接？"></a>15. 区块链以什么顺序链接？</h2><p>回答：区块链中的所有区块都以反向顺序链接，或者每个区块都与其前一个区块链接。</p>
<h2 id="16-BIP代表什么？"><a href="#16-BIP代表什么？" class="headerlink" title="16. BIP代表什么？"></a>16. BIP代表什么？</h2><p>回答：BIP代表比特币改进提案。</p>
<h2 id="17-什么是加密及其在区块链中的作用？"><a href="#17-什么是加密及其在区块链中的作用？" class="headerlink" title="17. 什么是加密及其在区块链中的作用？"></a>17. 什么是加密及其在区块链中的作用？</h2><p>回答：加密是帮助组织保持数据安全的数据安全方法之一。在加密中，任何类型的数据都可以从可读格式转换为加密版本，并且只能由实际上有权访问解密密钥的其他实体解码。在区块链中，这种方法很有用，因为它可以增加区块的整体安全性和真实性，并保持区块的安全性。</p>
<h2 id="18-区块链分类账与普通分类账有何不同？"><a href="#18-区块链分类账与普通分类账有何不同？" class="headerlink" title="18. 区块链分类账与普通分类账有何不同？"></a>18. 区块链分类账与普通分类账有何不同？</h2><p>回答：主要区别在于，区块链是一种数字账本，可以很容易地分散，与原始账本相比，区块链账本中的错误机会要少得多。区块链自动执行其所有任务，而在普通分类账中，每项任务都是手动或人工完成的。</p>
<h2 id="19-什么是共识算法？"><a href="#19-什么是共识算法？" class="headerlink" title="19. 什么是共识算法？"></a>19. 什么是共识算法？</h2><p>回答：共识算法是一种方法，通过该方法，区块链网络的所有对等方都可以达成分布式账本当前状态的标准协议。它可实现高可靠性，并在分布式计算环境中的未知对等方之间建立信任。</p>
<h2 id="20-共识算法有哪些类型？"><a href="#20-共识算法有哪些类型？" class="headerlink" title="20. 共识算法有哪些类型？"></a>20. 共识算法有哪些类型？</h2><p>回答： 可用的最受欢迎的共识算法如下：</p>
<p>工作量证明（PoW）<br>容量证明（PoC）<br>活动证明（PoA）<br>委托权益证明（DPoS）<br>股权证明（PoS）<br>权威证明<br>燃烧证明<br>唯一节点列表<br>重量证明<br>证明时间<br>筛<br>拜占庭容错</p>
<h2 id="21-比特币区块链中使用哪种加密算法？"><a href="#21-比特币区块链中使用哪种加密算法？" class="headerlink" title="21. 比特币区块链中使用哪种加密算法？"></a>21. 比特币区块链中使用哪种加密算法？</h2><p>回答：不同的区块链使用不同的密码算法。比特币区块链使用SHA256哈希算法。</p>
<h2 id="22-什么是加密货币？"><a href="#22-什么是加密货币？" class="headerlink" title="22. 什么是加密货币？"></a>22. 什么是加密货币？</h2><p>回答：加密货币是一种数字资产，可以用作使用加密功能进行金融交易的交换媒介。加密货币利用区块链技术获得透明度，去中心化和不变性。加密货币可使用公钥和私钥在两方之间直接发送，而手续费极低。</p>
<h2 id="23-使用区块链技术有什么好处？"><a href="#23-使用区块链技术有什么好处？" class="headerlink" title="23. 使用区块链技术有什么好处？"></a>23. 使用区块链技术有什么好处？</h2><p>回答：使用区块链技术的主要好处如下：</p>
<p>增强安全性<br>改进的可追溯性<br>节约成本<br>用户假名<br>不变性<br>交易的透明度<br>自动对帐<br>欺诈控制<br>中介服务不付款</p>
<h2 id="24-区块链架构的核心组件是什么？"><a href="#24-区块链架构的核心组件是什么？" class="headerlink" title="24. 区块链架构的核心组件是什么？"></a>24. 区块链架构的核心组件是什么？</h2><p>回答：以下是区块链架构的核心组成部分：</p>
<p>节点-区块链架构中的用户/计算机。<br>交易-这是区块链系统的最小组成部分。<br>块-用于维护一组分配给网络中所有节点的事务。<br>链-块顺序。<br>矿工-在添加到区块链结构之前执行块验证过程的特定节点。<br>共识协议-进行区块链操作的规则集。<br>25. 区块链中的一个区块永远不能有多个父区块吗？<br>    回答：是的，的确，区块链永远不会有父区块。每个区块在区块链中都是独立的。</p>
<h2 id="26-什么是双重支出？"><a href="#26-什么是双重支出？" class="headerlink" title="26. 什么是双重支出？"></a>26. 什么是双重支出？</h2><p>回答：双倍支出被认为是数字现金计划的潜在缺陷，因为多次使用相同的数字令牌。令牌通常由可以轻松克隆的数字文件组成。比特币用户通过在区块链上付款时等待确认来保护自己免受双重支出欺诈；随着确认的增加，交易变得不可逆转。</p>
<h2 id="27-什么是盲目签名？"><a href="#27-什么是盲目签名？" class="headerlink" title="27. 什么是盲目签名？"></a>27. 什么是盲目签名？</h2><p>回答： 盲签名是密码术中数字签名的一种形式，其中消息的内容在签名或考虑之前是盲的。它主要用于作者和签名方不同的隐私相关协议中。这是一种经过验证的方法。</p>
<p>例如：数字现金计划</p>
<h2 id="28-区块链中有助于消除安全威胁的关键原则是什么？"><a href="#28-区块链中有助于消除安全威胁的关键原则是什么？" class="headerlink" title="28. 区块链中有助于消除安全威胁的关键原则是什么？"></a>28. 区块链中有助于消除安全威胁的关键原则是什么？</h2><p>回答：以下是区块链中有助于消除安全威胁的关键原则：</p>
<p>连续性计划<br>稽核<br>确保测试和类似方法<br>数据库安全<br>保护应用程序<br>数字化劳动力培训</p>
<h2 id="29-权益证明和工作证明有什么区别？"><a href="#29-权益证明和工作证明有什么区别？" class="headerlink" title="29. 权益证明和工作证明有什么区别？"></a>29. 权益证明和工作证明有什么区别？</h2><p>回答：</p>
<p>工作量证明是区块链中的原始共识算法。它用于确认交易并为链产生新的区块。在这种情况下，矿工相互竞争以完成网络上的交易并获得奖励。<br>股权证明使共识机制完全虚拟。在这种情况下，一组节点决定放样其交易验证的加密货币。</p>
<h2 id="30-什么是51％的攻击？"><a href="#30-什么是51％的攻击？" class="headerlink" title="30. 什么是51％的攻击？"></a>30. 什么是51％的攻击？</h2><p>回答：51％攻击或双花攻击是指区块链上的单个或一组矿工，他们试图控制超过50％的网络挖掘哈希率或计算能力。这些攻击者试图阻止新交易获得确认，并使他们停止某些或所有用户之间的付款。它们还能够撤销在控制网络时完成的交易。这意味着他们可以双倍花费硬币。</p>
<h2 id="31-什么是Coinbase交易？"><a href="#31-什么是Coinbase交易？" class="headerlink" title="31. 什么是Coinbase交易？"></a>31. 什么是Coinbase交易？</h2><p>回答：Coinbase交易是矿工创建的独特类型的比特币交易。这是新区块中的第一笔交易。矿工使用它来收集工作的集体奖励。矿工收取的任何交易费也将在此交易中发送。</p>
<h2 id="32-什么是默克尔树？它在区块链中的重要性是什么？"><a href="#32-什么是默克尔树？它在区块链中的重要性是什么？" class="headerlink" title="32. 什么是默克尔树？它在区块链中的重要性是什么？"></a>32. 什么是默克尔树？它在区块链中的重要性是什么？</h2><p>回答：默克尔树在区块链技术中起着重要作用。它描述了由各种数据块组成的数学数据结构。它还通过提供整个交易集的数字指纹来汇总一个块中的所有交易。</p>
<p>它可以对大量数据进行有效且安全的内容验证。Merkle树也称为哈希树，主要由以太坊和比特币使用。</p>
<p>区块链中的Merkle树的重要性在于，如果有人想验证某个区块中的特定交易，他们可以下载区块头链，而不必下载每个交易和每个区块。</p>
<h2 id="33-是什么使您的交易数据在区块链中安全？"><a href="#33-是什么使您的交易数据在区块链中安全？" class="headerlink" title="33. 是什么使您的交易数据在区块链中安全？"></a>33. 是什么使您的交易数据在区块链中安全？</h2><p>回答：顾名思义，区块链是存储交易记录的数字区块链。每个块都连接到它之前和之后的所有块。这使得黑客很难篡改单个记录，因为他们需要更改包含该记录的整个块以及与其连接的块，以避免检测。区块链提供了出色的安全性。</p>
<p>除上述内容外，它还具有以下固有特征：</p>
<p>记录通过区块链上的密码保护。<br>网络参与者具有自己的交易专用密钥，并且充当个人数字签名。<br>如果记录被更改，签名将无效</p>
<h2 id="34-什么是秘密共享？"><a href="#34-什么是秘密共享？" class="headerlink" title="34. 什么是秘密共享？"></a>34. 什么是秘密共享？</h2><p>回答：秘密共享是用于在区块链中提供数据安全性的主要方法之一。这种方法将个人信息或机密信息分为不同的单元，然后将其发送给网络上的用户。原始信息共享给分配了秘密共享的参与者。</p>
<h2 id="35-您对主管会计了解多少？区块链支持相同吗？"><a href="#35-您对主管会计了解多少？区块链支持相同吗？" class="headerlink" title="35. 您对主管会计了解多少？区块链支持相同吗？"></a>35. 您对主管会计了解多少？区块链支持相同吗？</h2><p>回答：执行会计是一种特殊类型的会计，旨在使企业为人们提供服务。实际上，服务没有上限，企业可以通过执行会计来管理任何服务。</p>
<p>区块链具有专为高管会计而设计的算法，可以减少与之相关的问题。</p>
<h2 id="36-什么是安全策略？"><a href="#36-什么是安全策略？" class="headerlink" title="36. 什么是安全策略？"></a>36. 什么是安全策略？</h2><p>回答：安全策略是一个正式且简短的计划，其中包含组织的目标，目的和信息安全程序。简而言之，它定义了确切地需要保护免受威胁的条件以及在威胁发生时如何处理情况。</p>
<h2 id="37-区块链开发中的活板门功能是什么？"><a href="#37-区块链开发中的活板门功能是什么？" class="headerlink" title="37. 区块链开发中的活板门功能是什么？"></a>37. 区块链开发中的活板门功能是什么？</h2><p>回答：活板门函数是一种单向函数，即，除非您有特殊信息，否则易于在一个方向上进行计算，但很难在相反的方向上进行计算。这些功能对于公钥加密至关重要，在区块链开发中最广泛地用于代表地址和私钥的思想。</p>
<h2 id="38-为什么区块链需要硬币或代币？"><a href="#38-为什么区块链需要硬币或代币？" class="headerlink" title="38. 为什么区块链需要硬币或代币？"></a>38. 为什么区块链需要硬币或代币？</h2><p>回答： 令牌/硬币被用作国家之间的交换媒介。它们是内置的数字资产，可在区块链内执行特定功能。</p>
<p>某人进行交易时，状态会发生变化，硬币会从一个地址移到另一个地址。除此之外，交易还包含一些其他数据。这些数据可以通过状态改变而变异。因此，区块链需要硬币或令牌来激励参与者加入他们的网络。</p>
<h2 id="39-scriptPubKey和P2SH地址之间有什么区别？"><a href="#39-scriptPubKey和P2SH地址之间有什么区别？" class="headerlink" title="39. scriptPubKey和P2SH地址之间有什么区别？"></a>39. scriptPubKey和P2SH地址之间有什么区别？</h2><p>回答：</p>
<p>一个scriptPubKey在交易输出发现也被称为锁定脚本。<br>该P2SH地址是一种特殊类型的地址，即，它是用于其哈希代替复杂的锁定脚本。除了解锁脚本之外，事务还必须包含与哈希匹配的脚本。</p>
<h2 id="40-什么是采矿？"><a href="#40-什么是采矿？" class="headerlink" title="40. 什么是采矿？"></a>40. 什么是采矿？</h2><p>回答：在区块链技术的背景下，挖掘是通过向网络提供工作证明来向大型分布式公共分类账添加交易的过程，即生成的区块是有效的。它还将新硬币添加到生成的块中。术语“采矿”以与比特币的关联而闻名。</p>
<h2 id="41-硬叉与区块链中的软叉有何不同？"><a href="#41-硬叉与区块链中的软叉有何不同？" class="headerlink" title="41. 硬叉与区块链中的软叉有何不同？"></a>41. 硬叉与区块链中的软叉有何不同？</h2><p>回答：</p>
<p>区块链中的硬分叉指的是对软件协议的根本性更改，使先前无效的交易/块有效。它要求所有用户/节点升级到最新的软件协议。<br>软叉是指对软件协议的更改，该更改使先前无效的事务/块无效。</p>
<h2 id="42-如何实施区块链项目？"><a href="#42-如何实施区块链项目？" class="headerlink" title="42. 如何实施区块链项目？"></a>42. 如何实施区块链项目？</h2><p>回答：请按照以下步骤实施区块链项目。</p>
<p>选择你的平台<br>初始化区块链<br>选择正确的共识协议<br>执行您的第一个智能合约<br>调试和扩展</p>
<h2 id="43-脱链交易和链上交易有什么区别？"><a href="#43-脱链交易和链上交易有什么区别？" class="headerlink" title="43. 脱链交易和链上交易有什么区别？"></a>43. 脱链交易和链上交易有什么区别？</h2><p>回答：</p>
<p>链上交易：这些交易在区块链上可用，并且对区块链网络上的所有节点都是可见的。它包括由一定数量的参与者对交易进行身份验证和确认。<br>链下交易：这些交易处理区块链外部的值，可以使用多种方法进行。</p>
<h2 id="44-集中式网络，分散式网络和分布式分类帐之间有什么区别？"><a href="#44-集中式网络，分散式网络和分布式分类帐之间有什么区别？" class="headerlink" title="44. 集中式网络，分散式网络和分布式分类帐之间有什么区别？"></a>44. 集中式网络，分散式网络和分布式分类帐之间有什么区别？</h2><p>回答：</p>
<p>分布式分类帐：这是共享分类帐，不受任何中央机构的控制。它本质上是分散的，并充当金融，法律或电子资产的数据库。<br>集中式网络：集中式网络具有中央机构以方便其操作。<br>分散网络：分散网络中连接的节点不依赖于单个服务器点，并且每个节点都拥有网络配置的整个副本。</p>
<h2 id="45-哪些是使用最广泛的密码算法？"><a href="#45-哪些是使用最广泛的密码算法？" class="headerlink" title="45. 哪些是使用最广泛的密码算法？"></a>45. 哪些是使用最广泛的密码算法？</h2><p>回答：下面列出了最常用的加密算法：</p>
<p>Triple DES<br>RSA<br>Blowfish<br>Twofish<br>AES</p>
<h2 id="46-什么是RSA算法？"><a href="#46-什么是RSA算法？" class="headerlink" title="46. 什么是RSA算法？"></a>46. 什么是RSA算法？</h2><p>回答：RSA（Rivest-Shamir-Adelman）算法是用于签名数据和加密的第一个算法。它最广泛用于保护敏感数据。它也被称为非对称密码算法，它对两个不同的密钥（即公共密钥和私有密钥）起作用。公开密钥可以与任何人共享，并且私有密钥必须保密。</p>
<h2 id="47-RSA会受到攻击吗？如果是这样，怎么办？"><a href="#47-RSA会受到攻击吗？如果是这样，怎么办？" class="headerlink" title="47. RSA会受到攻击吗？如果是这样，怎么办？"></a>47. RSA会受到攻击吗？如果是这样，怎么办？</h2><p>回答：是的，黑客可以攻击RSA算法。但是，受到攻击并不等于薄弱的保护。</p>
<p>通常，有两种攻击RSA的方法：</p>
<p>蛮力：包括所有潜在的秘密密钥。<br>数学攻击：在这种情况下，我们使用不同的技术来近似地计算两个素数的乘积。</p>
<h2 id="48-区块链生态系统的主要元素是什么？"><a href="#48-区块链生态系统的主要元素是什么？" class="headerlink" title="48. 区块链生态系统的主要元素是什么？"></a>48. 区块链生态系统的主要元素是什么？</h2><p>回答：区块链具有四个主要元素：</p>
<p>共享账本-本质上是分散的，是区块链的核心组成部分。<br>节点应用程序-它是一种软件，可让您的计算机与区块链连接。例如：比特币使用比特币钱包应用程序来检测网络上的每种模式。<br>虚拟应用程序-处理区块链承担的所有任务。<br>共识算法-用于管理区块链规则，通过该规则每个节点都可以得出结论。</p>
<h2 id="49-在保护交易记录时，您将如何进行风险管理？"><a href="#49-在保护交易记录时，您将如何进行风险管理？" class="headerlink" title="49. 在保护交易记录时，您将如何进行风险管理？"></a>49. 在保护交易记录时，您将如何进行风险管理？</h2><p>回答： 基于数据的价值，可以采用多种方法来处理风险管理。</p>
<p>首先，确定与组织的财务记录相关的威胁和漏洞，并相应地采取正确的对策。<br>另一种方法是注意备份计划。<br>第三是购买新的风险管理软件。</p>
<h2 id="50-在组织中采用区块链技术是否有特定于网络的条件？"><a href="#50-在组织中采用区块链技术是否有特定于网络的条件？" class="headerlink" title="50. 在组织中采用区块链技术是否有特定于网络的条件？"></a>50. 在组织中采用区块链技术是否有特定于网络的条件？</h2><h1 id="二、以太坊面试题A"><a href="#二、以太坊面试题A" class="headerlink" title="二、以太坊面试题A"></a>二、以太坊面试题A</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/81509">参考链接</a></p>
<h2 id="1-以太坊的有价通证叫什么？"><a href="#1-以太坊的有价通证叫什么？" class="headerlink" title="1. 以太坊的有价通证叫什么？"></a>1. 以太坊的有价通证叫什么？</h2><p>答：以太（ETH：Ether）</p>
<h2 id="2-Wei和以太有什么区别？"><a href="#2-Wei和以太有什么区别？" class="headerlink" title="2. Wei和以太有什么区别？"></a>2. Wei和以太有什么区别？</h2><p>答：Wei是一个面额，像美分到美元或便士到磅。 1 ETH =10^18 Wei</p>
<h2 id="3-以太坊的平均出块时间是多少？"><a href="#3-以太坊的平均出块时间是多少？" class="headerlink" title="3. 以太坊的平均出块时间是多少？"></a>3. 以太坊的平均出块时间是多少？</h2><p>答：大约14秒</p>
<h2 id="4-以太坊的平均块大小是多少？"><a href="#4-以太坊的平均块大小是多少？" class="headerlink" title="4. 以太坊的平均块大小是多少？"></a>4. 以太坊的平均块大小是多少？</h2><p>答：大约2KB，实际值取决于具体情况。</p>
<h2 id="5-以太坊是否支持脚本？-如果是这样，支持什么类型的脚本？"><a href="#5-以太坊是否支持脚本？-如果是这样，支持什么类型的脚本？" class="headerlink" title="5. 以太坊是否支持脚本？ 如果是这样，支持什么类型的脚本？"></a>5. 以太坊是否支持脚本？ 如果是这样，支持什么类型的脚本？</h2><p>答：是的。 它支持智能合约</p>
<h2 id="6-你如何得到以太？"><a href="#6-你如何得到以太？" class="headerlink" title="6. 你如何得到以太？"></a>6. 你如何得到以太？</h2><p>答：有几种方法：<br>1.成为一名矿工<br>2.用其他货币换取<br>3.使用以太Faucet，例如 <a target="_blank" rel="noopener" href="https://faucet.metamask.io/">https://faucet.metamask.io</a><br>4.接受别人的赠送</p>
<h2 id="7-以太从哪里来的？"><a href="#7-以太从哪里来的？" class="headerlink" title="7. 以太从哪里来的？"></a>7. 以太从哪里来的？</h2><p>答：在2014年预售中首次创建了6000万个。另外，在挖出新块时也会生成以太。</p>
<h2 id="8-什么是节点？"><a href="#8-什么是节点？" class="headerlink" title="8. 什么是节点？"></a>8. 什么是节点？</h2><p>答：一个节点本质上是一台连接到网络的计算机，它负责处理交易。</p>
<h2 id="9-你熟悉多少种以太坊网络？"><a href="#9-你熟悉多少种以太坊网络？" class="headerlink" title="9. 你熟悉多少种以太坊网络？"></a>9. 你熟悉多少种以太坊网络？</h2><p>答：有三种类型的网络 - 实时网络（主），测试网络（如Ropsten和Rinkeby）和私有网络。</p>
<h2 id="10-与以太坊网络交互的方式有哪些？"><a href="#10-与以太坊网络交互的方式有哪些？" class="headerlink" title="10. 与以太坊网络交互的方式有哪些？"></a>10. 与以太坊网络交互的方式有哪些？</h2><p>答：可以使用电子钱包或DApp</p>
<h2 id="11-你可以“隐藏”一个以太坊交易吗？"><a href="#11-你可以“隐藏”一个以太坊交易吗？" class="headerlink" title="11. 你可以“隐藏”一个以太坊交易吗？"></a>11. 你可以“隐藏”一个以太坊交易吗？</h2><p>答：不可以。所有交易对每个人都是可见的。</p>
<h2 id="12-交易记录在哪里？"><a href="#12-交易记录在哪里？" class="headerlink" title="12. 交易记录在哪里？"></a>12. 交易记录在哪里？</h2><p>答：在公共账本上</p>
<h2 id="13-这些网络的ID是什么？"><a href="#13-这些网络的ID是什么？" class="headerlink" title="13. 这些网络的ID是什么？"></a>13. 这些网络的ID是什么？</h2><p>答：Live（id = 1），Ropsten（id = 3），Rinkeby（id = 4），Private（由开发人员分配）</p>
<h2 id="14-我可以在Rinkeby测试网络中挖一些以太，然后转移到Live网络吗？"><a href="#14-我可以在Rinkeby测试网络中挖一些以太，然后转移到Live网络吗？" class="headerlink" title="14. 我可以在Rinkeby测试网络中挖一些以太，然后转移到Live网络吗？"></a>14. 我可以在Rinkeby测试网络中挖一些以太，然后转移到Live网络吗？</h2><p>答：不可以。不能在不同的以太坊网络之间传递以太。</p>
<h2 id="15-为什么需要私有网络？"><a href="#15-为什么需要私有网络？" class="headerlink" title="15. 为什么需要私有网络？"></a>15. 为什么需要私有网络？</h2><p>答：有很多原因，但主要是为了数据隐私、分布式数据库、权限控制和测试。</p>
<h2 id="16-你如何轻松查看有关交易和区块的详细信息？"><a href="#16-你如何轻松查看有关交易和区块的详细信息？" class="headerlink" title="16. 你如何轻松查看有关交易和区块的详细信息？"></a>16. 你如何轻松查看有关交易和区块的详细信息？</h2><p>答：使用区块链浏览器，如etherscan.io或live.ether.camp</p>
<h2 id="17-私有网络的交易和区块信息怎么查看呢？"><a href="#17-私有网络的交易和区块信息怎么查看呢？" class="headerlink" title="17. 私有网络的交易和区块信息怎么查看呢？"></a>17. 私有网络的交易和区块信息怎么查看呢？</h2><p>答：可以使用开源浏览器客户端，例如<a target="_blank" rel="noopener" href="https://github.com/etherparty/explorer">https://github.com/etherparty/explorer</a></p>
<h2 id="18-区块链的共识是什么？"><a href="#18-区块链的共识是什么？" class="headerlink" title="18. 区块链的共识是什么？"></a>18. 区块链的共识是什么？</h2><p>答：遵循特定协议（如以太坊）验证交易（创建块）的过程。</p>
<h2 id="19-区块链中两种常用的共识模型是什么？"><a href="#19-区块链中两种常用的共识模型是什么？" class="headerlink" title="19. 区块链中两种常用的共识模型是什么？"></a>19. 区块链中两种常用的共识模型是什么？</h2><p>答：工作量证明（POW）和权益证明（POS）。</p>
<h2 id="20-简单地解释下工作量证明。"><a href="#20-简单地解释下工作量证明。" class="headerlink" title="20. 简单地解释下工作量证明。"></a>20. 简单地解释下工作量证明。</h2><p>答：它实际上是矿工为了证明自己的工作量并验证交易而对一个计算密集型问题的求解。</p>
<h2 id="21-以简单的方式解释权益证明。"><a href="#21-以简单的方式解释权益证明。" class="headerlink" title="21. 以简单的方式解释权益证明。"></a>21. 以简单的方式解释权益证明。</h2><p>答：区块的创建者是根据节点所持有的财富和股权随机选择的。 它不是计算密集型的。</p>
<h2 id="22-以太坊使用什么共识模式？"><a href="#22-以太坊使用什么共识模式？" class="headerlink" title="22. 以太坊使用什么共识模式？"></a>22. 以太坊使用什么共识模式？</h2><p>答：截至2018年初，它使用工作量证明，但今后将切换到权益证明。</p>
<h2 id="23-怎么挖以太币？"><a href="#23-怎么挖以太币？" class="headerlink" title="23. 怎么挖以太币？"></a>23. 怎么挖以太币？</h2><p>答：使用钱包或geth客户端。</p>
<h2 id="24-用什么来对交易进行签名？"><a href="#24-用什么来对交易进行签名？" class="headerlink" title="24. 用什么来对交易进行签名？"></a>24. 用什么来对交易进行签名？</h2><p>答：用户的私钥。</p>
<h2 id="25-丢失私钥后还能恢复以太坊账户吗？"><a href="#25-丢失私钥后还能恢复以太坊账户吗？" class="headerlink" title="25. 丢失私钥后还能恢复以太坊账户吗？"></a>25. 丢失私钥后还能恢复以太坊账户吗？</h2><p>答：可以，可以使用助记词组。</p>
<h2 id="26-有哪些方法可以连接到一个以太坊节点？"><a href="#26-有哪些方法可以连接到一个以太坊节点？" class="headerlink" title="26. 有哪些方法可以连接到一个以太坊节点？"></a>26. 有哪些方法可以连接到一个以太坊节点？</h2><p>答：IPC-RPC、JSON-RPC和WS-RPC。</p>
<h2 id="27-那么Geth是什么？"><a href="#27-那么Geth是什么？" class="headerlink" title="27. 那么Geth是什么？"></a>27. 那么Geth是什么？</h2><p>答：Geth是以太坊的客户端。</p>
<h2 id="28-连接到geth客户端的默认方式是什么？"><a href="#28-连接到geth客户端的默认方式是什么？" class="headerlink" title="28. 连接到geth客户端的默认方式是什么？"></a>28. 连接到geth客户端的默认方式是什么？</h2><p>答：默认情况下启用IPC-RPC，其他RPC都被禁用。</p>
<h2 id="29-你知道geth的哪些API？"><a href="#29-你知道geth的哪些API？" class="headerlink" title="29. 你知道geth的哪些API？"></a>29. 你知道geth的哪些API？</h2><p>答：Admin、eth、web3、miner、net、personal、shh、debug和txpool。</p>
<h2 id="30-你可以使用哪些RPC通过网络连接到geth客户端？"><a href="#30-你可以使用哪些RPC通过网络连接到geth客户端？" class="headerlink" title="30. 你可以使用哪些RPC通过网络连接到geth客户端？"></a>30. 你可以使用哪些RPC通过网络连接到geth客户端？</h2><p>答：可以使用JSON-RPC和WS-RPC通过网络连接到geth客户端。 IPC-RPC只能连接到同一台机器上的geth客户端。</p>
<h2 id="31-如果启动geth时使用了-rpc选项，哪些RPC会被启用？"><a href="#31-如果启动geth时使用了-rpc选项，哪些RPC会被启用？" class="headerlink" title="31. 如果启动geth时使用了-rpc选项，哪些RPC会被启用？"></a>31. 如果启动geth时使用了-rpc选项，哪些RPC会被启用？</h2><p>答：JSON-RPC。</p>
<h2 id="32-哪些RPC-API是默认启用的？"><a href="#32-哪些RPC-API是默认启用的？" class="headerlink" title="32. 哪些RPC API是默认启用的？"></a>32. 哪些RPC API是默认启用的？</h2><p>答：eth、web3和net。</p>
<h2 id="33-如何为JSON-RPC启用Admin-API？"><a href="#33-如何为JSON-RPC启用Admin-API？" class="headerlink" title="33. 如何为JSON RPC启用Admin API？"></a>33. 如何为JSON RPC启用Admin API？</h2><p>答：使用-rpcapi选项。</p>
<h2 id="34-选项-datadir有什么作用？"><a href="#34-选项-datadir有什么作用？" class="headerlink" title="34. 选项-datadir有什么作用？"></a>34. 选项-datadir有什么作用？</h2><p>答：它指定了区块链的存储位置。</p>
<h2 id="35-什么是geth的“快速”同步，为什么它更快？"><a href="#35-什么是geth的“快速”同步，为什么它更快？" class="headerlink" title="35. 什么是geth的“快速”同步，为什么它更快？"></a>35. 什么是geth的“快速”同步，为什么它更快？</h2><p>答：快速同步会将事务处理回执与区块一起下载并完整提取最新的状态数据库，而不是重新执行所有发生过的交易。</p>
<h2 id="36-选项–testnet是做什么的？"><a href="#36-选项–testnet是做什么的？" class="headerlink" title="36. 选项–testnet是做什么的？"></a>36. 选项–testnet是做什么的？</h2><p>答：它将客户端连接到Ropsten网络。</p>
<h2 id="37-启动geth客户端会在屏幕上输出大量文字，应该如何减少输出信息？"><a href="#37-启动geth客户端会在屏幕上输出大量文字，应该如何减少输出信息？" class="headerlink" title="37. 启动geth客户端会在屏幕上输出大量文字，应该如何减少输出信息？"></a>37. 启动geth客户端会在屏幕上输出大量文字，应该如何减少输出信息？</h2><p>答：可以将–verbosity设置为较低的数字（默认值为3）</p>
<h2 id="38-如何使用IPC-RPC将一个geth客户端连接到另一个客户端？"><a href="#38-如何使用IPC-RPC将一个geth客户端连接到另一个客户端？" class="headerlink" title="38. 如何使用IPC-RPC将一个geth客户端连接到另一个客户端？"></a>38. 如何使用IPC-RPC将一个geth客户端连接到另一个客户端？</h2><p>答：首先启动一个geth客户端，复制它的管道位置，然后使用同一个datadir启动另一个geth客户端并使用–attach选项传入管道位置。</p>
<h2 id="39-如何将自定义javascript文件加载到geth控制台中？"><a href="#39-如何将自定义javascript文件加载到geth控制台中？" class="headerlink" title="39. 如何将自定义javascript文件加载到geth控制台中？"></a>39. 如何将自定义javascript文件加载到geth控制台中？</h2><p>答：通使用–preload选项传入js文件的路径。</p>
<h2 id="40-geth客户端的帐户存储在哪里？"><a href="#40-geth客户端的帐户存储在哪里？" class="headerlink" title="40. geth客户端的帐户存储在哪里？"></a>40. geth客户端的帐户存储在哪里？</h2><p>答：在keystore目录中。</p>
<h2 id="41-为了进行交易，需要对账户进行什么操作？"><a href="#41-为了进行交易，需要对账户进行什么操作？" class="headerlink" title="41. 为了进行交易，需要对账户进行什么操作？"></a>41. 为了进行交易，需要对账户进行什么操作？</h2><p>答：必须先解锁该账户 - 可以传入账户地址或账户序号来解锁。 也可以使用–password选项传入一个密码文件，其中包含每个账户的密码。</p>
<h2 id="42-你提到了一些有关账户序号的内容。-什么因素决定账户的序号？"><a href="#42-你提到了一些有关账户序号的内容。-什么因素决定账户的序号？" class="headerlink" title="42. 你提到了一些有关账户序号的内容。 什么因素决定账户的序号？"></a>42. 你提到了一些有关账户序号的内容。 什么因素决定账户的序号？</h2><p>答：添加帐户的先后顺序。</p>
<h2 id="43-是否可以使用geth进行挖矿？"><a href="#43-是否可以使用geth进行挖矿？" class="headerlink" title="43. 是否可以使用geth进行挖矿？"></a>43. 是否可以使用geth进行挖矿？</h2><p>答：可以，使用–mine选项开启。</p>
<h2 id="44-什么是“etherbase”？"><a href="#44-什么是“etherbase”？" class="headerlink" title="44. 什么是“etherbase”？"></a>44. 什么是“etherbase”？</h2><p>答：这是接收挖矿奖励的帐户，它是序号为0的帐户。</p>
<h2 id="45-什么是智能合约？"><a href="#45-什么是智能合约？" class="headerlink" title="45. 什么是智能合约？"></a>45. 什么是智能合约？</h2><p>答：这是用多种语言编写的计算机代码。 智能合约存在于以太坊网络上，它们根据预定规则执行动作，规则是由参与者在这些合约中商定的。</p>
<h2 id="46-智能合约可以使用哪些语言编写？"><a href="#46-智能合约可以使用哪些语言编写？" class="headerlink" title="46. 智能合约可以使用哪些语言编写？"></a>46. 智能合约可以使用哪些语言编写？</h2><p>答：Solidity，这是最常用的语言，也可以使用Serpent和LLL。</p>
<h2 id="47-你能举出一个智能合约的用例吗？"><a href="#47-你能举出一个智能合约的用例吗？" class="headerlink" title="47. 你能举出一个智能合约的用例吗？"></a>47. 你能举出一个智能合约的用例吗？</h2><p>答：卖方-买方应用场景：买方在智能合约中存入款项，卖方看到存款并发送货物，买方收到货物并放行付款。</p>
<h2 id="48-什么是Metamask？"><a href="#48-什么是Metamask？" class="headerlink" title="48. 什么是Metamask？"></a>48. 什么是Metamask？</h2><p>答：Metamask是一个可以帮助用户在浏览器中与以太坊网络进行交互的工具</p>
<h2 id="49-Metamask使用哪个以太坊节点？"><a href="#49-Metamask使用哪个以太坊节点？" class="headerlink" title="49. Metamask使用哪个以太坊节点？"></a>49. Metamask使用哪个以太坊节点？</h2><p>答：它使用infura.io</p>
<h2 id="50-Metamask不支持什么？"><a href="#50-Metamask不支持什么？" class="headerlink" title="50. Metamask不支持什么？"></a>50. Metamask不支持什么？</h2><p>答：挖矿和合约部署。</p>
<h2 id="51-执行合约是否免费？"><a href="#51-执行合约是否免费？" class="headerlink" title="51. 执行合约是否免费？"></a>51. 执行合约是否免费？</h2><p>答：不，调用合约方法是一个交易，因此需要支付费用。</p>
<h2 id="52-访问智能合约的状态是否免费？"><a href="#52-访问智能合约的状态是否免费？" class="headerlink" title="52. 访问智能合约的状态是否免费？"></a>52. 访问智能合约的状态是否免费？</h2><p>答：是的，查询状态不是交易。</p>
<h2 id="53-谁执行合同？"><a href="#53-谁执行合同？" class="headerlink" title="53. 谁执行合同？"></a>53. 谁执行合同？</h2><p>答：矿工。</p>
<h2 id="54-为什么调用智能合约的方法需要付费？"><a href="#54-为什么调用智能合约的方法需要付费？" class="headerlink" title="54. 为什么调用智能合约的方法需要付费？"></a>54. 为什么调用智能合约的方法需要付费？</h2><p>答：有些方法不会修改合约的状态，也没有其他逻辑，只是返回一个值，这样的方法是可以免费调用的。 调用那些改变合约状态的方法则需要付费，因为它们需要gas来执行。</p>
<h2 id="55-为什么需要gas？"><a href="#55-为什么需要gas？" class="headerlink" title="55. 为什么需要gas？"></a>55. 为什么需要gas？</h2><p>答：由于矿工在他们的机器上执行合约代码，他们需要gas来覆盖执行合约代码的成本。</p>
<h2 id="56-是不是gas的价格决定了交易什么时候被处理？"><a href="#56-是不是gas的价格决定了交易什么时候被处理？" class="headerlink" title="56. 是不是gas的价格决定了交易什么时候被处理？"></a>56. 是不是gas的价格决定了交易什么时候被处理？</h2><p>答：即是，也不是。 gas价格越高，交易成功的可能性就越大。 尽管如此，gas价格并不能保证更快的交易处理。</p>
<h2 id="57-交易中的gas使用量取决于什么？"><a href="#57-交易中的gas使用量取决于什么？" class="headerlink" title="57. 交易中的gas使用量取决于什么？"></a>57. 交易中的gas使用量取决于什么？</h2><p>答：这取决于合约所用的存储量、指令（操作码）的类型和数量。 每个EVM操作码都对应一个固定的gas用量。</p>
<h2 id="58-交易费是如何计算的？"><a href="#58-交易费是如何计算的？" class="headerlink" title="58. 交易费是如何计算的？"></a>58. 交易费是如何计算的？</h2><p>答：gas用量*gas价格（由调用方指定gas价格）</p>
<h2 id="59-如果智能合约的执行成本低于调用方指定的gas用量，用户是否得到退款？"><a href="#59-如果智能合约的执行成本低于调用方指定的gas用量，用户是否得到退款？" class="headerlink" title="59. 如果智能合约的执行成本低于调用方指定的gas用量，用户是否得到退款？"></a>59. 如果智能合约的执行成本低于调用方指定的gas用量，用户是否得到退款？</h2><p>答：是的</p>
<h2 id="60-如果智能合约的执行成本高于指定的gas用量，会发生什么情况？"><a href="#60-如果智能合约的执行成本高于指定的gas用量，会发生什么情况？" class="headerlink" title="60. 如果智能合约的执行成本高于指定的gas用量，会发生什么情况？"></a>60. 如果智能合约的执行成本高于指定的gas用量，会发生什么情况？</h2><p>答：用户不会得到退款，并且一旦所有的gas用完，执行就会停止，合约也不会改变。</p>
<h2 id="61-谁支付智能合约的调用费用？"><a href="#61-谁支付智能合约的调用费用？" class="headerlink" title="61. 谁支付智能合约的调用费用？"></a>61. 谁支付智能合约的调用费用？</h2><p>答：调用合约的用户。</p>
<h2 id="62-节点在什么上面运行智能合约代码？"><a href="#62-节点在什么上面运行智能合约代码？" class="headerlink" title="62. 节点在什么上面运行智能合约代码？"></a>62. 节点在什么上面运行智能合约代码？</h2><p>答：EVM - 以太坊虚拟机。 EVM遵循EVM规范，该规范是以太坊协议的组成部分。 EVM只是节点上的一个进程。</p>
<h2 id="63-为了运行智能合同，EVM需要什么？"><a href="#63-为了运行智能合同，EVM需要什么？" class="headerlink" title="63. 为了运行智能合同，EVM需要什么？"></a>63. 为了运行智能合同，EVM需要什么？</h2><p>答：它需要合约的字节码，是通过编译Solidity等更高级别的语言编写的合约来生成字节码。</p>
<h2 id="64-粗略的说，EVM有哪些组成部分？"><a href="#64-粗略的说，EVM有哪些组成部分？" class="headerlink" title="64. 粗略的说，EVM有哪些组成部分？"></a>64. 粗略的说，EVM有哪些组成部分？</h2><p>答：内存区域、堆栈和执行引擎。</p>
<h2 id="65-什么是Remix？"><a href="#65-什么是Remix？" class="headerlink" title="65. 什么是Remix？"></a>65. 什么是Remix？</h2><p>答：开发，测试和部署合约的在线工具。 适合快速构建和测试轻量级合约，但不适合更复杂的合约。</p>
<h2 id="66-在Remix中，可以连接哪些节点？"><a href="#66-在Remix中，可以连接哪些节点？" class="headerlink" title="66. 在Remix中，可以连接哪些节点？"></a>66. 在Remix中，可以连接哪些节点？</h2><p>答：可以使用Metamask连接到公共节点、也可以链接到使用Geth搭建的本地节点，或者在Javascript VM中模拟的内存节点。</p>
<h2 id="67-什么是DApp，它与App有什么不同？有什么不同？"><a href="#67-什么是DApp，它与App有什么不同？有什么不同？" class="headerlink" title="67. 什么是DApp，它与App有什么不同？有什么不同？"></a>67. 什么是DApp，它与App有什么不同？有什么不同？</h2><p>答：App通常包含一个客户端，这个客户端会与一些中心化的资源（由一个组织拥有）进行通信，通常客户端通过一个中间层连接到中心化的数据层，如果中心化的数据层中的信息丢失，不能很轻松地恢复。<br>DApp表示去中心化应用程序。 DApps通过智能合约与区块链网络进行交互。 DApp使用的数据驻留在合约实例中。<br>中心化数据可能比去中心化数据更容易受到破坏。</p>
<h2 id="68-DApp的前端是否局限于某些技术或框架？"><a href="#68-DApp的前端是否局限于某些技术或框架？" class="headerlink" title="68. DApp的前端是否局限于某些技术或框架？"></a>68. DApp的前端是否局限于某些技术或框架？</h2><p>答：不受限制。可以使用任何技术来开发DApp的前端，比如HTML，CSS，JS，Java，Python…</p>
<h2 id="69-前端用什么库连接后端（智能合同）？"><a href="#69-前端用什么库连接后端（智能合同）？" class="headerlink" title="69. 前端用什么库连接后端（智能合同）？"></a>69. 前端用什么库连接后端（智能合同）？</h2><p>答：Web3.js库。</p>
<h2 id="70-在DApp的前端需要哪些东西才能与指定的智能合约进行交互？"><a href="#70-在DApp的前端需要哪些东西才能与指定的智能合约进行交互？" class="headerlink" title="70. 在DApp的前端需要哪些东西才能与指定的智能合约进行交互？"></a>70. 在DApp的前端需要哪些东西才能与指定的智能合约进行交互？</h2><p>答：合约的ABI和字节码。</p>
<h2 id="71-ABI有什么作用？"><a href="#71-ABI有什么作用？" class="headerlink" title="71. ABI有什么作用？"></a>71. ABI有什么作用？</h2><p>答：ABI是合约的公开接口描述对象，被DApps用于调用合约的接口。</p>
<h2 id="72-字节码有什么作用？"><a href="#72-字节码有什么作用？" class="headerlink" title="72. 字节码有什么作用？"></a>72. 字节码有什么作用？</h2><p>答：节点上的EVM只能执行合约的字节码。</p>
<h2 id="73-为什么要使用BigNumber库？"><a href="#73-为什么要使用BigNumber库？" class="headerlink" title="73. 为什么要使用BigNumber库？"></a>73. 为什么要使用BigNumber库？</h2><p>答：因为Javascript不能正确处理大数。</p>
<h2 id="74-为什么需要检查在Web-DApp代码的开始部分是否设置了web3提供器（Provider）？"><a href="#74-为什么需要检查在Web-DApp代码的开始部分是否设置了web3提供器（Provider）？" class="headerlink" title="74. 为什么需要检查在Web DApp代码的开始部分是否设置了web3提供器（Provider）？"></a>74. 为什么需要检查在Web DApp代码的开始部分是否设置了web3提供器（Provider）？</h2><p>答：因为Metamask会注入一个web3对象，它覆盖其他的web3设置。</p>
<h2 id="75-为什么要使用web3-js版本1-x而不是0-2x-x？"><a href="#75-为什么要使用web3-js版本1-x而不是0-2x-x？" class="headerlink" title="75. 为什么要使用web3.js版本1.x而不是0.2x.x？"></a>75. 为什么要使用web3.js版本1.x而不是0.2x.x？</h2><p>答：主要是因为1.x的异步调用使用Promise而不是回调，Promise目前在javascript世界中<br>是处理异步调用的首选方案。</p>
<h2 id="76-如何在web3-1-x中列出账户？"><a href="#76-如何在web3-1-x中列出账户？" class="headerlink" title="76. 如何在web3 1.x中列出账户？"></a>76. 如何在web3 1.x中列出账户？</h2><p>答：web3.eth.getAccounts</p>
<h2 id="77-call和-send有什么区别？"><a href="#77-call和-send有什么区别？" class="headerlink" title="77. .call和.send有什么区别？"></a>77. .call和.send有什么区别？</h2><p>答：.send发送交易并支付费用，而.call查询合约状态。</p>
<h2 id="78-这样发送1个以太对吗：-send-value-1-？"><a href="#78-这样发送1个以太对吗：-send-value-1-？" class="headerlink" title="78. 这样发送1个以太对吗：.send({value:1})？"></a>78. 这样发送1个以太对吗：.send({value:1})？</h2><p>A：不对，这样发送的是1 wei。 交易中总是以wei为单位。</p>
<h2 id="79-那么为了发送1个以太，我必须将这个值乘以10-18？"><a href="#79-那么为了发送1个以太，我必须将这个值乘以10-18？" class="headerlink" title="79. 那么为了发送1个以太，我必须将这个值乘以10^18？"></a>79. 那么为了发送1个以太，我必须将这个值乘以10^18？</h2><p>答：可以使用web3.utils.toWei(1，’ether’)。</p>
<h2 id="80-调用-send-时需要指定什么？"><a href="#80-调用-send-时需要指定什么？" class="headerlink" title="80. 调用.send()时需要指定什么？"></a>80. 调用.send()时需要指定什么？</h2><p>答：必须指定from字段，即发送账户地址。 其他一切都是可选的。</p>
<h2 id="81-web3-eth-sendTransaction-的唯一功能是将以太发送到特定的地址，这个说法是否正确？"><a href="#81-web3-eth-sendTransaction-的唯一功能是将以太发送到特定的地址，这个说法是否正确？" class="headerlink" title="81. web3.eth.sendTransaction()的唯一功能是将以太发送到特定的地址，这个说法是否正确？"></a>81. web3.eth.sendTransaction()的唯一功能是将以太发送到特定的地址，这个说法是否正确？</h2><p>答：不对，也可以用它调用合约方法。</p>
<h2 id="82-你是否知道以太坊的可扩展性解决方案？"><a href="#82-你是否知道以太坊的可扩展性解决方案？" class="headerlink" title="82. 你是否知道以太坊的可扩展性解决方案？"></a>82. 你是否知道以太坊的可扩展性解决方案？</h2><p>答：2层协议。可能的解决方案是状态通道（state channels）和Plasma。</p>
<h2 id="83-Solidity是静态类型的还是动态类型的语言？"><a href="#83-Solidity是静态类型的还是动态类型的语言？" class="headerlink" title="83. Solidity是静态类型的还是动态类型的语言？"></a>83. Solidity是静态类型的还是动态类型的语言？</h2><p>答：它是静态类型语言，这意味着类型在编译时是已知的。</p>
<h2 id="84-Solidity中与Java“Class”类似的是什么？"><a href="#84-Solidity中与Java“Class”类似的是什么？" class="headerlink" title="84. Solidity中与Java“Class”类似的是什么？"></a>84. Solidity中与Java“Class”类似的是什么？</h2><p>答：合约。</p>
<h2 id="85-什么是合约实例？"><a href="#85-什么是合约实例？" class="headerlink" title="85. 什么是合约实例？"></a>85. 什么是合约实例？</h2><p>答：合约实例是区块链上已部署的合约。</p>
<h2 id="86-请说出Java和Solidity之间的一些区别。"><a href="#86-请说出Java和Solidity之间的一些区别。" class="headerlink" title="86. 请说出Java和Solidity之间的一些区别。"></a>86. 请说出Java和Solidity之间的一些区别。</h2><p>答：Solidity支持多重继承，但不支持重载。</p>
<h2 id="87-你必须在Solidity文件中指定的第一件事是什么？"><a href="#87-你必须在Solidity文件中指定的第一件事是什么？" class="headerlink" title="87. 你必须在Solidity文件中指定的第一件事是什么？"></a>87. 你必须在Solidity文件中指定的第一件事是什么？</h2><p>答：Solidity编译器的版本，比如指定为^ 0.4.8。 这是必要的，因为这样可以防止在使用其他版本的编译器时引入不兼容性错误。</p>
<h2 id="88-合约中包含什么？"><a href="#88-合约中包含什么？" class="headerlink" title="88. 合约中包含什么？"></a>88. 合约中包含什么？</h2><p>答：主要由存储变量、函数和事件组成。</p>
<h2 id="89-合约中有哪些类型的函数？"><a href="#89-合约中有哪些类型的函数？" class="headerlink" title="89. 合约中有哪些类型的函数？"></a>89. 合约中有哪些类型的函数？</h2><p>答：有构造函数、fallback函数、修改合约状态的函数和只读的constant函数。</p>
<h2 id="90-如果我将多个合约定义放入单个Solidity文件中，我会得到什么错误？"><a href="#90-如果我将多个合约定义放入单个Solidity文件中，我会得到什么错误？" class="headerlink" title="90. 如果我将多个合约定义放入单个Solidity文件中，我会得到什么错误？"></a>90. 如果我将多个合约定义放入单个Solidity文件中，我会得到什么错误？</h2><p>答：将多个合约定义放入单个Solidity文件是完全正确的。</p>
<h2 id="91-两个合约之间交互的方式有哪些？"><a href="#91-两个合约之间交互的方式有哪些？" class="headerlink" title="91. 两个合约之间交互的方式有哪些？"></a>91. 两个合约之间交互的方式有哪些？</h2><p>答：一个合约可以调用另一个合约，也可以继承其他合约。</p>
<h2 id="92-当你尝试使用部署一个包含多个合约的文件时会发生什么？"><a href="#92-当你尝试使用部署一个包含多个合约的文件时会发生什么？" class="headerlink" title="92. 当你尝试使用部署一个包含多个合约的文件时会发生什么？"></a>92. 当你尝试使用部署一个包含多个合约的文件时会发生什么？</h2><p>答：编译器只会部署该文件中的最后一个合约，而忽略所有其他合约。</p>
<h2 id="93-如果我有一个大项目，我需要将所有相关的合约保存到一个文件中吗？"><a href="#93-如果我有一个大项目，我需要将所有相关的合约保存到一个文件中吗？" class="headerlink" title="93. 如果我有一个大项目，我需要将所有相关的合约保存到一个文件中吗？"></a>93. 如果我有一个大项目，我需要将所有相关的合约保存到一个文件中吗？</h2><p>答：不需要。可以使用import语句导入其他合约文件，例如import “./MyOtherContracts.sol”;。</p>
<h2 id="94-我只能导入本地合约文件吗？"><a href="#94-我只能导入本地合约文件吗？" class="headerlink" title="94. 我只能导入本地合约文件吗？"></a>94. 我只能导入本地合约文件吗？</h2><p>答：还可以使用HTTP协议导入其他合约文件，例如从Github导入：import “<a target="_blank" rel="noopener" href="http://github.com/owner/repo/path_to_file&quot;;%E3%80%82">http://github.com/owner/repo/path_to_file";。</a></p>
<h2 id="95-EVM的内存分成了哪些部分？"><a href="#95-EVM的内存分成了哪些部分？" class="headerlink" title="95. EVM的内存分成了哪些部分？"></a>95. EVM的内存分成了哪些部分？</h2><p>答：它分为Storage、Memory和Calldata。</p>
<h2 id="96-请解释一下Storage。"><a href="#96-请解释一下Storage。" class="headerlink" title="96. 请解释一下Storage。"></a>96. 请解释一下Storage。</h2><p>答：可以把它想象成一个数据库。 每个合约管理自己的Storage变量。 它是一个键-值数据库（256位键值）。<br>就每次执行使用的gas而言，在Storage上读取和写入的成本更高。</p>
<h2 id="97-请解释一下Memory。"><a href="#97-请解释一下Memory。" class="headerlink" title="97. 请解释一下Memory。"></a>97. 请解释一下Memory。</h2><p>答：这是一个临时存储区。 一旦执行结束，数据就会丢失。 可以在Memory上分配像数组和结构这样复杂的数据类型。</p>
<h2 id="98-请解释一下Calldata-。"><a href="#98-请解释一下Calldata-。" class="headerlink" title="98. 请解释一下Calldata 。"></a>98. 请解释一下Calldata 。</h2><p>答：可以把calldata视为一个调用堆栈。 它是临时的、不可修改的，用来存储EVM的执行数据。</p>
<h2 id="99-哪些变量存储在Storage，那些变量存储在Memory？"><a href="#99-哪些变量存储在Storage，那些变量存储在Memory？" class="headerlink" title="99. 哪些变量存储在Storage，那些变量存储在Memory？"></a>99. 哪些变量存储在Storage，那些变量存储在Memory？</h2><p>答：状态变量和局部变量（它们是对状态变量的引用）存储在Storage区域， 函数参数位于Memory区域。</p>
<h2 id="100-看看下面的代码，并解释代码的哪一部分对应于哪个内存区域："><a href="#100-看看下面的代码，并解释代码的哪一部分对应于哪个内存区域：" class="headerlink" title="100. 看看下面的代码，并解释代码的哪一部分对应于哪个内存区域："></a>100. 看看下面的代码，并解释代码的哪一部分对应于哪个内存区域：</h2><pre><code>contract MyContract {
  // part 1
  uint count;
  uint[] totalPoints;
 
  function localVars(){
     // part 2
     uint[] localArr;
     // part 3
     uint[] memory memoryArr;
     // part 4
     uint[] pointer = totalPoints;
  }
}
</code></pre>
<p>答：<br>第1部分 - Storage<br>第2部分 - Storage<br>第3部分 - Memory<br>第4部分 - Storage</p>
<h2 id="101-这样做对吗："><a href="#101-这样做对吗：" class="headerlink" title="101. 这样做对吗："></a>101. 这样做对吗：</h2><pre><code>function doSomething(uint[] storage args) internal returns(uint[] storage data) {…}
</code></pre>
<p>答：可以，可以强制将函数的参数设置为Storage存储。 在这种情况下，如果没有传递存储引用，编译器会报错。</p>
<h1 id="三、以太坊面试题B"><a href="#三、以太坊面试题B" class="headerlink" title="三、以太坊面试题B"></a>三、以太坊面试题B</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/05ea991faa49">参考链接</a></p>
<h2 id="1-什么是UTXO，-以太坊转账流程"><a href="#1-什么是UTXO，-以太坊转账流程" class="headerlink" title="1. 什么是UTXO， 以太坊转账流程"></a>1. 什么是UTXO， 以太坊转账流程</h2><p>UTXO 模式（Unspent Transaction Output) 和 Account 模式。Bitcoin 采用的是 UTXO 模型，Ethereum 采用的 Account 模型</p>
<p>优点：计算是在链外的，交易本身既是结果也是证明。节点只做验证即可，不需要对交易进行额外的计算，也没有额外的状态存储。交易本身的输出 UTXO 的计算是在钱包完成的，这样交易的计算负担完全由钱包来承担，一定程度上减少了链的负担。除 Coinbase 交易外，交易的 Input 始终是链接在某个 UTXO 后面。交易无法被重放，并且交易的先后顺序和依赖关系容易被验证，交易是否被消费也容易被举证。UTXO 模型是无状态的，更容易并发处理。对于 P2SH 类型的交易，具有更好的隐私性。交易中的 Input 是互不相关联的，可以使用 CoinJoin 这样的技术，来增加一定的隐私性。</p>
<p>缺点：Account 模型交易之间没有依赖性，需要解决重放问题。对于实现闪电网络/雷电网络，Plasma 等，用户举证需要更复杂的 Proof 证明机制，子链向主链进行状态迁移需要更复杂的协议。<br>以太坊交易相关概念：<a target="_blank" rel="noopener" href="https://ethfans.org/posts/479">账户，交易，gas的概念</a></p>
<h2 id="2-交易中的nonce有什么作用，区块中的nonce有什么作用"><a href="#2-交易中的nonce有什么作用，区块中的nonce有什么作用" class="headerlink" title="2. 交易中的nonce有什么作用，区块中的nonce有什么作用"></a>2. 交易中的nonce有什么作用，区块中的nonce有什么作用</h2><p>交易中的nonce：</p>
<p>1 ).是一个整数类型，可以使用相同的随机数来覆盖自己已经发送的但是处于pending状态的交易 ，nonce值需要连续递增</p>
<p>2). nonce小于当前使用的nonce值，交易会被拒绝。</p>
<p>3). Nonce太大，交易会进入queue队列，直到新交易到来，可以连续排序后，转为pending，否则，退出或者一定条件最终被抛弃。</p>
<p>4). 交易队列单帐户单次最多64个交易</p>
<p>5). 合约账户每创建一个合约nonce加一。而合约调用其他合约属于内部调用，因此nonce值不变。<br>区块中的nonce用于工作量证明</p>
<p>digest, result := hashimotoFull(dataset, hash, nonce) //  hashimotoFull 根据块中数据生成用于计算header和nonce的值</p>
<p>if new(big.Int).SetBytes(result).Cmp(target) &lt;= 0  // 判断nonce是否匹配</p>
<h2 id="3-密码学相关，什么是非对称加密，原理是什么、如何运行（公钥私钥生成、使用），签名，-多签，-盲签"><a href="#3-密码学相关，什么是非对称加密，原理是什么、如何运行（公钥私钥生成、使用），签名，-多签，-盲签" class="headerlink" title="3. 密码学相关，什么是非对称加密，原理是什么、如何运行（公钥私钥生成、使用），签名， 多签， 盲签"></a>3. 密码学相关，什么是非对称加密，原理是什么、如何运行（公钥私钥生成、使用），签名， 多签， 盲签</h2><p>公钥、私钥：公开密钥加密（public-key cryptography，也称为非对称(密钥)加密），是指存在一对数学算法相关的密钥，使用其中一个密钥加密后所得的信息，只能用另一个密钥才能解密。如果其中一个公开后并不会危害到另外一个的秘密性质，则称公开的密钥为公钥，不公开的密钥为私钥。公钥的主要作用：加密；验证签名。私钥的主要作用：签名；解密<br>V、R、S是交易的签名数据。以太坊当中，交易经过数字签名之后，生成的signature是一个长度65的字节数组，它被截成三段，前32字节被放进R，再32字节放进S，最后1个字节放进V。那么为什么要被截成3段呢？以太坊用的是ECDSA算法，R和S就是ECSDA签名输出，V则是Recovery ID<br>签名过程：</p>
<p>用户的密钥对:（d, Q）；(d为私钥，Q为公钥)</p>
<p>待签名的信息：M；</p>
<p>签名：Signature(M) = ( r, s)</p>
<p>签名过程：</p>
<p>1、根据ECC算法随机生成一个密钥对(k, R), R=(xR, yR)</p>
<p>2、令 r = xR mod n，如果r = 0，则返回步骤1</p>
<p>3、计算 H = Hash(M)</p>
<p>4、按照数据类型转换规则，将H转化为一个big endian的整数e</p>
<p>5、s = k^-1 (e + rd) mod n，若s = 0, 则返回步骤1</p>
<p>6、输出的S =(r,s)即为签名。</p>
<p>验证过程：</p>
<p>1、 计算 H = Hash(M)</p>
<p>2、按照数据类型转换规则，将H转化为一个big endian的整数e</p>
<p>3、计算 u1 = es^-1 mod n, u2 = rs^-1 mod n</p>
<p>4、计算 R = (xR, yR) = u1G + u2Q, 如果R = 零点，则验证该签名无效</p>
<p>5、令 v = xR mod n6、若 v == r，则签名有效，若 v ≠ r, 则签名无效<br>参考资料：</p>
<p>MD5：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653191503&amp;idx=1&amp;sn=b18bd0458bf884bcb5d01f1cf2ca8301&amp;chksm=8c990f95bbee8683fcfa9e972fd887cb1e50328ab4d8bd1f6a68ea90de6c67f46e50847e36fb&amp;scene=21%23wechat_redirect">什么是MD5，如何使用</a></p>
<p>SHA：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;chksm=f1feed21c68964375afea60d46bea99dc1ad7bf3ff047086c9a974230982791b44ae3f85e7b4&amp;idx=1&amp;mid=2650561442&amp;scene=21&amp;sn=0bbb6ea44e4b4feb6b3257a3dd0e2990">SHA是什么，SHA-1, SHA-2区别</a></p>
<h2 id="4-熟悉的共识算法有哪些，运行过程是什么"><a href="#4-熟悉的共识算法有哪些，运行过程是什么" class="headerlink" title="4. 熟悉的共识算法有哪些，运行过程是什么"></a>4. 熟悉的共识算法有哪些，运行过程是什么</h2><p>pow， pos，DPOS， PBFT， RAFT，</p>
<h2 id="5-Merkle-Tree-数据结构，-以太坊中的块中有哪几颗MPT数，-作用是什么，布隆过滤器"><a href="#5-Merkle-Tree-数据结构，-以太坊中的块中有哪几颗MPT数，-作用是什么，布隆过滤器" class="headerlink" title="5. Merkle Tree 数据结构， 以太坊中的块中有哪几颗MPT数， 作用是什么，布隆过滤器"></a>5. Merkle Tree 数据结构， 以太坊中的块中有哪几颗MPT数， 作用是什么，布隆过滤器</h2><p>MPT(Merkle Patricia Tries)是以太坊中存储区块数据的核心数据结构，它Merkle Tree和Patricia Tree融合一个树形结构。</p>
<p>Merkle Tree，也被称为Hash Tree，中文名称：默克尔树，主要用于数据集较大时的文件校验。其主要特点为：叶节点存储着数据块的Hash（如：文件块、一段数据集）非叶子节点（包括中间节点和根节点）存储着对应子节点Hash值串联字符串之后的Hash值。</p>
<p>Patricia树，或称Patricia trie，或crit bit tree，压缩前缀树，是一种更节省空间的Trie。对于基数树的每个节点，如果该节点是唯一的儿子的话，就和父节点合并。</p>
<p><img src="https://img-blog.csdnimg.cn/20210618100405568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="Merkle树"></p>
<p>MTP树中的节点包含空节点、叶子节点、扩展节点和分支节点 。</p>
<p>Nibble：它是key的基本单元，是一个四元组（四个bit位的组合例如二进制表达的0010就是一个四元组）</p>
<p>空节点**：简单的表示空，在代码中是一个空串。</p>
<p>叶子节点（leaf）：只有两个元素，分别为key和value，表示为key,value的一个键值对，其中key是key的一种特殊十六进制编码，value是value的RLP编码。</p>
<p>扩展节点（extension）：也是key，value的一个键值对，但是这里的value是其他节点的hash值，这个hash可以被用来查询数据库中的节点。也就是说通过hash链接到其他节点。</p>
<p>分支节点（branch）：分支节点有17个元素，回到Nibble，四元组是key的基本单元，四元组最多有16个值。所以前16个必将落入到在其遍历中的键的十六个可能的半字节值中的每一个。第17个是存储那些在当前结点结束了的节点(例如， 有三个key,分别是 (abc ,abd, ab) 第17个字段储存了ab节点的值)<br><img src="https://img-blog.csdnimg.cn/20210618100423223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="MPT树"></p>
<p>以太坊中主要有一下几个地方用了MPT树形结构：</p>
<p>State Trie 区块头中的状态树</p>
<pre><code>    key =&gt; sha3(以太坊账户地址address)

    value =&gt; rlp(账号内容信息account)
</code></pre>
<p>Transactions Trie 区块头中的交易树</p>
<pre><code>    key =&gt; rlp(交易的偏移量 transaction index)

    每个块都有各自的交易树，且不可更改
</code></pre>
<p>Receipts Trie 区块头中的收据树</p>
<pre><code>    key = rlp(交易的偏移量 transaction index)

    每个块都有各自的交易树，且不可更改
</code></pre>
<p>Storage Trie 存储树</p>
<pre><code>    存储智能合约状态

    每个账号有自己的Storage Trie
</code></pre>
<p>MPT树：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://blog.csdn.net/ITleaks/article/details/79992072">MPT的使用</a><br>布隆过滤器：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561343&amp;idx=1&amp;sn=4574e177b648ff3677037ec0fde3f48e&amp;chksm=f1feedbcc68964aa5b64c62b67c9fb306cc5b5d39df8aec8fc7c222b2f9acfef04c3e98322f9&amp;scene=21%23wechat_redirect">什么是布隆过滤器</a></p>
<h2 id="6-智能合约相关，-ERC20-ERC721协议的区别，ERC20定义的接口有哪些"><a href="#6-智能合约相关，-ERC20-ERC721协议的区别，ERC20定义的接口有哪些" class="headerlink" title="6. 智能合约相关， ERC20 ERC721协议的区别，ERC20定义的接口有哪些"></a>6. 智能合约相关， ERC20 ERC721协议的区别，ERC20定义的接口有哪些</h2><p>ERC-20标准里没有价值的区别，Token之间是可以互换的。这就相当于说在ERC-20标准下，你的100块“钱”和我的100块“钱”是一样的。ERC-20标准里规定了Token需要有它的名字、符号、总供应量以及包含转账、汇款等其他功能。这个标准带来的好处是：只要Token符合ERC-20标准，那么它将兼容以太坊钱包。也就是说，你可以在你的以太坊钱包里加入这个Token，还可以通过钱包把它发送给别人</p>
<p>既然ERC-20那么厉害，为什么还要多出一个ERC-721标准呢？前面提到ERC-20标准的Token没有价值的区别，那对于一些需要有独一无二属性的资产（比如加密收藏品、游戏道具）便不再适用。ERC-721标准规定了符合它这种标准的每个Token都有唯一的Token ID。在ERC-721标准里，每个Token都是独一无二的。也就是说，在ERC-721标准下，你的100块“钱”和我的100块“钱”是不一样的，因为这两张100块钱的编号是不一样的。</p>
<p>ERC-20和ERC-721都是以太坊Token发行的一种标准协议。基于ERC-20标准发行的Token没有价值区别，可以互换，可以分割；基于ERC-721标准发行的Token不可互换，每个Token都是唯一的，独一无二的，而且是不可以分割的。<br>ERC-20接口：</p>
<p>function name() view returns (string name)</p>
<p>function symbol() constant returns (string symbol)</p>
<p>function decimals() view returns (uint8 decimals)</p>
<p>function totalSupply() constant returns (uint256 totalSupply)</p>
<p>function balanceOf(address _owner) constant returns (uint256 balance)</p>
<p>function transfer(address _to, uint256 _value) returns (bool success)</p>
<p>function transferFrom(address _from, address _to, uint256 _value) returns (bool success)</p>
<p>function approve(address _spender, uint256 _value) returns (bool success)</p>
<p>function allowance(address _owner, address _spender) constant returns (uint256 remaining)</p>
<p>event</p>
<p>event Transfer(address indexed _from, address indexed _to, uint256 _value)</p>
<p>event Approval(address indexed _owner, address indexed _spender, uint256 _value)</p>
<h2 id="7-如何进行合约调用，-关键字payable的作用"><a href="#7-如何进行合约调用，-关键字payable的作用" class="headerlink" title="7. 如何进行合约调用， 关键字payable的作用"></a>7. 如何进行合约调用， 关键字payable的作用</h2><p>简单描述就是根据abi实例化合约，设置合约地址，发起合约调用。</p>
<p>关键字payable指相关function是可以接受以太坊的调用</p>
<h2 id="8-合约中如何实现随机数"><a href="#8-合约中如何实现随机数" class="headerlink" title="8. 合约中如何实现随机数"></a>8. 合约中如何实现随机数</h2><p>取伪随机数进行单次或者多次hash生成随机数。</p>
<h2 id="9-含有library的合约如何部署"><a href="#9-含有library的合约如何部署" class="headerlink" title="9. 含有library的合约如何部署"></a>9. 含有library的合约如何部署</h2><p>Solidity提供了Library的概念来实现代码重用，它可以被多个不同的智能合约调用。</p>
<p>当我们部署合约时，我们需要首先部署library的代码，然后在部署合约之前指向已部署的库地址。这个过程称为链接。</p>
<h2 id="10-转账交易是否会进EVM"><a href="#10-转账交易是否会进EVM" class="headerlink" title="10. 转账交易是否会进EVM"></a>10. 转账交易是否会进EVM</h2><p>以太坊交易分为两种：普通的账户间转账，创建合约或者合约调用。  无论是哪一种，EVM在运行(excute)交易时都会创建合约(Contract)。</p>
<p>以太坊源码中无论是evm.Create()还是evm.Call()最终都是创建一个Contract结构，然后调用run()方法运行之。即使是外部账户之间普通的转账也会调用Call() 和 run()，只是由于接收者地址上没有代码，运行会很快结束而已。run()最终调用Interpreter的Run()方法。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://learnblockchain.cn/2019/04/09/easy-evm/">深入浅出虚拟机</a></p>
<h2 id="11-关键词index的作用"><a href="#11-关键词index的作用" class="headerlink" title="11. 关键词index的作用"></a>11. 关键词index的作用</h2><p>可以在事件参数上增加indexed属性，最多可以对三个参数增加这样的属性。加上这个属性，可以允许你在web3.js中通过对加了这个属性的参数进行值过滤</p>
<h2 id="12-hash计算的种类"><a href="#12-hash计算的种类" class="headerlink" title="12. hash计算的种类"></a>12. hash计算的种类</h2><h2 id="13-以太坊存储区域"><a href="#13-以太坊存储区域" class="headerlink" title="13. 以太坊存储区域"></a>13. 以太坊存储区域</h2><p>以太坊有三个存储区域：</p>
<p>存储（Storage）：所有智能合约状态变量所在的位置。每个智能合约都有自己的存储，并且只有函数调用才能改变存储中的状态变量。</p>
<p>内存（Memory）：用于保存外部调用的临时数据并在调用结束之后释放数据，相比之下，使用内存中的数据价格更低。</p>
<p>堆栈（Stack）：用于保存小的局部变量。堆栈几乎是免费使用的，但只能保存有限数量的值。</p>
<h2 id="14-交易的hash是如何生成的"><a href="#14-交易的hash是如何生成的" class="headerlink" title="14. 交易的hash是如何生成的"></a>14. 交易的hash是如何生成的</h2><p>// Hash hashes the RLP encoding of tx. It uniquely identifies the transaction.</p>
<h2 id="15-以太坊合约常见问题"><a href="#15-以太坊合约常见问题" class="headerlink" title="15. 以太坊合约常见问题"></a>15. 以太坊合约常见问题</h2><p>solidity常见bug及避坑指南：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7d207bdb8b9c">https://www.jianshu.com/p/7d207bdb8b9c</a><br>问：请列几个你所知道的DApp。</p>
<p>答：Golem（单词含义：傀儡），Golem项目旨在创建业界首个闲置计算机算力的全球市场；Augur（单词含义：预兆），Augur项目旨在将预测市场与去中心化网络相结合，创建一个预测工具，以获得潜在的收益；Aragon Network，它旨在充当一个方便用户的数字化管理组织。<br>附加题：（就是能懂加分的那种）</p>
<h2 id="16-EOS，-IPFS，-COSMOS，Fabric，-BTC-等的运行原理"><a href="#16-EOS，-IPFS，-COSMOS，Fabric，-BTC-等的运行原理" class="headerlink" title="16. EOS， IPFS， COSMOS，Fabric， BTC 等的运行原理"></a>16. EOS， IPFS， COSMOS，Fabric， BTC 等的运行原理</h2><p>IPFS：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://cloud.tencent.com/developer/article/1376417">IPFS相关概念</a></p>
<p>EOS：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://cloud.tencent.com/developer/article/1127767">EOS与ETH对比</a></p>
<h2 id="17-公有链，-私有链，-联盟链是什么，-如何运行"><a href="#17-公有链，-私有链，-联盟链是什么，-如何运行" class="headerlink" title="17. 公有链， 私有链， 联盟链是什么， 如何运行"></a>17. 公有链， 私有链， 联盟链是什么， 如何运行</h2><h2 id="18-各种链的性能"><a href="#18-各种链的性能" class="headerlink" title="18. 各种链的性能"></a>18. 各种链的性能</h2><p>ETH： 10-20TPS</p>
<p>BTC：7 tps</p>
<p>EOS：3000tps<br>参考链接：</p>
<p>fabric相关概念：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d7a77dd4d7de">https://www.jianshu.com/p/d7a77dd4d7de</a></p>
<p>开发技术相关（go）</p>
<h2 id="19-channel，-有无缓冲，是否阻塞"><a href="#19-channel，-有无缓冲，是否阻塞" class="headerlink" title="19. channel， 有无缓冲，是否阻塞"></a>19. channel， 有无缓冲，是否阻塞</h2><p>一个channel可以理解为一个先进先出的消息队列。channel用来在协程[goroutine]之前传递数据，准确的说，是用来传递数据的所有权。一个设计良好的程序应该确保同一时刻channel里面的数据只会被同一个协程拥有，这样就可以避免并发带来的数据不安全问题[data races]。</p>
<p>像数组、切片和字典一样，channel类型是一种组合类型，每一种channel类型都对应着一种简单的数据类型。比如元素的类型是string，那么对应的channel类型就是chan string，进入channel的数据也就必须是string类型的值。</p>
<p>官方文档中限制channel最多能容纳到65535个元素，channel的数据从进入到流出会涉及到数据拷贝操作。如果元素体积过大，最好的方法还是使用传递指针来取代传递值。</p>
<p>它有3种基本状态：nil、open、closed：</p>
<p>用通信来共享内存，而不要用共享内存来通信，可以帮助我们更好的理解channel</p>
<h2 id="20-select-相关"><a href="#20-select-相关" class="headerlink" title="20. select 相关"></a>20. select 相关</h2><ol start="3">
<li><p>slice 和数组的区别，slice空间不足时如何扩容、 过程，每次扩容的增长空间多大</p>
</li>
<li><p>什么是gorutine， 与线程的区别（进程，线程，协程的区别）</p>
</li>
</ol>
<h2 id="21-什么是gorutine？"><a href="#21-什么是gorutine？" class="headerlink" title="21. 什么是gorutine？"></a>21. 什么是gorutine？</h2><p>goroutine是建立在线程之上的轻量级的抽象。它允许我们以非常低的代价在同一个地址空间中并行地执行多个函数或者方法。相比于线程，它的创建和销毁的代价要小很多，并且它的调度是独立于线程的。在golang中创建一个goroutine非常简单，使用“go”关键字即可。<br>与线程的区别</p>
<p>goroutine并不会比线程更快，它只是增加了更多的并发性。当一个goroutine被阻塞（比如等待IO），golang的scheduler会调度其它可以执行的goroutine运行。与线程相比，它有以下几个优点：内存消耗更少，创建和销毁代价更小。<br>Go调度器</p>
<p>Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。调度器会在以下几个时间点对其进行切换：</p>
<p>a). Channel接受或者发送会造成阻塞的消息</p>
<p>b). 当一个新的goroutine被创建时</p>
<p>c). 可以造成阻塞的系统调用，如文件和网络操作</p>
<p>d). 垃圾回收</p>
<h2 id="22-protobuf-是什么，如何使用"><a href="#22-protobuf-是什么，如何使用" class="headerlink" title="22. protobuf 是什么，如何使用"></a>22. protobuf 是什么，如何使用</h2><p>和http中常用的json协议一样，protobuf也是用来传输数据的，但是它使用二进制格式，传输效率更高。</p>
<h2 id="23-go-tools-建议了解一下"><a href="#23-go-tools-建议了解一下" class="headerlink" title="23. go tools, 建议了解一下"></a>23. go tools, 建议了解一下</h2><h2 id="24-一致性哈希算法"><a href="#24-一致性哈希算法" class="headerlink" title="24. 一致性哈希算法"></a>24. 一致性哈希算法</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561254&amp;idx=1&amp;sn=7500e3e54a573b19ce2fbfa0a82f2b13&amp;chksm=f1feec65c689657386c8913f819bb5253bece3bd56f7fcc725201c925723e2fbc5bfcb962b9c&amp;scene=21#wechat_redirect">一致性哈希算法</a></p>
</article><div id="paginator"></div></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/zhang_zhishun"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/zhangzhishun"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Sugar 2022</span></p><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script></body></html>