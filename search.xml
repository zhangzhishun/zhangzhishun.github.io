<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Solidityå­¦ä¹ ç¬”è®°(åŸºç¡€éƒ¨åˆ†)</title>
      <link href="/2022/05/05/blockchain/ethereum/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/05/blockchain/ethereum/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidityå­¦ä¹ ç¬”è®°-åŸºç¡€éƒ¨åˆ†"><a href="#Solidityå­¦ä¹ ç¬”è®°-åŸºç¡€éƒ¨åˆ†" class="headerlink" title="Solidityå­¦ä¹ ç¬”è®°(åŸºç¡€éƒ¨åˆ†)"></a>Solidityå­¦ä¹ ç¬”è®°(åŸºç¡€éƒ¨åˆ†)</h1><p>æœ¬æ–‡å‚è€ƒï¼š<a href="https://solidity-by-example.org/">https://solidity-by-example.org/</a></p><p>æ¨èè§†é¢‘è¯¾ç¨‹ï¼š<a href="https://www.bilibili.com/video/BV1St411a7Pk">https://www.bilibili.com/video/BV1St411a7Pk</a></p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><pre><code class="solidity">// SPDX-License-Identifier: MIT// compiler version must be greater than or equal to 0.8.13 and less than 0.9.0pragma solidity ^0.8.13;contract HelloWorld {    string public greet = "Hello World!";}</code></pre><h2 id="ç¬¬ä¸€ä¸ªç¨‹åº"><a href="#ç¬¬ä¸€ä¸ªç¨‹åº" class="headerlink" title="ç¬¬ä¸€ä¸ªç¨‹åº"></a>ç¬¬ä¸€ä¸ªç¨‹åº</h2><p>è¿™æ˜¯ä¸€ä¸ªç®€å•çš„åˆçº¦ï¼Œç”¨äºè·å–ã€å¢åŠ ã€å‡å°‘è´¦æˆ·ä½™é¢</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Counter {    uint public count;    // Function to get the current count    function get() public view returns (uint) {        return count;    }    // Function to increment count by 1    function inc() public {        count += 1;    }    // Function to decrement count by 1    function dec() public {        // This function will fail if count = 0        count -= 1;    }}</code></pre><h2 id="åŸºæœ¬æ•°æ®ç±»å‹"><a href="#åŸºæœ¬æ•°æ®ç±»å‹" class="headerlink" title="åŸºæœ¬æ•°æ®ç±»å‹"></a>åŸºæœ¬æ•°æ®ç±»å‹</h2><p>åœ¨è¿™é‡Œä»‹ç»å››ç§æ•°æ®ç±»å‹ï¼š</p><ul><li>boolean</li><li>uint</li><li>int</li><li>address</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Primitives {    bool public boo = true;    /*    uint stands for unsigned integer, meaning non negative integers    different sizes are available        uint8   ranges from 0 to 2 ** 8 - 1        uint16  ranges from 0 to 2 ** 16 - 1        ...        uint256 ranges from 0 to 2 ** 256 - 1    */    uint8 public u8 = 1;    uint public u256 = 456;    uint public u = 123; // uint is an alias for uint256    /*    Negative numbers are allowed for int types.    Like uint, different ranges are available from int8 to int256        int256 ranges from -2 ** 255 to 2 ** 255 - 1    int128 ranges from -2 ** 127 to 2 ** 127 - 1    */    int8 public i8 = -1;    int public i256 = 456;    int public i = -123; // int is same as int256    // minimum and maximum of int    int public minInt = type(int).min;    int public maxInt = type(int).max;    address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;    /*    In Solidity, the data type byte represent a sequence of bytes.     Solidity presents two type of bytes types :     - fixed-sized byte arrays     - dynamically-sized byte arrays.          The term bytes in Solidity represents a dynamic array of bytes.      Itâ€™s a shorthand for byte[] .    */    bytes1 a = 0xb5; //  [10110101]    bytes1 b = 0x56; //  [01010110]    // Default values    // Unassigned variables have a default value    bool public defaultBoo; // false    uint public defaultUint; // 0    int public defaultInt; // 0    address public defaultAddr; // 0x0000000000000000000000000000000000000000}</code></pre><h2 id="å˜é‡ç±»å‹"><a href="#å˜é‡ç±»å‹" class="headerlink" title="å˜é‡ç±»å‹"></a>å˜é‡ç±»å‹</h2><p>Solidity ä¸­æœ‰ 3 ç§ç±»å‹çš„å˜é‡</p><ul><li>local<ul><li>å‡½æ•°å†…å®šä¹‰</li><li>ä¸å­˜å‚¨åœ¨åŒºå—é“¾</li></ul></li><li>state<ul><li>å‡½æ•°å¤–å®šä¹‰</li><li>å­˜å‚¨åœ¨åŒºå—é“¾</li></ul></li><li>global (ä¿å­˜åŒºå—é“¾çš„ä¿¡æ¯)</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Variables {    // State variables are stored on the blockchain.    string public text = "Hello";    uint public num = 123;    function doSomething() public {        // Local variables are not saved to the blockchain.        uint i = 456;        // Here are some global variables        uint timestamp = block.timestamp; // Current block timestamp        address sender = msg.sender; // address of the caller    }}</code></pre><h2 id="å¸¸é‡"><a href="#å¸¸é‡" class="headerlink" title="å¸¸é‡"></a>å¸¸é‡</h2><p>å¸¸é‡æ˜¯ä¸èƒ½è¢«ä¿®æ”¹çš„</p><p>å®ƒä»¬çš„å€¼æ˜¯ç¡¬ç¼–ç çš„ï¼Œä½¿ç”¨å¸¸é‡å¯ä»¥èŠ‚çœ gas æˆæœ¬</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Constants {    // coding convention to uppercase constant variables    address public constant MY_ADDRESS = 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc;    uint public constant MY_UINT = 123;}</code></pre><h2 id="ä¸å¯å˜å˜é‡"><a href="#ä¸å¯å˜å˜é‡" class="headerlink" title="ä¸å¯å˜å˜é‡"></a>ä¸å¯å˜å˜é‡</h2><p>ä¸å¯å˜å˜é‡å°±åƒå¸¸é‡ã€‚ä¸å¯å˜å˜é‡çš„å€¼å¯ä»¥åœ¨æ„é€ å‡½æ•°ä¸­è®¾ç½®ï¼Œä½†ä¹‹åä¸èƒ½ä¿®æ”¹ã€‚</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Immutable {    // coding convention to uppercase constant variables    address public immutable MY_ADDRESS;    uint public immutable MY_UINT;    constructor(uint _myUint) {        MY_ADDRESS = msg.sender;        MY_UINT = _myUint;    }}</code></pre><h2 id="è¯»å–å’Œå†™å…¥çŠ¶æ€å˜é‡"><a href="#è¯»å–å’Œå†™å…¥çŠ¶æ€å˜é‡" class="headerlink" title="è¯»å–å’Œå†™å…¥çŠ¶æ€å˜é‡"></a>è¯»å–å’Œå†™å…¥çŠ¶æ€å˜é‡</h2><p>è¦å†™å…¥æˆ–æ›´æ–°çŠ¶æ€å˜é‡ï¼Œæ‚¨éœ€è¦å‘é€äº¤æ˜“</p><p>ä½†æ˜¯æ‚¨å¯ä»¥å…è´¹è¯»å–çŠ¶æ€å˜é‡ï¼Œæ— éœ€ä»»ä½•äº¤æ˜“è´¹ç”¨</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract SimpleStorage {    // State variable to store a number    uint public num;    // You need to send a transaction to write to a state variable.    function set(uint _num) public {        num = _num;    }    // You can read from a state variable without sending a transaction.    function get() public view returns (uint) {        return num;    }}</code></pre><h2 id="ä»¥å¤ªåŠå•ä½ï¼šEther-and-Wei"><a href="#ä»¥å¤ªåŠå•ä½ï¼šEther-and-Wei" class="headerlink" title="ä»¥å¤ªåŠå•ä½ï¼šEther and Wei"></a>ä»¥å¤ªåŠå•ä½ï¼šEther and Wei</h2><p>äº¤æ˜“ä½¿ç”¨ä»¥å¤ªå¸æ”¯ä»˜ï¼Œç±»ä¼¼äºä¸€ç¾å…ƒç­‰äº 100 ç¾åˆ†ï¼Œ1ethç­‰äº 10^18wei</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract EtherUnits {    uint public oneWei = 1 wei;    // 1 wei is equal to 1    bool public isOneWei = 1 wei == 1;    uint public oneEther = 1 ether;    // 1 ether is equal to 10^18 wei    bool public isOneEther = 1 ether == 1e18;}</code></pre><h2 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h2><ol><li><p>ä¸€æ¬¡äº¤æ˜“éœ€è¦æ”¯ä»˜å¤šå°‘ethï¼Ÿ</p><p>æ‚¨æ”¯ä»˜çš„ gas spent * gas price çš„ethæ•°é‡ï¼Œå…¶ä¸­ï¼š</p><ul><li>gasæ˜¯ä¸€ä¸ªè®¡ç®—å•ä½</li><li>gasèŠ±è´¹æ˜¯äº¤æ˜“ä¸­ä½¿ç”¨çš„ gas æ€»é‡</li><li>gas priceæ˜¯æ‚¨æ„¿æ„ä¸ºæ¯ gas æ”¯ä»˜å¤šå°‘ ether </li></ul><p>å…·æœ‰æ›´é«˜ gas ä»·æ ¼çš„äº¤æ˜“æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§è¢«åŒ…å«åœ¨ä¸€ä¸ªå—ä¸­ï¼Œæœªä½¿ç”¨çš„Gaså°†è¢«é€€è¿˜</p></li><li><p>Gasé™åˆ¶</p><p>æ‚¨å¯ä»¥èŠ±è´¹çš„ gas é‡æœ‰ 2 ä¸ªä¸Šé™ï¼š</p><ul><li>gas limitï¼ˆæ‚¨æ„¿æ„ä¸ºäº¤æ˜“ä½¿ç”¨çš„æœ€å¤§ gas é‡ï¼Œç”±æ‚¨è®¾ç½®ï¼‰</li><li>å— gas é™åˆ¶ï¼ˆä¸€ä¸ªå—ä¸­å…è®¸çš„æœ€å¤§ gas é‡ï¼Œç”±åŒºå—é“¾ç½‘ç»œè®¾ç½®ï¼‰</li></ul></li></ol><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Gas {    uint public i = 0;    // Using up all of the gas that you send causes your transaction to fail.    // State changes are undone.    // Gas spent are not refunded.    function forever() public {        // Here we run a loop until all of the gas are spent        // and the transaction fails        while (true) {            i += 1;        }    }}</code></pre><h2 id="If-Else"><a href="#If-Else" class="headerlink" title="If / Else"></a>If / Else</h2><p>Solidity æ”¯æŒæ¡ä»¶è¯­å¥ ifã€else if å’Œ else</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract IfElse {    function foo(uint x) public pure returns (uint) {        if (x &lt; 10) {            return 0;        } else if (x &lt; 20) {            return 1;        } else {            return 2;        }    }    function ternary(uint _x) public pure returns (uint) {        // if (_x &lt; 10) {        //     return 1;        // }        // return 2;        // shorthand way to write if / else statement        return _x &lt; 10 ? 1 : 2;    }}</code></pre><h2 id="Forã€Whileå¾ªç¯"><a href="#Forã€Whileå¾ªç¯" class="headerlink" title="Forã€Whileå¾ªç¯"></a>Forã€Whileå¾ªç¯</h2><p>Solidity æ”¯æŒ forã€while å’Œ do while å¾ªç¯ï¼Œä¸è¦ç¼–å†™æ— ç•Œå¾ªç¯ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šè¾¾åˆ° gas é™åˆ¶ï¼Œå¯¼è‡´æ‚¨çš„äº¤æ˜“å¤±è´¥</p><p>ç”±äºä¸Šè¿°åŸå› ï¼Œå¾ˆå°‘ä½¿ç”¨ while å’Œ do while å¾ªç¯</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Loop {    function loop() public {        // for loop        for (uint i = 0; i &lt; 10; i++) {            if (i == 3) {                // Skip to next iteration with continue                continue;            }            if (i == 5) {                // Exit loop with break                break;            }        }        // while loop        uint j;        while (j &lt; 10) {            j++;        }    }}</code></pre><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>Mappingæ˜¯ä½¿ç”¨è¯­æ³•æ˜ å°„ï¼ˆkeyType =&gt; valueTypeï¼‰åˆ›å»ºçš„</p><p>keyTypeå¯ä»¥æ˜¯ä»»ä½•å†…ç½®å€¼ç±»å‹ã€å­—èŠ‚ã€å­—ç¬¦ä¸²æˆ–åˆçº¦åœ°å€</p><p>valueTypeå¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼ŒåŒ…æ‹¬å¦ä¸€ä¸ªMappingæˆ–æ•°ç»„</p><p>Mappingsä¸å¯è¿­ä»£</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Mapping {    // Mapping from address to uint    mapping(address =&gt; uint) public myMap;    function get(address _addr) public view returns (uint) {        // Mapping always returns a value.        // If the value was never set, it will return the default value.        return myMap[_addr];    }    function set(address _addr, uint _i) public {        // Update the value at this address        myMap[_addr] = _i;    }    function remove(address _addr) public {        // Reset the value to the default value.        delete myMap[_addr];    }}contract NestedMapping {    // Nested mapping (mapping from address to another mapping)    mapping(address =&gt; mapping(uint =&gt; bool)) public nested;    function get(address _addr1, uint _i) public view returns (bool) {        // You can get values from a nested mapping        // even when it is not initialized        return nested[_addr1][_i];    }    function set(        address _addr1,        uint _i,        bool _boo    ) public {        nested[_addr1][_i] = _boo;    }    function remove(address _addr1, uint _i) public {        delete nested[_addr1][_i];    }}</code></pre><h2 id="æ•°ç»„"><a href="#æ•°ç»„" class="headerlink" title="æ•°ç»„"></a>æ•°ç»„</h2><p>æ•°ç»„å¯ä»¥å…·æœ‰ç¼–è¯‘æ—¶å›ºå®šå¤§å°æˆ–åŠ¨æ€å¤§å°</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Array {    // Several ways to initialize an array    uint[] public arr;    uint[] public arr2 = [1, 2, 3];    // Fixed sized array, all elements initialize to 0    uint[10] public myFixedSizeArr;    function get(uint i) public view returns (uint) {        return arr[i];    }    // Solidity can return the entire array.    // But this function should be avoided for    // arrays that can grow indefinitely in length.    function getArr() public view returns (uint[] memory) {        return arr;    }    function push(uint i) public {        // Append to array        // This will increase the array length by 1.        arr.push(i);    }    function pop() public {        // Remove last element from array        // This will decrease the array length by 1        arr.pop();    }    function getLength() public view returns (uint) {        return arr.length;    }    function remove(uint index) public {        // Delete does not change the array length.        // It resets the value at index to it's default value,        // in this case 0        delete arr[index];    }    function examples() external {        // create array in memory, only fixed size can be created        uint[] memory a = new uint[](5);    }}</code></pre><h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><p>Solidity æ”¯æŒæšä¸¾ï¼Œå®ƒä»¬å¯¹äºè·Ÿè¸ªçŠ¶æ€å¾ˆæœ‰ç”¨ã€‚æšä¸¾å¯ä»¥åœ¨åˆçº¦ä¹‹å¤–å£°æ˜</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Enum {    // Enum representing shipping status    enum Status {        Pending,        Shipped,        Accepted,        Rejected,        Canceled    }    // Default value is the first element listed in    // definition of the type, in this case "Pending"    Status public status;    // Returns uint    // Pending  - 0    // Shipped  - 1    // Accepted - 2    // Rejected - 3    // Canceled - 4    function get() public view returns (Status) {        return status;    }    // Update status by passing uint into input    function set(Status _status) public {        status = _status;    }    // You can update to a specific enum like this    function cancel() public {        status = Status.Canceled;    }    // delete resets the enum to its first value, 0    function reset() public {        delete status;    }}</code></pre><h2 id="ç»“æ„ä½“"><a href="#ç»“æ„ä½“" class="headerlink" title="ç»“æ„ä½“"></a>ç»“æ„ä½“</h2><p>æ‚¨å¯ä»¥é€šè¿‡åˆ›å»ºç»“æ„ä½“æ¥å®šä¹‰è‡ªå·±çš„ç±»å‹</p><p>å®ƒä»¬å¯¹äºå°†ç›¸å…³æ•°æ®ç»„åˆåœ¨ä¸€èµ·å¾ˆæœ‰ç”¨</p><p>ç»“æ„ä½“å¯ä»¥åœ¨åˆçº¦ä¹‹å¤–å£°æ˜å¹¶åœ¨å¦ä¸€ä¸ªåˆçº¦ä¸­å¯¼å…¥</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Todos {    struct Todo {        string text;        bool completed;    }    // An array of 'Todo' structs    Todo[] public todos;    function create(string memory _text) public {        // 3 ways to initialize a struct        // - calling it like a function        todos.push(Todo(_text, false));        // key value mapping        todos.push(Todo({text: _text, completed: false}));        // initialize an empty struct and then update it        Todo memory todo;        todo.text = _text;        // todo.completed initialized to false        todos.push(todo);    }    // Solidity automatically created a getter for 'todos' so    // you don't actually need this function.    function get(uint _index) public view returns (string memory text, bool completed) {        Todo storage todo = todos[_index];        return (todo.text, todo.completed);    }    // update text    function update(uint _index, string memory _text) public {        Todo storage todo = todos[_index];        todo.text = _text;    }    // update completed    function toggleCompleted(uint _index) public {        Todo storage todo = todos[_index];        todo.completed = !todo.completed;    }}</code></pre><h2 id="æ•°æ®å­˜å‚¨ä½ç½®"><a href="#æ•°æ®å­˜å‚¨ä½ç½®" class="headerlink" title="æ•°æ®å­˜å‚¨ä½ç½®"></a>æ•°æ®å­˜å‚¨ä½ç½®</h2><p>å˜é‡è¢«å£°æ˜ä¸º storageã€memory æˆ– calldata ä»¥æ˜ç¡®æŒ‡å®šæ•°æ®çš„ä½ç½®ï¼š</p><ul><li>storageï¼šå˜é‡æ˜¯çŠ¶æ€å˜é‡ï¼ˆå­˜å‚¨åœ¨åŒºå—é“¾ä¸Šï¼‰</li><li>memoryï¼šå˜é‡åœ¨å†…å­˜ä¸­ï¼Œåœ¨è°ƒç”¨å‡½æ•°æ—¶å­˜åœ¨ï¼Œåœ¨å£°æ˜è¦å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼ˆä¸´æ—¶ï¼‰çš„å˜é‡ï¼ˆå‡½æ•°å‚æ•°ä»¥åŠå‡½æ•°å†…éƒ¨çš„é€»è¾‘ï¼‰æ—¶åº”ä½¿ç”¨memory</li><li>calldataï¼šä¸€ä¸ªä¸å¯ä¿®æ”¹ã€éæŒä¹…æ€§çš„åŒºåŸŸï¼Œç”¨äºå­˜å‚¨å‡½æ•°å‚æ•°ã€‚åœ¨å£°æ˜å¤–éƒ¨å‡½æ•°çš„åŠ¨æ€å‚æ•°æ—¶å¿…é¡»ä½¿ç”¨ calldataï¼Œcalldata æ˜¯å­˜å‚¨å‡½æ•°å‚æ•°çš„ä¸å¯ä¿®æ”¹ã€éæŒä¹…æ€§åŒºåŸŸ</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract DataLocations {    uint[] public arr;    mapping(uint =&gt; address) map;    struct MyStruct {        uint foo;    }    mapping(uint =&gt; MyStruct) myStructs;    function f() public {        // call _f with state variables        _f(arr, map, myStructs[1]);        // get a struct from a mapping        MyStruct storage myStruct = myStructs[1];        // create a struct in memory        MyStruct memory myMemStruct = MyStruct(0);    }    function _f(        uint[] storage _arr,        mapping(uint =&gt; address) storage _map,        MyStruct storage _myStruct    ) internal {        // do something with storage variables    }    // You can return memory variables    function g(uint[] memory _arr) public returns (uint[] memory) {        // do something with memory array    }    function h(uint[] calldata _arr) external {        // do something with calldata array    }}</code></pre><h2 id="å‡½æ•°"><a href="#å‡½æ•°" class="headerlink" title="å‡½æ•°"></a>å‡½æ•°</h2><p>æœ‰å‡ ç§æ–¹æ³•å¯ä»¥ä»å‡½æ•°ä¸­è¾“å‡º</p><p>å…¬å…±å‡½æ•°ä¸èƒ½æ¥å—æŸäº›æ•°æ®ç±»å‹ä½œä¸ºè¾“å…¥æˆ–è¾“å‡º(ä¾‹å¦‚Mapping)</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Function {    // Functions can return multiple values.    function returnMany()        public        pure        returns (            uint,            bool,            uint        )    {        return (1, true, 2);    }    // Return values can be named.    function named()        public        pure        returns (            uint x,            bool b,            uint y        )    {        return (1, true, 2);    }    // Return values can be assigned to their name.    // In this case the return statement can be omitted.    function assigned()        public        pure        returns (            uint x,            bool b,            uint y        )    {        x = 1;        b = true;        y = 2;    }    // Use destructuring assignment when calling another    // function that returns multiple values.    function destructuringAssignments()        public        pure        returns (            uint,            bool,            uint,            uint,            uint        )    {        (uint i, bool b, uint j) = returnMany();        // Values can be left out.        (uint x, , uint y) = (4, 5, 6);        return (i, b, j, x, y);    }    // Cannot use map for either input or output    // Can use array for input    function arrayInput(uint[] memory _arr) public {}    // Can use array for output    uint[] public arr;    function arrayOutput() public view returns (uint[] memory) {        return arr;    }}</code></pre><h2 id="Viewã€Pureä¿®é¥°å‡½æ•°"><a href="#Viewã€Pureä¿®é¥°å‡½æ•°" class="headerlink" title="Viewã€Pureä¿®é¥°å‡½æ•°"></a>Viewã€Pureä¿®é¥°å‡½æ•°</h2><p>GetteråŠŸèƒ½çš„å‡½æ•°å¯ä»¥å£°æ˜ä¸º view æˆ– pure</p><p>View å‡½æ•°å£°æ˜ä¸ä¼šæ›´æ”¹çŠ¶æ€</p><p>Pure å‡½æ•°å£°æ˜ä¸ä¼šæ›´æ”¹æˆ–è¯»å–ä»»ä½•çŠ¶æ€å˜é‡</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract ViewAndPure {    uint public x = 1;    // Promise not to modify the state.    function addToX(uint y) public view returns (uint) {        return x + y;    }    // Promise not to modify or read from the state.    function add(uint i, uint j) public pure returns (uint) {        return i + j;    }}</code></pre><h2 id="Errorå¼‚å¸¸"><a href="#Errorå¼‚å¸¸" class="headerlink" title="Errorå¼‚å¸¸"></a>Errorå¼‚å¸¸</h2><p>Errorå¼‚å¸¸å°†æ’¤æ¶ˆäº‹åŠ¡æœŸé—´å¯¹çŠ¶æ€æ‰€åšçš„æ‰€æœ‰æ›´æ”¹</p><p>æ‚¨å¯ä»¥é€šè¿‡è°ƒç”¨ requireã€revert æˆ– assert æ¥æŠ›å‡ºå¼‚å¸¸</p><ul><li><p>requireç”¨äºåœ¨æ‰§è¡Œä¹‹å‰éªŒè¯è¾“å…¥å’Œæ¡ä»¶</p></li><li><p>revert ç±»ä¼¼äº requireï¼Œæœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…ä¸‹é¢çš„ä»£ç </p></li><li><p>assert ç”¨äºæ£€æŸ¥ä¸åº”ä¸ºå‡çš„ä»£ç ã€‚æ–­è¨€å¤±è´¥å¯èƒ½æ„å‘³ç€å­˜åœ¨Bug</p></li></ul><p>ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯æ¥èŠ‚çœGas</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Error {    function testRequire(uint _i) public pure {        // Require should be used to validate conditions such as:        // - inputs        // - conditions before execution        // - return values from calls to other functions        require(_i &gt; 10, "Input must be greater than 10");    }    function testRevert(uint _i) public pure {        // Revert is useful when the condition to check is complex.        // This code does the exact same thing as the example above        if (_i &lt;= 10) {            revert("Input must be greater than 10");        }    }    uint public num;    function testAssert() public view {        // Assert should only be used to test for internal errors,        // and to check invariants.        // Here we assert that num is always equal to 0        // since it is impossible to update the value of num        assert(num == 0);    }    // custom error    error InsufficientBalance(uint balance, uint withdrawAmount);    function testCustomError(uint _withdrawAmount) public view {        uint bal = address(this).balance;        if (bal &lt; _withdrawAmount) {            revert InsufficientBalance({balance: bal, withdrawAmount: _withdrawAmount});        }    }}</code></pre><h2 id="Modifierå‡½æ•°"><a href="#Modifierå‡½æ•°" class="headerlink" title="Modifierå‡½æ•°"></a>Modifierå‡½æ•°</h2><p>Modifieræ˜¯å¯ä»¥åœ¨å‡½æ•°è°ƒç”¨ä¹‹å‰å’Œ/æˆ–ä¹‹åè¿è¡Œçš„ä»£ç </p><p>Modifierå¯ç”¨äºï¼š</p><ul><li>é™åˆ¶è®¿é—®</li><li>éªŒè¯è¾“å…¥</li><li>é˜²æ­¢é‡å…¥é»‘å®¢æ”»å‡»</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract FunctionModifier {    // We will use these variables to demonstrate how to use    // modifiers.    address public owner;    uint public x = 10;    bool public locked;    constructor() {        // Set the transaction sender as the owner of the contract.        owner = msg.sender;    }    // Modifier to check that the caller is the owner of    // the contract.    modifier onlyOwner() {        require(msg.sender == owner, "Not owner");        // Underscore is a special character only used inside        // a function modifier and it tells Solidity to        // execute the rest of the code.        _;    }    // Modifiers can take inputs. This modifier checks that the    // address passed in is not the zero address.    modifier validAddress(address _addr) {        require(_addr != address(0), "Not valid address");        _;    }    function changeOwner(address _newOwner) public onlyOwner validAddress(_newOwner) {        owner = _newOwner;    }    // Modifiers can be called before and / or after a function.    // This modifier prevents a function from being called while    // it is still executing.    modifier noReentrancy() {        require(!locked, "No reentrancy");        locked = true;        _;        locked = false;    }    function decrement(uint i) public noReentrancy {        x -= i;        if (i &gt; 1) {            decrement(i - 1);        }    }}</code></pre><h2 id="äº‹ä»¶"><a href="#äº‹ä»¶" class="headerlink" title="äº‹ä»¶"></a>äº‹ä»¶</h2><p>äº‹ä»¶å…è®¸è®°å½•æ—¥å¿—åˆ°ä»¥å¤ªåŠåŒºå—é“¾</p><p>äº‹ä»¶çš„ä¸€äº›ç”¨ä¾‹æ˜¯ï¼š</p><ul><li>ç›‘å¬äº‹ä»¶å’Œæ›´æ–°ç”¨æˆ·ç•Œé¢</li><li>ä¸€ç§å»‰ä»·çš„å­˜å‚¨å½¢å¼</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Event {    // Event declaration    // Up to 3 parameters can be indexed.    // Indexed parameters helps you filter the logs by the indexed parameter    event Log(address indexed sender, string message);    event AnotherLog();    function test() public {        emit Log(msg.sender, "Hello World!");        emit Log(msg.sender, "Hello EVM!");        emit AnotherLog();    }}</code></pre><h2 id="æ„é€ æ–¹æ³•"><a href="#æ„é€ æ–¹æ³•" class="headerlink" title="æ„é€ æ–¹æ³•"></a>æ„é€ æ–¹æ³•</h2><p>æ„é€ å‡½æ•°æ˜¯åœ¨åˆ›å»ºåˆçº¦æ—¶æ‰§è¡Œçš„å¯é€‰å‡½æ•°</p><p>ä»¥ä¸‹æ˜¯å¦‚ä½•å°†å‚æ•°ä¼ é€’ç»™æ„é€ å‡½æ•°çš„ç¤ºä¾‹</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;// Base contract Xcontract X {    string public name;    constructor(string memory _name) {        name = _name;    }}// Base contract Ycontract Y {    string public text;    constructor(string memory _text) {        text = _text;    }}// There are 2 ways to initialize parent contract with parameters.// Pass the parameters here in the inheritance list.contract B is X("Input to X"), Y("Input to Y") {}contract C is X, Y {    // Pass the parameters here in the constructor,    // similar to function modifiers.    constructor(string memory _name, string memory _text) X(_name) Y(_text) {}}// Parent constructors are always called in the order of inheritance// regardless of the order of parent contracts listed in the// constructor of the child contract.// Order of constructors called:// 1. X// 2. Y// 3. Dcontract D is X, Y {    constructor() X("X was called") Y("Y was called") {}}// Order of constructors called:// 1. X// 2. Y// 3. Econtract E is X, Y {    constructor() Y("Y was called") X("X was called") {}}</code></pre><h2 id="ç»§æ‰¿"><a href="#ç»§æ‰¿" class="headerlink" title="ç»§æ‰¿"></a>ç»§æ‰¿</h2><p>Solidity æ”¯æŒå¤šé‡ç»§æ‰¿</p><p>åˆçº¦å¯ä»¥ä½¿ç”¨iså…³é”®å­—ç»§æ‰¿å…¶ä»–åˆçº¦</p><p>è¦è¢«å­åˆçº¦è¦†ç›–çš„å‡½æ•°å¿…é¡»å£°æ˜ä¸ºvirtual</p><p>è¦è¦†ç›–çˆ¶å‡½æ•°çš„å‡½æ•°å¿…é¡»ä½¿ç”¨å…³é”®å­—override</p><p>ç»§æ‰¿çš„é¡ºåºå¾ˆé‡è¦</p><p>ä½ å¿…é¡»æŒ‰ç…§ä»â€œæœ€åŸºç¡€â€åˆ°â€œæœ€è¡ç”Ÿâ€ï¼ˆâ€œmost base-likeâ€ to â€œmost derivedâ€ï¼‰çš„é¡ºåºåˆ—å‡ºçˆ¶åˆçº¦</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;/* Graph of inheritance    A   / \  B   C / \ /F  D,E*/contract A {    function foo() public pure virtual returns (string memory) {        return "A";    }}// Contracts inherit other contracts by using the keyword 'is'.contract B is A {    // Override A.foo()    function foo() public pure virtual override returns (string memory) {        return "B";    }}contract C is A {    // Override A.foo()    function foo() public pure virtual override returns (string memory) {        return "C";    }}// Contracts can inherit from multiple parent contracts.// When a function is called that is defined multiple times in// different contracts, parent contracts are searched from// right to left, and in depth-first manner.contract D is B, C {    // D.foo() returns "C"    // since C is the right most parent contract with function foo()    function foo() public pure override(B, C) returns (string memory) {        return super.foo();    }}contract E is C, B {    // E.foo() returns "B"    // since B is the right most parent contract with function foo()    function foo() public pure override(C, B) returns (string memory) {        return super.foo();    }}// Inheritance must be ordered from â€œmost base-likeâ€ to â€œmost derivedâ€.// Swapping the order of A and B will throw a compilation error.contract F is A, B {    function foo() public pure override(A, B) returns (string memory) {        return super.foo();    }}</code></pre><h2 id="è¦†ç›–ç»§æ‰¿çš„åˆçº¦çŠ¶æ€å˜é‡"><a href="#è¦†ç›–ç»§æ‰¿çš„åˆçº¦çŠ¶æ€å˜é‡" class="headerlink" title="è¦†ç›–ç»§æ‰¿çš„åˆçº¦çŠ¶æ€å˜é‡"></a>è¦†ç›–ç»§æ‰¿çš„åˆçº¦çŠ¶æ€å˜é‡</h2><p>ä¸å‡½æ•°ä¸åŒï¼ŒçŠ¶æ€å˜é‡ä¸èƒ½é€šè¿‡åœ¨å­åˆçº¦ä¸­é‡æ–°å£°æ˜æ¥è¦†ç›–</p><p>è®©æˆ‘ä»¬å­¦ä¹ å¦‚ä½•æ­£ç¡®è¦†ç›–ç»§æ‰¿çš„çŠ¶æ€å˜é‡</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract A {    string public name = "Contract A";    function getName() public view returns (string memory) {        return name;    }}// Shadowing is disallowed in Solidity 0.6// This will not compile// contract B is A {//     string public name = "Contract B";// }contract C is A {    // This is the correct way to override inherited state variables.    constructor() {        name = "Contract C";    }    // C.getName returns "Contract C"}</code></pre><h2 id="è°ƒç”¨çˆ¶åˆçº¦"><a href="#è°ƒç”¨çˆ¶åˆçº¦" class="headerlink" title="è°ƒç”¨çˆ¶åˆçº¦"></a>è°ƒç”¨çˆ¶åˆçº¦</h2><p>å¯ä»¥ç›´æ¥è°ƒç”¨çˆ¶åˆçº¦ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å…³é”®å­— super è°ƒç”¨</p><p>ä½¿ç”¨å…³é”®å­— super ä¼šè°ƒç”¨æ‰€æœ‰çš„ç›´æ¥çˆ¶åˆçº¦</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;/* Inheritance tree   A /  \B   C \ /  D*/contract A {    // This is called an event. You can emit events from your function    // and they are logged into the transaction log.    // In our case, this will be useful for tracing function calls.    event Log(string message);    function foo() public virtual {        emit Log("A.foo called");    }    function bar() public virtual {        emit Log("A.bar called");    }}contract B is A {    function foo() public virtual override {        emit Log("B.foo called");        A.foo();    }    function bar() public virtual override {        emit Log("B.bar called");        super.bar();    }}contract C is A {    function foo() public virtual override {        emit Log("C.foo called");        A.foo();    }    function bar() public virtual override {        emit Log("C.bar called");        super.bar();    }}contract D is B, C {    // Try:    // - Call D.foo and check the transaction logs.    //   Although D inherits A, B and C, it only called C and then A.    // - Call D.bar and check the transaction logs    //   D called C, then B, and finally A.    //   Although super was called twice (by B and C) it only called A once.    function foo() public override(B, C) {        super.foo();    }    function bar() public override(B, C) {        super.bar();    }}</code></pre><h2 id="å˜é‡å¯è§çº¦æŸ"><a href="#å˜é‡å¯è§çº¦æŸ" class="headerlink" title="å˜é‡å¯è§çº¦æŸ"></a>å˜é‡å¯è§çº¦æŸ</h2><p>å‡½æ•°å’ŒçŠ¶æ€å˜é‡å¿…é¡»å£°æ˜å®ƒä»¬æ˜¯å¦å¯ä»¥è¢«å…¶ä»–åˆçº¦è®¿é—®</p><p>å‡½æ•°å¯ä»¥å£°æ˜ä¸ºï¼š</p><ul><li><p>publicï¼šä»»ä½•åˆçº¦å’Œè´¦æˆ·éƒ½å¯ä»¥è°ƒç”¨</p></li><li><p>privateï¼šåªåœ¨å®šä¹‰å‡½æ•°çš„åˆçº¦å†…éƒ¨</p></li><li><p>internalï¼šä»…ç»§æ‰¿å†…éƒ¨å‡½æ•°çš„å†…éƒ¨åˆçº¦</p></li><li><p>externalï¼šåªæœ‰å…¶ä»–åˆçº¦å’Œè´¦æˆ·å¯ä»¥è°ƒç”¨</p></li></ul><p>çŠ¶æ€å˜é‡å¯ä»¥å£°æ˜ä¸ºå…¬å…±çš„ã€ç§æœ‰çš„æˆ–å†…éƒ¨çš„ï¼Œä½†ä¸èƒ½å£°æ˜ä¸ºå¤–éƒ¨çš„</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Base {    // Private function can only be called    // - inside this contract    // Contracts that inherit this contract cannot call this function.    function privateFunc() private pure returns (string memory) {        return "private function called";    }    function testPrivateFunc() public pure returns (string memory) {        return privateFunc();    }    // Internal function can be called    // - inside this contract    // - inside contracts that inherit this contract    function internalFunc() internal pure returns (string memory) {        return "internal function called";    }    function testInternalFunc() public pure virtual returns (string memory) {        return internalFunc();    }    // Public functions can be called    // - inside this contract    // - inside contracts that inherit this contract    // - by other contracts and accounts    function publicFunc() public pure returns (string memory) {        return "public function called";    }    // External functions can only be called    // - by other contracts and accounts    function externalFunc() external pure returns (string memory) {        return "external function called";    }    // This function will not compile since we're trying to call    // an external function here.    // function testExternalFunc() public pure returns (string memory) {    //     return externalFunc();    // }    // State variables    string private privateVar = "my private variable";    string internal internalVar = "my internal variable";    string public publicVar = "my public variable";    // State variables cannot be external so this code won't compile.    // string external externalVar = "my external variable";}contract Child is Base {    // Inherited contracts do not have access to private functions    // and state variables.    // function testPrivateFunc() public pure returns (string memory) {    //     return privateFunc();    // }    // Internal function call be called inside child contracts.    function testInternalFunc() public pure override returns (string memory) {        return internalFunc();    }}</code></pre><h2 id="æ¥å£"><a href="#æ¥å£" class="headerlink" title="æ¥å£"></a>æ¥å£</h2><p>æ‚¨å¯ä»¥é€šè¿‡å£°æ˜æ¥å£ä¸å…¶ä»–åˆçº¦äº¤äº’</p><p>æ¥å£ï¼š</p><ul><li>ä¸èƒ½å®ç°ä»»ä½•å‡½æ•°</li><li>å¯ä»¥ä»å…¶ä»–æ¥å£ç»§æ‰¿</li><li>æ‰€æœ‰å£°æ˜çš„å‡½æ•°å¿…é¡»æ˜¯å¤–éƒ¨çš„</li><li>ä¸èƒ½å£°æ˜æ„é€ å‡½æ•°</li><li>ä¸èƒ½å£°æ˜çŠ¶æ€å˜é‡</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Counter {    uint public count;    function increment() external {        count += 1;    }}interface ICounter {    function count() external view returns (uint);    function increment() external;}contract MyContract {    function incrementCounter(address _counter) external {        ICounter(_counter).increment();    }    function getCount(address _counter) external view returns (uint) {        return ICounter(_counter).count();    }}// Uniswap exampleinterface UniswapV2Factory {    function getPair(address tokenA, address tokenB)        external        view        returns (address pair);}interface UniswapV2Pair {    function getReserves()        external        view        returns (            uint112 reserve0,            uint112 reserve1,            uint32 blockTimestampLast        );}contract UniswapExample {    address private factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;    address private dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;    address private weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;    function getTokenReserves() external view returns (uint, uint) {        address pair = UniswapV2Factory(factory).getPair(dai, weth);        (uint reserve0, uint reserve1, ) = UniswapV2Pair(pair).getReserves();        return (reserve0, reserve1);    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPFS and Friends: A Qualitative Comparison of Next Generation Peer-to-Peer Data Networks</title>
      <link href="/2022/04/28/distributed_storage/IPFS%20and%20Friends:%20A%20Qualitative%20Comparison%20of%20Next%20Generation%20Peer-to-Peer%20Data%20Networks/"/>
      <url>/2022/04/28/distributed_storage/IPFS%20and%20Friends:%20A%20Qualitative%20Comparison%20of%20Next%20Generation%20Peer-to-Peer%20Data%20Networks/</url>
      
        <content type="html"><![CDATA[<h2 id="æ‘˜è¦"><a href="#æ‘˜è¦" class="headerlink" title="æ‘˜è¦"></a>æ‘˜è¦</h2><p>åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†å¯¹ä¸‹ä¸€ä»£æ•°æ®ç½‘ç»œè¿›è¡ŒæŠ€æœ¯æ¦‚è¿°ã€‚æˆ‘ä»¬ä½¿ç”¨é€‰å®šçš„æ•°æ®ç½‘ç»œæ¥ä»‹ç»ä¸€èˆ¬æ¦‚å¿µå’Œå¼ºè°ƒæ–°çš„å‘å±•ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬æä¾›äº†IPFSçš„æ›´æ·±å±‚æ¬¡çš„æ¦‚è¿°ï¼Œä»¥åŠSwarmã€Hypercore Protocolã€SAFEã€Storjå’ŒArweaveçš„æ€»ä½“æ¦‚è¿°ã€‚æˆ‘ä»¬ç¡®å®šå¸¸è§çš„æ„å»ºæ¨¡å—ï¼Œå¹¶æä¾›å®šæ€§æ¯”è¾ƒã€‚ä»æ¦‚è¿°ä¸­ï¼Œæˆ‘ä»¬å¾—å‡ºäº†æœªæ¥å…³äºæ•°æ®ç½‘ç»œçš„æŒ‘æˆ˜å’Œç ”ç©¶ç›®æ ‡ã€‚</p><h2 id="I-æ¦‚è¿°"><a href="#I-æ¦‚è¿°" class="headerlink" title="I. æ¦‚è¿°"></a>I. æ¦‚è¿°</h2><p>é›†ä¸­å¼æ§åˆ¶å’Œæ²»ç†ä¼šå¯¼è‡´æ•°æ®å­¤å²›ï¼Œè¿™å¯èƒ½ä¼šå½±å“å¯è®¿é—®æ€§ã€å¯ç”¨æ€§å’Œæœºå¯†æ€§ã€‚ä¾‹å¦‚ï¼Œæ•°æ®è®¿é—®å¯èƒ½ä¼šå—åˆ°å®¡æŸ¥ã€‚ä¸æ­¤åŒæ—¶ï¼Œæ•°æ®å­¤å²›ä¸ºæ•°æ®æ³„éœ²å’Œæ•°æ®å‡ºå”®æä¾›äº†ä¸€ä¸ªæœ‰ä»·å€¼çš„ç›®æ ‡ï¼Œè¿™å¯èƒ½ä¼šå±åŠå®‰å…¨å’Œéšç§ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œç”¨æˆ·ä¼šå¤±å»è‡ªå·±çš„æ§åˆ¶æƒï¼Œå¹¶å°†å…¶å§”æ‰˜ç»™äº‘æä¾›å•†ã€‚</p><p>æ‰“ç ´æ•°æ®ç«–äº•å’Œå‡å°‘ä¿¡ä»»å‡è®¾çš„ä¸€ä¸ªæ–¹å‘æ˜¯ç‚¹å¯¹ç‚¹æ•°æ®ç½‘ç»œã€‚è¿™ä¸ªæœ¯è¯­æ¦‚æ‹¬äº†å»ºç«‹åœ¨ç‚¹å¯¹ç‚¹(P2P)ç½‘ç»œä¹‹ä¸Šçš„ä¸€ç³»åˆ—æ•°æ®å­˜å‚¨æ–¹æ³•ï¼ŒåŒ…æ‹¬æ•°æ®å­˜å‚¨ã€å¤åˆ¶ã€åˆ†å‘å’Œäº¤æ¢ç­‰æ–¹é¢ã€‚ä½œä¸ºå…¸å‹çš„P2Pç½‘ç»œï¼Œå¯¹ç­‰ç‚¹å¯ä»¥ç›´æ¥äº¤äº’ï¼Œå»ºç«‹è¦†ç›–ç½‘ç»œï¼Œå…±äº«èµ„æºï¼Œå¹¶å¯ä»¥åšå‡ºè‡ªæ²»çš„æœ¬åœ°å†³ç­–ã€‚å› æ­¤ï¼ŒP2Pæ•°æ®ç½‘ç»œåŠªåŠ›å…±åŒç®¡ç†å’Œå…±äº«å­˜å‚¨ã€‚è™½ç„¶P2Pç½‘ç»œçš„ä¸»è¦ç›®æ ‡å’ŒåŸåˆ™åœ¨è¿‡å»äºŒåå¹´ä¸­æ²¡æœ‰æ”¹å˜ï¼Œä½†P2Pç½‘ç»œéšç€æ—¶é—´çš„æ¨ç§»ä¸æ–­å‘å±•ï¼Œæé«˜äº†å¯ç”¨æ€§å’ŒåŠŸèƒ½ã€‚åœ¨å›¾1ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†ä»ç¬¬ä¸€ä»£åˆ°ä¸‹ä¸€ä»£æ•°æ®ç½‘ç»œçš„å‘å±•ã€‚</p><p><img src="/images/distributed_storage/image-20220428142211126.png" alt="image-20220428142211126"></p><p>å›¾1 ä¸‹ä¸€ä»£P2Pæ•°æ®ç½‘ç»œçš„å…ˆé©±æŠ€æœ¯</p><h3 id="A-ç¬¬ä¸€ä»£æ•°æ®ç½‘ç»œ"><a href="#A-ç¬¬ä¸€ä»£æ•°æ®ç½‘ç»œ" class="headerlink" title="A. ç¬¬ä¸€ä»£æ•°æ®ç½‘ç»œ"></a>A. ç¬¬ä¸€ä»£æ•°æ®ç½‘ç»œ</h3><p>è¿˜æœ‰è®¸å¤šä¸åŒçš„æ—§P2Pç½‘ç»œä¹Ÿå¯ä»¥å½’ç±»ä¸ºæ•°æ®ç½‘ç»œã€‚1999å¹´éšç€éŸ³é¢‘æ–‡ä»¶å…±äº«ç½‘ç»œNapsterçš„å‡ºç°ï¼ŒP2PæŠ€æœ¯å¼€å§‹æµè¡Œèµ·æ¥ï¼Œç´§éšå…¶åçš„æ˜¯Gnutellaï¼Œå®ƒå¯ä»¥å…±äº«æ‰€æœ‰ç±»å‹çš„æ–‡ä»¶ã€‚Napsterå’ŒGnutellaæ ‡å¿—ç€P2Pç½‘ç»œçš„å¼€å§‹ï¼Œéšåå‡ºç°äº†è®¸å¤šä¸“æ³¨äºç‰¹å®šåº”ç”¨é¢†åŸŸæˆ–æ–°é¢–ç½‘ç»œç»“æ„çš„P2Pç½‘ç»œã€‚ä¾‹å¦‚Freenetå®ç°äº†åŒ¿åå­˜å‚¨å’Œæ£€ç´¢ã€‚Chordï¼Œ CANå’ŒPastryæä¾›äº†ç»´æŠ¤ç»“æ„åŒ–è¦†ç›–ç½‘ç»œæ‹“æ‰‘çš„åè®®ã€‚ç‰¹åˆ«æ˜¯BitTorrentå—åˆ°äº†ç”¨æˆ·å’Œç ”ç©¶ç¤¾åŒºçš„å¹¿æ³›å…³æ³¨ã€‚BitTorrentå¼•å…¥äº†æ¿€åŠ±æœºåˆ¶æ¥å®ç°å¸•ç´¯æ‰˜æ•ˆç‡ï¼Œè¯•å›¾æé«˜ç½‘ç»œåˆ©ç”¨ç‡ï¼Œå®ç°æ›´é«˜æ°´å¹³çš„é²æ£’æ€§ã€‚æˆ‘ä»¬è®¤ä¸ºNapsterã€Gnutellaã€Freenetã€BitTorrentç­‰ç½‘ç»œæ˜¯ç¬¬ä¸€ä»£P2Pæ•°æ®ç½‘ç»œï¼Œä¸»è¦å…³æ³¨æ–‡ä»¶å…±äº«ã€‚</p><p>Androutsellis Theotokiså’ŒSpinellisæä¾›äº†P2På†…å®¹åˆ†å‘æŠ€æœ¯çš„2004å¹´å‘å±•æ¦‚å†µâ€”â€”æä¾›äº†å¯¹ä¸Šä¸€ä»£æŠ€æœ¯çš„å¹¿æ³›æ¦‚è¿°ã€‚ä»¥å‰çš„å…¶ä»–å·¥ä½œä¹Ÿæä¾›äº†å¯¹ä¸Šä¸€ä»£çš„æ›´ä»”ç»†çš„ç ”ç©¶ï¼Œæ›´å¯†åˆ‡åœ°å…³æ³¨ç‰¹å®šçš„P2Pæ•°æ®ç½‘ç»œ(ä¾‹å¦‚ï¼ŒFreeNetå’ŒPast)æˆ–ä¸€èˆ¬çš„åˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿ(ä¾‹å¦‚ï¼ŒGoogle FSå’ŒHadoop Distributed FS)ã€‚</p><p>P2PæŠ€æœ¯çš„è¿›æ­¥å’Œç¬¬ä¸€ä»£æ•°æ®ç½‘ç»œçš„æ™®åŠï¼Œå½±å“äº†åˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿå’Œå†…å®¹åˆ†å‘æŠ€æœ¯çš„é¢†åŸŸã€‚è¿™ç§è¶‹åŠ¿ä¹Ÿå±äºä¸€èˆ¬çš„æ•°æ®ç½‘ç»œï¼Œç‰¹åˆ«æ˜¯P2Pæ•°æ®ç½‘ç»œã€‚</p><h3 id="B-Transistioné˜¶æ®µ"><a href="#B-Transistioné˜¶æ®µ" class="headerlink" title="B. Transistioné˜¶æ®µ"></a>B. Transistioné˜¶æ®µ</h3><p>åœ¨P2Pæ–‡ä»¶å…±äº«ç³»ç»Ÿä¸­ä¼¼ä¹ç¼ºå¤±çš„ä¸€ä¸ªç»„ä»¶æ˜¯æ”¹å–„æ–‡ä»¶çš„é•¿æœŸå­˜å‚¨å’Œå¯ç”¨æ€§çš„æ–¹æ³•ã€‚éšç€2008å¹´æ¯”ç‰¹å¸çš„å¼•å…¥ï¼ŒP2Pæ€æƒ³ï¼Œç‰¹åˆ«æ˜¯è”åˆæ•°æ®å¤åˆ¶å¾—åˆ°äº†æ–°çš„å…³æ³¨ã€‚åˆ†å¸ƒå¼åˆ†ç±»è´¦æŠ€æœ¯åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­æä¾›å¯ç”¨æ€§ã€å®Œæ•´æ€§å’Œå¤æ‚çš„å®¹é”™èƒ½åŠ›ã€‚ç‰¹åˆ«æ˜¯ï¼ŒåŠ å¯†è´§å¸æ˜¾ç¤ºäº†å…¶åœ¨å»ä¸­å¿ƒåŒ–ç¯å¢ƒä¸­ä½œä¸ºè´§å¸æ¿€åŠ±æœºåˆ¶çš„æ½œåŠ›ã€‚è¿™äº›ä»¥åŠå…¶ä»–çš„è¶‹åŠ¿å’Œå‘å±•ï¼Œä¾‹å¦‚Kademliaå’Œä¿¡æ¯ä¸­å¿ƒç½‘ç»œï¼Œå¯¼è‡´äº†æˆ‘ä»¬ç§°ä¹‹ä¸ºä¸‹ä¸€ä»£P2Pæ•°æ®ç½‘ç»œçš„å‘æ˜ã€‚</p><h3 id="C-ä¸‹ä¸€ä»£æ•°æ®ç½‘ç»œ"><a href="#C-ä¸‹ä¸€ä»£æ•°æ®ç½‘ç»œ" class="headerlink" title="C.ä¸‹ä¸€ä»£æ•°æ®ç½‘ç»œ"></a>C.ä¸‹ä¸€ä»£æ•°æ®ç½‘ç»œ</h3><p>ä»2014å¹´IPFSçš„å¼•å…¥å¼€å§‹ï¼Œæˆ‘ä»¬å°†ä¸‹ä¸€ä»£æ•°æ®ç½‘ç»œå®šä¹‰ä¸ºåˆ†æ•£å…±äº«å’Œå­˜å‚¨æ•°æ®çš„ç³»ç»Ÿå’Œæ¦‚å¿µï¼Œè¿™æ˜¯åœ¨è¿‡å»åå¹´ä¸­å‡ºç°çš„ã€‚æˆ‘ä»¬æä¾›ä¸‹ä¸€ä»£P2Pæ•°æ®ç½‘ç»œçš„æŠ€æœ¯æ¦‚è¿°ã€‚ä¸ç°æœ‰æ–‡çŒ®ç›¸æ¯”ï¼Œæˆ‘ä»¬æä¾›äº†ä¸‹ä¸€ä»£æ•°æ®ç½‘ç»œï¼Œå³P2Pæ•°æ®ç½‘ç»œçš„æ¯”è¾ƒæ¦‚è¿°ã€‚æˆ‘ä»¬ä¸»è¦å…³æ³¨ç‹¬ç«‹äºåŒºå—é“¾çš„ä½¿ç”¨çš„å­˜å‚¨å’Œå†…å®¹å…±äº«ã€‚<br>åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†å±•ç¤ºè¿™äº›æ–°ç³»ç»Ÿæ˜¯å¦‚ä½•æ„å»ºçš„ï¼Œå®ƒä»¬å¦‚ä½•åˆ©ç”¨ä»ä»¥å‰çš„ç³»ç»Ÿä¸­è·å¾—çš„çŸ¥è¯†ï¼Œä»¥åŠè¿‡å»åå¹´ä¸­æ–°çš„å‘å±•å’Œè¿›æ­¥ã€‚æˆ‘ä»¬ç¡®å®šè¿™äº›ç³»ç»Ÿçš„æ„å»ºæ¨¡å—ã€ç›¸ä¼¼æ€§å’Œè¶‹åŠ¿ã€‚è™½ç„¶æœ‰äº›ç³»ç»Ÿæœ¬èº«æ˜¯å…¶ä»–åº”ç”¨ç¨‹åºçš„æ„å»ºå—ï¼Œä¾‹å¦‚å»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åº(DApps)ï¼Œä½†æˆ‘ä»¬ä¸»è¦å…³æ³¨ç³»ç»Ÿçš„ä¸¤ä¸ªæ–¹é¢:å†…å®¹åˆ†å‘å’Œåˆ†å¸ƒå¼å­˜å‚¨ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜æä¾›äº†æ¿€åŠ±æœºåˆ¶çš„è§è§£ï¼Œç”¨äºæ£€ç´¢æˆ–å­˜å‚¨æ–‡ä»¶ï¼Œæˆ–ä¸¤è€…å…¼è€Œæœ‰ä¹‹ã€‚ç”±äºè®¸å¤šæ–°çš„æ•°æ®ç½‘ç»œè¢«å¼€å‘ï¼Œæˆ‘ä»¬ä¸èƒ½æä¾›æ‰€æœ‰æ•°æ®ç½‘ç»œçš„å…¨é¢æ¦‚è¿°ã€‚ç›¸åï¼Œæˆ‘ä»¬å°†é‡ç‚¹å…³æ³¨å‡ ä¸ªç²¾é€‰çš„ç³»ç»Ÿï¼Œå®ƒä»¬å…·æœ‰å¤æ‚æˆ–ç‹¬ç‰¹çš„æœºåˆ¶ã€ä¸åŒçš„ç”¨ä¾‹ä»¥åŠä¸åŒç¨‹åº¦çš„å†…å®¹å’Œç”¨æˆ·éšç§ã€‚æˆ‘ä»¬çš„æ¦‚è¿°ä¾§é‡äºæ¦‚å¿µå’Œå®ç°ç»†èŠ‚çš„æŠ½è±¡ï¼Œä»¥æå–ä¸€èˆ¬çš„è§è§£ã€‚ç„¶è€Œï¼Œåº”è¯¥æŒ‡å‡ºçš„æ˜¯ï¼Œç”±äºæ­£åœ¨è¿›è¡Œçš„å¼€å‘ï¼Œç³»ç»Ÿå¾ˆå®¹æ˜“å‘ç”Ÿå˜åŒ–ã€‚æˆ‘ä»¬çš„è°ƒæŸ¥è®ºæ–‡ä½¿ç”¨äº†å¹¿æ³›çš„æ¥æºï¼ŒåŒ…æ‹¬åŒè¡Œè¯„è®®çš„è®ºæ–‡ã€ç™½çš®ä¹¦ä»¥åŠæ–‡æ¡£ã€è§„èŒƒå’Œæºä»£ç ã€‚<br>å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬å…³æ³¨IPFSã€Swarmã€Hypercore Protocolã€SAFEã€Storjå’ŒArweaveã€‚ç‰¹åˆ«æ˜¯IPFS(InterPlanetary File System, IPFS)ä½œä¸ºåŒºå—é“¾çš„å­˜å‚¨å±‚å·²ç»å¾—åˆ°äº†å¹¿æ³›çš„åº”ç”¨ï¼Œå¹¶æˆä¸ºäº†ä¸€ç³»åˆ—ç ”ç©¶çš„å¯¹è±¡ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å°†è¿™äº›ç³»ç»Ÿçš„æ¦‚è¿°æ”¾åœ¨å‰é¢çš„ç³»ç»Ÿå’Œç ”ç©¶æ–¹å‘ï¼Œå³BitTorrentã€ä¿¡æ¯ä¸­å¿ƒç½‘ç»œå’ŒåŒºå—é“¾ã€‚é€šè¿‡å¯¹æ¯”å…ˆé©±ç³»ç»Ÿï¼Œæˆ‘ä»¬æ¦‚è¿°äº†æ•°æ®ç½‘ç»œçš„æ¼”å˜ï¼Œå¹¶èƒ½å¤Ÿæ·±å…¥è®¨è®ºä¸‹ä¸€ä»£çš„è¿›å±•ã€‚<br>åœ¨æ­¤åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬æå–äº†P2Pæ•°æ®ç½‘ç»œçš„æ„å»ºå—å’Œä¸€äº›ç‹¬ç‰¹çš„æ–¹é¢ã€‚è™½ç„¶æ‰€æœ‰çš„ç³»ç»Ÿéƒ½å…è®¸åˆ†å¸ƒå¼å†…å®¹å…±äº«å’Œå­˜å‚¨ï¼Œä½†å®ƒä»¬ä¼¼ä¹åªå…³æ³¨å…¶ä¸­çš„ä¸€ä¸ªæ–¹é¢ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯ä¸ªç³»ç»Ÿçš„ç›®æ ‡éƒ½æ˜¯æœåŠ¡äºå…·æœ‰ä¸åŒéœ€æ±‚å’Œå…³æ³¨ç‚¹çš„ç•¥æœ‰ä¸åŒçš„ç›®çš„ã€‚è¿™å¯¼è‡´äº†åœ¨ç½‘ç»œç»„ç»‡ã€æ–‡ä»¶æŸ¥æ‰¾ã€åˆ†æ•£ç¨‹åº¦ã€å†—ä½™å’Œéšç§æ–¹é¢çš„ä¸åŒè®¾è®¡å†³ç­–ã€‚ä¾‹å¦‚ï¼ŒStorjçš„ç›®æ ‡æ˜¯åˆ†å¸ƒå¼äº‘å­˜å‚¨ï¼Œè€ŒHypercoreåè®®åˆ™ä¸“æ³¨äºåˆ†å¸ƒå¼å¤§å‹æ•°æ®é›†ã€‚åŒæ ·ï¼ŒIPFSçš„ç›®æ ‡æ˜¯å–ä»£webçš„å®¢æˆ·ç«¯-æœåŠ¡å™¨ç»“æ„ï¼Œå› æ­¤éœ€è¦æ¯”BitTorrentæ›´å…³æ³¨æ•°æ®æŸ¥æ‰¾ï¼Œå› ä¸ºBitTorrentä¸»è¦æ˜¯æ¯ä¸ªæ–‡ä»¶éƒ½ä½äºè‡ªå·±çš„è¦†ç›–ç½‘ç»œä¸­ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬åœ¨æ„å»ºæ•°æ®ç½‘ç»œçš„æ–¹æ³•ä¸Šå‘ç°äº†è®¸å¤šç›¸ä¼¼ä¹‹å¤„ï¼Œä¾‹å¦‚ï¼Œä½¿ç”¨Kademliaæ¥æ„å»ºç½‘ç»œæˆ–å¯»æ‰¾å¯¹ç­‰ç‚¹ï¼Œå°†æ–‡ä»¶åˆ†å‰²æˆå—ï¼Œæˆ–æ¿€åŠ±ä¸åŒçš„ä»»åŠ¡æ¥å¢åŠ åŠŸèƒ½ã€‚<br>å…¶ä»–å…³äºä¸‹ä¸€ä»£æ•°æ®ç½‘ç»œçš„ç ”ç©¶å°¤å…¶å…³æ³¨ä¸åŒºå—é“¾çš„äº¤äº’ã€‚Huangç­‰äººä¸»è¦æ¶µç›–äº†IPFSå’ŒSwarm, Benisiç­‰äººè®¨è®ºäº†è¿™äº›æŠ€æœ¯ï¼Œæ›´ä¾§é‡äºåŒºå—é“¾æ–¹é¢ã€‚Casinoç­‰äººä»”ç»†ç ”ç©¶äº†å»ä¸­å¿ƒåŒ–å­˜å‚¨çš„ä¸å˜æ€§åŠå…¶åæœå’Œå¯èƒ½çš„å¨èƒã€‚ç„¶è€Œï¼Œç”±äºå¯ä¼¸ç¼©æ€§æˆ–å»¶è¿Ÿé—®é¢˜ï¼Œä¸€äº›æ•°æ®ç½‘ç»œæ˜ç¡®å†³å®šä¸ä½¿ç”¨åŒºå—é“¾ã€‚å› æ­¤ï¼Œåœ¨æˆ‘ä»¬çš„è°ƒæŸ¥è®ºæ–‡ä¸­ï¼Œæˆ‘ä»¬å¯¹æ•°æ®ç½‘ç»œé‡‡å–äº†æ›´å¹¿æ³›çš„è§†è§’ï¼Œç€çœ¼äºåŒºå—é“¾ä»¥å¤–çš„æ•°æ®ç½‘ç»œçš„è®¾è®¡å†³ç­–ã€‚<br>Naikå’ŒKeshavamurthyå¯¹æœ€è¿‘çš„P2Pç½‘ç»œç»™å‡ºäº†ä¸€ä¸ªæ›´æ™®éçš„è§‚ç‚¹ã€‚ä»–ä»¬æè¿°äº†ä¸‹ä¸€ä¸ªå±‚æ¬¡çš„P2Pç½‘ç»œï¼ŒåƒBitTorrentå’ŒChordè¿™æ ·çš„ç»å…¸ç½‘ç»œçš„æ¼”å˜ï¼Œå¹¶è®¨è®ºäº†åŠ¨è¡ä¸‹çš„æ€§èƒ½æ–¹é¢ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä»–ä»¬å¯¹ä¸‹ä¸€çº§ç½‘ç»œçš„å®šä¹‰ä¸æˆ‘ä»¬çš„ä¸‹ä¸€ä»£ç½‘ç»œçš„å®šä¹‰ä¸åŒï¼Œå› ä¸ºä»–ä»¬å°†IPFSå®šä¹‰ä¸ºâ€œç»å…¸çš„P2Pç½‘ç»œâ€ã€‚ç›¸åï¼Œæˆ‘ä»¬è®¤ä¸ºï¼ŒP2Pæ•°æ®ç½‘ç»œæ˜¯éšç€æ—¶é—´çš„æ¨ç§»è€Œæ¼”å˜çš„ï¼Œèåˆäº†æ–°å»ºç«‹çš„é¢†åŸŸçš„æƒ³æ³•ï¼Œä¾‹å¦‚ï¼Œæ˜ç¡®çš„æ¿€åŠ±æœºåˆ¶ã€‚</p><h2 id="II-æŠ€æœ¯ä»‹ç»"><a href="#II-æŠ€æœ¯ä»‹ç»" class="headerlink" title="II. æŠ€æœ¯ä»‹ç»"></a>II. æŠ€æœ¯ä»‹ç»</h2><p>è‡ªP2Pæ•°æ®ç½‘ç»œé¦–æ¬¡å‡ºç°ä»¥æ¥ï¼Œå·²ç»è¿‡å»äº†20å¤šå¹´ã€‚åœ¨æ­¤æœŸé—´ï¼Œè¿™é¡¹æŠ€æœ¯ä¸æ–­å‘å±•ï¼Œå¹¶å½±å“äº†æ–°ç½‘ç»œçš„å‘å±•ã€‚æˆ‘ä»¬è§‚å¯Ÿåˆ°ï¼ŒåŸºæœ¬ä¸Šæœ‰ä¸‰ä¸ªâ€œæ—¶ä»£â€çš„P2Pæ•°æ®ç½‘ç»œ:å®ƒå¼€å§‹äº1999-2002å¹´çš„P2Pæ–‡ä»¶å…±äº«å’Œç½‘ç»œï¼Œå¦‚BitTorrentå’ŒKademliaï¼Œæˆ‘ä»¬è®¤ä¸ºè¿™æ˜¯ç¬¬ä¸€ä»£ã€‚è¿™ä¸ªæ—¶ä»£ä¹‹åæ˜¯ä¸€ä¸ªâ€œè¿‡æ¸¡é˜¶æ®µâ€ï¼Œä»¥ä¿¡æ¯ä¸ºä¸­å¿ƒçš„ç½‘ç»œå’ŒåŠ å¯†è´§å¸ç­‰æ–°æƒ³æ³•å‡ºç°äº†ã€‚å¤§çº¦è‡ª2014å¹´IPFSçš„å‘æ˜ä»¥æ¥ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†æ–°ä¸€ä»£P2Pæ•°æ®ç½‘ç»œçš„å‘å±•ã€‚ä¸ºäº†æ›´å¥½åœ°ç†è§£å’Œæ¬£èµè¿™äº›å½±å“ï¼Œæˆ‘ä»¬ä»‹ç»äº†å¥ å®šåŸºç¡€çš„é‡è¦â€œå…ˆé©±â€æŠ€æœ¯ï¼Œå³BitTorrentã€Kademliaã€Information-Centric Networkingã€Self-Certifying Nameså’ŒåŒºå—é“¾ã€‚</p><h3 id="A-BitTorrent"><a href="#A-BitTorrent" class="headerlink" title="A. BitTorrent"></a>A. BitTorrent</h3><p>BitTorrentåè®®[6]æ˜¯ä¸€ç§P2Pæ–‡ä»¶å…±äº«åè®®ã€‚å®ƒæœ‰ä¸€ä¸ªæ¿€åŠ±ç»“æ„æ¥æ§åˆ¶ä¸‹è½½è¡Œä¸ºï¼Œè¯•å›¾å®ç°èµ„æºçš„å…¬å¹³æ¶ˆè€—ã€‚BitTorrentçš„ç›®æ ‡æ˜¯æä¾›ä¸€ç§æ¯”ä½¿ç”¨å•ä¸€æœåŠ¡å™¨æ›´æœ‰æ•ˆçš„æ–¹å¼æ¥åˆ†å‘æ–‡ä»¶ã€‚è¿™æ˜¯é€šè¿‡åœ¨æ¯æ¬¡ä¸‹è½½æ—¶å¤åˆ¶æ–‡ä»¶è¿™ä¸€äº‹å®å®ç°çš„ï¼Œä»è€Œä½¿æ–‡ä»¶åˆ†å‘å…·æœ‰è‡ªä¼¸ç¼©æ€§(self-scalable)ã€‚<br>æ–‡ä»¶ä»¥ç§å­å½¢å¼äº¤æ¢ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæ¯ä¸ªç§å­æ˜¯ä¸€ä¸ªP2Pè¦†ç›–ç½‘ç»œè´Ÿè´£ä¸€ä¸ªæ–‡ä»¶ã€‚ä¸ºäº†ç”¨BitTorrentåè®®äº¤æ¢æ–‡ä»¶ï¼Œéœ€è¦åˆ›å»ºä¸€ä¸ª.torrentç±»å‹çš„æ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«æ–‡ä»¶çš„å…ƒæ•°æ®å’Œä¸€ä¸ªè·Ÿè¸ªå™¨(tracker)ã€‚ä¹Ÿå¯ä»¥åœ¨ä¸€ä¸ª.torrentæ–‡ä»¶ä¸­å®šä¹‰å¤šä¸ªæ–‡ä»¶ã€‚ç§å­æ–‡ä»¶éœ€è¦è¢«æä¾›ï¼Œä¾‹å¦‚ï¼Œåœ¨ç½‘ç»œæœåŠ¡å™¨ä¸Šï¼Œæ–‡ä»¶å¯ä»¥è¢«å…±äº«ã€‚è·Ÿè¸ªå™¨ä½œä¸ºç§å­çš„å¼•å¯¼èŠ‚ç‚¹ã€‚å…·æœ‰å®Œæ•´æ–‡ä»¶çš„å¯¹ç­‰ç‚¹ç§°ä¸ºç§å­ç‚¹ã€‚ä»ç„¶æ²¡æœ‰å‘½ä¸­æ•°æ®å—çš„èŠ‚ç‚¹è¢«ç§°ä¸ºleechersã€‚leecherè¯·æ±‚æ•°æ®å—ï¼Œå¹¶åŒæ—¶ä½œä¸ºå·²ç»ä¸‹è½½çš„å—çš„ä¸‹è½½ç‚¹ã€‚<br>BitTorrentå¦‚ä½•å¤„ç†æ–‡ä»¶çš„æ¦‚å¿µæ¦‚è¿°è§å›¾2ã€‚è§’è‰²å’Œä»–ä»¬çš„äº¤äº’å¦‚ä¸‹:ä¸€ä¸ªå¯¹ç­‰ä½“è·å¾—.torrentæ–‡ä»¶ï¼Œè”ç³».torrentæ–‡ä»¶ä¸­åˆ—å‡ºçš„tracker ğ‘‡ï¼Œè·å¾—ä¸€ä¸ªå¯¹ç­‰ä½“åˆ—è¡¨ï¼Œè¿æ¥åˆ°å¯¹ç­‰ä½“ï¼Œæˆä¸ºä¸€ä¸ªleecherã€‚åœ¨å›¾ä¸­ï¼Œå¯¹ç­‰ä½“ğ‘†0ä½œä¸ºæ–‡ä»¶çš„ç§å­ï¼Œè€Œå¯¹ç­‰ä½“ğ¿ğ‘–ä»£è¡¨è¯·æ±‚ä¸åŒå—çš„leecherã€‚å¦‚.torrentæ–‡ä»¶æ‰€ç¤ºï¼Œè¯¥æ–‡ä»¶è¢«åˆ†å‰²ä¸ºğ‘ğ‘—å—ã€‚å½“leecheræˆåŠŸåœ°è·å¾—äº†æ‰€æœ‰çš„å—åï¼Œå®ƒå°±å˜æˆäº†ä¸€é¢—æ–°çš„ç§å­ã€‚Seedğ‘†0å’Œleechersä¸ºæ–‡ä»¶å»ºç«‹äº†torrentç½‘ç»œã€‚å…¶ä»–æ–‡ä»¶åˆ†å¸ƒåœ¨ä¸åŒçš„ç§å­ç½‘ç»œä¸å¯èƒ½ä¸åŒçš„å¯¹ç­‰ã€‚</p><p><img src="/images/distributed_storage/image-20220428145010491.png" alt="image-20220428145010491">é™¤äº†é›†ä¸­å‘ˆç°çš„è·Ÿè¸ªå™¨ï¼Œè¿˜æœ‰æ— è·Ÿè¸ªçš„ç§å­(trackerless torrents)ã€‚åœ¨æ— è·Ÿè¸ªtorrentä¸­ï¼Œç§å­æ˜¯é€šè¿‡ä¸€ä¸ªåˆ†å¸ƒå¼å“ˆå¸Œè¡¨(DHT)æ‰¾åˆ°çš„ã€‚å®¢æˆ·ç«¯ä»torrentæ–‡ä»¶ä¸­è·å–å¯†é’¥ï¼ŒDHTè¿”å›å¯ç”¨çš„torrentå¯¹ç­‰ç‚¹åˆ—è¡¨ã€‚BitTorrentå®¢æˆ·ç«¯å¯ä»¥ä½¿ç”¨é¢„å…ˆç¡®å®šçš„èŠ‚ç‚¹æˆ–ç”±torrentæ–‡ä»¶æä¾›çš„èŠ‚ç‚¹æ¥å¼•å¯¼DHTã€‚<br>ä½¿BitTorrentç‹¬ä¸€æ— äºŒ(å¯èƒ½æ˜¯æˆåŠŸçš„)çš„ç‰¹æ€§æ˜¯æ˜ç¡®æ¿€åŠ±å¯¹ç­‰ç‚¹äº¤æ¢æ•°æ®ï¼Œè¿™æ˜¯åœ¨æ–‡ä»¶å…±äº«ç­–ç•¥ä¸­æœ€ç¨€æœ‰çš„éƒ¨åˆ†é¦–å…ˆå’Œtit-for-tatå®ç°çš„ã€‚æœ€ç¨€æœ‰çš„éƒ¨åˆ†é¦–å…ˆæè¿°äº†BitTorrentçš„åŒºå—é€‰æ‹©ã€‚å®ƒç¡®ä¿äº†å—é‡å çš„æœ€å°åŒ–ï¼Œä½¿æ–‡ä»¶äº¤æ¢å¯¹äºèŠ‚ç‚¹å˜åŠ¨æ›´åŠ å¥å£®ã€‚æœ€å¥½é€‰æ‹©ç½‘ç»œä¸­æœ€ä¸å¸¸è§çš„å—è¿›è¡Œä¸‹è½½ã€‚é’ˆé”‹ç›¸å¯¹æè¿°äº†å¸¦å®½èµ„æºåˆ†é…æœºåˆ¶ã€‚åœ¨BitTorrentå¯¹ç­‰ç‚¹å†³å®šè°ä»–ä»¬ä¸Šä¼ æ•°æ®åŸºäºä¸‹è½½çš„æ•°æ®ä»å¯¹ç­‰ç‚¹ã€‚è¿™åº”è¯¥é˜²æ­¢leecheråªä¸‹è½½è€Œä¸æä¾›ä»»ä½•èµ„æºç»™åˆ«äººã€‚<br>BitTorrentå¾—åˆ°äº†å¾ˆå¥½çš„ç ”ç©¶ï¼Œå¹¶è¯æ˜äº†å®ƒçš„æ—¶é—´è€ƒéªŒã€‚å°½ç®¡å®ƒå·²ç»å¾ˆè€äº†ï¼Œä½†ä»æœ‰æ•°ç™¾ä¸‡äººåœ¨ç§¯æåœ°ä½¿ç”¨[45]æ¥å…±äº«æ–‡ä»¶ï¼Œå¹¶ä¸ºè¾ƒæ–°çš„ç‚¹å¯¹ç‚¹æ–‡ä»¶åˆ†å‘ç³»ç»Ÿæä¾›äº†ä¸€ä¸ªæ¦œæ ·ã€‚æ­¤å¤–ï¼ŒBitTorrentåŸºé‡‘ä¼šå’ŒTronåŸºé‡‘ä¼šå¼€å‘äº†BitTorrent Token (BTT)ï¼Œä½œä¸ºåŸºäºåŒºå—é“¾çš„æ¿€åŠ±å±‚ï¼Œä»¥å¢åŠ æ–‡ä»¶çš„å¯ç”¨æ€§å’ŒæŒä¹…æ€§ã€‚æ–°çš„æ¿€åŠ±ç»“æ„é€šè¿‡æ”¶è´­æ•°æ®æ‰©å¤§äº†é’ˆé”‹ç›¸å¯¹çš„ç«äº‰ã€‚æŠ¥ä»·æ•°æ®(bid data)å†³å®šäº†å¯¹ç­‰ç«¯ä¸ºæŒç»­æœåŠ¡æ»¡è¶³çš„BTT/byteé€Ÿç‡ã€‚ä½œä¸ºæ”¯ä»˜çš„äº¤æ¢ï¼Œå¯¹ç«¯è¢«è§£é™¤é˜»å¡å¹¶æœ‰èµ„æ ¼æ¥æ”¶æ•°æ®ã€‚ä»¤ç‰Œçš„äº¤æ¢ç”±æ”¯ä»˜é€šé“å¤„ç†ã€‚</p><h3 id="B-Kademlia"><a href="#B-Kademlia" class="headerlink" title="B. Kademlia"></a>B. Kademlia</h3><p>ä»ä»Šå¤©çš„è§’åº¦æ¥çœ‹ï¼ŒKademliaå¯èƒ½æ˜¯ä½¿ç”¨æœ€å¹¿æ³›çš„DHTã€‚æ­£å¦‚æˆ‘ä»¬ç¨åå°†çœ‹åˆ°çš„ï¼Œå¤§å¤šæ•°P2Pæ•°æ®ç½‘ç»œéƒ½ä»¥æŸç§æ–¹å¼æ„å»ºåœ¨Kademliaä¹‹ä¸Šã€‚Kademliaè¿˜å½±å“äº†P2Pæ–‡ä»¶äº¤æ¢åè®®ï¼Œå¦‚BitTorrentï¼Œå®ƒé€šè¿‡ä½¿ç”¨åŸºäºKademliaçš„DHTæ”¯æŒæ— è·Ÿè¸ªçš„torrentã€‚<br>ä¸€èˆ¬æ¥è¯´ï¼ŒKademliaå¯ä»¥è¢«å½’ç±»ä¸ºç»“æ„åŒ–çš„è¦†ç›–ç½‘ç»œï¼Œå®ƒè§„å®šäº†å¦‚ä½•æ„é€ å’Œç»´æŠ¤P2Pç½‘ç»œã€‚ä¸ºæ­¤ï¼Œå¯¹ç­‰ä½“è¢«åˆ†é…ä¸€ä¸ªèº«ä»½ï¼Œè¿™ä¸ªèº«ä»½å†³å®šäº†å®ƒçš„ä½ç½®ï¼Œè¿›è€Œå†³å®šäº†å®ƒçš„é‚»å±…ã€‚å¯¹äºé‚»å±…é€‰æ‹©ï¼Œä½¿ç”¨å¼‚æˆ–åº¦é‡ã€‚å¼‚æˆ–åº¦è§„çš„ä¼˜ç‚¹æ˜¯å®ƒæ˜¯å¯¹ç§°çš„å’Œå•å‘çš„ã€‚æ ¹æ®å®ƒä»¬çš„XORè·ç¦»ï¼ŒèŠ‚ç‚¹è¢«åˆ†ç±»ä¸ºğ‘˜-bucketsã€‚bucketè¢«æ’åˆ—æˆäºŒå‰æ ‘ï¼Œå…¶ä¸­æœ€çŸ­çš„å‰ç¼€å†³å®šäº†bucketã€‚å¦‚æœä¸€ä¸ªæ–°èŠ‚ç‚¹å±äºä¸€ä¸ªåŒ…å«ğ‘˜ä¸ªèŠ‚ç‚¹(åŒ…æ‹¬å®ƒè‡ªå·±)çš„æ¡¶ï¼Œé‚£ä¹ˆè¿™ä¸ªæ¡¶å°†è¢«åˆ†æˆæ›´å°çš„æ¡¶ï¼Œå¦åˆ™è¿™ä¸ªæ–°èŠ‚ç‚¹å°†è¢«ä¸¢å¼ƒã€‚å…·æœ‰8ä½æ ‡è¯†ç¬¦çš„ç¤ºä¾‹æ€§Kademliaæ ‘å¦‚å›¾3æ‰€ç¤ºã€‚</p><p><img src="/images/distributed_storage/image-20220428145024512.png" alt="image-20220428145024512"></p><h3 id="C-Information-Centric-Networking"><a href="#C-Information-Centric-Networking" class="headerlink" title="C. Information-Centric Networking"></a>C. Information-Centric Networking</h3><p>å¦ä¸€ä¸ªå€¼å¾—ä¸€æçš„å‰èº«æ˜¯ä¿¡æ¯ä¸­å¿ƒç½‘ç»œ(ICN)ã€‚å°½ç®¡ICNä¸æ˜¯ä¸€ä¸ªP2Pæ•°æ®ç½‘ç»œï¼Œä½†å®ƒçš„ä¸€äº›æƒ³æ³•å’Œæ¦‚å¿µè‡³å°‘ä¸æŸäº›æ•°æ®ç½‘ç»œç›¸ä¼¼ã€‚ä¸P2Pæ•°æ®ç½‘ç»œä¸åŒï¼ŒICNæå‡ºæ”¹å˜ç½‘ç»œå±‚ã€‚åŒ…çš„è·¯ç”±å’Œæµåº”è¯¥ä»ç‚¹å¯¹ç‚¹ä½ç½®æœç´¢æ›´æ”¹ä¸ºç›´æ¥ä»ç½‘ç»œè¯·æ±‚å†…å®¹ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œè®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬æƒ³è¦æ£€ç´¢ä¸€äº›æ•°æ®ï¼Œä¾‹å¦‚ï¼Œä¸€ä¸ªç½‘ç«™ï¼Œå¹¶ä¸”æˆ‘ä»¬çŸ¥é“è¿™ä¸ªç½‘ç«™åœ¨example.comæ˜¯å¯ç”¨çš„ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬é€šè¿‡DNSè¯·æ±‚ç«™ç‚¹ä¸»æœºçš„ä½ç½®ï¼Œå³IPåœ°å€ã€‚ç„¶åï¼Œæˆ‘ä»¬å»ºç«‹ä¸€ä¸ªè¿æ¥æ¥æ£€ç´¢ç½‘ç«™ã€‚åœ¨ICNä¸­ï¼Œæˆ‘ä»¬å°†ç›´æ¥è¯·æ±‚æ•°æ®ï¼Œè€Œä¸ä¼šå¯»å€æ•°æ®æ‰€åœ¨çš„ä¸»æœºã€‚ä»»ä½•å­˜å‚¨ç½‘ç«™çš„èŠ‚ç‚¹éƒ½å¯ä»¥ç«‹å³æä¾›æ•°æ®ã€‚<br>Jacobsonç­‰äººæå‡ºäº†ä»¥å†…å®¹ä¸ºä¸­å¿ƒçš„ç½‘ç»œï¼Œå…¶ä¸­è¿™äº›å†…å®¹è¯·æ±‚æ˜¯interest packetã€‚å†…å®¹çš„æ‰€æœ‰è€…å¯ä»¥ç›´æ¥ç”¨åŒ…å«è¯¥å†…å®¹çš„æ•°æ®åŒ…å›ç­”æ„Ÿå…´è¶£çš„æ•°æ®åŒ…ã€‚è¿™å°±éœ€è¦åœ¨åŸºç¡€è®¾æ–½çº§åˆ«ä¸Šå®ç°æµé‡æ§åˆ¶ã€è·¯ç”±å’Œå®‰å…¨çš„å…¶ä»–æœºåˆ¶ã€‚å¯¹interest packetè¿›è¡Œå¹¿æ’­ï¼Œå¯¹æ•°æ®æ„Ÿå…´è¶£çš„å¯¹ç­‰ä½“å¯ä»¥å…±äº«èµ„æºã€‚ç›®å‰æœ‰å¤šä¸ªå¤„ç†ICNçš„é¡¹ç›®ï¼Œä¾‹å¦‚å‘½åæ•°æ®ç½‘ç»œ(NDN)ã€‚å¯¹äºNtorrentï¼ŒMastorakisç­‰äººæå‡ºäº†ä¸€ä¸ªNDNçš„æ‰©å±•ï¼Œåœ¨NDNä¸­å®ç°äº†ä¸€ä¸ªç±»ä¼¼bittorrentçš„æœºåˆ¶ã€‚å…³äºICNçš„æ›´å¤šä¸€èˆ¬ä¿¡æ¯å¯åœ¨ä¸­æ‰¾åˆ°ã€‚ç”±äºæ•°æ®ç½‘ç»œä»¥å†…å®¹ä¸ºä¸­å¿ƒçš„æ€§è´¨ï¼Œå®ƒä»¬å¯ä»¥è¢«å¹¿æ³›åœ°è§£é‡Šä¸ºICNçš„è¦†ç›–å®ç°ã€‚</p><h3 id="D-Self-Certifying-Names"><a href="#D-Self-Certifying-Names" class="headerlink" title="D .Self-Certifying Names"></a>D .Self-Certifying Names</h3><p>ä»ä»¥ä¸»æœºä¸ºä¸­å¿ƒçš„é€šä¿¡åˆ°ä»¥å†…å®¹ä¸ºä¸­å¿ƒçš„é€šä¿¡çš„å˜åŒ–å¼•å…¥äº†æ–°çš„å®‰å…¨é—®é¢˜ã€‚æ­¤å¤–ï¼Œå½“ç¼“å­˜æˆä¸ºç½‘ç»œçš„ä¸»è¦ç‰¹å¾æ—¶ï¼Œéœ€è¦è€ƒè™‘ç‰¹å®šçš„å¨èƒï¼Œä¾‹å¦‚ç¼“å­˜ä¸­æ¯’æˆ–é’ˆå¯¹ç¼“å­˜çš„æ‹’ç»æœåŠ¡æ”»å‡»ã€‚æ›´å¹¿æ³›åœ°è¯´ï¼ŒICNçš„å®‰å…¨é—®é¢˜ä¸€èˆ¬åŒ…æ‹¬å†…å®¹è®¤è¯ã€æˆæƒå’Œè®¿é—®æ§åˆ¶ä»¥åŠéšç§ã€‚<br>ç›®å‰ï¼Œå®‰å…¨ç ”ç©¶çš„ä¸»è¦ç„¦ç‚¹åœ¨äºè®¤è¯ã€‚ç”±äºç¼“å­˜çš„å¹¿æ³›ä½¿ç”¨ï¼Œæ•°æ®æä¾›è€…ä¸å†ä¸€å®šæ˜¯å¯¹è±¡çš„åŸå§‹æº(æ•°æ®æ‰€æœ‰è€…)ã€‚è¿™éœ€è¦ä½¿æ¥æ”¶è€…èƒ½å¤Ÿè¯„ä¼°å¯¹è±¡çš„æœ‰æ•ˆæ€§(å®Œæ•´æ€§)ã€æ¥æº(å†…å®¹æ¥æº)å’Œç›¸å…³æ€§çš„æœºåˆ¶ã€‚<br>ç¡®ä¿æœ‰æ•ˆæ€§å’Œç›¸å…³æ€§çš„ä¸€ç§æ–¹æ³•æ˜¯è‡ªæˆ‘è®¤è¯åç§°ã€‚å¯ä»¥ä½¿ç”¨æ•£åˆ—æŒ‡é’ˆ(æˆ–æ›´é€šç”¨çš„å†…å®¹æ•£åˆ—)æ¥å¼•ç”¨å†…å®¹ï¼Œä»è€Œå¯ç”¨è‡ªè®¤è¯åç§°ã€‚æ–‡ä»¶çš„å†…å®¹è¢«ç”¨ä½œåŠ å¯†å“ˆå¸Œå‡½æ•°çš„è¾“å…¥ï¼Œä¾‹å¦‚SHA-3ã€‚å¾—åˆ°çš„æ‘˜è¦å¯ä»¥ç”¨æ¥è¯†åˆ«å†…å®¹ï¼Œå®¢æˆ·æœºå¯ä»¥åœ¨æœ¬åœ°éªŒè¯æ–‡ä»¶çš„å®Œæ•´æ€§ã€‚å“ˆå¸Œå‡½æ•°çš„åŠ å¯†ç‰¹æ€§ï¼Œæœ€é‡è¦çš„æ˜¯é¢„å›¾åƒå’ŒæŠ—ç¢°æ’ï¼Œç¡®ä¿æ²¡æœ‰äººå¯ä»¥åœ¨ä¸æ”¹å˜æ‘˜è¦çš„æƒ…å†µä¸‹æ›¿æ¢æˆ–ä¿®æ”¹è¾“å…¥æ•°æ®ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œåç§°æä¾›äº†å®Œæ•´æ€§å’Œç›¸å…³æ€§ï¼Œä½†æ˜¯ï¼Œè°è´Ÿè´£éªŒè¯å¯¹è±¡ï¼Œä¾‹å¦‚ï¼Œå®¢æˆ·ç«¯å’Œ/æˆ–ä¸­é—´ç«¯ï¼Œä»ç„¶æ˜¯å€¼å¾—æ€€ç–‘çš„ã€‚æ­¤å¤–ï¼Œè‡ªæˆ‘è¯æ˜çš„åç§°æœ¬èº«ä¸èƒ½æä¾›å‡ºå¤„æˆ–è¯æ˜ç‰©ä½“çš„æ¥æºã€‚åŠ å¯†ç­¾åå¯ä»¥ä¿è¯å¯¹è±¡æ¥æºçš„çœŸå®æ€§ï¼Œä½†éœ€è¦å…¬é’¥åŸºç¡€è®¾æ–½æˆ–ä¿¡ä»»ç½‘ç»œæ¥éªŒè¯ç­¾åã€‚è™½ç„¶è¿™å…è®¸éªŒè¯å¯¹è±¡æ¥æºçš„çœŸå®æ€§ï¼Œä½†ä»ç„¶å¯èƒ½å‘é€æ ¼å¼ä¸æ­£ç¡®çš„å¯¹è±¡ï¼Œå› æ­¤éœ€è¦ç¡®ä¿å®Œæ•´æ€§çš„æœºåˆ¶ã€‚é€šè¿‡ç¼“å­˜çš„å†…å®¹çš„å¯¿å‘½éœ€è¦è°¨æ…çš„å¯†é’¥ç®¡ç†ï¼Œä»¥é˜²æ­¢åŠ å¯†å‡­æ®è¢«ç ´åã€‚<br>è®¿é—®æ§åˆ¶ä¹Ÿæœ‰ç±»ä¼¼çš„é—®é¢˜:ä¸€æ—¦æ•°æ®å‘å¸ƒï¼Œå°±å¾ˆéš¾é™åˆ¶è®¿é—®æˆ–æ’¤é”€å‘å¸ƒã€‚åŠ å¯†å¯èƒ½ä¼šé™åˆ¶è®¿é—®ï¼Œä½†å¯èƒ½éœ€è¦å¸¦å¤–å¯†é’¥åˆ†å‘ã€‚å…³äºICNçš„å®‰å…¨ã€éšç§ã€è®¿é—®æ§åˆ¶å’Œå…¶ä»–æŒ‘æˆ˜çš„è¿›ä¸€æ­¥è§è§£è§[53,54]ã€‚</p><h3 id="E-åŒºå—é“¾"><a href="#E-åŒºå—é“¾" class="headerlink" title="E. åŒºå—é“¾"></a>E. åŒºå—é“¾</h3><p>2008å¹´æ¯”ç‰¹å¸çš„å¼•å…¥ä¸ºåˆ†å¸ƒå¼åº”ç”¨æä¾›äº†æ–°çš„å¯èƒ½æ€§ã€‚æ¯”ç‰¹å¸æ˜¯ä¸€ç§å·§å¦™è€Œå¤æ‚çš„ç»„åˆï¼Œå®ƒç»“åˆäº†æ¥è‡ªé“¾æ¥æ—¶é—´é¢†åŸŸçš„å„ç§æƒ³æ³•â€”â€”åŠ å¯†ã€æ•°å­—ç°é‡‘ã€P2Pç½‘ç»œã€æ‹œå åº­å®¹é”™å’Œå¯†ç å­¦ã€‚æ¯”ç‰¹å¸å¸¦æ¥çš„å…³é”®åˆ›æ–°ä¹‹ä¸€æ˜¯ä¸€ç§å¼€æ”¾çš„å…±è¯†ç®—æ³•ï¼Œå®ƒå¯ä»¥ç§¯ææ¿€åŠ±åŒè¡Œéµå®ˆè§„åˆ™ã€‚å› æ­¤ï¼Œå®ƒä½¿ç”¨äº†åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ç”Ÿæˆçš„ç¡¬å¸çš„æ¦‚å¿µï¼Œå³æŒ–çŸ¿ã€‚<br>è™½ç„¶æœ¯è¯­åŒºå—é“¾é€šå¸¸æŒ‡æ•´ä¸ªç³»ç»ŸåŠå…¶åè®®ï¼Œä½†å®ƒä¹ŸæŒ‡ç±»ä¼¼äºå“ˆå¸Œé“¾æˆ–å“ˆå¸Œæ ‘çš„ç‰¹å®šæ•°æ®ç»“æ„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒåŒºå—é“¾ä½¿ç”¨åŠ å¯†æ•£åˆ—å¯¹é“¾æ¥åˆ°å…¶å‰ä»»çš„å—è¿›è¡Œæ’åºã€‚è¿™ç§é“¾æ¥çš„æ•°æ®ç»“æ„ç¡®ä¿äº†åŒºå—é“¾æ•°æ®(ä¾‹å¦‚äº‹åŠ¡)çš„å®Œæ•´æ€§ã€‚åŒºå—é“¾çš„ä¸€è‡´æ€§ç”±å…±è¯†ç®—æ³•ä¿è¯ï¼Œä¾‹å¦‚æ¯”ç‰¹å¸ä¸­çš„Nakamotoå…±è¯†ã€‚æœ‰å…³æ¯”ç‰¹å¸å’ŒåŒºå—é“¾çš„æ›´å¤šç»†èŠ‚ï¼Œè¯·å‚é˜…ã€‚<br>ç”±äºåŒºå—é“¾å—åˆ°è¯¸å¦‚å¯ä¼¸ç¼©æ€§ç­‰é—®é¢˜çš„å›°æ‰°ï¼Œäººä»¬å¼€å‘äº†ä¸åŒçš„è®¾è®¡æ¥ç¼“è§£è¿™äº›é—®é¢˜ã€‚ä¸åŒçš„è®¾è®¡å¼€è¾Ÿäº†ä¸€ä¸ªæ–°çš„ç±»åˆ«ï¼Œç§°ä¸ºåˆ†å¸ƒå¼åˆ†ç±»è´¦æŠ€æœ¯(DLT)ã€‚dltæä¾›åˆ†å¸ƒå¼ã€æ‹œå åº­å¼å®¹é”™ã€ä¸å¯å˜å’Œæœ‰åºçš„æ—¥å¿—ã€‚ä¸å¹¸çš„æ˜¯ï¼Œç”±äºä¸€ç³»åˆ—çš„å¯æ‰©å±•æ€§é—®é¢˜å’Œé“¾ä¸Šå­˜å‚¨å®¹é‡æœ‰é™ï¼Œçº¯ç²¹åŸºäºDLTçš„æ•°æ®ç½‘ç»œçš„å¯è¡Œæ€§æœ‰é™[57,58]ã€‚æ­¤å¤–ï¼Œåœ¨è¢«è®¾è®¡ä¸ºäº¤æ¢å’Œä»·å€¼å­˜å‚¨åª’ä»‹çš„åŒºå—é“¾(å³æ¯”ç‰¹å¸ç­‰åŠ å¯†è´§å¸)ä¸­å­˜å‚¨å¤§é‡æ•°æ®ä¼šå¯¼è‡´é«˜é¢çš„äº¤æ˜“è´¹ç”¨ã€‚ç„¶è€Œï¼Œdltçš„ç ”ç©¶å’Œå¼€å‘è¡¨æ˜äº†åŸºäºåŒºå—é“¾çš„æ•°æ®ç½‘ç»œçš„å¯è¡Œæ€§ï¼Œä¾‹å¦‚Arweave(å‚è§ç¬¬4 - eèŠ‚)ã€‚<br>ç„¶è€Œï¼Œä¸€èˆ¬æ¥è¯´ï¼Œå…è®¸å»ä¸­å¿ƒåŒ–æ”¯ä»˜çš„åŠ å¯†è´§å¸å¯ä»¥ä½œä¸ºä¸€ç§æ¿€åŠ±ç»“æ„åœ¨P2Pæ•°æ®ç½‘ç»œä¸­ä½¿ç”¨ã€‚æ­£å¦‚æˆ‘ä»¬å°†åœ¨ä¸‹æ–‡ä¸­é˜è¿°çš„ï¼Œè¿™ç§æ¿€åŠ±ç»“æ„å¯ä»¥å¢åŠ æ•°æ®ç½‘ç»œçš„å¥å£®æ€§å’Œå¯ç”¨æ€§ï¼Œä»è€Œè§£å†³å‰å‡ ä»£äººçš„å¼±ç‚¹ã€‚</p><h2 id="III-INTERPLANETARY-FILE-SYSTEM-IPFS"><a href="#III-INTERPLANETARY-FILE-SYSTEM-IPFS" class="headerlink" title="III. INTERPLANETARY FILE SYSTEM (IPFS)"></a>III. INTERPLANETARY FILE SYSTEM (IPFS)</h2><h2 id="IV-RELATED-P2P-DATA-NETWORKS"><a href="#IV-RELATED-P2P-DATA-NETWORKS" class="headerlink" title="IV. RELATED P2P DATA NETWORKS"></a>IV. RELATED P2P DATA NETWORKS</h2><h3 id="A-Swarm"><a href="#A-Swarm" class="headerlink" title="A. Swarm"></a>A. Swarm</h3><p>Swarmæ˜¯ä¸€ä¸ªç”±ä»¥å¤ªåŠåŸºé‡‘ä¼šå¼€å‘çš„ç”¨äºå­˜å‚¨å’Œäº¤ä»˜å†…å®¹çš„P2Påˆ†å¸ƒå¼å¹³å°ã€‚å®ƒé€šè¿‡ä¸å…è®¸ä»»ä½•åˆ é™¤ï¼Œä»¥åŠä¸Šä¼ å’Œå¿˜è®°å±æ€§æ¥æŠµæŠ—å®¡æŸ¥ã€‚ç¾¤æ˜¯ä¸ºä»¥å¤ªåŠæ„å»ºçš„ï¼Œå› æ­¤åœ¨æŸäº›æ–¹é¢ä¾èµ–å¹¶å…±äº«ä»¥å¤ªåŠçš„è®¾è®¡æ–¹é¢ã€‚Swarmçš„ç›®æ ‡æ˜¯ä¸ºweb3æ ˆæä¾›å»ä¸­å¿ƒåŒ–çš„å­˜å‚¨å’Œæµåª’ä½“åŠŸèƒ½ï¼Œè¿™æ˜¯ä¸€ä¸ªç”¨äºå…±äº«äº’åŠ¨å†…å®¹çš„å»ä¸­å¿ƒåŒ–çš„ã€æŠµåˆ¶å®¡æŸ¥çš„ç¯å¢ƒã€‚ä»¥å¤ªåŠåŸºé‡‘ä¼šå°†Swarmè®¾æƒ³ä¸ºâ€œä¸–ç•Œè®¡ç®—æœºçš„ç¡¬ç›˜â€ã€‚<br>ä¸IPFSç±»ä¼¼çš„æ˜¯Swarmä½¿ç”¨åŸºäºå†…å®¹çš„å¯»å€ã€‚ä¸IPFSç›¸åçš„æ˜¯Swarmä¸­åŸºäºå†…å®¹çš„å¯»å€ä¹Ÿå†³å®šäº†å­˜å‚¨ä½ç½®ã€‚ä¸ºäº†ç¡®ä¿å¯ç”¨æ€§ï¼Œç¾¤æ§å¼•å…¥äº†èŒè´£èŒƒå›´ã€‚è´£ä»»åŒºåŸŸæ˜¯èŠ‚ç‚¹çš„è¿‘é‚»ã€‚è´£ä»»åŒºåŸŸä¸­çš„èŠ‚ç‚¹åº”è¯¥æä¾›å—å†—ä½™ã€‚é€šè¿‡ç‰ˆæœ¬æ§åˆ¶æ”¯æŒå¯å˜æ€§ï¼Œä¿æŒæ–‡ä»¶çš„æ¯ä¸ªç‰ˆæœ¬ã€‚æè¦ã€ä¸“é—¨æ„é€ å’Œå¯»å€çš„å—ä»¥åŠä»¥å¤ªåŠåç§°æœåŠ¡(ENS)ç”¨äºæŸ¥æ‰¾å˜å¼‚æ–‡ä»¶ã€‚ENSæ˜¯ä»¥å¤ªåŠæ”¹è¿›ææ¡ˆ137ä¸­å®šä¹‰çš„æ ‡å‡†ã€‚å®ƒæä¾›äº†å°†åœ°å€è½¬æ¢ä¸ºäººç±»å¯è¯»åç§°çš„èƒ½åŠ›ã€‚ä¸IPNSä¸åŒï¼ŒENSæ˜¯ä½œä¸ºä»¥å¤ªåŠåŒºå—é“¾ä¸Šçš„æ™ºèƒ½åˆçº¦æ¥å®ç°çš„ã€‚</p><p>å›¾6æ˜¯äº‘è®¡ç®—çš„æ¦‚å¿µæ¦‚è¿°ï¼Œæˆ‘ä»¬ç»§ç»­ä½¿ç”¨ä½œè€…å’Œå®¡ç¨¿äººä¹‹é—´äº¤æ¢çš„è°ƒæŸ¥è®ºæ–‡ä½œä¸ºè¿è¡Œä¾‹å­ã€‚Swarmä¼šå°†ä¸€ä¸ªæ–‡ä»¶åˆ†å‰²ï¼Œä¹Ÿå°±æ˜¯å°†è°ƒæŸ¥åˆ†æˆä¸€äº›å—ï¼Œè¿™äº›å—è¢«å®‰æ’åœ¨ä¸€ä¸ªæ‰€è°“çš„Swarm hashä¸­ã€‚Swarmå“ˆå¸Œæ˜¯æ’åˆ—åœ¨Merkleæ ‘ä¸­çš„å—çš„ç»„åˆï¼Œå…¶ä¸­å¶èŠ‚ç‚¹ä»£è¡¨è¾“å…¥æ•°æ®ï¼Œä¸­é—´èŠ‚ç‚¹æ˜¯å­èŠ‚ç‚¹çš„å¼•ç”¨ç»„åˆã€‚å¾—åˆ°çš„æ•°æ®å—è¢«ä¸Šä¼ åˆ°ç½‘ç»œã€‚ç¾¤é‡‡ç”¨Kademliaæ‹“æ‰‘ç»“æ„ï¼Œé‚»å±…ç”±å®ƒä»¬çš„æ ‡è¯†è·ç¦»å†³å®šã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé™¤äº†æ¡¶çš„è¿æ¥å¤–ï¼ŒSwarmè¿˜ä¾èµ–äºä¸€ä¸ªæœ€è¿‘çš„é‚»å±…é›†åˆï¼Œå³è¯¥é‚»å±…çš„å‰©ä½™èŠ‚ç‚¹ã€‚ä¸€ä¸ªé‚»å±…åŸºæœ¬ä¸Šæ˜¯åŒ…å«è‡³å°‘ä¸‰ä¸ªå…¶ä»–å¯¹ç­‰èŠ‚ç‚¹çš„æ¡¶æ•°é‡æœ€å°‘çš„æ¡¶ã€‚è¿™ä¸ªæœ€è¿‘çš„é‚»å±…é›†è´Ÿè´£å¤åˆ¶ï¼Œå¹¶ä¸”ä¸ä¸€å®šæ˜¯å¯¹ç§°çš„ã€‚ä¾‹å¦‚ï¼Œåœ¨å›¾6ä¸­ï¼Œğ‘3çš„æœ€è¿‘é‚»å±…æ˜¯ğ‘2ï¼Œğ‘1å’Œğ‘0ï¼Œè€Œğ‘12çš„é‚»å±…æ˜¯ğ‘8ï¼Œğ‘9ï¼Œğ‘10å’Œğ‘11(å‚è§å›¾3)ã€‚ä¸Šä¼ çš„å—è¢«ä¸­ç»§ï¼Œå­˜å‚¨å’Œå¤åˆ¶åœ¨æœ€è¿‘çš„åœ°å€ã€‚è¦æ£€ç´¢è°ƒæŸ¥ï¼Œå¿…é¡»ä½¿ç”¨ç¾¤æ ¹å“ˆå¸Œã€‚ç½‘ç»œæ ¹æ®å†…å®¹åœ°å€è½¬å‘è¯·æ±‚ã€‚</p><p><img src="/images/distributed_storage/image-20220428151148330.png" alt="image-20220428151148330"></p><p>ä¸ºäº†ä¿è¯ç¡®ä¿èŠ‚ç‚¹è¡Œä¸ºï¼ŒSwarmæä¾›äº†ä¸€ä¸ªæ¿€åŠ±å±‚ã€‚å…¶æ¿€åŠ±æœºåˆ¶åŸºäºSWAPã€SWEARå’ŒSWINDLEã€‚SWAP (SWarm Accounting Proto- col)å¤„ç†èŠ‚ç‚¹é—´æ•°æ®äº¤æ¢çš„å‡è¡¡ã€‚å„èŠ‚ç‚¹ç»´æŠ¤æœ¬åœ°è®¡è´¹ä¿¡æ¯ã€‚å¯¹ç­‰ç‚¹åŸºæœ¬ä¸Šæ˜¯åœ¨æ²¡æœ‰åˆ©æ¯çš„æƒ…å†µä¸‹ä»æœåŠ¡èŠ‚ç‚¹è´­ä¹°ä¸€å¤§å—ã€‚åŒºå—çš„ä»·æ ¼å¯ä»¥åœ¨åŒè¡Œä¹‹é—´åå•†ã€‚è¯·æ±‚ä¼šè¢«å¤„ç†åˆ°æŸä¸ªä¸å¹³è¡¡çš„é˜ˆå€¼ï¼Œå³å—è¢«ä¸å¹³è¡¡åœ°å¤„ç†ï¼Œå€ºåŠ¡å˜å¾—è¿‡é«˜ã€‚åœ¨è¾¾åˆ°ç¬¬ä¸€ä¸ªé˜ˆå€¼åï¼ŒèŠ‚ç‚¹å¸Œæœ›å¾—åˆ°å€ºåŠ¡çš„ç»“æ¸…ä»¥è¿›è¡Œè¿›ä¸€æ­¥çš„æœåŠ¡ã€‚å¦‚æœè¾¾åˆ°ç¬¬äºŒä¸ªé˜ˆå€¼ï¼Œåˆ™ç”±äºæœªæ¸…å¿å€ºåŠ¡ï¼ŒèŠ‚ç‚¹æ–­å¼€è¿æ¥ã€‚å€ºåŠ¡å¯ä»¥ç”¨æ”¯ç¥¨ç»“ç®—ï¼Œæ”¯ç¥¨å¯ä»¥è¢«ç†è§£ä¸ºä¸€ç§ç®€å•çš„å•å‘æ”¯ä»˜æ¸ é“ã€‚SWarm Enforcement And Registration (SWEAR)å’ŒSecured With INsurance Deposit Litigation And Escrow (SWINDLE)å°†ç¡®ä¿å†…å®¹çš„æŒä¹…æ€§ã€‚æ­¤å¤–ï¼ŒSwarmçš„æ¿€åŠ±æœºåˆ¶æœ‰é‚®ç¥¨ï¼Œå®ƒæä¾›äº†ä¸€ç§æœºåˆ¶æ¥é˜²æ­¢åƒåœ¾ä¸Šä¼ ï¼Œä¹Ÿæä¾›äº†ä¸€ç§å½©ç¥¨æœºåˆ¶æ¥æ¿€åŠ±å—çš„æŒç»­å­˜å‚¨ã€‚<br>é‚®ç¥¨å¯é€šè¿‡æ™ºèƒ½åˆçº¦æ‰¹é‡è·å–ã€‚é‚®ç¥¨è¢«é™„åœ¨ä¸Šä¼ çš„åŒºå—ä¸Šï¼Œå¹¶ç”±é‚®ç¥¨æ‰€æœ‰è€…ç­¾åã€‚è¿™å¯ä»¥ä½œä¸ºä¸Šä¼ åŒºå—çš„ä»˜æ¬¾å‡­è¯ã€‚åªèƒ½é€šè¿‡ä¸­ç»§æˆ–å­˜å‚¨èŠ‚ç‚¹ç›‘æ§æˆ³è®°çš„ä½¿ç”¨æƒ…å†µã€‚è¿™å…è®¸é‡å¤ä½¿ç”¨/è¿‡åº¦ä½¿ç”¨é‚®ç¥¨ã€‚ä¸ºäº†å‡å°‘è¿‡åº¦ä½¿ç”¨æˆ³è®°çš„é£é™©ï¼Œæˆ³è®°åªç”¨äºæŸäº›å‰ç¼€å†²çªï¼Œå°†æˆ³è®°é™åˆ¶ä¸ºç‰¹å®šå­˜å‚¨åŒºåŸŸä¸­çš„å—ã€‚<br>é‚®ç¥¨è¢«ç”¨äºæŠ½å¥–ã€‚å½©ç¥¨ä¸ºå—æä¾›äº†ä»·å€¼ï¼Œä»¥é˜²æ­¢å—çš„æ—©æœŸåˆ é™¤ã€‚é€šè¿‡æŠ½ç­¾ï¼Œå­˜å‚¨èŠ‚ç‚¹å¯ä»¥è·å¾—é‚®ç¥¨çš„éƒ¨åˆ†åˆå§‹æˆæœ¬ã€‚åœ¨å½©ç¥¨ä¸­é€‰æ‹©ä¸€ä¸ªåœ°å€åŒºåŸŸã€‚ä¸´è¿‘åŒºåŸŸçš„èŠ‚ç‚¹å¯ä»¥ç”³è¯·å¥–åŠ±ã€‚é€šè¿‡åº”ç”¨ï¼ŒèŠ‚ç‚¹å¯ä»¥è¯æ˜è¯¥åŒºåŸŸå†…å—çš„æ‰€æœ‰æƒã€‚èŠ‚ç‚¹å®šä¹‰äº†å­˜å‚¨å—çš„ä»·æ ¼ã€‚åœ¨è¯æ˜æ‹¥æœ‰è¿™äº›å—ä¹‹åï¼Œæ‹¥æœ‰æœ€ä¾¿å®œå¥–å“çš„èŠ‚ç‚¹è·å¾—å¥–åŠ±ã€‚è®¨è®º:ç¾¤æä¾›äº†å¤æ‚çš„æ¿€åŠ±æ¦‚å¿µã€‚ä¸ä¾èµ–åŒºå—é“¾äº¤æ˜“ç›¸æ¯”ï¼Œç”¨æ”¯ç¥¨ç»“ç®—ä¸å¹³è¡¡æ£€ç´¢æä¾›äº†ä¸€ç§æ›´å¿«ã€æ›´ä¾¿å®œçš„ç»“ç®—å·®å¼‚çš„æ–¹æ³•ã€‚ä¸å½©ç¥¨ä¸€èµ·å‘è¡Œçš„é‚®ç¥¨ä¸ºå‚¨å­˜å¤§å—çš„æ•°æ®æä¾›äº†é¢å¤–çš„æ¿€åŠ±ã€‚æ­¤å¤–ï¼Œè™½ç„¶ä¸Šä¼ å†…å®¹éœ€è¦èŠ±è´¹æˆæœ¬ï¼Œä½†èŠ‚ç‚¹å¯ä»¥é€šè¿‡ä¸»åŠ¨ä¸ºå‚ä¸è€…æä¾›å—æ¥èµšå–æˆæœ¬ã€‚ç„¶è€Œï¼Œé‚®ç¥¨å¯ä»¥å°†ç”¨æˆ·é“¾æ¥åˆ°ä¸Šä¼ çš„å†…å®¹ã€‚è™½ç„¶ç¾¤é›†æä¾›äº†ä¸€å®šç¨‹åº¦çš„å‘é€è€…åŒ¿åæ€§ï¼Œä½†ä¸Šä¼ çš„åŒ¿åæ€§å¯èƒ½ä¼šé™åˆ¶å¯ç”¨çš„å†…å®¹ã€‚<br>è€ƒè™‘åˆ°åˆ†å¸ƒå¼å—ä¸å¯å˜å­˜å‚¨(DISC)æ‰€ç¡®å®šçš„å­˜å‚¨ä½ç½®ï¼Œç½‘ç»œå¯èƒ½é¢ä¸´å­˜å‚¨é—®é¢˜ã€‚æè¦å¯ä»¥åœ¨ç½‘ç»œä¸­æä¾›ç”¨æˆ·å®šä¹‰çš„ç©ºé—´ï¼Œä»¥æ¢å¤æè¦å’Œå›ºå®šçš„å½¢å¼ï¼Œå¯èƒ½èƒ½å¤Ÿå‡è½»è¿™äº›ç¼ºç‚¹ã€‚<br>æ€»çš„æ¥è¯´ï¼ŒSwarmæ˜¾ç„¶ä¾èµ–äºä»¥å¤ªåŠç”Ÿæ€ç³»ç»Ÿã€‚è™½ç„¶è¿™æœ‰åˆ©äºæ¿€åŠ±ç»“æ„ï¼Œä½†ç”±äºä»¥å¤ªåŠå‘å±•ç§¯æï¼Œç”¨æˆ·åŸºç¡€å¹¿æ³›ï¼Œè¿™ä¹Ÿéœ€è¦ç”¨æˆ·å¯¹ä»¥å¤ªåŠçš„ä¾èµ–ã€‚è™½ç„¶æœ‰è¿™ä¹ˆåºå¤§çš„æ½œåœ¨ç”¨æˆ·ç¾¤ï¼Œä½†å¯¹ç”¨ä¾‹æˆ–Swarmæœºåˆ¶çš„ç ”ç©¶å´å¾ˆå°‘ã€‚Swarmå’Œä»¥å¤ªåŠçš„è¿æ¥å¯èƒ½æ˜¯ç¼ºä¹ç ”ç©¶çš„ä¸€ä¸ªåŸå› ï¼Œå› ä¸ºSwarmä¼¼ä¹æ²¡æœ‰IPFSé‚£ä¹ˆå®Œæ•´ï¼Œè€Œä»¥å¤ªåŠæœ¬èº«ä»ç„¶ä¿ç•™ç€è®¸å¤šç ”ç©¶æœºä¼šã€‚</p><h3 id="B-Hypercore-Protocol-Dat"><a href="#B-Hypercore-Protocol-Dat" class="headerlink" title="B. Hypercore Protocol/Dat"></a>B. Hypercore Protocol/Dat</h3><p>Hypercore Protocol(ä»¥å‰çš„Dat Protocol)æ”¯æŒç±»ä¼¼Gitçš„å†…å®¹å’Œå…ƒæ•°æ®çš„å¢é‡ç‰ˆæœ¬ã€‚Hypercoreåè®®ç”±å¤šä¸ªå­ç»„ä»¶ç»„æˆã€‚ä¸¥æ ¼åœ°è¯´ï¼ŒHypercoreæ˜¯å­ç»„ä»¶ä¹‹ä¸€ï¼Œä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªæœ¯è¯­æ¥æ³›æŒ‡Hypercoreåè®®ã€‚åœ¨Hypercoreä¸­ï¼Œæ•°æ®å­˜å‚¨åœ¨ä¸€ä¸ªç±»ä¼¼äºBitTorrentç»“æ„çš„ç›®å½•ä¸­ï¼Œæ¯ä¸ªç›®å½•å¤„ç†è‡ªå·±çš„ç½‘ç»œã€‚è¯¥åè®®æ”¯æŒä¸åŒçš„å­˜å‚¨æ¨¡å¼ï¼Œæ¯ä¸ªèŠ‚ç‚¹å¯ä»¥å†³å®šç›®å½•ä¸­çš„å“ªäº›æ•°æ®ä»¥åŠéœ€è¦å­˜å‚¨å“ªäº›ç‰ˆæœ¬çš„æ•°æ®ã€‚æ­¤å¤–ï¼Œè¯¥åè®®æ”¯æŒè®¢é˜…ç›®å½•ä¸­æ‰€æœ‰/ä»»ä½•æ–‡ä»¶çš„å®æ—¶æ›´æ”¹ã€‚åè®®ä¸­çš„æ‰€æœ‰é€šä¿¡éƒ½æ˜¯åŠ å¯†çš„ã€‚ä¸ºäº†æŸ¥æ‰¾å’Œè¯»å–æ•°æ®ï¼Œéœ€è¦çŸ¥é“ä¸€ä¸ªç‰¹å®šçš„è¯»é”®ã€‚<br>è¯¥åè®®æ—¨åœ¨å…±äº«å¤§é‡å¯å˜æ•°æ®ã€‚åˆ›å»ºè¯¥åè®®çš„åŠ¨æœºæ˜¯ä¸ºäº†é˜²æ­¢ç§‘å­¦æ–‡çŒ®çš„é“¾æ¥è…çƒ‚å’Œå†…å®¹æ¼‚ç§»ã€‚è¯¥åè®®åªå…è®¸éšæœºè®¿é—®éƒ¨åˆ†æ•°æ®ã€‚<br>Hypercoreå¯ä»¥ç†è§£ä¸ºå…±äº«ä¸€ä¸ªæ–‡ä»¶å¤¹ã€‚å¯ä»¥å¯¹æ–‡ä»¶å¤¹ä¸­çš„æ–‡ä»¶è¿›è¡Œä¿®æ”¹ã€æ·»åŠ å’Œåˆ é™¤æ“ä½œã€‚è¿™ä¹ŸåŒ…æ‹¬å¹¶å…è®¸å¯å˜æ–‡ä»¶ã€‚<br>Hypercoreçš„æ¦‚å¿µæ¦‚è¿°å¦‚å›¾7æ‰€ç¤ºã€‚å¯¹äºå¯¹ç­‰å‘ç°ï¼ŒHypercoreä½¿ç”¨Hyperswarmï¼Œä¸€ç§åŸºäºKademliaçš„DHTã€‚å¦‚æœä½œè€…æƒ³ä½¿ç”¨Hypercoreåè®®å…±äº«è°ƒæŸ¥ç»“æœï¼Œéœ€è¦åˆ›å»ºHypercoreå¹¶æ·»åŠ è°ƒæŸ¥ç»“æœã€‚è¦æƒ³è¢«è¶…perswarmå‘ç°ï¼Œå°±å¿…é¡»åŠ å…¥è¶…perswarmè¦†ç›–ç½‘ç»œã€‚é€šè¿‡å…±äº«å…¬é’¥ğ¾ğ‘ƒğ‘¢ğ‘ï¼Œå®¡é˜…è€…å¯ä»¥è®¡ç®—å‘ç°å¯†é’¥ğ¾ğ·ï¼Œå¹¶åœ¨æ‰¾åˆ°å¯¹ç­‰ç‚¹å¹¶åŠ å…¥æ•°æ®ç½‘ç»œåè§£å¯†æ¶ˆæ¯ã€‚ä¸€æ—¦å¦ä¸€ä¸ªè¦†ç›–ç½‘ç»œåŠ å…¥ï¼Œéç»“æ„åŒ–çš„å¿—æ„¿è€…ç½‘ç»œå°±å¯ä»¥å…±äº«æ•°æ®ï¼Œè°ƒæŸ¥å¯ä»¥è¢«æ£€ç´¢ã€‚<br>è®¨è®º:Hypercoreå…è®¸é€šè¿‡äº¤æ¢å…¬é’¥æ¥å…±äº«æ•°æ®ã€‚å¯ä»¥è·å–ç‰¹å®šç‰ˆæœ¬å’Œç‰¹å®šåŒºåŸŸçš„æ•°æ®ã€‚è¿™ä½¿å¾—å®ƒå˜å¾—ç®€å•ï¼Œç‰¹åˆ«æ˜¯å¯¹äºå¤§å‹æ•°æ®é›†ï¼Œå¹¶ä¸”å…è®¸å¯å˜æ•°æ®ã€‚è¯¥åè®®ä¸“æ³¨äºå…±äº«æ–‡ä»¶é›†åˆï¼Œè¿™æ‰©å¤§äº†åè®®çš„å¯ç”¨æ€§ã€‚<br>ç”±äºåŠ å¯†å’Œå‘ç°å¯†é’¥ï¼Œè¯¥åè®®ç¡®ä¿äº†æœºå¯†æ€§ã€‚å…¬é’¥å…è®¸è®¡ç®—å‘ç°å¯†é’¥ï¼Œä½†ä¸å¯èƒ½é€†è½¬å…¬é’¥ã€‚è¿™å°†é˜»æ­¢å…¶ä»–äººè¯»å–æ•°æ®ã€‚Hypercoreçš„ä¸€ä¸ªç¼ºç‚¹æ˜¯ç¼ºä¹å…¬é’¥ä»¥å¤–çš„å…¶ä»–èº«ä»½éªŒè¯æœºåˆ¶ï¼Œè¿™é˜»æ­¢äº†é¢å¤–çš„ç»†ç²’åº¦è®¿é—®æ§åˆ¶ã€‚æ­¤å¤–ï¼Œå®ƒä»ç„¶æ³„æ¼å…ƒæ•°æ®ï¼Œå› ä¸ºå‘ç°å¯†é’¥åªæ˜¯ä¸€ä¸ªå‡åã€‚<br>Hypercoreæ²¡æœ‰å¤åˆ¶æ•°æ®çš„æ¿€åŠ±æœºåˆ¶ï¼Œæ•°æ®çš„æŒä¹…æ€§ä¾èµ–äºå‚ä¸è€…ã€‚åˆ©ç”¨æˆ–åˆ†æHypercore/Datçš„ç ”ç©¶å¾ˆå°‘ã€‚è™½ç„¶è¯¥åè®®ä¼¼ä¹å¼€å‘å¾—å¾ˆå¥½ï¼Œè€Œä¸”å¯ç”¨ï¼Œä½†ç ”ç©¶ä¼¼ä¹ä¾§é‡äºIPFSã€‚</p><h3 id="C-Secure-Access-For-Everyone-SAFE"><a href="#C-Secure-Access-For-Everyone-SAFE" class="headerlink" title="C. Secure Access For Everyone(SAFE)"></a>C. Secure Access For Everyone(SAFE)</h3><p>äººäººå®‰å…¨è®¿é—®(SAFE)ç½‘ç»œ[17,81]è¢«è®¾è®¡ä¸ºä¸€ä¸ªå®Œå…¨è‡ªä¸»çš„åˆ†æ•£æ•°æ®å’Œé€šä¿¡ç½‘ç»œã€‚ç”šè‡³è®¤è¯ä¹Ÿéµå¾ªè‡ªæˆ‘è®¤è¯[82]æœºåˆ¶ï¼Œå®ƒä¸ä¾èµ–äºä»»ä½•é›†ä¸­ç»„ä»¶ã€‚SAFEçš„ä¸»è¦ç›®æ ‡æ˜¯æä¾›ä¸€ä¸ªç½‘ç»œï¼Œæ¯ä¸ªäººéƒ½å¯ä»¥åŠ å…¥å¹¶ä½¿ç”¨å®ƒæ¥å­˜å‚¨ã€æŸ¥çœ‹å’Œå‘å¸ƒæ•°æ®ï¼Œè€Œä¸ä¼šåœ¨æœºå™¨ä¸Šç•™ä¸‹ä»–ä»¬æ´»åŠ¨çš„ç—•è¿¹ã€‚è¿™å°†å…è®¸å‚ä¸è€…ä»¥è¾ƒä½çš„è¿«å®³é£é™©å‘å¸ƒå†…å®¹ã€‚<br>SAFEæ”¯æŒä¸‰ç§ä¸åŒçš„æ•°æ®ç±»å‹:Mapã€Sequenceå’ŒBlobã€‚æ•°æ®å¯ä»¥è¿›ä¸€æ­¥åˆ†ä¸ºå…¬å…±æ•°æ®å’Œç§æœ‰æ•°æ®ã€‚Mapå’Œsequenceæ˜¯æ— å†²çªçš„å¤åˆ¶æ•°æ®ç±»å‹ï¼Œè¿™å¯¹äºç¡®ä¿å¯å˜æ•°æ®çš„ä¸€è‡´æ€§å¾ˆé‡è¦ã€‚Blobç”¨äºä¸å¯å˜æ•°æ®ã€‚SAFEç½‘ç»œä¸­çš„æ‰€æœ‰æ•°æ®éƒ½æ˜¯åŠ å¯†çš„ï¼ŒåŒ…æ‹¬å…¬å…±æ•°æ®ã€‚ä½¿ç”¨çš„åŠ å¯†ç®—æ³•æ˜¯è‡ªåŠ å¯†[83]ï¼Œä½¿ç”¨æ–‡ä»¶æœ¬èº«å¯¹æ–‡ä»¶è¿›è¡ŒåŠ å¯†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€ä¸ªæ–‡ä»¶è¢«åˆ†å‰²æˆè‡³å°‘ä¸‰ä¸ªå›ºå®šå¤§å°çš„å—ã€‚æ¯ä¸ªå—ä½¿ç”¨å‰ä¸€ä¸ªå—çš„æ•£åˆ—å’ŒåŠ å¯†ï¼Œå³ğ‘›âˆ’1ï¼Œå…¶ä¸­ğ‘›æ˜¯å½“å‰å—ã€‚ä¹‹åï¼ŒåŠ å¯†çš„å—ä¼šè¢«åŸå§‹å—çš„ä¸²æ¥å“ˆå¸Œå€¼æ··æ·†ã€‚å¯¹äºSAFEï¼Œæ··æ·†åçš„å—å­˜å‚¨åœ¨ç½‘ç»œä¸­ã€‚å¯¹äºè§£å¯†ï¼Œåœ¨åŠ å¯†è¿‡ç¨‹ä¸­ä¼šåˆ›å»ºä¸€ä¸ªæ•°æ®æ˜ å°„ã€‚æ•°æ®æ˜ å°„åŒ…å«å…³äºæ–‡ä»¶çš„ä¿¡æ¯ï¼Œå¹¶å°†æ¨¡ç³Šå—çš„æ•£åˆ—æ˜ å°„åˆ°çœŸå®å—çš„æ•£åˆ—ã€‚å¯¹äºå…¬å…±æ•°æ®ï¼Œè§£å¯†å¯†é’¥ç”±ç½‘ç»œæä¾›ã€‚ç§äººæ•°æ®å¯ä»¥åˆ é™¤ï¼Œè€Œå…¬å…±æ•°æ®åº”è¯¥æ˜¯æ°¸ä¹…çš„ã€‚å› æ­¤ï¼Œå¯å˜æ•°æ®åªèƒ½æ˜¯ç§æœ‰çš„ã€‚åç§°è§£æç³»ç»Ÿå…è®¸äººç±»å¯è¯»çš„åœ°å€æ¥æ£€ç´¢æ•°æ®ã€‚<br>ç½‘ç»œæœ¬èº«æ˜¯æ ¹æ®åŸºäºå¡å¾·ç±³åˆ©äºšçš„DHTç”±å¼‚æˆ–åœ°å€ç»„ç»‡çš„ã€‚æ­¤å¤–ï¼Œç½‘ç»œè¢«åˆ†æˆå‡ ä¸ªéƒ¨åˆ†ã€‚å½“ä¸€ä¸ªæ–°çš„ä¿é™©åº“æƒ³è¦åŠ å…¥ç½‘ç»œæ—¶ï¼Œæ–°çš„ä¿é™©åº“éœ€è¦è¯æ˜å®ƒå¯ä»¥æä¾›æ‰€éœ€çš„èµ„æºï¼Œç„¶åè¢«éšæœºåˆ†é…ä¸€ä¸ªXORåœ°å€ï¼Œä»è€Œåˆ†é…ç»™ä¸€ä¸ªèŠ‚ã€‚è¿™äº›éƒ¨åˆ†æ˜¯åŠ¨æ€ç»´æŠ¤çš„ã€‚æ ¹æ®ç½‘ç»œä¸­ä¿é™©åº“çš„æ•°é‡ï¼Œåˆ†åŒºå¹¶å°†ä¿é™©åº“é‡æ–°åˆ†é…åˆ°æ–°çš„åˆ†åŒºã€‚å¯¹äºé•¿å¾—å¤ªå°çš„èŠ‚ï¼Œå¯ä»¥é€šè¿‡è·å–æ–°èŠ‚ç‚¹æˆ–è¯·æ±‚é‡æ–°å®šä½èŠ‚ç‚¹æ¥å¹³è¡¡èŠ‚çš„å¤§å°ã€‚æ›´æ”¹sectionä¼šå¢åŠ ä¿é™©åº“çš„èŠ‚ç‚¹å¹´é¾„ã€‚èŠ‚ç‚¹å¹´é¾„æ˜¯ä¿¡ä»»çš„è¡¡é‡æ ‡å‡†ï¼Œå¯ä»¥å¤±å»ï¼Œç„¶åå¿…é¡»é‡æ–°èµ¢å¾—ã€‚åœ¨ä¸€ä¸ªsectionä¸­ï¼Œåªæœ‰ä¸€å®šæ•°é‡çš„èŠ‚ç‚¹å¯ä»¥åšå‡ºå†³ç­–ï¼Œå³é•¿è€…ã€‚é•¿è€…æ˜¯è¯¥åŒºåŸŸä¸­æœ€å¤è€çš„èŠ‚ç‚¹ã€‚ç”±é•¿è€æŠ•ç¥¨å†³å®šæ˜¯å¦æ¥å—åˆ†åŒºå†…çš„äº‹ä»¶ï¼Œç»ä¸€å®šäººæ•°çš„é•¿è€åŒæ„å¹¶é›†ä½“ç­¾å­—åç”Ÿæ•ˆã€‚ç½‘ç»œæ®µä¸­çš„äº‹ä»¶æ˜¯ï¼Œä¾‹å¦‚ï¼ŒåŠ å…¥/ç¦»å¼€ä¸€ä¸ªèŠ‚ç‚¹æˆ–å­˜å‚¨ä¸€ä¸ªå—ã€‚é•¿è€…çš„çœŸå®æ€§ç”±SectionProofChainä¿è¯ï¼ŒSectionProofChainåŒ…å«é•¿è€…çš„ç¾¤ç»„ç­¾åï¼Œæ˜¯è¯æ˜ä¸€ä¸ªåŒºæ®µæœ‰æ•ˆæ€§çš„å…¬é’¥åºåˆ—ã€‚æ¯å½“é•¿è€…ç»„å‘ç”Ÿå˜åŒ–æ—¶ï¼Œåºåˆ—å°±ä¼šæ›´æ–°å’Œç­¾åã€‚<br>SAFEç½‘ç»œçš„æ¦‚å¿µæ¦‚è¿°å¦‚å›¾8æ‰€ç¤ºã€‚è€ƒè™‘åˆ°æˆ‘ä»¬æ­£åœ¨è¿è¡Œçš„ç¤ºä¾‹ï¼Œè°ƒæŸ¥è¢«åˆ’åˆ†ä¸ºè‡ªåŠ å¯†çš„å—ï¼Œå¹¶ç”¨äºç”Ÿæˆæ•°æ®åœ°å›¾ã€‚åœ¨å®Œæˆè‡ªæˆ‘è®¤è¯è¿‡ç¨‹åï¼Œå‘ç½‘ç»œå‘é€ä¸€ä¸ªPUTè¯·æ±‚ã€‚å½“è´Ÿè´£å­˜å‚¨å—çš„åŒºåŸŸä¸­çš„é•¿è€…åŒæ„åï¼Œæ•°æ®å°±è¢«å­˜å‚¨ã€‚ä¸‹è½½æ–‡ä»¶æ—¶ï¼Œéœ€è¦æ•°æ®å›¾ã€‚æ•°æ®æ˜ å°„ç”¨äºGETè¯·æ±‚ï¼Œä»¥è·å–ç»è¿‡æ¨¡ç³Šå¤„ç†çš„åŠ å¯†å—ã€‚ä¸‹è½½å…¬å…±æ•°æ®ä¸éœ€è¦è®¤è¯ã€‚åœ¨è·å¾—è¿™äº›å—ä¹‹åï¼Œå¯ä»¥åœ¨æ•°æ®æ˜ å°„çš„å¸®åŠ©ä¸‹é‡æ–°åˆ›å»ºæ–‡ä»¶ã€‚<br>åœ¨SAFEç½‘ç»œä¸­ï¼Œå­˜å‚¨æ•°æ®éœ€è¦ä½¿ç”¨è¯¥ç½‘ç»œè‡ªèº«çš„è´§å¸ï¼Œå³Safecoinã€‚å®¢æˆ·çš„å®‰å…¨å¸å¹³è¡¡ç”±å®¢æˆ·ç»ç†ç›‘æ§ï¼Œå¹¶åœ¨å¤–ç®¡å±€çš„å…±è¯†æœºåˆ¶çš„å¸®åŠ©ä¸‹è¢«æ‰¹å‡†/æ‹’ç»ã€‚èŠ‚ç‚¹å¯ä»¥é€šè¿‡è€•ç§(å³å‘è¯·æ±‚è€…æä¾›å†…å®¹)èµšå–Safecoinã€‚<br>è®¨è®º:è‡ªæˆ‘è®¤è¯ã€è‡ªæˆ‘åŠ å¯†å’Œç½‘ç»œç»„ç»‡ç»™äº†ç”¨æˆ·å¯¹å…¶æ•°æ®çš„é«˜åº¦æ§åˆ¶ã€‚ä¸­å¿ƒç»„ä»¶çš„ç¼ºå¤±å‡å°‘äº†å•ç‚¹æ•…éšœã€‚æ­¤å¤–ï¼Œéšç§å’Œåœ¨ä¸€å®šç¨‹åº¦ä¸ŠåŒ¿åæ˜¯SAFEç½‘ç»œçš„å…³é”®ç‰¹å¾ã€‚ç½‘ç»œä¸­ä»…å­˜å‚¨æ•°æ®æ—¶éœ€è¦é‰´æƒã€‚æ£€ç´¢æ•°æ®é€šè¿‡å®¢æˆ·ç«¯é€‰æ‹©çš„ä»£ç†è¿›è¡Œä¸­ä»‹ï¼Œè¯¥ä»£ç†æä¾›äº†åŒ¿åé€šä¿¡ã€‚Safecoinæ—¨åœ¨æä¾›ä¸€ä¸ªæ¿€åŠ±å±‚ï¼Œç¡®ä¿ç½‘ç»œçš„å¯ç”¨æ€§å’Œå¯é æ€§ã€‚<br>Paulç­‰äºº[84]åœ¨2014å¹´é¦–æ¬¡å¯¹SAFEè¿›è¡Œäº†å®‰å…¨åˆ†æï¼Œæ¶‰åŠæœºå¯†æ€§ã€å®Œæ•´æ€§å’Œå¯ç”¨æ€§ä»¥åŠå¯èƒ½çš„æ”»å‡»ã€‚2015å¹´ï¼ŒJacobç­‰äºº[85]ä»çœŸå®æ€§ã€å®Œæ•´æ€§ã€ä¿å¯†æ€§ã€å¯ç”¨æ€§å’ŒåŒ¿åæ€§ç­‰æ–¹é¢åˆ†æäº†ç½‘ç»œçš„å®‰å…¨æ€§ã€‚ä½œè€…è§£é‡Šäº†å¦‚ä½•åˆ©ç”¨è‡ªæˆ‘è®¤è¯å’Œå»ä¸­å¿ƒåŒ–ç‰¹æ€§æ¥æ­ç¤ºå•ä¸ªå®ä½“çš„ä¸ªäººæ•°æ®ã€‚</p><h3 id="D-Storj"><a href="#D-Storj" class="headerlink" title="D. Storj"></a>D. Storj</h3><p>Storj[18]æ˜¯ä¸€ä¸ªP2På­˜å‚¨ç½‘ç»œã€‚ä¸‹é¢æˆ‘ä»¬å¼•ç”¨çš„æ˜¯3.0ç‰ˆæœ¬ã€‚å®ƒä¸“æ³¨äºæ•°æ®çš„é«˜æŒä¹…æ€§ã€ä½å»¶è¿Ÿä»¥åŠå­˜å‚¨æ•°æ®çš„é«˜å®‰å…¨æ€§å’Œç§å¯†æ€§ã€‚æ”¯æŒå¯¹é€šä¿¡ã€æ–‡ä»¶ä½ç½®å’Œæ–‡ä»¶è¿›è¡Œç«¯åˆ°ç«¯åŠ å¯†ã€‚ä¸ºäº†æ–‡ä»¶çš„é«˜æŒä¹…æ€§æˆ–æ¢å¥è¯è¯´ï¼Œæ–‡ä»¶åœ¨ç½‘ç»œä¸­æ›´å¥½çš„å¯ç”¨æ€§ï¼ŒStorjä½¿ç”¨äº†æ“¦é™¤ç ã€‚æ­¤å¤–ï¼Œä½å¸¦å®½æ¶ˆè€—ä¹Ÿæ˜¯è®¾è®¡çš„ä¸»è¦ç›®æ ‡ä¹‹ä¸€ã€‚è¯¥åè®®å‡è®¾å¯¹è±¡å¤§å°ä¸º4ğ‘€ğµæˆ–æ›´å¤šï¼Œè™½ç„¶æ”¯æŒè¾ƒå°çš„å¯¹è±¡å¤§å°ï¼Œä½†å­˜å‚¨è¿‡ç¨‹çš„æ•ˆç‡å¯èƒ½è¾ƒä½ã€‚åœ¨Storjä¸­ï¼Œå»ä¸­å¿ƒåŒ–è¢«è§£é‡Šä¸ºæ²¡æœ‰ä¸€ä¸ªæ“ä½œè€…å•ç‹¬è´Ÿè´£ç³»ç»Ÿçš„æ“ä½œã€‚åœ¨ä¸€ä¸ªåˆ†æ•£çš„ç³»ç»Ÿä¸­ï¼Œä¿¡ä»»å’Œæ‹œå åº­å¼çš„å¤±è´¥å‡è®¾æ˜¯é‡è¦çš„ã€‚Storjå‡è®¾æ²¡æœ‰åˆ©ä»–çš„ï¼Œæ€»æ˜¯è¡¨ç°è‰¯å¥½çš„èŠ‚ç‚¹ï¼Œå¤§å¤šæ•°ç†æ€§èŠ‚ç‚¹ï¼Œåªæœ‰åœ¨ç›ˆåˆ©æ—¶è¡¨ç°å‡ºæ¶æ„ï¼Œè¿˜æœ‰å°‘æ•°æ‹œå åº­å¼æ¶æ„èŠ‚ç‚¹ã€‚<br>Storjçš„ç›®æ ‡æ˜¯æˆä¸ºå»ä¸­å¿ƒåŒ–çš„äº‘å­˜å‚¨ã€‚Storj Labs Inc.å¸Œæœ›ä¸ºé›†ä¸­å¼å­˜å‚¨æä¾›å•†æä¾›å¦ä¸€ç§é€‰æ‹©ã€‚ä¸ºæ­¤ï¼ŒStorjæä¾›äº†ä¸Amazon S3åº”ç”¨ç¨‹åºç¼–ç¨‹æ¥å£çš„å…¼å®¹æ€§ï¼Œä»¥æé«˜æ€»ä½“æ¥å—åº¦å¹¶ç®€åŒ–æ–°ç”¨æˆ·çš„è¿ç§»ã€‚ç”±äºStorjæä¾›äº†äº‘å­˜å‚¨ï¼Œç”¨æˆ·å¯ä»¥å­˜å‚¨å’Œæ£€ç´¢æ•°æ®ï¼Œä»¥åŠåˆ é™¤ã€ç§»åŠ¨å’Œå¤åˆ¶æ•°æ®ã€‚<br>Storjç½‘ç»œç”±ä¸‰ç§èŠ‚ç‚¹ç±»å‹ç»„æˆ:å«æ˜ŸèŠ‚ç‚¹ã€å­˜å‚¨èŠ‚ç‚¹å’Œä¸Šè¡ŒèŠ‚ç‚¹ã€‚å«æ˜ŸèŠ‚ç‚¹ç®¡ç†æ–‡ä»¶çš„å­˜å‚¨è¿‡ç¨‹å’Œç»´æŠ¤ã€‚å¯¹å…ƒæ•°æ®ç”šè‡³æ–‡ä»¶è·¯å¾„çš„åŠ å¯†å¢åŠ äº†å¯¹å…ƒæ•°æ®çš„é¢å¤–ä¿æŠ¤ã€‚ä¸Šè¡ŒèŠ‚ç‚¹æ˜¯ç»ˆç«¯ç”¨æˆ·ï¼Œéœ€è¦å­˜å‚¨å’Œè®¿é—®æ–‡ä»¶ã€‚å­˜å‚¨èŠ‚ç‚¹ç”¨äºå­˜å‚¨æ•°æ®ã€‚å­˜å‚¨å’Œä¸Šè¡ŒèŠ‚ç‚¹é€‰æ‹©ä¸å“ªäº›å«æ˜ŸèŠ‚ç‚¹åˆä½œã€‚è¿™å¯¼è‡´äº†ä¸€ä¸ªç±»ä¼¼äºBitTorrentçš„ç½‘ç»œï¼Œå…¶ä¸­å«æ˜Ÿæˆä¸ºä¸­å¿ƒéƒ¨åˆ†ã€‚<br>Storjçš„æ¦‚å¿µæ¦‚è¿°å¦‚å›¾9æ‰€ç¤ºã€‚ä¸ºäº†ä¸Šä¼ è°ƒæŸ¥è®ºæ–‡ï¼Œä½œè€…éœ€è¦å°†å…¶åˆ†å‰²æˆç‰‡æ®µï¼Œç„¶åå¯¹ç‰‡æ®µè¿›è¡ŒåŠ å¯†ã€‚ä½œè€…è¦æ±‚å«æ˜Ÿå­˜å‚¨ä¸€ä¸ªç‰‡æ®µã€‚å«æ˜Ÿæ£€æŸ¥å­˜å‚¨èŠ‚ç‚¹çš„å®¹é‡å¹¶è¿”å›è¶³å¤Ÿçš„å€™é€‰å­˜å‚¨åˆ—è¡¨ã€‚ç„¶åï¼Œç‰‡æ®µè¢«åˆ†å‰²æˆæ¡çŠ¶ï¼Œè¿™äº›æ¡çŠ¶è¢«æ“¦é™¤ç¼–ç å¹¶æ’åˆ—æˆç‰‡æ®µã€‚ç„¶åï¼Œè¿™äº›ç‰‡æ®µè¢«å¹¶è¡Œä¸Šä¼ è‡³å­˜å‚¨èŠ‚ç‚¹ã€‚</p><p>å¯¹äºæ“¦é™¤ç¼–ç ï¼ŒStorjä½¿ç”¨Reed-Solomonæ“¦é™¤ç [86]ã€‚å¯¹äºerasure codeï¼Œæ•°æ®ç¼–ç ä¸º(ğ‘˜ï¼Œğ‘›)erasure codeã€‚è¿™æ„å‘³ç€ï¼Œä¸€ä¸ªå¯¹è±¡è¢«ç¼–ç ä¸ºğ‘›ç‰‡æ®µï¼Œä»¥è¿™ç§æ–¹å¼åªéœ€è¦ğ‘˜ç‰‡æ®µå°±å¯ä»¥é‡æ–°åˆ›å»ºå¯¹è±¡ã€‚Storjä¸ºæ¯ä¸ªå¯¹è±¡é€‰æ‹©å››ä¸ªå€¼:ğ‘˜ã€ğ‘šã€ğ‘œå’Œğ‘›ã€‚ğ‘˜è¡¨ç¤ºé‡å»ºæ•°æ®æ‰€éœ€çš„æœ€å°å—æ•°ï¼Œğ‘šæ˜¯ç”¨äºä¿®å¤çš„ç¼“å†²åŒºï¼Œğ‘œæ˜¯ç”¨äºchurnçš„ç¼“å†²åŒºï¼Œğ‘›æ˜¯æ€»å—æ•°ã€‚ä¸å¤šæ¬¡å­˜å‚¨æ•°æ®å—ç›¸æ¯”ï¼ŒErasure codeæä¾›äº†æ›´é«˜çš„å†—ä½™ï¼Œå¼€é”€æ›´å°ã€‚æ­¤å¤–ï¼Œç”±äºæ£€ç´¢æ–‡ä»¶åªéœ€è¦ğ‘˜ç‰‡æ®µï¼Œå› æ­¤å¯ä»¥å‡å°‘æ–‡ä»¶å¯ç”¨å‰çš„å»¶è¿Ÿã€‚<br>ä¸Šä¼ å®Œæˆåï¼Œä¸€ä¸ªåŒ…å«ç‰‡æ®µå…ƒæ•°æ®çš„æŒ‡é’ˆ(ä¾‹å¦‚ç‰‡æ®µçš„å“ˆå¸Œå€¼ã€å­˜å‚¨ä½ç½®ã€æ“¦é™¤ç¼–ç æ–¹æ¡ˆ)è¢«è¿”å›ç»™å«æ˜Ÿã€‚å¯¹æ¯ä¸ªéƒ¨åˆ†é‡å¤è¿™ä¸ªæ­¥éª¤ï¼Œæœ€åä¸€ä¸ªéƒ¨åˆ†åŒ…å«å…³äºè°ƒæŸ¥çš„é¢å¤–å…ƒæ•°æ®ã€‚å¦‚éœ€ä¸‹è½½è°ƒæŸ¥æŠ¥å‘Šï¼Œè¯·æä¾›å„éƒ¨åˆ†çš„æŒ‡é’ˆã€‚è¿™äº›ç‰‡æ®µæ˜¯ç”±å­˜å‚¨èŠ‚ç‚¹å¹¶è¡Œè¯·æ±‚çš„ã€‚ä¸€æ—¦æ”¶é›†åˆ°è¶³å¤Ÿå¤šçš„ç‰‡æ®µï¼Œå°±å¯ä»¥é˜…è¯»è°ƒæŸ¥æŠ¥å‘Šäº†ã€‚<br>ä¸ºäº†ä¿è¯ç†æ€§èŠ‚ç‚¹ä¹‹é—´çš„åˆä½œï¼ŒStorjæä¾›äº†æ¿€åŠ±æœºåˆ¶ã€‚å¥–åŠ±ç³»ç»Ÿå¥–åŠ±å­˜å‚¨èŠ‚ç‚¹å­˜å‚¨å’Œæä¾›å†…å®¹ã€‚é€šè¿‡å®¡è®¡å’Œå£°èª‰ç³»ç»Ÿå¯¹èŠ‚ç‚¹è¿›è¡Œç›‘æ§å’Œè¯„ä¼°ã€‚Storjçš„ä¸€ä¸ªç›®æ ‡æ˜¯ä½å»¶è¿Ÿï¼Œä»è€Œé¿å…ä¾èµ–åŒºå—é“¾çš„æ¿€åŠ±æœºåˆ¶ã€‚<br>è®¨è®º:ä¸å…¶ä»–P2Pæ•°æ®ç½‘ç»œç›¸æ¯”ï¼ŒStorjä½¿ç”¨äº†ä¸€äº›ç‹¬ç‰¹çš„æ¦‚å¿µã€‚ç‰¹åˆ«æ˜¯ï¼ŒAmazon S3çš„å…¼å®¹æ€§å¯èƒ½ä¼šä¿ƒè¿›Storjæˆä¸ºå»ä¸­å¿ƒåŒ–çš„å­˜å‚¨ç³»ç»Ÿã€‚æ“¦é™¤ç å¢åŠ äº†å­˜å‚¨æ–‡ä»¶çš„å¼€é”€ï¼Œä½†åœ¨æ£€ç´¢æ–‡ä»¶æ—¶ï¼Œåªéœ€è¦ä¸‹è½½å¿…è¦æ•°é‡çš„ç‰‡æ®µã€‚é€šè¿‡æ“¦é™¤ç çš„å­˜å‚¨å»ä¸­å¿ƒåŒ–ï¼Œä»¥åŠè¶³å¤Ÿçš„å­˜å‚¨èŠ‚ç‚¹é€‰æ‹©å’Œå£°èª‰ç³»ç»Ÿçš„å¸®åŠ©ï¼Œå¢åŠ äº†å¯¹æ•°æ®æ³„éœ²çš„ä¿æŠ¤ã€‚<br>å«æ˜ŸèŠ‚ç‚¹æ˜¯ç½‘ç»œçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œå¹¶å¯¹ç½‘ç»œè¿›è¡Œåˆ†åŒºï¼Œå› ä¸ºåœ¨ä¸€é¢—å«æ˜Ÿä¸Šå¯ç”¨çš„æ–‡ä»¶åœ¨å¦ä¸€é¢—å«æ˜Ÿä¸Šä¸å¯ç”¨ã€‚è¿™ä¿ƒè¿›äº†å«æ˜Ÿå½¢å¼çš„é›†ä¸­åŒ–ã€‚è™½ç„¶ç”±äºåŠ å¯†ï¼Œå«æ˜Ÿæ— æ³•ä¸å¯èƒ½çš„ç¬¬ä¸‰æ–¹å…±äº«å…ƒæ•°æ®ï¼Œä½†ä»ç„¶æœ‰å¯èƒ½æ³„éœ²è®¿é—®æ¨¡å¼ã€‚<br>è™½ç„¶å·²ç»éƒ¨ç½²äº†Storjï¼Œå¹¶ä¸”ç¡®å®å¯ä»¥ä½¿ç”¨ï¼Œä½†å…³äºè¯¥ä¸»é¢˜çš„åº”ç”¨ç¨‹åºå’Œç ”ç©¶ç›¸å½“å°‘ã€‚De Figueiredoç­‰äºº[87]åˆ†æäº†Storjç½‘ç»œï¼Œå¹¶å°†å«æ˜ŸèŠ‚ç‚¹è¯†åˆ«ä¸ºæ‹’ç»æœåŠ¡æ”»å‡»çš„å¯èƒ½å‘é‡ã€‚ä»–ä»¬ä¿®æ”¹äº†å­˜å‚¨èŠ‚ç‚¹è¿æ¥å¤„ç†çš„å®ç°ï¼Œåœ¨æµ‹è¯•ç¯å¢ƒä¸­æˆåŠŸæ‹¿ä¸‹äº†ä¸€ä¸ªå«æ˜ŸèŠ‚ç‚¹ï¼Œä½¿å¾—æ”¯ä»˜å’Œæ–‡ä»¶æ£€ç´¢åœ¨ä¸€æ®µæ—¶é—´å†…æ— æ³•å®ç°ã€‚ä½†æ˜¯ï¼Œç”Ÿäº§ç³»ç»Ÿåº”è¯¥èƒ½å¤ŸæŠµæŠ—è¿™ç§æ”»å‡»ã€‚å¦ä¸€é¡¹ç ”ç©¶ä¹Ÿæ˜¾ç¤ºäº†å¯¹æ•°æ®ç½‘ç»œçš„å¦ä¸€ç§æ”»å‡»ã€‚Zhangç­‰äºº[88]æŒ‡å‡ºï¼Œåœ¨Storj v2.0ä¸­ï¼Œå¯ä»¥å°†æœªåŠ å¯†çš„æ•°æ®ä¸Šä¼ åˆ°å­˜å‚¨èŠ‚ç‚¹ï¼Œç”¨äºæ¡†æ¶å­˜å‚¨èŠ‚ç‚¹çš„æ‰€æœ‰è€…ã€‚å°½ç®¡å¦‚æ­¤ï¼ŒStorjæä¾›äº†éšç§ä¿éšœã€å¼¹æ€§ã€å¯è·å–çš„å…ƒæ•°æ®æˆ–æ¯ä¸ªäººéƒ½å¯ä»¥éƒ¨ç½²ä¸åŒèŠ‚ç‚¹çš„å¯èƒ½æ€§ï¼Œè¿™äº›éƒ½å¯ä»¥ä¸ºäº‘å­˜å‚¨æä¾›æœ‰ä»·å€¼çš„è§è§£ã€‚</p><h3 id="E-Arweave"><a href="#E-Arweave" class="headerlink" title="E. Arweave"></a>E. Arweave</h3><p>Arweaveåè®®[19]åˆ©ç”¨äº†ä¸€ç§ç±»ä¼¼åŒºå—é“¾çš„ç»“æ„(ç§°ä¸ºblockweave)ï¼Œä¸ºæ°¸ä¹…çš„é“¾ä¸Šæ•°æ®å­˜å‚¨ä»¥åŠå­˜å‚¨æ”¯ä»˜æä¾›äº†ä¸€ç§æœºåˆ¶ã€‚åœ¨å—ç»„ç»‡ä¸­ï¼Œä¸€ä¸ªå—æŒ‡å‘ç›´æ¥å‰ä¸€ä¸ªå—å’Œå¬å›å—ï¼Œå¬å›å—æ˜¯åŸºäºå‰ä¸€ä¸ªå—çš„ä¿¡æ¯ç¡®å®šåœ°é€‰æ‹©çš„ã€‚è™½ç„¶ç¼–ç»‡æ˜¯ä¸å¯æ”¹å˜çš„ï¼Œå¹¶æä¾›äº†å¯¹å…¶æ•°æ®çš„å®¡æŸ¥é˜»åŠ›ï¼Œä½†æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥å†³å®šæ‹’ç»æ¥å—å†…å®¹ã€‚é€šè¿‡è¶³å¤Ÿå¤šçš„èŠ‚ç‚¹æ‹’ç»å†…å®¹å¯ä»¥é˜²æ­¢åŒ…å«ä¸éœ€è¦çš„å†…å®¹ã€‚<br>Arweaveä½¿ç”¨äº†ä¸€ç§ç±»ä¼¼äºBitTorrentçš„â€œtit-for-tatâ€çš„åè®®Wildfireæ¥ä¸ºåŒè¡Œæ’åã€‚é€šè¿‡Wildfireï¼Œæ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤ä¸€ä¸ªèŠ‚ç‚¹åˆ—è¡¨ï¼Œå¹¶æ ¹æ®èŠ‚ç‚¹çš„å“åº”èƒ½åŠ›(å¦‚å“åº”è¯·æ±‚æˆ–å‘é€äº‹åŠ¡)è¿›è¡Œè¯„åˆ†å’Œæ’åã€‚è¿™ä¸ªåˆ†æ•°åŸºæœ¬ä¸Šæ˜¯ç”±æœ€è¿‘è¯·æ±‚çš„å¹³å‡æ¯ç§’æ¥æ”¶å­—èŠ‚æ•°å†³å®šçš„ã€‚çº§åˆ«é«˜(å› æ­¤æ€§èƒ½æœ€å¥½)çš„å¯¹ç­‰ç‚¹é¦–å…ˆå¹¶è¡Œåœ°æ¥æ”¶æ¶ˆæ¯ï¼Œç„¶åä¾æ¬¡æ¥æ”¶å…¶ä½™çš„æ¶ˆæ¯ã€‚å®šæœŸä¿®å‰ªè¿æ¥åˆ°ä½ç­‰çº§å¯¹ç­‰ä½“çš„è¿æ¥ã€‚è¿™æ¿€åŠ±èŠ‚ç‚¹è‡ªèº«é«˜åº¦å“åº”ï¼Œä»¥å°½å¯èƒ½å¿«çš„é€Ÿåº¦æ¥æ”¶æ¶ˆæ¯ã€‚ä¼˜åŒ–èŠ‚ç‚¹çš„èµ„æºåˆ©ç”¨ç‡ï¼Œå‡å°‘é€šä¿¡æ—¶é—´ã€‚<br>Arweaveçš„æ ¸å¿ƒæ˜¯åŸºäºåŒºå—é“¾çš„ç½‘ç»œã€‚è™½ç„¶é‡ç«å¼•å…¥äº†ä¸€ä¸ªæœ‰åˆ©äºæŸäº›è¿æ¥çš„æ’åï¼Œä½†å®ƒä»ç„¶æ˜¯ä¸€ä¸ªéç»“æ„åŒ–çš„P2Pç½‘ç»œã€‚å›¾10ç»™å‡ºäº†Arweaveçš„æ¦‚å¿µæ¦‚è¿°ä»¥åŠå¦‚ä½•å½’æ¡£/æ£€ç´¢æ–‡ä»¶ã€‚ä¸ºäº†åœ¨Arweaveä¸­å­˜æ¡£è°ƒæŸ¥è®ºæ–‡ï¼Œæœ‰å¿…è¦å°†äº¤æ˜“å‘é€åˆ°ç½‘ç»œä¸Šã€‚å¯¹ç­‰ç‚¹é€šè¿‡å°†è¯¥äº¤æ˜“åŒ…å«åœ¨ä¸€ä¸ªå—ä¸­æ¥ç¡®è®¤è¯¥äº¤æ˜“ã€‚å¦‚æœæœ‰äººæƒ³è¦é˜…è¯»è°ƒæŸ¥ï¼Œç½‘ç»œè¢«è¦æ±‚ã€‚å¦‚æœä¸€ä¸ªå¯¹ç­‰ç‚¹å­˜å‚¨äº†åŒ…å«è°ƒæŸ¥çš„å—ï¼Œå®ƒå¯ä»¥è¢«è¿”å›ï¼Œè°ƒæŸ¥å¯ä»¥è¢«è¯»å–ã€‚</p><p><img src="/images/distributed_storage/image-20220428173237462.png" alt="image-20220428173237462">Arweaveçš„ç›®æ ‡æ˜¯æä¾›æ•°æ®çš„æ°¸ä¹…å­˜å‚¨ï¼Œä»¥ä¸€ç§ä¸å¯å˜çš„æ–¹å¼ä¿å­˜å’Œæ—¶é—´æˆ³ä¿¡æ¯ã€‚æ•°æ®å­˜å‚¨åœ¨åŒºå—ç»„ç»‡çš„é“¾ä¸Šï¼Œå› æ­¤ï¼Œæ˜¯ä¸å¯å˜çš„ï¼Œåªæœ‰é€šè¿‡åˆ†å‰ç»„ç»‡æ‰èƒ½ç§»é™¤ã€‚blockweaveä¸ºæ°¸ä¹…ç½‘ç»œæä¾›äº†å»ä¸­å¿ƒåŒ–å­˜å‚¨ã€‚<br>blockweaveåŠå…¶æ•°æ®çš„å­˜å‚¨å’Œç»´æŠ¤é€šè¿‡Arweaveçš„åŠ å¯†è´§å¸:Arweaveä»£å¸æ¥ç¡®ä¿ã€‚ä»£å¸ç”¨äºå¥–åŠ±çŸ¿å·¥å’Œæ”¯ä»˜å‘é€äº¤æ˜“ã€‚<br>è®¨è®º:Arweaveåè®®åœ¨ç±»ä¼¼åŒºå—é“¾çš„ç»“æ„ä¸Šæä¾›é“¾ä¸Šå­˜å‚¨ã€‚è¿™ä½¿å¾—å­˜å‚¨å…·æœ‰ä¸åŒºå—é“¾ç±»ä¼¼çš„ä¼˜ç‚¹å’Œç¼ºç‚¹ã€‚Arweaveæä¾›æ—¶é—´æˆ³ã€é€æ˜åº¦ã€æ¿€åŠ±æœºåˆ¶å’Œä¸å¯å˜å­˜å‚¨ã€‚æ•°æ®æ˜¯é€šè¿‡æä¾›åŒ¿åæ•°æ®ä½œè€…çš„äº‹åŠ¡å­˜å‚¨çš„ã€‚<br>åŒºå—é“¾æœ€å¤§çš„é—®é¢˜ä¹‹ä¸€æ˜¯å¯æ‰©å±•æ€§ã€‚Arweaveè¯•å›¾é€šè¿‡åŒºå—é˜´å½±(ä¸€ç§ç±»ä¼¼äºç´§å‡‘å—çš„æœºåˆ¶ï¼Œåœ¨æ¯”ç‰¹å¸æ”¹è¿›ææ¡ˆ152[89]ä¸­æœ‰è§£é‡Š)å’Œé‡ç«(ç”¨äºå¿«é€Ÿå—ä¼ æ’­ï¼Œå‡å°‘åˆ†å‰æ¦‚ç‡)æ¥å‡å°‘è¿™äº›é—®é¢˜ã€‚æ­¤å¤–ï¼Œä½¿ç”¨å—å“ˆå¸Œåˆ—è¡¨å’Œé’±åŒ…åˆ—è¡¨å¯ä»¥é™ä½åˆå§‹å‚ä¸æˆæœ¬ã€‚åœ¨2.0ç‰ˆæœ¬ä¸­ï¼ŒArweaveå¼•å…¥äº†ä¸€ä¸ªç¡¬åˆ†å‰æ¥æé«˜å¯ä¼¸ç¼©æ€§ï¼Œå°†æ•°æ®ä¸äº‹åŠ¡åˆ†ç¦»ã€‚åœ¨äº‹åŠ¡ä¸­ä¸åŒ…æ‹¬æ•°æ®ï¼Œè€Œæ˜¯åŒ…æ‹¬æ•°æ®çš„Merkleæ ¹ã€‚è¿™æé«˜äº†äº‹åŠ¡ä¼ æ’­é€Ÿåº¦ï¼Œå› ä¸ºè½¬å‘äº‹åŠ¡ä¸å†éœ€è¦æ•°æ®ã€‚<br>ç”±äºå­˜åœ¨ä¼ªéšæœºå¬å›å—ï¼Œä¸ºäº†ä½¿æŒ–æ˜æ”¶ç›Šæœ€å¤§åŒ–ï¼ŒèŠ‚ç‚¹è¢«æ¿€åŠ±å­˜å‚¨å¤§é‡çš„å—ã€‚è¿™å¢åŠ äº†æ•°æ®çš„å¤åˆ¶ã€‚ç„¶è€Œï¼Œå¹¶ä¸æ˜¯æ¯ä¸ªèŠ‚ç‚¹éƒ½å¿…é¡»å­˜å‚¨æ¯ä¸ªå—æˆ–å†…å®¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹æ ¹æ®å†…å®¹è¿‡æ»¤å™¨ä¸ºè‡ªå·±å†³å®šå­˜å‚¨å“ªäº›æ•°æ®ã€‚è¯·æ±‚å†…å®¹å¯èƒ½ä¼šå˜å¾—å¤æ‚ï¼Œå› ä¸ºèŠ‚ç‚¹æ˜¯éšæœºè¯·æ±‚çš„ï¼Œå¸Œæœ›å®ƒä»¬å­˜å‚¨å†…å®¹ã€‚<br>å¯¹Arweaveçš„ç›´æ¥ç ”ç©¶å¾ˆå°‘ã€‚ç„¶è€Œï¼Œè¿™å¯ä»¥è§£é‡Šä¸ºæ–°å…´çš„åŸºäºåŒºå—é“¾çš„åè®®çš„å¹¿æ³›èŒƒå›´å’ŒåŒºå—é“¾çš„ç ”ç©¶è‡³å°‘å¯ä»¥éƒ¨åˆ†åº”ç”¨äºArweaveã€‚</p><h3 id="F-Honorable-Mentions-and-Related-Concepts"><a href="#F-Honorable-Mentions-and-Related-Concepts" class="headerlink" title="F. Honorable Mentions and Related Concepts"></a>F. Honorable Mentions and Related Concepts</h3><p>åœ¨æˆ‘ä»¬å¯¹é€‰å®šçš„P2Pæ•°æ®ç½‘ç»œçš„è¯¦ç»†æ¦‚è¿°ä¹‹åï¼Œæˆ‘ä»¬æä¾›äº†æœ‰å…³å½“å‰ä¸€ä»£P2Pæ•°æ®ç½‘ç»œçš„å…¶ä»–ç³»ç»Ÿå’Œæ¦‚å¿µçš„å…¶ä»–æ–‡çŒ®ã€‚ç‰¹åˆ«æ˜¯ï¼Œä¸€äº›è®ºæ–‡æ¦‚å¿µä¸ºP2På†…å®¹å…±äº«æä¾›äº†ä¸åŒçš„ã€å¤æ‚çš„æƒ³æ³•ã€‚<br>Sia[90]çš„ç›®æ ‡æ˜¯æˆä¸ºå»ä¸­å¿ƒåŒ–çš„äº‘å­˜å‚¨å¹³å°ã€‚ä¸€ä¸ªæ–‡ä»¶è¢«åˆ†å‰²æˆå¤šä¸ªå—ï¼Œè¿™äº›å—è¢«åŠ å¯†ï¼Œç„¶åé€šè¿‡æ“¦é™¤ç¼–ç å­˜å‚¨åœ¨å¤šä¸ªå­˜å‚¨èŠ‚ç‚¹ä¸Šã€‚å—çš„ä½ç½®å­˜å‚¨ä¸ºå…ƒæ•°æ®ã€‚Siaä½¿ç”¨åŒºå—é“¾æ¥æ¿€åŠ±æ•°æ®çš„å­˜å‚¨å’Œæ£€ç´¢ã€‚æ•°æ®å­˜å‚¨çš„æ¡ä»¶å’ŒæŒç»­æ—¶é—´åœ¨å­˜å‚¨åˆåŒä¸­æ˜¯å›ºå®šçš„ã€‚æ•°æ®æ‰€æœ‰è€…è´Ÿè´£æ–‡ä»¶è¿è¡ŒçŠ¶å†µã€‚<br>OSN (Open Storage Network)[91]æ˜¯ä¸€ä¸ªç”¨äºä¼ è¾“å’Œå…±äº«ç ”ç©¶æ•°æ®çš„åˆ†å¸ƒå¼ç½‘ç»œã€‚å®ƒå¯ä»¥ä¸ä¸“æ³¨äºå¤§é‡ç ”ç©¶æ•°æ®çš„åˆ†å¸ƒå¼äº‘æœåŠ¡ç›¸åª²ç¾ã€‚æ•°æ®å­˜å‚¨åœ¨ä¸­å¤®ç›‘æ§å’Œç»´æŠ¤çš„åŠèˆ±ä¸­ã€‚è¿™äº›OSNåŠèˆ±æ˜¯ä¸“é—¨é…ç½®çš„æœåŠ¡å™¨æœºæ¶ï¼Œéœ€è¦é«˜å¸¦å®½äº’è”ç½‘è¿æ¥ã€‚æƒ³è¦ä¸ºè¿™ä¸ªç½‘ç»œåšå‡ºè´¡çŒ®çš„æœºæ„å¯ä»¥å®‰ç½®è±†èšã€‚å› æ­¤ï¼Œç ”ç©¶äººå‘˜å¯ä»¥åœ¨OSNç½‘ç»œä¸­å­˜å‚¨å’Œå…±äº«ä»–ä»¬çš„ç ”ç©¶æ•°æ®ã€‚OSNåŠèˆ±çš„è¿æ¥æ€§åº”ä¿è¯æ•°æ®çš„å¿«é€Ÿè®¿é—®ã€‚æ•°æ®å¯ä»¥ä¸é€‰å®šçš„å‚ä¸è€…å…±äº«ï¼Œä¹Ÿå¯ä»¥é€šè¿‡å¼€æ”¾è·å–ã€‚å¯¹podsçš„é›†ä¸­ç®¡ç†å’Œä¸¥æ ¼çš„æ¡ä»¶å°†OSNä¸ç°æœ‰çš„å…¶ä»–æ•°æ®ç½‘ç»œåŒºåˆ†å¼€æ¥ï¼Œåˆ†æ•£å’Œä»»æ„å‚ä¸æ˜¯è¿™äº›æ•°æ®ç½‘ç»œçš„ä¸€ä¸ªå…³é”®ç‰¹å¾ã€‚<br>Fukumitsuç­‰äºº[92]æå‡ºäº†ä¸€ç§ç‚¹å¯¹ç‚¹ç±»å‹çš„å­˜å‚¨ç³»ç»Ÿï¼Œåœ¨è¯¥ç³»ç»Ÿä¸­ï¼Œå³ä½¿æ˜¯é‡æ„æ‰€å­˜å‚¨æ–‡ä»¶æ‰€éœ€çš„å…ƒæ•°æ®ä¹Ÿå­˜å‚¨åœ¨ç½‘ç»œä¸­ï¼Œå¯ä»¥é€šè¿‡IDã€å¯†ç å’Œæ—¶é—´æˆ³æ¥æ£€ç´¢ã€‚ä½œè€…å‡è®¾ä¸€ä¸ªéç»“æ„åŒ–çš„P2Pç½‘ç»œï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æä¾›ä¸åŒçš„æœåŠ¡ã€‚èŠ‚ç‚¹å®šæœŸå¹¿æ’­æœ‰å…³è‡ªèº«çš„å¿…è¦ä¿¡æ¯ï¼Œä¾‹å¦‚æä¾›çš„æœåŠ¡åŠå…¶IPåœ°å€ã€‚è¯¥æ–¹æ¡ˆçš„ä¸€ä¸ªé‡è¦ç»„æˆéƒ¨åˆ†æ˜¯å­˜å‚¨åœ¨åŒºå—é“¾ä¸Šçš„å­˜å‚¨èŠ‚ç‚¹åˆ—è¡¨ã€‚å­˜å‚¨èŠ‚ç‚¹åˆ—è¡¨æ˜¯éšæœºé€‰å–çš„æä¾›å­˜å‚¨æœåŠ¡çš„èŠ‚ç‚¹åˆ—è¡¨ã€‚æ•°æ®æŒ‰éƒ¨åˆ†å­˜å‚¨ï¼Œå­˜å‚¨è¿‡ç¨‹åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µ:å­˜å‚¨ç”¨æˆ·æ•°æ®å’Œå­˜å‚¨é‡æ„ç”¨æˆ·æ•°æ®æ‰€éœ€çš„æ•°æ®ã€‚ç”¨æˆ·æ•°æ®è¢«åŠ å¯†ï¼Œåˆ†æˆéƒ¨åˆ†ï¼Œå­˜å‚¨åœ¨å½“å‰å¯ç”¨çš„å­˜å‚¨èŠ‚ç‚¹ä¸­é€‰æ‹©çš„èŠ‚ç‚¹ä¸Šã€‚å¯ä»¥ä½¿ç”¨æ¢å¤é”®è¯·æ±‚éƒ¨ä»¶ã€‚ä¸ºäº†é‡æ„ç”¨æˆ·æ•°æ®ï¼Œéœ€è¦è§£å¯†å¯†é’¥ã€å­˜å‚¨èŠ‚ç‚¹å¯¹å’Œæ¢å¤å¯†é’¥ã€‚å› æ­¤ï¼Œéœ€è¦å°†æ•°æ®å¤åˆ¶åˆ°å…¶ä»–èŠ‚ç‚¹ã€‚ç”¨æˆ·åˆ›å»ºIDã€å¯†ç å¯¹ï¼Œå¹¶é€‰æ‹©å­˜å‚¨åˆ—è¡¨ã€‚æ•°æ®é€šè¿‡IDã€å¯†ç å’Œå­˜å‚¨åˆ—è¡¨çš„æ•£åˆ—è¿›è¡ŒåŠ å¯†ã€‚å­˜å‚¨èŠ‚ç‚¹æ˜¯ä»å­˜å‚¨åˆ—è¡¨ä¸­ç¡®å®šé€‰æ‹©çš„ã€‚éƒ¨ä»¶çš„æ¢å¤é”®æ˜¯å­˜å‚¨åˆ—è¡¨çš„æ•£åˆ—å’Œå—ç´¢å¼•çš„æ•£åˆ—ï¼Œå³IDå’Œå¯†ç ã€‚è¯¥æ–¹æ¡ˆå…è®¸è·å–æ•°æ®ï¼Œè€Œæ— éœ€å°†ä¿¡æ¯å­˜å‚¨åœ¨ç”¨æˆ·è®¾å¤‡ä¸Šã€‚<br>Jiaç­‰äºº[93]æå‡ºäº†ä¸€ç§å®ç°å¥å¿˜RAMéšè—æ•°æ®è®¿é—®æ¨¡å¼çš„æœºåˆ¶â€”â€”oblvp2pã€‚è™½ç„¶ä½œè€…æåˆ°ä»–ä»¬çš„æœºåˆ¶é€‚ç”¨äºå…¶ä»–ç‚¹å¯¹ç‚¹ç³»ç»Ÿï¼Œä½†ä»–ä»¬å…³æ³¨çš„æ˜¯å¸¦æœ‰è·Ÿè¸ªå™¨çš„ç±»ä¼¼BitTorrentçš„ç³»ç»Ÿã€‚<br>Qianç­‰äºº[94]æå‡ºäº†Garlic Castï¼Œä¸€ç§æ”¹å–„è¦†ç›–ç½‘ç»œä¸­åŒ¿åæ€§çš„æœºåˆ¶ã€‚å¯¹ç­‰ç‚¹ä¸ç›´æ¥è¯·æ±‚å’Œæœç´¢å†…å®¹ã€‚ç›¸åï¼Œå¯¹ç­‰ä½“æœç´¢ä»£ç†ï¼Œä»£ç†äº¤æ¢å’Œè¯·æ±‚å†…å®¹ã€‚å¯¹ç­‰ä½“åŠå…¶ä»£ç†ä¹‹é—´çš„æ¶ˆæ¯æ˜¯é€šè¿‡å®‰å…¨å¢å¼ºçš„ä¿¡æ¯åˆ†æ•£ç®—æ³•(IDA)äº¤æ¢çš„ã€‚rdaæ˜¯ä¸€ç§æ“¦é™¤ç¼–ç å½¢å¼ï¼Œå…¶ä¸­ğ‘˜çš„ğ‘›ç‰‡æ®µè¶³ä»¥é‡å»ºå¯¹è±¡ã€‚å®‰å…¨å¢å¼ºçš„IDAé¦–å…ˆå¯¹æ¶ˆæ¯è¿›è¡ŒåŠ å¯†ï¼Œä½¿ç”¨ğ‘˜-threshold IDAå°†æ¶ˆæ¯å’Œå¯†é’¥åˆ†å‰²ä¸ºğ‘›ç‰‡æ®µï¼Œç„¶åå‘é€clovesï¼Œå³åŒ…å«å¯†é’¥å’Œæ¶ˆæ¯ç‰‡æ®µçš„æ¶ˆæ¯ã€‚é€šè¿‡éšæœºæ¸¸èµ°å‘ç°ä»£ç†:ä¸é¦™è¢«å‘é€ç»™å®ƒçš„é‚»å±…ï¼Œè¯·æ±‚å¯¹ç­‰ç‚¹ä½œä¸ºä¸€ä¸ªå…·æœ‰éšæœºä¸é¦™åºåˆ—å·çš„ä»£ç†ï¼Œæ¯ä¸ªé‚»å±…éšæœºè½¬å‘ä¸é¦™ï¼Œå¹¶ç»´æŠ¤ç»§æ‰¿è€…å’Œå‰ä»»çš„çŠ¶æ€ã€‚å…·æœ‰ä¸¤ä¸ªå…·æœ‰ç›¸åŒåºåˆ—å·çš„ä¸é¦™çš„å¯¹ç­‰ä½“å¯ä»¥æ¢å¤è¯·æ±‚ï¼Œå¦‚æœå®ƒè‡ªæ„¿æˆä¸ºå¯¹ç­‰ä½“ï¼Œå®ƒå°†è¿”å›ä¸€ä¸ªå›å¤ç»™è¯·æ±‚è€…ã€‚<br>å…¶ä»–è®ºæ–‡æ¦‚å¿µåˆ©ç”¨åŒºå—é“¾è¿›è¡Œè®¿é—®æ§åˆ¶ï¼Œå¹¶å­˜å‚¨æ•°æ®ä½ç½®ï¼Œè€Œä¸æ˜¯ä½œä¸ºæ¿€åŠ±æœºåˆ¶çš„è¡¥å……ï¼Œå¦‚Blockstack[95]ï¼Œå®ƒåœ¨åŒºå—é“¾ä¸Šç»´æŠ¤å…ƒæ•°æ®ï¼Œå¹¶ä¾èµ–å¤–éƒ¨æ•°æ®å­˜å‚¨æ¥å®é™…å­˜å‚¨æ•°æ®ã€‚ä¹Ÿæœ‰ä½¿ç”¨åˆ†å¸ƒå¼è´¦æœ¬æŠ€æœ¯è¿›è¡Œè®¿é—®æ§åˆ¶çš„æ¦‚å¿µã€‚<br>Calypso[96]ï¼Œå®ƒä½¿ç”¨åŸºäºè·³é“¾çš„èº«ä»½å’Œè®¿é—®ç®¡ç†ï¼Œå…è®¸å¯å®¡è®¡çš„æ•°æ®å…±äº«ã€‚ç„¶è€Œï¼Œè¿™äº›ç³»ç»Ÿå’Œä»…é›†ä¸­äºé€šè¿‡åŒºå—é“¾å‡ºå”®æ•°æ®çš„ç³»ç»Ÿä¸åœ¨æœ¬æ¬¡è°ƒæŸ¥çš„èŒƒå›´ä¹‹å†…ã€‚</p><h2 id="V-DISCUSSION-OF-BUILDING-BLOCKS"><a href="#V-DISCUSSION-OF-BUILDING-BLOCKS" class="headerlink" title="V. DISCUSSION OF BUILDING BLOCKS"></a>V. DISCUSSION OF BUILDING BLOCKS</h2><p><img src="/images/distributed_storage/image-20220428171303982.png" alt="image-20220428171303982"></p><h3 id="A-Performance"><a href="#A-Performance" class="headerlink" title="A. Performance"></a>A. Performance</h3><p>ç³»ç»Ÿæ€§èƒ½çš„ç ”ç©¶å·²ç»æˆä¸ºä¸€äº›ç ”ç©¶è€…æ‰€è¿½æ±‚çš„ç ”ç©¶æ–¹å‘ã€‚é€šè¿‡æ¨¡æ‹Ÿæˆ–æµ‹è¯•æ¥è°ƒæŸ¥æ€§èƒ½ã€è¯»/å†™æ—¶é—´ã€å­˜å‚¨å¼€é”€ã€æ–‡ä»¶æŸ¥æ‰¾ã€æŠ—churné˜»åŠ›ï¼Œå¯ä»¥ç”¨æ¥è¯†åˆ«æ–°çš„ç”¨ä¾‹ï¼Œå¹¶å·©å›ºä¸€ä¸ªç³»ç»Ÿå¯èƒ½å–ä»£é›†ä¸­å¼ç³»ç»Ÿçš„æ–­è¨€ã€‚IPFSå¼€å‘äººå‘˜å¼€å‘äº†â€œTestgroundâ€[103]ï¼Œç”¨äºå¤§è§„æ¨¡æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•P2Pç³»ç»Ÿã€‚ä»è¿™ä¸ªæ„ä¹‰ä¸Šè¯´ï¼ŒTestgroundçš„æ€§èƒ½åŠå…¶å¯¹çœŸå®ç³»ç»Ÿçš„å¤åˆ¶èƒ½åŠ›ä¹Ÿæ˜¯ä¸€ä¸ªå€¼å¾—ç ”ç©¶çš„é¢†åŸŸã€‚ä¹Ÿæœ‰å…¶ä»–åˆ†æIPFSæ€§èƒ½çš„ç ”ç©¶ï¼Œå¦‚è¯»å†™æ—¶å»¶[28,31]ï¼Œä½¿ç”¨IPFSé›†ç¾¤è¿›è¡Œç‰©è”ç½‘æ•°æ®å…±äº«[29]ï¼Œæ”¹è¿›ç³»ç»Ÿ[30,36]ï¼Œæˆ–åˆ†æç½‘ç»œ[34,35,37]ã€‚Heinisuoç­‰äºº[32]è¡¨æ˜ï¼Œç”±äºé«˜ç½‘ç»œæµé‡æ¶ˆè€—ç”µæ± ï¼ŒIPFSéœ€è¦æ”¹è¿›æ‰èƒ½åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šä½¿ç”¨ã€‚å…³äºIPFSç«äº‰å¯¹æ‰‹çš„ç ”ç©¶è¿˜å¾ˆç¼ºä¹ã€‚æ­¤å¤–ï¼ŒNaikå’ŒKeshavamurthy[41]å…³æ³¨çš„ä¸»é¢˜æ˜¯P2Pç½‘ç»œçš„æµå¤±ã€‚æ­¤å¤–ï¼Œè€ƒè™‘åˆ°ç ”ç©¶æ•°æ®çš„å¢åŠ ï¼Œéœ€è¦ç ”ç©¶åœ¨Tera-å’ŒPetabytesèŒƒå›´å†…å»ºç«‹å¤§å‹å•ä¸€æ•°æ®é›†çš„æ•°æ®ç½‘ç»œçš„å¯è¡Œæ€§ã€‚</p><h3 id="B-Confidentiality-and-Access-Control"><a href="#B-Confidentiality-and-Access-Control" class="headerlink" title="B. Confidentiality and Access Control"></a>B. Confidentiality and Access Control</h3><p>è¿‡å»å’Œç°åœ¨çš„æ•°æ®ç½‘ç»œæä¾›äº†ä¸€äº›æœºå¯†æ€§å’Œè®¿é—®æ§åˆ¶ï¼Œä½†è¿™äº›ç³»ç»Ÿæ˜¯ä¸ºå…¬å…±æ•°æ®è€Œä¸æ˜¯ä¸ºç§æœ‰æ•°æ®è®¾è®¡çš„ã€‚éœ€è¦ç ”ç©¶èŠ‚ç‚¹åœ¨å­˜å‚¨æ•°æ®æ—¶æ‰€è·å¾—çš„çŸ¥è¯†ã€‚è¿™ä¸ä»…æ¶‰åŠæ•°æ®å†…å®¹çš„ä¿¡æ¯ï¼Œè¿˜æ¶‰åŠå…ƒæ•°æ®(å¦‚è®¿é—®æ¨¡å¼)ã€‚ç°æœ‰çš„è®¿é—®æ§åˆ¶ç³»ç»Ÿçš„å®‰å…¨æ€§æœ‰å¾…è¿›ä¸€æ­¥ç ”ç©¶ã€‚æœ‰ç ”ç©¶å»ºè®®ä½¿ç”¨åŒºå—é“¾è¿›è¡Œè®¿é—®æ§åˆ¶[22 - 25,64]ï¼Œä½†åŒºå—é“¾çš„ä¸å˜æ€§ä½¿å¾—è¿™å¯¹äºç§äººå’Œä¸ªäººæ•°æ®æ¥è¯´å­˜åœ¨é—®é¢˜ã€‚å…³äºç§æœ‰æ•°æ®çš„å¦ä¸€ä¸ªæ–¹é¢æ˜¯åˆ é™¤æ•°æ®ã€‚è™½ç„¶é˜²æ­¢åˆ é™¤æ•°æ®æœ‰åŠ©äºæŠµåˆ¶å®¡æŸ¥ï¼Œä½†åˆ é™¤ä¸ªäººã€æ¶æ„æˆ–éæ³•æ•°æ®çš„å¯èƒ½æ€§å¯èƒ½æé«˜å¯¹æ•°æ®ç½‘ç»œçš„æ¥å—ç¨‹åº¦ã€‚ä¾‹å¦‚ï¼ŒPolitouç­‰äºº[102]æå‡ºäº†ä¸€ç§IPFSä¸­åˆ é™¤å†…å®¹çš„æœºåˆ¶ã€‚è°ƒæŸ¥å’Œæ”¹è¿›ç°æœ‰ç³»ç»Ÿå¯ä»¥å¢åŠ å¯¹æ•°æ®ç½‘ç»œçš„ä¿¡ä»»ã€‚å¢å¼ºå¯¹æœºå¯†æ€§çš„ä¿¡ä»»å’Œé˜²æ­¢æœªç»æˆæƒçš„è®¿é—®å¯ä»¥æ‰“å¼€è¿™äº›ç³»ç»Ÿæ¥å­˜å‚¨ç§äººå’Œä¸ªäººæ•°æ®ã€‚</p><h3 id="C-Security"><a href="#C-Security" class="headerlink" title="C. Security"></a>C. Security</h3><p>å¯¹äºå®‰å…¨ç ”ç©¶æ¥è¯´ï¼Œè¿™ä¸€é¢†åŸŸçš„å·¥ä½œé€šå¸¸æ˜¯åœ¨å‘ç°å’Œä¿®å¤æ–°çš„æ¼æ´ä¹‹é—´åå¤è¿›è¡Œã€‚æ­¤å¤–ï¼Œç ”ç©¶è¿˜æ¶‰åŠåˆ©ç”¨P2Pæ•°æ®ç½‘ç»œä¸æ¶æ„è½¯ä»¶äº¤æ¢æ•°æ®çš„æ¶æ„æ´»åŠ¨<br>åœ¨å®‰å…¨æ¼æ´æ–¹é¢ï¼ŒPrÃ¼nsterç­‰äºº[33]æŠ«éœ²äº†å¯¹IPFSçš„eclipseæ”»å‡»ï¼ŒDe Figueiredoç­‰äºº[87]æŠ«éœ²äº†å¯¹Storjçš„æµ‹è¯•ç½‘ç»œçš„æ‹’ç»æœåŠ¡æ”»å‡»ã€‚æ­¤å¤–ï¼Œä¸ä»…éœ€è¦ç ”ç©¶å·²çŸ¥çš„æ”»å‡»å‘é‡ï¼Œè¿˜éœ€è¦ç ”ç©¶æ–°çš„æ”»å‡»å‘é‡çš„å­˜åœ¨ã€‚ä¾‹å¦‚ï¼ŒStorjæ‰¿è®¤å­˜åœ¨â€œHonest Geppettoâ€æ”»å‡»çš„å¯èƒ½æ€§ï¼Œå³æ”»å‡»è€…(è¯šå®åœ°)é•¿æ—¶é—´åœ°æ“ä½œè®¸å¤šå­˜å‚¨èŠ‚ç‚¹ï¼Œæœ‰æ•ˆåœ°æ§åˆ¶å¤§éƒ¨åˆ†å­˜å‚¨èƒ½åŠ›ã€‚è¿™ç§æ§åˆ¶å…è®¸å°†æ•°æ®ä½œä¸ºâ€œäººè´¨â€æˆ–ä¸€èˆ¬åœ°å–ä¸‹æ•°æ®ï¼Œä½¿æ•°æ®ç½‘ç»œæ— æ³•æ“ä½œã€‚å¦ä¸€ä¸ªä¾‹å­æ˜¯Frameup[88]ï¼Œå…¶ä¸­æœªåŠ å¯†çš„æ•°æ®å­˜å‚¨åœ¨å­˜å‚¨èŠ‚ç‚¹ä¸Šï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´æ³•å¾‹é—®é¢˜ã€‚å­˜å‚¨ä»»æ„æ•°æ®ä¹Ÿå¯èƒ½ç»™å­˜å‚¨è®¾å¤‡å¸¦æ¥é£é™©ã€‚å®‰å…¨æ˜¯ç ”ç©¶é¢†åŸŸï¼Œæˆ‘ä»¬è§‚å¯ŸIPFSä»¥å¤–çš„ç ”ç©¶ã€‚</p><h3 id="D-Anonymity"><a href="#D-Anonymity" class="headerlink" title="D. Anonymity"></a>D. Anonymity</h3><p>é™¤æ¶‰åŠæ•°æ®å®‰å…¨å’Œéšç§çš„æœºå¯†æ€§å¤–ï¼Œä¿æŠ¤ä¸ªäººéšç§æ˜¯å¦ä¸€ä¸ªç›¸å…³çš„æ–¹é¢;ç‰¹åˆ«æ˜¯åŒ¿åæ€§ï¼Œå®ƒæè¿°çš„æ˜¯æ— æ³•åœ¨ä¸€ç¾¤ä¸ªä½“ä¸­è¯†åˆ«ä¸€ä¸ªä¸ªä½“ï¼Œå³ä¸å¯é“¾æ¥æ€§[104]ã€‚<br>åœ¨åŒ¿åæ–¹é¢ï¼Œæ•°æ®ç½‘ç»œä¸­å¯ä»¥ä¿æŠ¤å„ç§å®ä½“:å†…å®¹åˆ›å»ºè€…ã€å­˜å‚¨èŠ‚ç‚¹å’Œè¯·æ±‚å†…å®¹çš„ç”¨æˆ·ã€‚åœ¨ä¸Šä¸€ä»£æ•°æ®ç½‘ç»œä¸­ï¼Œç‰¹åˆ«æ˜¯Freenet[2]å’ŒGNUnet[105]ç€é‡äºä¿æŠ¤ä¸åŒå®ä½“çš„èº«ä»½ã€‚Baldufç­‰äºº[70]å·²ç»è¡¨æ˜ï¼ŒIPFSé€šè¿‡ç›‘æ§æ•°æ®è¯·æ±‚è¯†åˆ«å†…å®¹è¯·æ±‚è€…ï¼Œä»è€Œç»§ç»­å­˜åœ¨éšç§é—®é¢˜ã€‚<br>ç”±äºæ¿€åŠ±æœºåˆ¶å’Œç”±æ­¤äº§ç”Ÿçš„ä¸ªäººæŒ‡æ§ï¼Œå¾ˆéš¾ä¿è¯åŒ¿åï¼Œå› ä¸ºè‡³å°‘éœ€è¦å‡åã€‚ä¸€æ—¦ä½¿ç”¨äº†æ¿€åŠ±æœºåˆ¶ï¼Œæœ‰å…³è¯·æ±‚è€…çš„ä¿¡æ¯å°±å¾—åˆ°äº†ã€‚è®°å½•äº¤æ˜“çš„åˆ†å¸ƒå¼åˆ†ç±»è´¦ï¼Œä¾‹å¦‚Filecoinã€Ethereum Swarmã€Arweaveï¼Œå¯ä»¥æ­ç¤ºé¢å¤–çš„ä¿¡æ¯ï¼Œå› æ­¤å‚ä¸è€…æ˜¯åŒ¿åçš„ã€‚å½“ä¸€ä¸ªä¸­å¿ƒç»„ä»¶æˆæƒè¯·æ±‚å’Œå¤„ç†æ¿€åŠ±æ—¶ï¼Œä¾‹å¦‚Storjä¸­çš„å«æ˜ŸèŠ‚ç‚¹ï¼Œè¯·æ±‚è€…ã€å­˜å‚¨èŠ‚ç‚¹å’Œä¸­å¿ƒç»„ä»¶ç›¸äº’è®¤è¯†ã€‚åœ¨æ¿€åŠ±è¯·æ±‚çš„æƒ…å†µä¸‹ï¼Œæ˜¾ç¤ºè¯·æ±‚èŠ‚ç‚¹å’Œå­˜å‚¨èŠ‚ç‚¹ã€‚è¯·æ±‚è€…çš„èº«ä»½å¯ä»¥é€šè¿‡è½¬å‘ç­–ç•¥æˆ–ä»£ç†(å¦‚Swarmã€SAFE)éƒ¨åˆ†åœ°å¾—åˆ°ä¿æŠ¤ã€‚<br>ç¬¬ä¸€ä»£æœ‰åƒFreenetè¿™æ ·çš„ç³»ç»Ÿï¼Œæ—¨åœ¨åŒ¿åå’ŒæŠµåˆ¶å®¡æŸ¥ã€‚è¿™ä¸€ä»£çš„åŒ¿åæ€§ä¼¼ä¹è½åäºç¬¬ä¸€ä»£ã€‚å°½ç®¡ä½¿ç”¨mixnetæˆ–Torè¿›è¡ŒåŒ¿åé€šä¿¡å–å¾—äº†è¿›å±•[106]ï¼Œä½†è¿˜æ²¡æœ‰æ•°æ®ç½‘ç»œæä¾›å¼ºåŒ¿åæ€§ã€‚æ€»ä¹‹ï¼Œæä¾›çš„åŒ¿åä¿è¯å’Œè¿›ä¸€æ­¥çš„å¢å¼ºéœ€è¦è°ƒæŸ¥ã€‚è¿™åŒ…æ‹¬åŒ¿åå®ç”¨ç¨‹åºçš„æƒè¡¡å’Œå¯¹ä¸åŒæ”»å‡»è€…æ¨¡å‹çš„åˆ†æã€‚åŒ¿åä¸ä»…å¯¹ä¿æŠ¤ä¸ªäººéšç§å¾ˆé‡è¦ï¼Œè€Œä¸”å¯¹ä¿è¯å£°ç§°çš„æŠµåˆ¶å®¡æŸ¥ä¹Ÿå¾ˆé‡è¦ã€‚å¦‚æœå¯ä»¥å¾ˆå®¹æ˜“åœ°æ¨æ–­å‡ºå­˜å‚¨èŠ‚ç‚¹çš„èº«ä»½ï¼Œé‚£ä¹ˆå³ä½¿ç½‘ç»œä¿æŠ¤ä¸è¢«åˆ é™¤ï¼Œæ‰§æ³•éƒ¨é—¨ä¹Ÿæœ‰å¯èƒ½æ‰§è¡Œ<br>å®¡æŸ¥ã€‚è¿™æ˜¯ä¸€ä¸ªå€¼å¾—å…³æ³¨çš„é—®é¢˜ï¼Œç‰¹åˆ«æ˜¯å¯¹äºåƒSwarmè¿™æ ·çš„ç³»ç»Ÿï¼Œå­˜å‚¨å—çš„ä½ç½®æ˜¯é¢„å…ˆç¡®å®šçš„ï¼ŒèŠ‚ç‚¹èº«ä»½æ˜¯ä¸ä»¥å¤ªåŠå‡åç›¸è¿çš„</p><h3 id="E-Naming"><a href="#E-Naming" class="headerlink" title="E. Naming"></a>E. Naming</h3><p>å‘½åï¼Œç‰¹åˆ«æ˜¯åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­æä¾›äººç±»å¯è¯»çš„åç§°ï¼Œæ˜¯ä¸€ä¸ªå·²çŸ¥çš„æŒ‘æˆ˜ã€‚Zooko â€˜s Triangle[107]æ•æ‰åˆ°äº†è¿™ä¸ªé—®é¢˜åŠå…¶é‚»è¿‘çš„æŒ‘æˆ˜ã€‚å®ƒæè¿°äº†æ„å»ºåˆ†å¸ƒå¼å‘½åç©ºé—´çš„å›°éš¾ï¼Œåˆ†å¸ƒå¼å‘½åç©ºé—´æ˜¯åˆ†å¸ƒå¼çš„(æ²¡æœ‰ä¸­å¤®æƒå¨)ã€å®‰å…¨çš„(æ¸…æ™°çš„è§£æ)å’Œäººç±»å¯è¯»çš„ã€‚<br>åœ¨æ‰€æœ‰ç³»ç»Ÿä¸­ï¼Œæ•°æ®çš„å¯»å€è¦ä¹ˆç¼ºä¹åˆ†å¸ƒæ€§(åŸºäºè·Ÿè¸ªå™¨çš„BitTorrentå’ŒStorj)ï¼Œè¦ä¹ˆç¼ºä¹äººç±»å¯è¯»æ€§(æ— è·Ÿè¸ªå™¨çš„BitTorrentã€Hypercoreã€IPFSã€Swarmå’ŒSAFE)ã€‚BitTorrentæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­ï¼Œè·Ÿè¸ªå™¨æ˜¯ä¸€ä¸ªä¸­å¤®æƒå¨ï¼Œåœ¨æ— è·Ÿè¸ªçš„BitTorrentçš„æƒ…å†µä¸‹ï¼Œäººç±»å¯è¯»çš„ç§å­æ˜¯ç”¨ä¸å¤ªå¯è¯»çš„ä¿¡æ¯å“ˆå¸Œ(ç§å­çš„å“ˆå¸Œ)è§£å†³çš„ã€‚åœ¨Storjçš„3.0ç‰ˆæœ¬ä¸­ï¼Œå«æ˜Ÿæ˜¯ä¸€ä¸ªä¸­å¿ƒç»„ä»¶ã€‚<br>ç¼ºä¹å¯è¯»æ€§æ˜¯è‡ªè®¤è¯æ•°æ®çš„ç»“æœï¼Œå…¶ä¸­æ•°æ®å†³å®šäº†æ•°æ®çš„åœ°å€æˆ–åç§°ã€‚æ•°æ®å˜æ›´åï¼Œåœ°å€ä¹Ÿéšä¹‹å˜æ›´ã€‚å› æ­¤ï¼Œé€šè¿‡ä¸åŒçš„æœºåˆ¶(ç‹¬ç«‹äºå†…å®¹çš„å‘½å)æ¥æ”¯æŒäººç±»çš„å¯è¯»æ€§ã€‚Hy- percoreæ˜¯ä¸€ä¸ªä¾‹å¤–ã€‚åœ¨Hypercoreä¸­ï¼Œæ•°æ®ç»„è¢«ç»‘å®šåˆ°å…¬é’¥ï¼Œå¹¶ä¸”é€šè¿‡ç‰ˆæœ¬æ§åˆ¶æ¥ä¿æŠ¤ç»„å†…çš„å¯å˜æ€§ã€‚<br>æä¾›äººç±»å¯è¯»æ€§çš„ä¸€ä¸ªè§£å†³æ–¹æ¡ˆæ˜¯åç§°è§£æã€‚åç§°è§£æå…è®¸å°†å¯†é’¥æ˜ å°„åˆ°è‡ªæˆ‘è®¤è¯çš„å†…å®¹ã€‚åç§°è§£æå¯ä»¥æä¾›äººç±»çš„å¯è¯»æ€§ï¼Œå¹¶æä¾›å¯¹æ–‡ä»¶ç‰ˆæœ¬æ§åˆ¶çš„æ”¯æŒã€‚ç„¶è€Œï¼Œç”±äºæ›´æ–°å€¼çš„å¯èƒ½æ€§å’Œä¼ æ’­çš„å»¶è¿Ÿï¼Œå³ä½¿å¯†é’¥æ˜¯å”¯ä¸€çš„ï¼Œäººä»¬ä¹Ÿä¼šè®¤ä¸ºå®‰å…¨æ€§è¢«ç ´åäº†ã€‚åç§°è§£æç‹¬ç«‹äºZooko â€˜s Triangleï¼Œå®£å¸ƒå†…å®¹ï¼Œå¹¶ç»™å‡ºæ¨¡æ£±ä¸¤å¯çš„å­—ç¬¦ä¸²å«ä¹‰ï¼Œåº”è¯¥åªç”¨äºå…¬å…±æ•°æ®ï¼Œé™¤éåç§°è§£ææä¾›è®¿é—®æ§åˆ¶ã€‚<br>ä¸ºæ­¤ï¼ŒIPFSã€Swarmå’ŒSAFEæä¾›äº†æŸç§å‘½åæœåŠ¡ã€‚å®é™…ä¸Šï¼ŒIPFSæä¾›äº†ä¸¤ç§å‘½åæœåŠ¡:IPNSå’ŒDNSLinkï¼Œç”¨äºä¸åŒçš„ç›®çš„ã€‚IPNSç”¨äºå°†å…¬é’¥çš„å“ˆå¸Œæ˜ å°„åˆ°IPFS CIDï¼Œå…è®¸å¯å˜æ•°æ®ã€‚DNSLinkä½¿ç”¨DNS TXTè®°å½•å®ç°åŸŸååˆ°IPFSåœ°å€çš„æ˜ å°„ã€‚<br>Swarmè¿˜æä¾›äº†ä¸¤ç§å‘½åç³»ç»Ÿ:single-owner chunkå’ŒENS[79]ã€‚å•æ‰€æœ‰è€…å—æä¾›äº†åŸºäºæ‰€æœ‰è€…å’Œæ ‡è¯†ç¬¦çš„æ•°æ®æ ‡è¯†ï¼Œæä¾›äº†ä¸€ä¸ªå®‰å…¨çš„ã€éäººç±»å¯è¯»çš„é”®å’Œä¸€ä¸ªå¯æ›´æ–°çš„å€¼ã€‚ä»¥å¤ªåŠåç§°ç³»ç»Ÿç±»ä¼¼äºDNSï¼Œå…¶ä¸­ä¸€æ¡è®°å½•è¢«æ˜ å°„åˆ°ä¸€ä¸ªåœ°å€ã€‚<br>Swartz[108]è®¤ä¸ºï¼ŒåŸºäºåŒºå—é“¾çš„åç§°æœåŠ¡æä¾›äº†Zookoä¸‰è§’å½¢çš„æ‰€æœ‰ä¸‰ä¸ªå±æ€§ã€‚ä»»ä½•äººéƒ½å¯ä»¥åœ¨æä¾›å»ä¸­å¿ƒåŒ–çš„åŒºå—é“¾ä¸Šæ³¨å†Œåç§°ï¼Œåç§°å¯ä»¥æ˜¯ä»»ä½•æä¾›äººç±»å¯è¯»æ€§çš„åç§°ï¼Œè€Œé˜²ç¯¡æ”¹åˆ†ç±»å¸ç¡®ä¿æä¾›å®‰å…¨æ€§çš„å”¯ä¸€åç§°ã€‚æ ¹æ®è¿™ä¸€è®ºç‚¹ï¼ŒåƒName- coinã€Blockstack[95]å’ŒENSè¿™æ ·çš„ç³»ç»Ÿè¢«å¼€å‘å‡ºæ¥ï¼Œå®ƒä»¬é‡‡ç”¨äº†åŸºäºåŒºå—é“¾çš„åç§°ç³»ç»Ÿçš„æ€æƒ³ã€‚è™½ç„¶è¿™äº›ç³»ç»Ÿçš„å­˜åœ¨ï¼Œé™¤äº†å¸¦æœ‰ENSçš„ç¾¤ç³»ç»Ÿï¼Œä¼¼ä¹æ²¡æœ‰ä¸€ä¸ªç³»ç»Ÿèƒ½è§£å†³Zookoçš„ä¸‰è§’å½¢é—®é¢˜ã€‚ç„¶è€Œï¼Œç”±äºç¼ºä¹äº¤æ˜“æœ€ç»ˆæ€§å’Œå¯èƒ½çš„åŒºå—é“¾åˆ†å‰ï¼Œå¯ä»¥è®¤ä¸ºåŸºäºåŒºå—é“¾çš„ç³»ç»Ÿè¿åäº†å¼ºå¤§çš„å®‰å…¨æ–¹é¢ï¼Œåªæä¾›æœ€ç»ˆå®‰å…¨æ€§ã€‚</p><h2 id="VII-CONCLUSION-AND-LESSONS-LEARNED"><a href="#VII-CONCLUSION-AND-LESSONS-LEARNED" class="headerlink" title="VII. CONCLUSION AND LESSONS LEARNED"></a>VII. CONCLUSION AND LESSONS LEARNED</h2><p>ç¬¬ä¸€ä»£P2Pæ•°æ®ç½‘ç»œå‘Šè¯‰æˆ‘ä»¬ï¼ŒP2Pé©±åŠ¨çš„æ–‡ä»¶äº¤æ¢æ˜¯å¯è¡Œçš„ï¼Œå¹¶ä¸”æœ‰ä¸€äº›ä¸»è¦çš„ä¼˜åŠ¿ï¼Œä¾‹å¦‚ï¼Œè‡ªæ‰©å±•æ€§ã€‚è¿™é¡¹æŠ€æœ¯æŒç»­å­˜åœ¨çš„å¦ä¸€ä¸ªæŒ‡æ ‡æ˜¯BitTorrentçš„æŒç»­å­˜åœ¨å’Œå¹¿æ³›çš„ç”¨æˆ·åŸºç¡€ã€‚ç„¶è€Œï¼Œç¬¬ä¸€ä»£ä¹Ÿæ•™ä¼šäº†æˆ‘ä»¬å¼±ç‚¹ï¼Œä¾‹å¦‚ï¼Œç¼ºä¹é•¿æœŸå¯ç”¨æ€§ã€‚ä¸‹ä¸€ä»£æ•°æ®ç½‘ç»œå»ºç«‹åœ¨ä¸Šä¸€ä»£æ•°æ®ç½‘ç»œçš„åŸºç¡€ä¸Šå¹¶åŠ ä»¥æ”¹è¿›ï¼Œåˆ©ç”¨æŠ€æœ¯è¿›æ­¥å’Œæ¦‚å¿µæ¥è§£å†³å¼±ç‚¹ã€‚</p><p>åœ¨è¿™ç¯‡è°ƒæŸ¥è®ºæ–‡ä¸­ï¼Œæˆ‘ä»¬ç ”ç©¶äº†æ–°å…´çš„æ–°ä¸€ä»£P2Pæ•°æ®ç½‘ç»œã€‚ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬è°ƒæŸ¥äº†æ–°çš„å‘å±•å’ŒæŠ€æœ¯æ„ä»¶ã€‚ä»æˆ‘ä»¬çš„å®šæ€§æ¯”è¾ƒä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºç»“è®ºï¼Œé™¤äº†è¦†ç›–ç»“æ„ä¹‹å¤–ï¼Œå„ç§æ•°æ®ç½‘ç»œåœ¨æ–‡ä»¶ç®¡ç†ã€å¯ç”¨æ€§å’Œæ¿€åŠ±æ–¹é¢æ¢ç´¢äº†ä¸åŒçš„è§£å†³æ–¹æ¡ˆã€‚æœ€å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæ˜¾æ€§æ¿€åŠ±æœºåˆ¶ï¼Œå¦‚ä½¿ç”¨åŠ å¯†è´§å¸æˆ–æŸç§ä»£å¸ï¼Œä¼¼ä¹æ— å¤„ä¸åœ¨ï¼Œä»¥ç¡®ä¿é•¿æœŸå¯ç”¨æ€§å’Œå‚ä¸è€…çš„å‚ä¸ã€‚æˆ‘ä»¬è¿˜çœ‹åˆ°äº†ä¸åŒçš„åº¦é‡æ–¹æ³•ï¼Œä»¥ç¡®ä¿åœ¨é¢å¯¹æ‹’ç»æœåŠ¡æ”»å‡»æˆ–è¶…è¶Šæ¿€åŠ±æœºåˆ¶çš„æµå¤±æ—¶çš„å¯ç”¨æ€§ï¼Œå³å¤åˆ¶ã€æ“¦é™¤ç ï¼Œç”šè‡³ä¸¤è€…çš„ç»“åˆã€‚æ­¤å¤–ï¼Œç”±äºè®¸å¤šç³»ç»Ÿåœ¨åˆ†å¸ƒå¼ä½“ç³»ç»“æ„ä¸­ç»“åˆäº†å‘½åæœåŠ¡å’Œå†…å®¹å¯»å€ï¼Œå®ƒä»¬æœ‰å¯èƒ½åƒZookoçš„ä¸‰è§’å½¢é‚£æ ·åè°ƒäººç±»çš„å¯è¯»æ€§ã€å®‰å…¨æ€§å’Œåˆ†æ•£æ€§ç­‰ç³»ç»Ÿå±æ€§ã€‚<br>ç°åœ¨ä¸€ä¸ªé‡è¦çš„å¼€æ”¾ä»»åŠ¡æ˜¯è°ƒæŸ¥å’Œè¯„ä¼°å„ç§æ„å»ºå—ã€‚ç‰¹åˆ«æ˜¯ï¼Œæ¿€åŠ±æœºåˆ¶çš„è®¾è®¡æ˜¯å‡ºäº†åçš„å›°éš¾ã€‚åœ¨æŸç§ç¨‹åº¦ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å°†P2Pæ•°æ®ç½‘ç»œçš„ä¸åŒéƒ¨ç½²è§†ä¸ºä¸€ä¸ªå¤§å‹ç°åœºæµ‹è¯•ï¼Œåœ¨é‚£é‡Œæˆ‘ä»¬å¯ä»¥è§‚å¯ŸæŸäº›è®¾è®¡å†³ç­–çš„å½±å“ã€‚æ€»çš„æ¥è¯´ï¼Œæ— è®ºæ˜¯ä½œä¸ºå…¶ä»–åº”ç”¨çš„åŸºç¡€ï¼Œè¿˜æ˜¯ä½œä¸ºç ”ç©¶å¯¹è±¡æœ¬èº«ï¼ŒP2Pæ•°æ®ç½‘ç»œå·²ç»æˆä¸ºç ”ç©¶è®®ç¨‹çš„ä¸€éƒ¨åˆ†ã€‚<br>ç„¶è€Œï¼Œè®¸å¤šæŒ‘æˆ˜å’Œå¼€æ”¾çš„ç ”ç©¶é—®é¢˜ä»ç„¶å­˜åœ¨ï¼Œä¾‹å¦‚ï¼Œè°ƒæŸ¥åŒ¿åæ€§ï¼Œå‚ä¸è€…çš„éšç§å’Œè®¿é—®æ§åˆ¶ï¼Œå¼€æ”¾P2Pæ•°æ®ç½‘ç»œåˆ°æ›´å¹¿æ³›çš„å¯èƒ½çš„ç”¨ä¾‹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ç›¸ä¿¡æ–°ä¸€ä»£çš„P2Pæ•°æ®ç½‘ç»œä¸ºæœªæ¥çš„ç ”ç©¶æä¾›äº†è®¸å¤šä»¤äººå…´å¥‹çš„æœºä¼šã€‚</p><p>æ¨èé˜…è¯»ï¼š</p><ol><li><a href="https://www.youtube.com/watch?v=jp0bF9Qu2Jw">Vol 075 åˆ«å†é—®æˆ‘ä»€ä¹ˆå« BT ç§å­</a></li><li>åŸè®ºæ–‡é“¾æ¥ï¼š<a href="https://ieeexplore.ieee.org/abstract/document/9684521">https://ieeexplore.ieee.org/abstract/document/9684521</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>åŸºäºUbuntu20.04æ­å»ºå•æœºFabric2.3.0Raftå…±è¯†æµ‹è¯•ç½‘ç»œ</title>
      <link href="/2022/04/17/blockchain/fabric/%E5%9F%BA%E4%BA%8ERaft%E5%85%B1%E8%AF%86%E6%90%AD%E5%BB%BA%E5%8D%95%E6%9C%BAFabric2.3%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/04/17/blockchain/fabric/%E5%9F%BA%E4%BA%8ERaft%E5%85%B1%E8%AF%86%E6%90%AD%E5%BB%BA%E5%8D%95%E6%9C%BAFabric2.3%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Enter the password to read.">    <label for="pass">Enter the password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> éƒ¨ç½²æ–‡æ¡£ </tag>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arweave â€“ ä¸€ç§ç±»åŒºå—é“¾çš„åŒºå—ç¼–ç»‡ç»“æ„ï¼ˆLightpaperï¼‰</title>
      <link href="/2022/04/12/blockchain/arweave/Arweave_%E4%B8%80%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%8C%BA%E5%9D%97%E7%BC%96%E7%BB%87%E7%BB%93%E6%9E%84(Lightpaper)/"/>
      <url>/2022/04/12/blockchain/arweave/Arweave_%E4%B8%80%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%8C%BA%E5%9D%97%E7%BC%96%E7%BB%87%E7%BB%93%E6%9E%84(Lightpaper)/</url>
      
        <content type="html"><![CDATA[<p>è½¬è½½ï¼š<a href="http://ipfsdrop.com/docs/whitepaper/arweave-lightpaper/">http://ipfsdrop.com/docs/whitepaper/arweave-lightpaper/</a></p><h2 id="æ‘˜è¦"><a href="#æ‘˜è¦" class="headerlink" title="æ‘˜è¦"></a>æ‘˜è¦</h2><p>ç»å…¸çš„åŒºå—é“¾åœ¨æ•°æ®å­˜å‚¨æ–¹é¢å­˜åœ¨å‡ ä¸ªä¼—æ‰€å‘¨çŸ¥çš„ä¸»è¦é—®é¢˜ã€‚è¿™äº›é—®é¢˜éœ€è¦å°†æ–°çš„ç¬¬ä¸‰æ–¹åè®®é›†æˆåˆ°ç°æœ‰åŒºå—é“¾çš„ä¸Šå±‚ï¼Œå› ä¸ºè´¹ç”¨å¤ªé«˜ï¼Œæ— æ³•è¿›è¡Œé“¾ä¸Šå­˜å‚¨ã€‚å› æ­¤ï¼Œå¯¹äºç»å…¸çš„åŒºå—é“¾æ¥è¯´ï¼Œè®¿é—®å†…å®¹å§‹ç»ˆä¼šäº§ç”Ÿæˆæœ¬ï¼Œè€Œä¸”å†…å®¹æ°¸è¿œä¸ä¼šæ°¸ä¹…å­˜å‚¨Â­ã€‚éšç€å¯¹æ•°æ®å­˜å‚¨çš„éœ€æ±‚å‘ˆæŒ‡æ•°å¢é•¿ï¼Œå¯¹å¯æ‰©å±•çš„åˆ†å¸ƒå¼ä½æˆæœ¬æ•°æ®å­˜å‚¨åè®®çš„éœ€æ±‚æ˜¯å¿…è¦çš„ã€‚</p><p>åœ¨è¿™é¡¹å·¥ä½œä¸­ï¼Œæˆ‘ä»¬ä»‹ç»Arweaveâ€”â€”ä¸€ç§ç±»åŒºå—é“¾çš„åŒºå—ç¼–ç»‡ç»“æ„ã€‚åŒºå—ç¼–ç»‡æ˜¯ä¸€ä¸ªå¹³å°Â­ï¼Œè‡´åŠ›äºé¦–æ¬¡ä»¥ç»æµé«˜æ•ˆçš„æ–¹å¼æä¾›å¯æ‰©å±•çš„é“¾ä¸Šå­˜å‚¨ã€‚éšç€ç³»ç»Ÿä¸­å­˜å‚¨çš„æ•°æ®é‡çš„å¢åŠ ï¼Œè¾¾æˆå…±è¯†æ‰€éœ€çš„å“ˆå¸Œå€¼å‡å°‘ï¼Œä»è€Œé™ä½äº†å­˜å‚¨æ•°æ®çš„æˆæœ¬ã€‚è¯¥åè®®ç°æœ‰çš„REST APIä½¿å¾—åœ¨åŒºå—ç¼–ç»‡ä¸Šå±‚æ„å»ºå»ä¸­å¿ƒåŒ–çš„åº”ç”¨ç¨‹åºÂ­ååˆ†ç®€å•ï¼Œåæ˜ äº†Arweaveå¯¹å¼€å‘è€…ç¤¾åŒºçš„å…³æ³¨åŠå…¶æ¨åŠ¨é‡‡ç”¨æ–°å…´å’Œæ–°é¢–åè®®çš„èƒ½åŠ›ã€‚</p><p>åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬è¿˜ä»‹ç»äº†æ–°é¢–çš„æ¦‚å¿µÂ­è¯¸å¦‚ã€ŒåŒºå—é˜´å½±ï¼ˆblock-shadowingï¼‰ã€â€”â€”ä¸€ç§çµæ´»çš„äº¤æ˜“åŒºå—åˆ†é…ç®—æ³•â€”â€”Â­æ”¹è¿›äº†å…¶ä»–åŒºå—é“¾çš„ç°æœ‰â€œåˆ†ç‰‡â€æŠ€æœ¯Â­ä¼˜åŒ–ç½‘ç»œæ‹“æ‰‘ï¼Œå¹¶å¸¦æ¥æ–°çš„å…±è¯†æœºåˆ¶ï¼Œç§°ä¸ºè®¿é—®è¯æ˜ï¼ˆProof of Accessï¼‰ã€‚</p><h2 id="1-å¯¼è¯­ï¼ˆIntroductionï¼‰"><a href="#1-å¯¼è¯­ï¼ˆIntroductionï¼‰" class="headerlink" title="1. å¯¼è¯­ï¼ˆIntroductionï¼‰"></a>1. å¯¼è¯­ï¼ˆIntroductionï¼‰</h2><p>åœ¨è¿™ä¸ªä¿¡æ¯æ—¶ä»£ï¼Œæˆ‘ä»¬å¸¸å¸¸å±ˆæœäºä¸€ç§å¹»æƒ³ï¼Œå³ä¿¡æ¯è¢«è¯»å–Â­å¯ç”¨ï¼Œå®ƒæ°¸è¿œä¸ä¼šè¢«æ›´æ”¹æˆ–ä¸¢å¤±ã€‚ä»æ ¹æœ¬ä¸Šè®²è¿™æ˜¯ä¸æ­£ç¡®çš„[7]ã€‚åœ¨äº’è”ç½‘ä¸Šï¼Œæˆ‘ä»¬å»ºç«‹äº†ä¸€ä¸ªå·¨å¤§çš„å»ä¸­å¿ƒåŒ–ä¿¡æ¯ä¼ æ’­ç³»ç»ŸÂ­ä¿¡æ¯ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰å»ºç«‹ä¸€ä¸ªå¯¹åº”çš„Â­æ°¸ä¹…çŸ¥è¯†å­˜å‚¨ç³»ç»Ÿã€‚ç°ä»£å†å²æœ‰éå¸¸å¤šçš„ä¾‹å­â€”â€”Â­ä»å›¾ä¹¦é¦†å’Œæ¡£æ¡ˆé¦†çš„å¤§ç«[9ï¼Œ10ï¼Œ3ï¼Œ8]åˆ°ä¸“åˆ¶å›½å®¶çš„ä¹¦ç±ç‡ƒçƒ§ï¼ˆç„šä¹¦å‘å„’ï¼‰[12ï¼Œ11]ï¼Œé‡è¦ä¿¡æ¯çš„æ„å»ºå’Œä¸¢å¤±ã€‚å½“æˆ‘ä»¬åœ¨äº’è”ç½‘ä¸ŠæŸ¥è¯¢ä¿¡æ¯æ—¶Â­ï¼Œæˆ‘ä»¬ä¾èµ–äºè¢«å…è®¸è®¿é—®è¢«é›†ä¸­å­˜å‚¨çš„è¯¥æ•°æ®ã€‚Â­æ‹¥æœ‰æ­¤ä¿¡æ¯çš„æœåŠ¡å™¨çš„è®¿é—®Â­æ‰€æœ‰è€…å¯ä»¥éšæ—¶æ’¤æ¶ˆè¯¥è®¸å¯ã€‚åŒæ ·ï¼Œç”±äºåœ¨Internetä¸Šæä¾›ä¿¡æ¯éœ€è¦æ”¯ä»˜æœåŠ¡å™¨è´¹ç”¨å’Œç»´æŠ¤è´¹ç”¨ï¼Œå› æ­¤å½“èµ„é‡‘ä¸è¶³æ—¶ï¼Œç½‘ç«™é€šå¸¸ä¼šè½»æ˜“åœ°æ¶ˆå¤±ã€‚</p><p>æ›´è¿›ä¸€æ­¥ï¼Œè®¸å¤šæ”¿åºœæ­£åœ¨é‡‡å–è¶Šæ¥è¶Šå¤šçš„æ­¥éª¤æ¥å®¡æŸ¥å’Œåˆ é™¤å¯¹äº’è”ç½‘ä¸Šæ”¿æ²»æ•æ„Ÿä¿¡æ¯çš„è®¿é—®[13ã€5ã€4]ã€‚ä¸åª’ä½“å’Œæ–°é—»æœºæ„ä¸€æ ·ï¼Œæˆ‘ä»¬æ›¾ç»æ‹¥æœ‰å®ä½“å’Œä¸å¯æ’¤é”€çš„å‰¯æœ¬ï¼Œç°åœ¨æˆ‘ä»¬Â­å•çº¯åœ°è®¿é—®ä¿¡æ¯ï¼Œç„¶åå°†å…¶ä¸¢å¼ƒã€‚éšç€æ—¶é—´çš„æ¨ç§»ï¼Œåª’ä½“ç»„ç»‡æ›´æ–°å…¶æ–‡ç« çš„å†…å®¹å·²å˜å¾—å¸ç©ºè§æƒ¯ã€‚è™½ç„¶è¿™æä¾›äº†ä¸€äº›Â­ä¸ä»¥å‰çš„ç³»ç»Ÿç›¸æ¯”ï¼Œå®ƒå…·æœ‰è®¸å¤šä¼˜ç‚¹ï¼Œæœ€æ˜¾ç€çš„æ˜¯ï¼Œå®ƒå¯ä»¥ä¼ æ’­æœ‰å…³å±•å¼€æƒ…å†µçš„å®æ—¶æ›´æ–°ï¼Œè¿˜å¯ä»¥ä½¿é‡è¦çš„ä¸Šä¸‹æ–‡ä¸¢å¤±æˆ–å˜å¾—æ¨¡ç³Šã€‚</p><h2 id="2-èƒŒæ™¯ï¼ˆBackgroundï¼‰"><a href="#2-èƒŒæ™¯ï¼ˆBackgroundï¼‰" class="headerlink" title="2. èƒŒæ™¯ï¼ˆBackgroundï¼‰"></a>2. èƒŒæ™¯ï¼ˆBackgroundï¼‰</h2><p>æ‰€æœ‰åŒºå—é“¾åˆ›æ–°éƒ½ç«™åœ¨å·¨äººçš„è‚©è†€ä¸Šï¼ŒåŒ…æ‹¬æ¯”ç‰¹å¸æœ¬èº«ï¼Œæ•°æ®ç»“æ„äº¤å“æ›²ï¼Œåˆ†å¸ƒå¼ç½‘ç»œå·¥ä½œå’Œå¯†ç å­¦ã€‚æˆ‘ä»¬ä¹Ÿè¯•å›¾æ‰©å¤§ç©ºé—´ï¼Œè§£å†³ç°æœ‰åŒºå—é“¾ç½‘ç»œçš„ç‰¹å®šç¼ºç‚¹ï¼Œå³å­˜å‚¨ï¼Œå¹¶é‡‡ç”¨ä¸€ç§æ–°é¢–çš„äº¤æ˜“é€Ÿåº¦æ–¹æ³•ã€‚å¦‚ä»Šï¼Œå¤§å¤šæ•°åŒºå—é“¾æŠ€æœ¯éƒ½åšæŒè®¤ä¸ºï¼Œâ€œå…¨èŠ‚ç‚¹â€å¿…é¡»ç»´æŠ¤æ•´ä¸ªåŒºå—é“¾çš„å‰¯æœ¬ä»¥éªŒè¯æœªæ¥çš„äº¤æ˜“ï¼Œè€Œä½¿ä¹‹æˆä¸ºå¯èƒ½çš„Merkleæ•°æ®ç»“æ„æœ¬èº«å°±æ˜¯ä¸€é¡¹äº†ä¸èµ·çš„å£®ä¸¾ï¼Œå¹¶å¢åŠ äº†æ— ä¸ä¼¦æ¯”çš„å®‰å…¨æ€§ï¼Œæˆ‘ä»¬è®¤ä¸ºå›´ç»•æ­¤è¿‡ç¨‹çš„ä¸€äº›æ€§èƒ½å¢å¼ºå¯ä»¥å‡è½»æ•´ä¸ªèŠ‚ç‚¹çš„åŒæ­¥è´Ÿæ‹…ï¼Œåœ¨ç¬¬4èŠ‚ä¸­ä»‹ç»äº†è§£å†³å—ï¼ŒèŠ‚ç‚¹å’Œé’±åŒ…åŒæ­¥çš„å‡ ç§æŠ€æœ¯ã€‚</p><p>å½“æ¶‰åŠåˆ°å­˜å‚¨æ•°æ®æ—¶ï¼Œå®Œæ•´çš„åŒºå—é“¾è¦æ±‚å¯èƒ½ç”šè‡³æ˜¯ç°æœ‰åŒºå—é“¾æŠ€æœ¯çš„éšœç¢ã€‚åœ¨ä»¥å¤ªåŠï¼ˆä¸€ç§å»ä¸­å¿ƒåŒ–çš„ä¸–ç•Œè®¡ç®—æœºï¼‰çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨å…¶æœ¬æœºä»¤ç‰Œçš„å­˜å‚¨æˆæœ¬ä»¤äººéš¾ä»¥ç½®ä¿¡ã€‚ Arweaveçš„ä¸»è¦åŠ¨æœºæ˜¯ä»¥ä¸ä»¥å¤ªåŠä¸­è¡¨ç¤ºçš„æ–¹å¼ç›¸åŒçš„æ–¹å¼å®ç°æ°¸ä¹…ï¼Œä¸å˜çš„å­˜å‚¨ã€‚ä½†æ˜¯ï¼Œé«˜æ˜‚çš„è´¹ç”¨ä½¿è¿™ç§å­˜å‚¨å˜å¾—è¶Šæ¥è¶Šä¸åˆ‡å®é™…ã€‚è™½ç„¶å¯ä»¥åœ¨ä»¥å¤ªåŠä¸Šå­˜å‚¨æ•°æ®ï¼Œä½†æ˜¯ç”±äºæ•°æ®å­˜å‚¨æˆæœ¬ï¼Œå…ˆå‰çš„å°è¯•æ˜¯ä¸åˆ‡å®é™…çš„ã€‚</p><p>å…¶ä»–åŒºå—é“¾æŠ€æœ¯ä¸“æ³¨äºæ”¹å–„èŠ‚ç‚¹ä¹‹é—´çš„å…±è¯†ç®—æ³•ï¼Œç‰¹åˆ«æ˜¯Stellar Lumenså’ŒAPoå’ŒNeoç­‰dPosæ¶æ„ã€‚å°½ç®¡è¿™å¯ä»¥æé«˜äº‹åŠ¡å¤„ç†é€Ÿåº¦ï¼Œä½†å­˜å‚¨è´Ÿæ‹…ä»ç„¶æ˜¯è®¸å¤šæ­¤ç±»ç½‘ç»œå°†é¢ä¸´çš„é•¿æœŸéšœç¢ã€‚é€šè¿‡é¦–å…ˆä¸“æ³¨äºè§£å†³å­˜å‚¨é—®é¢˜ï¼Œæˆ‘ä»¬ä½“éªŒäº†ä¸€äº›æ€§èƒ½å¢å¼ºåŠŸèƒ½ï¼Œè¿™äº›æ€§èƒ½å¢å¼ºåŠŸèƒ½å¯ç”¨äºä¿ƒè¿›é«˜ååé‡è´§å¸äº¤æ˜“ã€‚</p><h2 id="3-æ¿€åŠ±ï¼ˆMotivationï¼‰"><a href="#3-æ¿€åŠ±ï¼ˆMotivationï¼‰" class="headerlink" title="3. æ¿€åŠ±ï¼ˆMotivationï¼‰"></a>3. æ¿€åŠ±ï¼ˆMotivationï¼‰</h2><p>æˆ‘ä»¬å·²ç»è®¾è®¡å¹¶å®ç°äº†ä¸€ä¸ªåŒºå—é“¾ç½‘ç»œï¼Œå…¶ä¸­æ°¸ä¹…æ€§çš„ä½æˆæœ¬å­˜å‚¨å·²æˆä¸ºç°å®ã€‚å°†å­˜å‚¨è®¿é—®æƒçº³å…¥å…±è¯†ï¼Œå¹¶ç»“åˆæ–°é¢–çš„äº¤æ˜“æ†ç»‘æ–¹æ³•å’Œä»»æ„å¤§å°çš„å—ï¼Œå¯åˆ›å»ºé«˜ååé‡çš„åŠ å¯†è´§å¸ï¼Œè¯¥åŠ å¯†è´§å¸å°†æ¯”å…¶ä»–åŠ å¯†è´§å¸ï¼ˆå¦‚æ¯”ç‰¹å¸[10]å’Œä»¥å¤ªåŠ[12]ï¼‰æœ‰æ‰€æ”¹å–„ã€‚è¿‡å»ï¼Œæ¡£æ¡ˆï¼ˆäº’è”ç½‘æˆ–å…¶ä»–æ–¹å¼ï¼‰é€šå¸¸ç”±å•ä¸ªæœºæ„ï¼ˆç”šè‡³æ˜¯ä¸ªäººï¼‰ç»´æŠ¤ï¼Œå› æ­¤å®¹æ˜“å—åˆ°ä¸¤ç§ä¸»è¦å½¢å¼çš„æ“çºµã€‚é¦–å…ˆæ˜¯é€šè¿‡åœ¨æ–‡æ¡£å­˜å‚¨è¿‡ç¨‹ä¸­ä¿®æ”¹æ–‡æ¡£[2]ã€‚ç¬¬äºŒä¸ªé—®é¢˜æ˜¯ï¼Œæ–‡æ¡£åœ¨è¿›å…¥å­˜å‚¨ä¹‹å‰å¯èƒ½å·²ç»è¢«ä¼ªé€ æˆ–ä¿®æ”¹è¿‡[1]ã€‚ä¾‹å¦‚ï¼Œè®¸å¤šå½’å› äºè‹æ ¼æ‹‰åº•çš„ä½œå“è¢«è®¤ä¸ºæ˜¯ä»–çš„é—¨å¾’ä»¬å†™çš„[6]ã€‚ Arweaveè§£å†³äº†è¿™ä¸¤ä¸ªé—®é¢˜ã€‚ä¸€æ—¦å°†æ–‡æ¡£å­˜å‚¨åœ¨ç»„ç»‡ä¸Šï¼Œå°±å°†å…¶ä¸ç»„ç»‡ä¸Šçš„æ¯ä¸ªå…¶ä»–å—åŠ å¯†é“¾æ¥ã€‚è¿™ç¡®ä¿äº†ä»»ä½•å°è¯•æ›´æ”¹æ–‡æ¡£å†…å®¹çš„å°è¯•éƒ½ä¼šè¢«ç½‘ç»œæ£€æµ‹åˆ°å¹¶æ‹’ç»ã€‚ä»¥è¿™ç§æ–¹å¼ï¼Œä¸å¯èƒ½ç ´åç»„ç»‡ä¸Šçš„ä¿¡æ¯ã€‚ Arweaveæ˜¯Internetä¸Šå¯æµè§ˆçš„å§Šå¦¹ç½‘ç»œï¼Œå¯æä¾›Internetè¿«åˆ‡éœ€è¦ä½†ç›®å‰ç¼ºä¹çš„é•¿æœŸï¼Œæ°¸ä¹…æ•°æ®å­˜å‚¨åŠŸèƒ½ã€‚</p><p>Arweaveç³»ç»Ÿçš„å…³é”®ç»„ä»¶æ—¨åœ¨è®©å¼€å‘äººå‘˜è½»æ¾æ„å»ºä¸ç½‘ç»œæ•°æ®äº¤äº’ï¼Œåˆ›å»ºå’Œä½¿ç”¨çš„åº”ç”¨ç¨‹åºã€‚è¿™äº›ä½¿ç”¨ä¸è¯­è¨€æ— å…³çš„REST APIæ„å»ºçš„åº”ç”¨ç¨‹åºå°†å……å½“ç½‘ç»œä¸­ä¾¦å¬ç½‘ç»œçš„èŠ‚ç‚¹ã€‚è¿™äº›åº”ç”¨ç¨‹åºçš„åŠŸèƒ½å°†æ˜¯å¹¿æ³›è€Œå¤šæ ·çš„ï¼Œä»åˆ†æ•£å’Œä¸å˜çš„ç¤¾äº¤ç½‘ç»œåˆ°è®¨è®ºç½‘ç«™å’Œæ–°é—»èšåˆå™¨ã€‚ä¸ºäº†å‘ç¼–ç»‡æäº¤ä¿¡æ¯ï¼Œå°†éœ€è¦å°‘é‡ä»¤ç‰Œã€‚è¿™äº›ä»£å¸å°†ç”¨äºæ”¯ä»˜çŸ¿å·¥åœ¨ç»´æŠ¤ç»„ç»‡å’Œç½‘ç»œæ–¹é¢çš„å·¥ä½œï¼Œä»¥åŠæŠ‘åˆ¶åƒåœ¾é‚®ä»¶çš„ä¼ æ’­ã€‚è¿™ä»£è¡¨äº†å¯¹å…¸å‹é›†ä¸­å¼å­˜å‚¨ç³»ç»Ÿçš„æå¤§æ”¹è¿›ã€‚åŒæ ·ï¼Œå®ƒä½¿ä¸ªäººæœ‰èƒ½åŠ›ç¡®ä¿è‡ªå·±å…³å¿ƒçš„ä¿¡æ¯èƒ½å¤Ÿé•¿æœŸå­˜åœ¨ã€‚éšç€ç½‘ç»œå’Œæ–‡æ¡£å°†å¢å¼ºä»¤ç‰Œçš„ä»·å€¼ï¼Œç»´æŒç»‡æ³•çš„åŠ¨æœºä¹Ÿä¼šå¢åŠ ã€‚éšç€è¿™äº›å½±å“çš„åŠ å‰§ï¼Œæˆ‘ä»¬æœŸæœ›Arweaveä»£å¸å°†æˆä¸ºä¿¡æ¯æ—¶ä»£çš„å®è´µèµ„äº§ã€‚ä¸å¤§é‡é‡è¦æ–‡ä»¶å¯†ä¸å¯åˆ†ä¸”å†…åœ¨è”ç³»ã€‚</p><h2 id="4-æŠ€æœ¯ï¼ˆTechnologyï¼‰"><a href="#4-æŠ€æœ¯ï¼ˆTechnologyï¼‰" class="headerlink" title="4. æŠ€æœ¯ï¼ˆTechnologyï¼‰"></a>4. æŠ€æœ¯ï¼ˆTechnologyï¼‰</h2><p>Arweaveå»ºç«‹åœ¨å››é¡¹æ ¸å¿ƒæŠ€æœ¯çš„åŸºç¡€ä¸Šï¼Œè¿™äº›æŠ€æœ¯å¯ä»¥å…±åŒåœ¨æ–°çš„åŒºå—é“¾ä¸Šåˆ›å»ºä½æˆæœ¬ï¼Œé«˜ååé‡çš„æ°¸ä¹…å­˜å‚¨ã€‚ è¿™äº›åˆ›æ–°æ˜¯ï¼š</p><ul><li>åŒºå—ç¼–ç»‡ï¼ˆBlockweaveï¼‰</li><li>è®¿é—®è¯æ˜ï¼ˆProof of Accessï¼‰</li><li>é‡ç«ï¼ˆWildfireï¼‰</li><li>åŒºå—é˜´å½±ï¼ˆBlockshadowsï¼‰</li></ul><p>è™½ç„¶è¿™äº›æŠ€æœ¯ç›¸äº’äº¤ç»‡ï¼Œä½†æ˜¯æ¯ç§æŠ€æœ¯åœ¨åˆ›å»ºé€‚ç”¨äºå¿«é€Ÿäº‹åŠ¡å¤„ç†å’Œä½æˆæœ¬æ°¸ä¹…æ€§å­˜å‚¨çš„æ–°å‹ç½‘ç»œæ–¹é¢éƒ½å‘æŒ¥ç€å…³é”®ä½œç”¨ã€‚</p><h3 id="4-1-åŒºå—ç¼–ç»‡ï¼ˆBlockweaveï¼‰"><a href="#4-1-åŒºå—ç¼–ç»‡ï¼ˆBlockweaveï¼‰" class="headerlink" title="4.1 åŒºå—ç¼–ç»‡ï¼ˆBlockweaveï¼‰"></a>4.1 åŒºå—ç¼–ç»‡ï¼ˆBlockweaveï¼‰</h3><p>å¤§å¤šæ•°åŒºå—é“¾çš„ä¸€ä¸ªä¼—æ‰€å‘¨çŸ¥çš„ç‰¹æ€§æ˜¯ï¼Œå¿…é¡»å­˜å‚¨æ¯ä¸ªåŒºå—ä»¥ä½œä¸ºâ€œå®Œæ•´èŠ‚ç‚¹â€å‚ä¸éªŒè¯äº¤æ˜“ã€‚ Arweaveå¹¶éå¦‚æ­¤ã€‚</p><p>å–è€Œä»£ä¹‹çš„æ˜¯ï¼ŒArweaveå¼•å…¥äº†ä¸¤ä¸ªæ–°æ¦‚å¿µï¼Œè¿™äº›æ¦‚å¿µå…è®¸èŠ‚ç‚¹åœ¨ä¸æ‹¥æœ‰æ•´ä¸ªé“¾æ¡çš„æƒ…å†µä¸‹å®Œæˆå…³é”®çš„ç½‘ç»œåŠŸèƒ½ã€‚è¿™äº›æ¦‚å¿µä¸­çš„ç¬¬ä¸€ä¸ªæ˜¯å—å“ˆå¸Œåˆ—è¡¨ï¼Œå®ƒæ˜¯æ‰€æœ‰å…ˆå‰å—çš„å“ˆå¸Œçš„åˆ—è¡¨ã€‚è¿™æ ·å¯ä»¥éªŒè¯æ—§å—ï¼Œå¹¶æœ‰æ•ˆè¯„ä¼°æ½œåœ¨çš„æ–°å—ã€‚è¿™äº›æ¦‚å¿µçš„ç¬¬äºŒä¸ªæ˜¯é’±åŒ…åˆ—è¡¨ï¼Œè¿™æ˜¯ç³»ç»Ÿä¸­æ‰€æœ‰æ´»åŠ¨é’±åŒ…çš„åˆ—è¡¨ã€‚è¿™æ ·å°±å¯ä»¥åœ¨ä¸å ç”¨æœ€åä¸€æ¬¡äº¤æ˜“ä½¿ç”¨çš„åŒºå—çš„æƒ…å†µä¸‹éªŒè¯äº¤æ˜“ã€‚ä½¿ç”¨è¿™äº›ç”±ç½‘ç»œåŒæ­¥å¹¶å¯ä»¥ç”±çŸ¿å·¥ä¸‹è½½çš„åŒºå—é“¾åˆ—è¡¨å’Œé’±åŒ…åˆ—è¡¨ï¼ŒèŠ‚ç‚¹å‡ ä¹å¯ä»¥ç«‹å³åŠ å…¥ç½‘ç»œå¹¶å‚ä¸å¯¹ç»„ç»‡çš„æŒ–æ˜ã€‚</p><p>æ­¤å¤–ï¼ŒArweaveä½¿ç”¨â€œæŒç»­éªŒè¯â€ç³»ç»Ÿï¼Œè€Œä¸æ˜¯è®©æ¯ä¸ªçŸ¿å·¥åœ¨è¿›å…¥ç½‘ç»œæ—¶éƒ½éªŒè¯ä»åŸºå› å—åˆ°å½“å‰å—çš„æ•´ä¸ªå—ç»“æ„ã€‚å½“çŸ¿å·¥åŠ å…¥Arweaveç½‘ç»œæ—¶ï¼Œä»–ä»¬å°†ä¸‹è½½å½“å‰åŒºå—å¹¶ä»å½“å‰åŒºå—ä¸­æ£€ç´¢åŒºå—å“ˆå¸Œå’Œé’±åŒ…åˆ—è¡¨ã€‚ç”±äºè¿™äº›åŒºå—é“¾å’Œé’±åŒ…åˆ—è¡¨å·²é€šè¿‡æ¯ä¸ªåŒºå—çš„æŒç»­è¿›è¡Œè¿›è¡Œäº†è¿ç»­éªŒè¯ï¼Œå› æ­¤æ–°çŸ¿å·¥å¯ä»¥ç«‹å³å¼€å§‹å‚ä¸ï¼Œè€Œæ— éœ€éªŒè¯æ•´ä¸ªç»„ç»‡ã€‚å½“ç„¶ï¼Œå®Œå…¨ç¼–ç»‡éªŒè¯å¯ç”¨äºå¸Œæœ›æ‰§è¡Œè¯¥éªŒè¯çš„ä»»ä½•èŠ‚ç‚¹ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼ŒçŸ¿å·¥æ— éœ€æŸ¥æ‰¾ä¸é’±åŒ…ç›¸å…³è”çš„å…ˆå‰äº¤æ˜“å³å¯éªŒè¯æ–°äº¤æ˜“ã€‚å–è€Œä»£ä¹‹çš„æ˜¯ï¼ŒçŸ¿å·¥å°†åªéœ€è¦éªŒè¯äº¤æ˜“æ˜¯å¦å·²ç”±é’±åŒ…æ‹¥æœ‰è€…çš„ç§é’¥æ­£ç¡®ç­¾åã€‚ä¸ºäº†é˜²æ­¢å¬å›å—ä¼ªé€ æ”»å‡»ï¼Œå—å“ˆå¸Œè¡¨çš„å“ˆå¸Œå°†ä¸æ¯ä¸ªæ–°å—ä¸€èµ·åˆ†å‘ã€‚</p><p>Arweave - ä¸€ç§ç±»åŒºå—é“¾çš„åŒºå—ç¼–ç»‡ç»“æ„ï¼ˆLightpaperï¼‰</p><p><img src="/images/arweave/image-20220412232151857.png" alt="image-20220412232151857">å›¾1ï¼šblockweaveæ•°æ®ç»“æ„çš„ç¤ºæ„å›¾ï¼Œå±•ç¤ºäº†åˆ°å‰ä¸€ä¸ªåŒºå—å’Œå›è°ƒåŒºå—çš„é“¾æ¥ã€‚</p><h3 id="4-2-è®¿é—®è¯æ˜ï¼ˆProof-of-Accessï¼‰"><a href="#4-2-è®¿é—®è¯æ˜ï¼ˆProof-of-Accessï¼‰" class="headerlink" title="4.2 è®¿é—®è¯æ˜ï¼ˆProof of Accessï¼‰"></a>4.2 è®¿é—®è¯æ˜ï¼ˆProof of Accessï¼‰</h3><p>Arweaveså…±è¯†æœºåˆ¶åŸºäºè®¿é—®è¯æ˜ï¼ˆPoAï¼‰å’Œå·¥ä½œè¯æ˜ï¼ˆPoWï¼‰ã€‚è™½ç„¶å…¸å‹çš„PoWç³»ç»Ÿä»…ä¾èµ–äºå‰ä¸€ä¸ªå—æ‰èƒ½ç”Ÿæˆæ¯ä¸ªè¿ç»­çš„å—ï¼Œä½†PoAç®—æ³•ä¼šåˆå¹¶æ¥è‡ªéšæœºé€‰æ‹©çš„å‰ä¸€ä¸ªå—çš„æ•°æ®ã€‚ç»“åˆåŒºå—ç¼–ç»‡æ•°æ®ç»“æ„ï¼ŒçŸ¿å·¥ä¸éœ€è¦å­˜å‚¨æ‰€æœ‰åŒºå—ï¼ˆå½¢æˆä¸€ä¸ªåŒºå—é“¾ï¼‰ï¼Œè€Œæ˜¯å¯ä»¥å­˜å‚¨ä»»ä½•å…ˆå‰çš„åŒºå—ï¼ˆç”±PoAå’Œé‡ç«æ¨åŠ¨ï¼‰ï¼Œä»è€Œå½¢æˆåŒºå—ç¼–ç»‡ï¼Œå³åŒºå—ç¼–ç»‡ã€‚é€šè¿‡è·å–å½“å‰å—çš„å“ˆå¸Œå€¼å¹¶è®¡ç®—å…¶ç›¸å¯¹äºå½“å‰å—é«˜åº¦çš„æ¨¡æ•°ï¼Œå¯ä»¥é€‰æ‹©è¦åˆå¹¶åˆ°ä¸‹ä¸€ä¸ªå—ä¸­çš„â€œè°ƒç”¨å—â€ã€‚</p><p>è°ƒç”¨å—ä¸­çš„äº‹åŠ¡ä¸åœ¨å½“å‰å—ä¸­æ‰¾åˆ°çš„äº‹åŠ¡ä¸€èµ·è¿›è¡Œå“ˆå¸Œå¤„ç†ï¼Œä»¥ç”Ÿæˆä¸‹ä¸€ä¸ªå—ã€‚å½“çŸ¿å·¥æ‰¾åˆ°åˆé€‚çš„å“ˆå¸Œåï¼Œä»–ä»¬ä¼šå°†æ–°å—ä¸å›è°ƒåŒºå—ä¸€èµ·åˆ†å‘ç»™ç½‘ç»œçš„å…¶ä»–æˆå‘˜ã€‚è¿™ä½¿ç½‘ç»œçš„å…¶ä»–æˆå‘˜ï¼Œå³ä½¿æ²¡æœ‰è‡ªå·±çš„å›è°ƒåŒºå—å‰¯æœ¬çš„é‚£äº›æˆå‘˜ï¼Œä¹Ÿå¯ä»¥ç‹¬ç«‹åœ°éªŒè¯æ–°å—æ˜¯å¦æœ‰æ•ˆã€‚</p><h3 id="4-3-é‡ç«ï¼ˆWildfireï¼‰"><a href="#4-3-é‡ç«ï¼ˆWildfireï¼‰" class="headerlink" title="4.3 é‡ç«ï¼ˆWildfireï¼‰"></a>4.3 é‡ç«ï¼ˆWildfireï¼‰</h3><p>ä½œä¸ºæ•°æ®å­˜å‚¨ç³»ç»Ÿï¼ŒArweaveä¸ä»…éœ€è¦å­˜å‚¨å¤§é‡ä¿¡æ¯çš„èƒ½åŠ›ï¼Œè€Œä¸”è¿˜éœ€è¦ä»¥æœ€æ–¹ä¾¿çš„æ–¹å¼æä¾›å¯¹è¯¥æ•°æ®çš„è®¿é—®ã€‚æ­¤å¤–ï¼ŒArweaveç³»ç»Ÿçš„é‡è¦ç»„æˆéƒ¨åˆ†æ˜¯åœ¨è¯·æ±‚æ—¶å¯¹æ•°æ®è¿›è¡Œæ— æˆæœ¬çš„è®¿é—®ã€‚éšåï¼ŒArweaveå¢åŠ äº†ä¸€å±‚æ¿€åŠ±æªæ–½ï¼Œä»¥é¼“åŠ±çŸ¿å·¥è‡ªç”±å…±äº«æ•°æ®ã€‚</p><p>Wildfireæ˜¯ä¸€ç§ç³»ç»Ÿï¼Œå®ƒé€šè¿‡ä½¿ç½‘ç»œä¸Šæ•°æ®è¯·æ±‚çš„å¿«é€Ÿæ»¡è¶³æˆä¸ºå‚ä¸çš„å¿…è¦éƒ¨åˆ†ï¼Œä»è€Œè§£å†³äº†åˆ†æ•£å¼ç½‘ç»œä¸­æ•°æ®å…±äº«çš„é—®é¢˜ã€‚ Wildfireé€šè¿‡åœ¨æ¯ä¸ªèŠ‚ç‚¹æœ¬åœ°åˆ›å»ºä¸€ä¸ªæ’åç³»ç»Ÿæ¥è¿›è¡Œå·¥ä½œï¼Œè¯¥æ’åç³»ç»Ÿç¡®å®šæ–°å—å’Œäº‹åŠ¡å‘å¯¹ç­‰å¯¹è±¡åˆ†å‘çš„é€Ÿåº¦å¦‚ä½•ï¼ŒåŸºäºå®ƒä»¬å¯¹è¯·æ±‚è¿›è¡Œå“åº”å¹¶æ¥å—æ¥è‡ªå…¶ä»–å¯¹è±¡çš„æ•°æ®çš„é€Ÿåº¦ã€‚å¯¹ç­‰ä½“æŒ‰å…¶ç­‰çº§é¡ºåºæœåŠ¡ï¼Œè€Œæ€§èƒ½ä¸ä½³çš„å¯¹ç­‰ä½“åˆ™è¢«ä»ç½‘ç»œä¸­é»‘åå•ä¸­åˆ é™¤ã€‚ä»ç»æµä¸Šæ¿€åŠ±åŒä¼´ï¼Œä½¿ä»–ä»¬åœ¨å½¼æ­¤çš„æ’åä¸­ä¿æŒè‰¯å¥½çš„ä½ç½®ï¼Œä»¥ä¾¿ä»–ä»¬å¯ä»¥èŠ±è´¹æœ€å¤§çš„æ—¶é—´è¿›è¡Œæœ‰æ•ˆçš„æŒ–æ˜ã€‚</p><p>Arweave - ä¸€ç§ç±»åŒºå—é“¾çš„åŒºå—ç¼–ç»‡ç»“æ„ï¼ˆLightpaperï¼‰</p><p><img src="/images/arweave/image-20220412232319579.png" alt="image-20220412232319579"></p><p>å›¾2ï¼šé‡ç«ç³»ç»Ÿç¤ºæ„å›¾ã€‚ æ¯ä¸ªèŠ‚ç‚¹æ ¹æ®è¿™äº›å¯¹ç­‰ç‚¹ä¹‹å‰å¯¹å®ƒä»¬çš„è¡¨ç°è¿›è¡Œè¯„ä¼°ï¼Œå¯¹å…¶å¯¹ç­‰ç‚¹è¿›è¡Œæ’åã€‚<br>è¿™æå¤§åœ°é¼“åŠ±ç³»ç»Ÿä¸­çš„èŠ‚ç‚¹ä»¥å¯¹å…¶ä»–å¯¹ç­‰æ–¹å°½å¯èƒ½æœ€å‹å¥½çš„æ–¹å¼è¿è¡Œï¼Œè€Œä¸ä¼šç»™æ­£åœ¨æ¥æ”¶æ•°æ®çš„äººï¼Œç”šè‡³å¯èƒ½æ˜¯ä¸€æ¬¡æ€§è¯·æ±‚çš„é‚£äº›äººå¸¦æ¥ä»£ä»·ã€‚ æ›´è¿›ä¸€æ­¥ï¼Œå®ƒåˆ›å»ºäº†ä¸€ç§ç½‘ç»œæ‹“æ‰‘ï¼Œè¯¥æ‹“æ‰‘é€‚åˆäºæœ€æœ‰æ•ˆçš„å…¨å±€è·¯ç”±ï¼Œå› ä¸ºé¦–é€‰äº†å…è®¸åœ¨ç³»ç»Ÿä¸­å¿«é€Ÿä¼ è¾“æ–°æ•°æ®çš„è¿æ¥ã€‚ å®é™…ä¸Šï¼Œé‡ç«æœºåˆ¶æ„å»ºäº†ä¸€ä¸ªç½‘ç»œæ‹“æ‰‘ï¼Œè¯¥æ‹“æ‰‘æ˜ å°„äº†Internetçš„åº•å±‚ç‰©ç†è¿æ¥åŸºç¡€ï¼Œä»¥é€‚åº”å…¶æ¶æ„éšæ—¶é—´çš„å˜åŒ–ã€‚ æ€»ä½“è€Œè¨€ï¼Œé‡ç«ç³»ç»Ÿå¯ç¡®ä¿æ–°å—çš„é«˜é€Ÿåˆ†å‘ï¼Œå¹¶ä»¥è¾ƒçŸ­çš„å»¶è¿Ÿä¿æŒæ•°æ®å¯ç”¨ã€‚</p><h3 id="4-4-åŒºå—é˜´å½±ï¼ˆBlockshadowsï¼‰"><a href="#4-4-åŒºå—é˜´å½±ï¼ˆBlockshadowsï¼‰" class="headerlink" title="4.4 åŒºå—é˜´å½±ï¼ˆBlockshadowsï¼‰"></a>4.4 åŒºå—é˜´å½±ï¼ˆBlockshadowsï¼‰</h3><p>åœ¨ä¼ ç»Ÿçš„åŒºå—é“¾ç³»ç»Ÿä¸­ï¼Œå½“æŒ–æ˜ä¸€ä¸ªæ–°å—æ—¶ï¼Œæ— è®ºä¸€ä¸ªèŠ‚ç‚¹å·²ç»æ‹¥æœ‰å¤šå°‘å—æ•°æ®ï¼Œæ¯ä¸ªå®Œæ•´çš„å—éƒ½ä¼šåˆ†é…åˆ°ç½‘ç»œä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ã€‚è¿™ä¸ä»…æµªè´¹å¤§é‡æ•°æ®ï¼Œè€Œä¸”æå¤§åœ°é™ä½äº†ç½‘ç»œå°±å—è¾¾æˆå…±è¯†çš„é€Ÿåº¦ã€‚å› æ­¤ï¼ŒArweaveå¼•å…¥äº†ä¸€ç§æ–°æŠ€æœ¯ï¼Œå³å—å½±å­ï¼Œå®ƒä¸ä»…å¯ä»¥æœ€å¤§ç¨‹åº¦åœ°å‡å°‘æ•°æ®æµªè´¹ï¼Œè€Œä¸”å¯ä»¥å®ç°å¿«é€Ÿçš„å—å…±è¯†å’Œå·¨å¤§çš„äº‹åŠ¡ååé‡ã€‚</p><p>Blockshadowingçš„å·¥ä½œåŸç†æ˜¯éƒ¨åˆ†å–æ¶ˆæ¥è‡ªå—çš„äº‹åŠ¡ï¼Œå¹¶ä¸”ä»…åœ¨èŠ‚ç‚¹ä¹‹é—´å‘é€æœ€å°çš„å—â€œå½±å­â€ï¼Œè¯¥å½±å­å…è®¸å¯¹ç­‰æ–¹é‡å»ºå®Œæ•´çš„å—ï¼Œè€Œä¸æ˜¯ä¼ è¾“å®Œæ•´çš„å—æœ¬èº«ã€‚è¿™äº›åŒºå—å½±å­ä¸“é—¨åŒ…å«é’±åŒ…åˆ—è¡¨å’Œå“ˆå¸Œåˆ—è¡¨çš„å“ˆå¸Œï¼Œå¹¶ä¸”ä»£æ›¿åŒºå—å†…çš„äº¤æ˜“ï¼Œä»…åŒ…å«äº¤æ˜“å“ˆå¸Œçš„åˆ—è¡¨ã€‚æ ¹æ®è¿™ä¸€ä¿¡æ¯ï¼ˆå¯èƒ½åªæœ‰å‡ åƒå­—èŠ‚ï¼‰ï¼Œä¸€ä¸ªå·²ç»åœ¨è¯¥åŒºå—ä¸­æ‹¥æœ‰æ‰€æœ‰äº¤æ˜“çš„èŠ‚ç‚¹ä»¥åŠä¸€ä¸ªæœ€æ–°çš„å“ˆå¸Œå’Œé’±åŒ…åˆ—è¡¨å¯ä»¥é‡å»ºå‡ ä¹ä»»æ„å¤§å°çš„æ•´ä¸ªåŒºå—ã€‚ä¸ºäº†ä¿ƒè¿›è¿™ä¸€ç‚¹ï¼ŒèŠ‚ç‚¹è¿˜å°†ç«‹å³å½¼æ­¤å…±äº«äº‹åŠ¡ï¼Œä½†æ˜¯åªæœ‰åœ¨å®ƒä»¬é«˜åº¦ç¡®å®šç½‘ç»œä¸­çš„å…¶ä»–èŠ‚ç‚¹ä¹Ÿå…·æœ‰äº‹åŠ¡å¤„ç†åï¼Œæ‰å°è¯•å°†äº‹åŠ¡æ”¾ç½®åœ¨ä¸€ä¸ªå—ä¸­ã€‚</p><p>è¿™ä¸ªåŒºå—é›†æ•£ç³»ç»Ÿçš„ç»“æœæ˜¯ä¸€ä¸ªå¿«é€Ÿï¼Œçµæ´»çš„åŒºå—åˆ†é…ç³»ç»Ÿï¼Œè¯¥ç³»ç»Ÿå¯ä»¥ä½¿äº¤æ˜“ä»¥å°½å¯èƒ½å¿«çš„é€Ÿåº¦åœ¨ç½‘ç»œä¸Šåˆ†å¸ƒï¼Œå¹¶ä¸”å¯ä»¥ä»¥æ¥è¿‘ç½‘ç»œçš„é€Ÿåº¦è¾¾æˆå…±è¯†ã€‚æ­¤å¤–ï¼Œè¯¥ç³»ç»Ÿå¯ç¡®ä¿å½“ç½‘ç»œä½¿ç”¨ç‡å¾ˆé«˜æ—¶ï¼Œäº¤æ˜“è´¹ç”¨ä¸ä¼šæ˜¾ç€å¢åŠ ï¼Œå¹¶ä¸”ä¹è§‚çš„100mbpsç½‘ç»œä¸Šçš„äº¤æ˜“ååé‡çš„ç†è®ºé™åˆ¶ä¸ºæ¯ç§’çº¦5000ç¬”äº¤æ˜“ã€‚</p><h3 id="4-5-æ°‘ä¸»å†…å®¹æ”¿ç­–ï¼ˆDemocratic-Content-Policyï¼‰"><a href="#4-5-æ°‘ä¸»å†…å®¹æ”¿ç­–ï¼ˆDemocratic-Content-Policyï¼‰" class="headerlink" title="4.5 æ°‘ä¸»å†…å®¹æ”¿ç­–ï¼ˆDemocratic Content Policyï¼‰"></a>4.5 æ°‘ä¸»å†…å®¹æ”¿ç­–ï¼ˆDemocratic Content Policyï¼‰</h3><p>ä¸ºäº†æ”¯æŒç½‘ç»œä¸­å„ä¸ªå‚ä¸è€…çš„è‡ªç”±ä»¥æ§åˆ¶ä»–ä»¬å­˜å‚¨çš„å†…å®¹ï¼Œå¹¶å…è®¸æ•´ä¸ªç½‘ç»œä»¥æ°‘ä¸»æ–¹å¼æ‹’ç»å—åˆ°å¹¿æ³›è°´è´£çš„å†…å®¹ï¼ŒArweaveè½¯ä»¶æä¾›äº†ä¸€ä¸ªé»‘åå•ç³»ç»Ÿã€‚æ¯ä¸ªèŠ‚ç‚¹ä¸»èŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªï¼ˆå¯é€‰ï¼‰é»‘åå•ï¼Œå…¶ä¸­åŒ…å«ä¾‹å¦‚å®ƒä¸å¸Œæœ›å­˜å‚¨çš„æŸäº›æ•°æ®çš„å“ˆå¸Œå€¼æˆ–å­å­—ç¬¦ä¸²ï¼Œå¹¶ä¸”æ°¸è¿œä¸ä¼šå†™å…¥ä¸æ­¤åŒ¹é…çš„ç£ç›˜å†…å®¹ã€‚è¿™äº›é»‘åå•å¯ä»¥ç”±ä¸ªäººå»ºç«‹ï¼Œä¹Ÿå¯ä»¥é€šè¿‡åä½œå»ºç«‹ï¼Œä¹Ÿå¯ä»¥ä»å…¶ä»–æ¥æºå¯¼å…¥ã€‚</p><p>åœ¨æœ¬åœ°çº§åˆ«ï¼Œè¿™äº›é»‘åå•å…è®¸èŠ‚ç‚¹æ§åˆ¶è‡ªå·±çš„å†…å®¹ï¼Œä½†æ˜¯è¿™äº›æœ¬åœ°æ‹’ç»çš„æ€»å’Œä¹Ÿä¼šåˆ›å»ºç½‘ç»œèŒƒå›´çš„å†…å®¹æ‹’ç»ã€‚è¶…è¿‡ä¸€åŠä»¥ä¸Šçš„ç½‘ç»œæ‹’ç»çš„å†…å®¹ä¸ä»…ä¼šè¢«è¿™äº›å•ä¸ªèŠ‚ç‚¹ä¸­çš„æ¯ä¸€ä¸ªæ‹’ç»ï¼Œè€Œä¸”è¿˜å°†è¢«æ•´ä¸ªç½‘ç»œæ•´ä½“æ‹’ç»ã€‚è¿™åˆ›å»ºäº†ä¸€ä¸ªæ°‘ä¸»çš„å…¨ç½‘ç»œå†…å®¹æ‹’ç»ç³»ç»Ÿï¼Œè¯¥ç³»ç»Ÿå¯ä»¥å°†å„ç§æ–‡åŒ–å’Œè§‚ç‚¹ä¸­çš„é»‘åå•åˆå¹¶ä¸ºä¸€ä¸ªæ™®éåˆ é™¤çš„å¾®å°çš„ç‰¹å®šå†…å®¹é»‘åå•ã€‚è¿™ä¸ªæ¥è¿‘æ™®éï¼Œæ°‘ä¸»çš„é»‘åå•ä½¿ç½‘ç»œä¸å—å°‘æ•°è¡Œä¸ºè€…çš„å¹²æ‰°ï¼ŒåŒæ—¶ä»å…è®¸å…¶ä»¥æ°‘ä¸»æ–¹å¼ä¿æŠ¤è‡ªå·±çš„è‡ªç”±ã€‚</p><h2 id="4-6-è®¨è®ºï¼ˆDiscussionï¼‰"><a href="#4-6-è®¨è®ºï¼ˆDiscussionï¼‰" class="headerlink" title="4.6 è®¨è®ºï¼ˆDiscussionï¼‰"></a>4.6 è®¨è®ºï¼ˆDiscussionï¼‰</h2><h3 id="4-6-1-å­˜å‚¨æ± ï¼ˆStorage-Poolsï¼‰"><a href="#4-6-1-å­˜å‚¨æ± ï¼ˆStorage-Poolsï¼‰" class="headerlink" title="4.6.1 å­˜å‚¨æ± ï¼ˆStorage Poolsï¼‰"></a>4.6.1 å­˜å‚¨æ± ï¼ˆStorage Poolsï¼‰</h3><p>å¯¹Arweaveçš„ä¸€ç§æ½œåœ¨çš„ç†è®ºæ”»å‡»å·²ç»å˜å¾—éå¸¸å¤§ï¼Œé‚£å°±æ˜¯çŸ¿å·¥å¯èƒ½ä¼šåˆä½œç»´æŠ¤ä¸€ä¸ªç»„ç»‡çš„å•ä¸ªå‰¯æœ¬ï¼Œä»–ä»¬éƒ½å¯ä»¥ä½¿ç”¨è¿™äº›å‰¯æœ¬æ¥æ£€ç´¢å¬å›å—ã€‚ è™½ç„¶è¿™ç§è¡Œä¸ºä¹çœ‹èµ·æ¥ä¼¼ä¹æ˜¯é—®é¢˜ï¼Œä½†äº‹å®å¹¶éå¦‚æ­¤ã€‚ å¦‚æœæ­¤ç±»â€œå­˜å‚¨æ± â€è¢«å¤§éƒ¨åˆ†çŸ¿å·¥é›‡ç”¨ï¼Œé‚£ä¹ˆå…¶ä»–çŸ¿å·¥å­˜å‚¨ç¨€æœ‰çŸ¿å—çš„åŠ¨æœºå°±ä¼šå¢åŠ ã€‚ è¿™æ˜¯å› ä¸ºï¼Œå¦‚æœé›†ä¸­å­˜å‚¨åŒºä¸å¯ç”¨ï¼Œåˆ™å½“å°†æ¥è¯¥ç¨€æœ‰å—æˆä¸ºæ’¤å›å—æ—¶ï¼Œå…·æœ‰ç¨€æœ‰å—å‰¯æœ¬çš„çŸ¿å·¥å°†å¾ˆå¯èƒ½è·å¾—å¥–åŠ±ã€‚ è¿™ç§è‡ªç§çš„è¡Œä¸ºä¸ºç½‘ç»œæä¾›äº†é£é™©æŠµé”€åŠŸèƒ½ï¼Œè¯¥åŠŸèƒ½ä¼šéšç€æ•°æ®ä¸¢å¤±ï¼ˆç”±é›†ä¸­å­˜å‚¨æ± å¼•èµ·ï¼‰çš„å¯èƒ½æ€§å¢é•¿è€Œæ‰©å±•ã€‚</p><h2 id="5-æ„å»ºAppï¼ˆBuilding-Appsï¼‰"><a href="#5-æ„å»ºAppï¼ˆBuilding-Appsï¼‰" class="headerlink" title="5. æ„å»ºAppï¼ˆBuilding Appsï¼‰"></a>5. æ„å»ºAppï¼ˆBuilding Appsï¼‰</h2><p>å¯ä»¥ä½¿ç”¨ç®€å•çš„REST APIæ„å»ºä½¿ç”¨ç»„ç»‡çš„åº”ç”¨ç¨‹åºã€‚ RESTç«¯ç‚¹æ˜¯HTTPï¼Œå¯ä»¥ç›´æ¥è®¿é—®ç½‘ç»œï¼Œå› æ­¤ä»»ä½•Arweaveé’±åŒ…éƒ½å¯ä»¥è¯»å–å’Œå†™å…¥æ•°æ®ã€‚ å®¢æˆ·åªéœ€è¦é€šè¿‡Chromeæ‰©å±•ç¨‹åºæˆ–å…·æœ‰Arweaveé’±åŒ…é›†æˆåŠŸèƒ½çš„æœ¬æœºåº”ç”¨ç¨‹åºå°†å…¶Arweaveé’±åŒ…å¸¦å…¥ç½‘ç«™ï¼Œå³å¯ä»ç½‘ç»œè¯»å–æ•°æ®æˆ–å‘ç½‘ç»œå†™å…¥æ•°æ®ã€‚ å¯ä»¥åœ¨ç»„ç»‡ä¹‹ä¸Šæ„å»ºå‡ ç§ä½“ç³»ç»“æ„ã€‚</p><h3 id="5-1-å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¶æ„ï¼ˆClient-Server-Architectureï¼‰"><a href="#5-1-å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¶æ„ï¼ˆClient-Server-Architectureï¼‰" class="headerlink" title="5.1 å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¶æ„ï¼ˆClient-Server Architectureï¼‰"></a>5.1 å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¶æ„ï¼ˆClient-Server Architectureï¼‰</h3><p>ä¼ ç»Ÿçš„Webæˆ–æœ¬æœºåº”ç”¨ç¨‹åºå…·æœ‰å®¢æˆ·ç«¯-æœåŠ¡å™¨ä½“ç³»ç»“æ„ã€‚åœ¨äº‘ä¸Šè¿è¡Œçš„æœåŠ¡å™¨å°†è¢«â€œå¯ç”¨Arweaveâ€ï¼Œä¸ä¸€ä¸ªæˆ–å¤šä¸ªArweaveèŠ‚ç‚¹è¿›è¡Œäº¤äº’ï¼Œä»£è¡¨å®¢æˆ·ç«¯è¯»å–å’Œå†™å…¥æ•°æ®ã€‚è¿™äº›æœåŠ¡å¯ä»¥æ˜¯å°†å®¢æˆ·ç«¯ä½œä¸ºè®¿é—®è€…çš„ç½‘ç«™ï¼Œä¹Ÿå¯ä»¥æ˜¯å°†å®¢æˆ·ç«¯è¯·æ±‚ä¼ é€’ç»™å¼€å‘äººå‘˜æ“ä½œçš„æœåŠ¡å™¨çš„æœ¬æœºåº”ç”¨ç¨‹åºã€‚è¿™äº›æœåŠ¡å™¨å°†éœ€è¦ç»´æŠ¤ARä»¤ç‰Œçš„æµ®åŠ¨ï¼Œä»¥ç¡®ä¿å¯ä»¥å¤„ç†å†™å…¥æ•°æ®çš„è¯·æ±‚ã€‚ä½¿ç”¨è¯¥æ¶æ„ä»ç¼–ç»‡è¯»å–æ•°æ®ä»ç„¶æ˜¯å…è´¹çš„ã€‚</p><p>è¯¥æ¶æ„çš„è·åˆ©æ½œåŠ›å¾ˆç®€å•ã€‚å¼€å‘äººå‘˜å°†éœ€è¦é€šè¿‡å¹¿å‘Šï¼Œæ¯æœˆè®¢é˜…æˆ–ç›´æ¥ä»˜æ¬¾æ¥è·å¾—æ›´å¤§çš„ä»·å€¼ï¼Œè€Œä¸æ˜¯ä½¿ç”¨å…¶ä¸ºå­˜å‚¨æä¾›åŠ¨åŠ›çš„ARä»¤ç‰Œæ•°é‡ã€‚æ°¸ä¹…æ€§ä¸å¯å˜å­˜å‚¨æœ‰è®¸å¤šåº”ç”¨ã€‚ä¾‹å¦‚ï¼Œå­˜å‚¨æŠ—é‡å­ï¼ŒåŠ å¯†çš„æ³•å¾‹æ¡ˆä¾‹æ–‡ä»¶ï¼Œèº«ä»½æˆ–åŒ»ç–—è®°å½•ã€‚å°½ç®¡æŸäº›æ³•è§„éœ€è¦é€‚åº”æ•æ„Ÿä¿¡æ¯çš„å­˜å‚¨ï¼Œåœ°ç†èŒƒå›´å’Œè¢«é—å¿˜çš„æƒåˆ©ï¼Œä½†ä¹Ÿå¯ä»¥é€šè¿‡åŠ å¯†å’Œå¯†é’¥ç®¡ç†æ¥ç¼“è§£è¿™ç§æƒ…å†µã€‚å‡ ä¸ªåˆ›æ”¶æ¨¡å‹å¯ä»¥åœ¨ç»„ç»‡çš„é¡¶éƒ¨åˆ†å±‚ï¼Œå…¶ä¸»è¦ä»·å€¼ä¸»å¼ æ˜¯é“¾ä¸Šæ°¸ä¹…ä¸å¯å˜çš„å­˜å‚¨ã€‚</p><h3 id="5-2-æ— æœåŠ¡å™¨æ¶æ„ï¼ˆServerless-Architectureï¼‰"><a href="#5-2-æ— æœåŠ¡å™¨æ¶æ„ï¼ˆServerless-Architectureï¼‰" class="headerlink" title="5.2 æ— æœåŠ¡å™¨æ¶æ„ï¼ˆServerless Architectureï¼‰"></a>5.2 æ— æœåŠ¡å™¨æ¶æ„ï¼ˆServerless Architectureï¼‰</h3><p>å®¢æˆ·ç«¯å¯ä»¥é€šè¿‡å¯ç”¨Arweaveçš„æµè§ˆå™¨è®¿é—®åº”ç”¨ç¨‹åºï¼Œè€Œåº”ç”¨ç¨‹åºå¯ä»¥è‡ªèº«è¿è¡Œã€‚ç”±äºæµè§ˆå™¨çš„æ™®åŠå’ŒWebæŠ€æœ¯çš„æ™®åŠï¼Œä½¿ç”¨HTML / CSS / JSå°†è¿™äº›åº”ç”¨ç¨‹åºå­˜å‚¨ä¸ºæ ‡å‡†å‰ç«¯Webåº”ç”¨ç¨‹åºæ˜¯æœ€æœ‰æ„ä¹‰çš„ã€‚ä½†æ˜¯ï¼Œå¦‚æœå®¢æˆ·ç«¯çš„æœ¬æœºåº”ç”¨ç¨‹åºåŒ…å«é’ˆå¯¹ä¸åŒè¯­è¨€ï¼ˆä¾‹å¦‚LLVMå­—èŠ‚ç ï¼‰æˆ–è„šæœ¬è¯­è¨€ï¼ˆå¦‚Pythonï¼‰çš„è§£é‡Šå™¨/è§£æå™¨ï¼Œåˆ™å®ƒä»¬å¯ä»¥åœ¨å®¢æˆ·ç«¯ä¸Šè¿è¡Œï¼Œå¹¶ä¸”å¯èƒ½ä¼šå—ç›ŠäºWebåº”ç”¨ç¨‹åºä¸­çš„ç›¸åŒå¯å‡çº§æ€§ã€‚</p><p>å¼€å‘äººå‘˜ä¸ä»…å¯ä»¥å°†æ— æœåŠ¡å™¨çš„åº”ç”¨ç¨‹åºéƒ¨ç½²åˆ°Arweaveï¼Œè€Œä¸”è¿™äº›åº”ç”¨ç¨‹åºè¿˜å¯ä»¥å°†æŒä¹…æ€§å’Œå¯è¯æ˜çŠ¶æ€å†™å…¥ç½‘ç»œã€‚ç”±äºArweaveæ²¡æœ‰æ–½åŠ ç‰¹å®šçš„æ•°æ®ç»“æ„ï¼Œå› æ­¤å¼€å‘äººå‘˜å¯ä»¥è‡ªç”±åœ°ä»¥å¯¹ä»–ä»¬æ¥è¯´æœ€æœ‰æ„ä¹‰çš„æ ¼å¼å­˜å‚¨æ•°æ®ã€‚å¦‚æœè¯¥åº”ç”¨ç¨‹åºæœ€å¥½é€šè¿‡é«˜åº¦ä¼˜åŒ–çš„Merkleç»“æ„ï¼ˆä¾‹å¦‚ä»¥å¤ªåŠè™šæ‹Ÿæœºï¼ˆEVMï¼‰ä¸­æ‰¾åˆ°çš„ç»“æ„ï¼‰æ¥æ»¡è¶³ï¼Œåˆ™å¯ä»¥è½»æ¾åœ°å°†å…¶å®ç°ã€‚å¦‚æœå¼€å‘äººå‘˜æ­£åœ¨å¯»æ‰¾æ›´å¤šçš„æ–‡æœ¬Blobæ ·å¼å­˜å‚¨ï¼Œé‚£ä¹ˆè¿™ä¹Ÿæ˜¯å¾®ä¸è¶³é“çš„ã€‚</p><p>æ— æœåŠ¡å™¨åº”ç”¨ç¨‹åºéå¸¸æœ‰è¶£ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥å†™å…¥è‡ªå·±çš„æ•°æ®ã€‚ä¾‹å¦‚ï¼ŒåŸºäºåˆ†å¸ƒå¼è®¡ç®—å°†å…è®¸è®­ç»ƒç¥ç»ç½‘ç»œå­˜å‚¨å…¶ç»“æœï¼Œå¹¶å¯èƒ½ä¸å…¶ä»–ç½‘ç»œå…±äº«å…¶ç»“æœæ¨¡å‹ã€‚</p><h3 id="5-3-åŸºäºäº‹ä»¶çš„ï¼ˆEvent-Basedï¼‰"><a href="#5-3-åŸºäºäº‹ä»¶çš„ï¼ˆEvent-Basedï¼‰" class="headerlink" title="5.3 åŸºäºäº‹ä»¶çš„ï¼ˆEvent Basedï¼‰"></a>5.3 åŸºäºäº‹ä»¶çš„ï¼ˆEvent Basedï¼‰</h3><p>åœ¨Twitteræˆç«‹ä¹‹åˆï¼Œä¾¿æœ‰äº†è“¬å‹ƒå‘å±•çš„å®¶åº­æ‰‹å·¥ä¸šåº”ç”¨ç¨‹åºç”Ÿæ€ç³»ç»Ÿï¼Œè€Œå¼€å‘äººå‘˜åˆ™åœ¨â€œ firehostâ€ APIçš„åŸºç¡€ä¸Šå¼€å‘ï¼Œè¿™äº›APIå°†æ¨æ–‡æµåŒ–ä¸ºä»»ä½•æ„¿æ„ä»˜è´¹è®¿é—®çš„äººã€‚ æƒ…å†µå·²ä¸å†å¦‚æ­¤ï¼Œåœ¨Facebook Cambridge Analyticaæƒ¨è´¥ä¹‹åï¼Œè¿™äº›å‘å®¢æˆ·æä¾›æ•°æ®åˆ†æçš„æœåŠ¡çš„è®¸å¤šâ€œå¯ä¿¡èµ–çš„åˆä½œä¼™ä¼´â€éƒ½è¢«ä»»æ„å…³é—­ã€‚</p><p>Arweaveæ˜¯ä¸€ä¸ªåˆ†æ•£çš„å…¬å…±æ•°æ®ç½‘ç»œï¼Œå› æ­¤ï¼Œé™¤äº†è¢«æ°‘ä¸»æ‹’ç»çš„å†…å®¹å¤–ï¼Œå®ƒæ°¸è¿œä¸ä¼šå®¡æŸ¥æ•°æ®è®¿é—®æˆ–æ•°æ®æœ¬èº«ã€‚ è¿™æ„å‘³ç€å¼€å‘äººå‘˜å¯ä»¥è‡ªç”±åœ°åœ¨Arweaveä¹‹ä¸Šè¿›è¡Œæ„å»ºï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨REST APIä¾¦å¬ä¼ å…¥çš„æ•°æ®ã€‚ è§¦å‘äº‹ä»¶åï¼Œä¾¦å¬å™¨å°†è§¦å‘è®¢é˜…äº†è¿™äº›äº‹ä»¶çš„å®¢æˆ·ç«¯çš„ç›¸åº”å‡½æ•°è°ƒç”¨ã€‚ å¼€å‘äººå‘˜ä¸å¿…æ‹…å¿ƒä¼šå—åˆ°é™åˆ¶æˆ–å…³é—­ï¼Œå› ä¸ºç½‘ç»œå—åˆ°æ¿€åŠ±ä»¥å‘ä»–ä»¬æä¾›å¯¹æ•°æ®é¦ˆé€çš„å¯é è®¿é—®ã€‚</p><h3 id="5-4-æ— ä¿¡ä»»å’Œå¯è¯æ˜ï¼ˆTrustless-and-Provableï¼‰"><a href="#5-4-æ— ä¿¡ä»»å’Œå¯è¯æ˜ï¼ˆTrustless-and-Provableï¼‰" class="headerlink" title="5.4 æ— ä¿¡ä»»å’Œå¯è¯æ˜ï¼ˆTrustless and Provableï¼‰"></a>5.4 æ— ä¿¡ä»»å’Œå¯è¯æ˜ï¼ˆTrustless and Provableï¼‰</h3><p>å¯ä»¥å¯¹åº”ç”¨ç¨‹åºä½“ç³»ç»“æ„è¿›è¡Œè®¾è®¡ï¼Œä»¥ä¾¿è½»æ¾å®ç°éœ€è¦å­˜å‚¨å¹¶ä¿è¯é˜²ç¯¡æ”¹çš„ä¿¡æ¯ã€‚ æ­¤å¤–ï¼Œå¯è¯æ˜å…¬å¹³çš„è¿è¡Œæ—¶ä»£ç å¯ä»¥å­˜å‚¨åœ¨ç»„ç»‡ä¸Šï¼Œå¹¶ç”±å®¢æˆ·ç«¯ç›´æ¥è§£é‡Šã€‚ å®¢æˆ·ç«¯ä½¿ç”¨å†…å®¹çš„äº‹åŠ¡IDï¼Œå¯ä»¥åœ¨è®¡ç®—ä¹‹å‰éªŒè¯ç¼–ç»‡ä¸­çš„æœ‰æ•ˆè´Ÿè½½ï¼Œå¹¶ç¡®ä¿å®ƒä»¬è¿è¡Œçš„ä»£ç æ—¢ä¸å—ä¿¡ä»»åˆå¯ä»¥è¯æ˜æ˜¯å…¬å¹³çš„ï¼Œå³ä¸å…¶ä»–å®¢æˆ·ç«¯è¿è¡Œçš„ä»£ç ç›¸åŒã€‚ è¿™ä¸ºæœåŠ¡äºå…¶ä»–åŒºå—é“¾ç½‘ç»œçš„æ— ä¿¡ä»»éšæœºæ•°ç”Ÿæˆå™¨å’Œå…¶ä»–åŸºäºoracleçš„æœåŠ¡å¼€è¾Ÿäº†æœ‰è¶£çš„å¯èƒ½æ€§ã€‚</p><h2 id="6-ç”¨ä¾‹ï¼ˆUse-Casesï¼‰"><a href="#6-ç”¨ä¾‹ï¼ˆUse-Casesï¼‰" class="headerlink" title="6. ç”¨ä¾‹ï¼ˆUse Casesï¼‰"></a>6. ç”¨ä¾‹ï¼ˆUse Casesï¼‰</h2><p>æ°¸ä¹…å­˜å‚¨æœ‰å‡ ä¸ªç”¨ä¾‹ã€‚ å…·ä½“è€Œè¨€ï¼Œæ³•è§„è¦æ±‚å°†æ–‡ä»¶å­˜æ¡£é•¿è¾¾ä¸€å®šå¹´é™ã€‚ å¯è¯æ˜çš„åª’ä½“æŠ¥é“ï¼Œå­¦æœ¯ç ”ç©¶å’Œä¸å˜çš„è®°å½•åœ¨æˆ‘ä»¬å›å£°å®¤å’Œå‡æ–°é—»æ³›æ»¥çš„ç°ä»£ä¸–ç•Œä¸­å˜å¾—è¶Šæ¥è¶Šé‡è¦ã€‚</p><h3 id="6-1-çœŸå®æ€§ï¼ˆAuthenticityï¼‰"><a href="#6-1-çœŸå®æ€§ï¼ˆAuthenticityï¼‰" class="headerlink" title="6.1 çœŸå®æ€§ï¼ˆAuthenticityï¼‰"></a>6.1 çœŸå®æ€§ï¼ˆAuthenticityï¼‰</h3><p>æ³•å¾‹ä½“ç³»å¸¸å¸¸ä¸æ–‡ä»¶çœŸå®æ€§çš„è¯‰è®¼çº ç¼ åœ¨ä¸€èµ·ã€‚ Arweaveé€šè¿‡æä¾›æ¥è‡ªä½œè€…çš„ä»»ä½•æ•°å­—å†…å®¹çš„ä¸ç¡®å®šä¸”å¯éªŒè¯çš„å­˜å‚¨æ¥è§£å†³æ­¤é—®é¢˜ã€‚ 2017å¹´ï¼Œç‰¹æ‹‰åå·è£å®šåœ¨æ³•é™¢è¯‰è®¼ç¨‹åºä¸­å¯ä»¥æ¥å—åŒºå—é“¾è¯æ®ã€‚ è¿™äº›è®°å½•å¯èƒ½ä¼šå¤§å¤§åŠ å¿«æœ‰å…³è‰ºæœ¯å½’å±å’ŒçŸ¥è¯†è´¢äº§ä¹‹äº‰çš„äº‰è®®ã€‚ å¯¹äºåˆ›æ„ç»æµè€Œè¨€ï¼Œæ•ˆæœæ˜¯åŒé‡çš„ï¼Œä½¿è‰ºæœ¯å®¶å¯ä»¥å°†è‡ªå·±çš„ä½œå“ç«‹å³è½¬è®©ç»™ä»–äººï¼Œå¹¶é¿å…çç¢çš„è¯‰è®¼ã€‚</p><h2 id="7-ç»“è®ºï¼ˆConclusionï¼‰"><a href="#7-ç»“è®ºï¼ˆConclusionï¼‰" class="headerlink" title="7. ç»“è®ºï¼ˆConclusionï¼‰"></a>7. ç»“è®ºï¼ˆConclusionï¼‰</h2><p>æˆ‘ä»¬æå‡ºäº†ä¸€ä¸ªæ–°çš„åŒºå—é“¾ç½‘ç»œï¼Œè¯¥ç½‘ç»œæ”¯æŒä½æˆæœ¬çš„ä¸å¯å˜æ•°æ®å­˜å‚¨å’Œé«˜ååé‡çš„åŠ å¯†è´§å¸ã€‚é€šè¿‡ä½¿ç”¨ä¸€ç§ç§°ä¸ºblockweaveçš„ç±»ä¼¼äºåŒºå—é“¾çš„æ–°æ•°æ®ç»“æ„ï¼Œå¯ä»¥å®ç°Arweaveåè®®ã€‚é€šè¿‡åŒºå—éšè—çµæ´»çš„å¤§å°äº¤æ˜“åŒºå—åˆ†é…ï¼›ä¸€ç§æ–°çš„å…±è¯†æœºåˆ¶ï¼Œå³å‡å°‘å¯¹å·¥ä½œè¯æ˜çš„ä¾èµ–åº¦ï¼Œç§°ä¸ºè®¿é—®è¯æ˜ï¼›ä»¥åŠç§°ä¸ºWildfireçš„è‡ªæˆ‘ä¼˜åŒ–ç½‘ç»œæ‹“æ‰‘ã€‚å°±åƒæ¯”ç‰¹å¸ç½‘ç»œä¸€æ ·ï¼Œæˆ‘ä»¬åœ¨éš”ç¦»æ–¹é¢çš„æŠ€æœ¯è¿›æ­¥å¹¶ä¸æ˜¯ååˆ†å¤æ‚ã€‚ä½†æ˜¯ï¼Œå½“ç»“åˆèµ·æ¥å½¢æˆæ•´ä¸ªç½‘ç»œæ—¶ï¼Œç´§æ€¥è¡Œä¸ºéå¸¸å¼ºå¤§ã€‚ä»æµ‹è¯•ç½‘çš„ç»“æœå¯ä»¥çœ‹å‡ºï¼Œåœ¨å…¬å…±çš„ï¼Œæ— è®¸å¯çš„å’Œåˆ†æ•£çš„ç½‘ç»œåè®®ä¸Šï¼Œå®‰å…¨ï¼Œå¯é å’Œä¸å˜çš„æ•°æ®å­˜å‚¨æ˜¯å¯èƒ½çš„ã€‚é™¤äº†æ•°æ®å­˜å‚¨æœŸé™å¤–ï¼Œä»»æ„å¤§å°çš„å—éƒ½ä½¿å®‰å…¨çš„é«˜ååé‡åŠ å¯†è´§å¸æˆä¸ºå¯èƒ½ï¼Œè€Œæ— éœ€è¯‰è¯¸å¤æ‚çš„å…±è¯†æœºåˆ¶ï¼Œä¾‹å¦‚dBFTæˆ–dPoSã€‚</p><p>Arweaveé€šè¿‡å…¶REST APIç´§å¯†åœ°è¿æ¥åˆ°Internetçš„ç»“æ„ä¸­ï¼Œå¹¶ä¸”æ­£åœ¨ä½¿ç”¨Arweaveä¸»ç½‘å»ºç«‹ä¸€äº›åˆ›æ”¶ä¸šåŠ¡ã€‚ Arweaveä¸å…¶ä»–æµè¡Œçš„åŠ å¯†è´§å¸ä¹‹é—´çš„æ¡¥æ¢ï¼Œå®‰å…¨çš„è®¡ç®—å’Œæ™ºèƒ½åˆçº¦åè®®å°†ä½¿ä½æˆæœ¬å’Œæ°¸ä¹…æ€§çš„æ•°æ®å­˜å‚¨è½»æ¾é›†æˆåˆ°åˆ†æ•£å¼åº”ç”¨ç¨‹åºçš„æŠ€æœ¯å †æ ˆä¸­ã€‚ä¸€ä¸ªå…¨é¢å…¨çƒåŒ–çš„ä¿¡æ¯å’Œé‡‘èäº¤æµä¸–ç•Œéœ€è¦æ°¸ä¹…è®°å½•ã€‚é€šè¿‡ç»“åˆåŠ å¯†æŠ€æœ¯å’Œåˆ†å¸ƒå¼ç³»ç»Ÿï¼Œæˆ‘ä»¬ä¸ºè¿™äº›æ°¸ä¹…è®°å½•æä¾›äº†åŸºç¡€ã€‚æˆ‘ä»¬å¸Œæœ›Arweaveå°†æˆä¸ºç°æœ‰äº’è”ç½‘åè®®ï¼ˆä¾‹å¦‚ï¼Œä¸‡ç»´ç½‘ï¼‰çš„å¿…è¦ä¼´ä¾£ã€‚ä¸ä»–äººåˆä½œï¼Œå»ºç«‹æ›´åŠ å¼€æ”¾å’Œé€æ˜çš„æœªæ¥ã€‚</p><h2 id="8-å¼•ç”¨ï¼ˆReferenceï¼‰"><a href="#8-å¼•ç”¨ï¼ˆReferenceï¼‰" class="headerlink" title="8. å¼•ç”¨ï¼ˆReferenceï¼‰"></a>8. å¼•ç”¨ï¼ˆReferenceï¼‰</h2><ol><li>Aweaveç™½çš®ä¹¦åœ°å€ï¼š<a href="https://www.arweave.org/files/arweave-lightpaper.pdf">https://www.arweave.org/files/arweave-lightpaper.pdf</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Arweave </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>å¸¸ç”¨å¯†ç å­¦åº“</title>
      <link href="/2022/03/28/cryptography/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%93%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/28/cryptography/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%93%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><p><a href="https://pkg.go.dev/golang.org/x/crypto/bn256">Goå®˜æ–¹</a> å·²ç»ä¸ç»´æŠ¤bn256.goåŒ…äº†ï¼Œæ¨èä½¿ç”¨<a href="https://github.com/cloudflare/bn256">cloudflare/bn256</a> ï¼Œä½†æ˜¯ä¹Ÿæœ‰å®‰å…¨æ¼æ´.</p><p>CP-ABEå®éªŒä¸­ä½¿ç”¨çš„åŒ…ä¸º<a href="https://github.com/fentec-project/bn256">fentec-project/bn256</a> ,æ­¤åŒ…æ˜¯ä» cloudflare/bn256 forkè¿‡æ¥çš„ï¼Œåªæ˜¯åŠ äº†HashG1ã€HashG2æ–¹æ³•</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><a href="https://github.com/JHUISI/charm">Charm</a></p><p>Charm æ˜¯ä¸€ä¸ªç”¨äºå¿«é€Ÿåˆ¶ä½œé«˜çº§å¯†ç ç³»ç»ŸåŸå‹çš„æ¡†æ¶ã€‚å®ƒåŸºäº Python è¯­è¨€ï¼Œä»å¤´å¼€å§‹è®¾è®¡ï¼Œä»¥æœ€å¤§é™åº¦åœ°å‡å°‘å¼€å‘æ—¶é—´å’Œä»£ç å¤æ‚æ€§ï¼ŒåŒæ—¶ä¿ƒè¿›ç»„ä»¶çš„é‡ç”¨ã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> å¯†ç å­¦ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30åˆ†é’Ÿåˆ›å»ºä¸€æ¡åŒºå—é“¾(äºŒ)</title>
      <link href="/2022/03/05/blockchain/other/30%E5%88%86%E9%92%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%BA%8C)/"/>
      <url>/2022/03/05/blockchain/other/30%E5%88%86%E9%92%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="å°†åŒºå—é“¾APIåŒ–"><a href="#å°†åŒºå—é“¾APIåŒ–" class="headerlink" title="å°†åŒºå—é“¾APIåŒ–"></a>å°†åŒºå—é“¾APIåŒ–</h2><p>åœ¨è¿™ä¸ªåŒºå—é“¾ä¸­ï¼Œæˆ‘ä»¬æƒ³è¦å®ç°ä¸‰ä¸ªAPIï¼Œåˆ†åˆ«æ˜¯</p><ul><li>/api/mineï¼šèŠ‚ç‚¹ä½¿ç”¨è¿™ä¸ªæ–¹æ³•æ¥æŒ–æ˜æ–°çš„åŒºå—</li><li>/api/transactions/new: è´¦æˆ·ä½¿ç”¨è¿™ä¸ªæ–¹æ³•æ¥å»ºç«‹æ–°çš„äº¤æ˜“</li><li>/api/chain: è¿”å›å½“å‰çš„åŒºå—é“¾</li></ul><p>ä¸ºäº†å¤ç”¨æˆ‘ä»¬åœ¨ä¸Šç¯‡å†™å¥½çš„ä»£ç ï¼Œæˆ‘ä»¬é¦–å…ˆå®‰è£…express.jsï¼Œå¹¶åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶ app.jsã€‚expressæ˜¯ä¸€ä¸ªåŸºäºnodeçš„httpæ¡†æ¶ï¼Œå®ƒå¯ä»¥å…è®¸æˆ‘ä»¬æ¥å—é€šè¿‡httpåè®®ä¼ è¾“çš„èŠ‚ç‚¹ä¿¡æ¯ã€‚æˆ‘ä»¬è¿˜éœ€è¦body-parserå¸®åŠ©æˆ‘ä»¬è§£ç èŠ‚ç‚¹å‘é€è¿‡æ¥çš„ä¿¡æ¯ã€‚</p><h2 id="å®ç°åˆ†å¸ƒå¼å…±è¯†"><a href="#å®ç°åˆ†å¸ƒå¼å…±è¯†" class="headerlink" title="å®ç°åˆ†å¸ƒå¼å…±è¯†"></a>å®ç°åˆ†å¸ƒå¼å…±è¯†</h2><p>ä»¥ä¸Šæˆ‘ä»¬å·²ç»å®ç°äº†ä¸€ä¸ªå•æœºç‰ˆçš„åŒºå—é“¾äº†ï¼Œä½†åŒºå—é“¾ä¹‹æ‰€ä»¥æœ‰ç”¨ï¼Œæ˜¯å› ä¸ºå®ƒèƒ½è¢«éƒ¨ç½²åˆ°å¤šä¸ªèŠ‚ç‚¹ä¸Šå»ï¼Œå¹¶ä¸”æ‰€æœ‰èŠ‚ç‚¹éƒ½èƒ½å¤Ÿç›¸äº’æ›´æ–°ï¼Œå®ç°åˆ†å¸ƒå¼çš„å…±è¯†ã€‚è¿™æ ·çš„æœºåˆ¶ä¿è¯äº†æˆ‘ä»¬èƒ½å¤ŸæŠµå¾¡double spending attackä»¥åŠç¡®ä¿åªæœ‰ä¸€æ¡åŒºå—é“¾åœ¨è¿è¡Œã€‚</p><p>ä¸ºäº†å®ç°æˆ‘ä»¬çš„åˆ†å¸ƒå¼å…±è¯†ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦çŸ¥é“ç½‘ç»œä¸Šå…¶ä»–çš„èŠ‚ç‚¹åœ¨å“ªé‡Œã€‚ä»¿ç…§Ethereumçš„ Node Discovery Protocolï¼Œæˆ‘ä»¬å¯ä»¥åšä¸€ä¸ªç±»ä¼¼çš„æœç´¢èŠ‚ç‚¹çš„åŠŸèƒ½å’ŒèŠ‚ç‚¹æ³¨å†ŒåŠŸèƒ½</p><pre><code class="javascript">_app.post('/api/nodes/register', (req, res) =&gt; {    // æ³¨å†ŒèŠ‚ç‚¹    let newNode = _.pick(req.body, ['ip', 'port']);    neighbors.push(newNode);    console.log('new node detected. Node info: ' + JSON.stringify(newNode));    res.send({        message: 'Node ' + newNode.ip + ':' + newNode.port + ' is added to my network'    });});</code></pre><h3 id="å…±è¯†å®ç°-è§£å†³å†²çªé“¾"><a href="#å…±è¯†å®ç°-è§£å†³å†²çªé“¾" class="headerlink" title="å…±è¯†å®ç°: è§£å†³å†²çªé“¾"></a>å…±è¯†å®ç°: è§£å†³å†²çªé“¾</h3><p>çŸ¥é“äº†é™„è¿‘çš„èŠ‚ç‚¹åœ¨å“ªï¼Œæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹å®ç°æˆ‘ä»¬çš„å…±è¯†ç®—æ³•ã€‚å…±è¯†ç®—æ³•çš„ç¬¬ä¸€éƒ¨åˆ†éœ€è¦æˆ‘ä»¬èƒ½å¤Ÿè¾¨åˆ«å‡ºæœ€é•¿ä¸”æœ‰æ•ˆçš„é“¾ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ä¹‹å‰å†™çš„åŒºå—é“¾æ¨¡å‹é‡ŒåŠ å…¥æ–°çš„å‡½æ•°å®ç°ã€‚</p><p>åœ¨ <code>app.js</code>ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ¯æ¬¡æŒ–çŸ¿ä¹‹åéƒ½å‘é™„è¿‘çš„èŠ‚ç‚¹å¹¿æ’­ï¼Œä»¥è§£å†³å†²çªé“¾ã€‚é¦–å…ˆæˆ‘ä»¬éœ€è¦å»ºç«‹ä¸€ä¸ªæ–°çš„ç«¯ç‚¹ <code>/api/nodes/resolve</code>ã€‚å»ºç«‹å¥½ç«¯ç‚¹ä¹‹åæˆ‘ä»¬éœ€è¦åœ¨æŒ–çŸ¿ä¹‹åå¯¹æ‰€æœ‰çš„é‚»å±…è¿›è¡Œå¹¿æ’­ã€‚</p><p>è¿™æ ·setupä¹‹åï¼Œæˆ‘ä»¬çš„èŠ‚ç‚¹åœ¨æ¯ä¸€æ¬¡æŒ–çŸ¿çš„æ—¶å€™éƒ½ä¼šå¯¹é™„è¿‘çš„é‚»å±…è¿›è¡Œå¹¿æ’­å¹¶å¯»æ±‚consensusã€‚å½“ç„¶ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥è®¾å®šå®šæ—¶ä»»åŠ¡æ¥æ›´é«˜é¢‘çš„è¿›è¡Œå¹¿æ’­ã€‚å¦å¤–ï¼Œæˆ‘ä»¬ä¹Ÿæ²¡æœ‰å¯¹æ”¶åˆ°çš„chainè¿›è¡Œç”µå­éªŒè¯ï¼Œæ²¡æœ‰åŠ¨æ€åŒ–çš„å¯»æ‰¾ç›¸é‚»èŠ‚ç‚¹ï¼Œæ²¡æœ‰å°†æ¯ä¸€ä¸ªtransactionå¹¿æ’­ï¼Œä»¥åŠä¸€ç³»åˆ—å¯ä»¥å®Œå–„çš„åœ°æ–¹ï¼Œä¸è¿‡åœ¨è¿™ç¯‡æ•™ç¨‹å½“ä¸­æˆ‘ä»¬å°±ä¸ç»§ç»­ä¸‹å»äº†ã€‚</p><pre><code class="javascript">_app.get('/api/mine', (req, res) =&gt; {    // æŒ–çŸ¿    myChain.createBlock();    let p = new Promise((resolve) =&gt; resolve());    for (let i of neighbors) {        let resolveUri = 'http://' + i.ip + ':' + i.port + '/api/nodes/resolve';        console.log("send resolve to: " + resolveUri);        p.then(() =&gt; rp({            uri: resolveUri,            method: 'POST',            json: true,            body: {'chain': myChain}        })).then((res) =&gt; {            // åŒæ­¥æœ€é•¿é“¾            myChain.resolveChain(JSON.parse(res.body)["chain"]);        });    }    p.then(() =&gt; {        res.send({            message: 'A new block is mined, and conflict is resolved',            content: myChain.lastBlock()        });    });});</code></pre><h2 id="æ€»ç»“"><a href="#æ€»ç»“" class="headerlink" title="æ€»ç»“"></a>æ€»ç»“</h2><p>ä»¥ä¸Šæˆ‘ä»¬å®ç°äº†ä¸€ä¸ªç®€å•çš„åŒºå—é“¾ï¼Œè™½ç„¶è¿™ä¸ªåŒºå—é“¾ç®€é™‹ä¸”ä¸å®‰å…¨ï¼Œä½†æ˜¯æˆ‘ä»¬èƒ½å¤ŸæˆåŠŸå°†å®ƒéƒ¨ç½²åˆ°å¤šä¸ªèŠ‚ç‚¹ä¸Šï¼Œå®ç°äº†æœ€åŸºæœ¬çš„åŒºå—é“¾çš„åŠŸèƒ½ã€‚</p><p>å®Œæ•´ä»£ç ï¼š<a href="https://github.com/zhangzhishun/sugar-blockchain-js">ä»£ç </a></p><h2 id="å‚è€ƒ"><a href="#å‚è€ƒ" class="headerlink" title="å‚è€ƒ"></a>å‚è€ƒ</h2><ol><li><a href="https://mp.weixin.qq.com/s/6jwIj_m86dpGk62biEJyIA">30åˆ†é’Ÿè‡ªå·±å†™ä¸€æ¡åŒºå—é“¾(ä¸€)</a></li><li><a href="https://mp.weixin.qq.com/s/UbLx2mHEb9OyPeJBwP2bvg">30åˆ†é’Ÿè‡ªå·±å†™ä¸€æ¡åŒºå—é“¾(äºŒ)</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> éƒ¨ç½²æ–‡æ¡£ </tag>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30åˆ†é’Ÿåˆ›å»ºä¸€æ¡åŒºå—é“¾(ä¸€)</title>
      <link href="/2022/02/28/blockchain/other/30%E5%88%86%E9%92%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%B8%80)/"/>
      <url>/2022/02/28/blockchain/other/30%E5%88%86%E9%92%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>å¦‚ä½•ä»æŠ€æœ¯ä¸Šå®ç°ä¸€æ¡åŒºå—é“¾ï¼Ÿ<br>é¦–å…ˆï¼Œè¿™é‡Œå‡å®šè¯»è€…æœ‰åŸºæœ¬çš„ç¼–ç¨‹èƒ½åŠ›ï¼Œè™½ç„¶æœ¬æ–‡ç”¨äº†Javascriptæ¥å†™ï¼Œä½†æŒæ¡ä»»æ„ä¸€é—¨ç¼–ç¨‹è¯­è¨€çš„è¯»è€…é˜…è¯»èµ·æ¥åº”è¯¥ä¸ä¼šæœ‰ä»»ä½•éš¾åº¦ã€‚</p><h2 id="å¼€å‘å‡†å¤‡"><a href="#å¼€å‘å‡†å¤‡" class="headerlink" title="å¼€å‘å‡†å¤‡"></a>å¼€å‘å‡†å¤‡</h2><p>æˆ‘ä»¬é¦–å…ˆéœ€è¦å®‰è£…æœ€æ–°ç‰ˆçš„Node.js</p><h2 id="ç¬¬ä¸€æ­¥ï¼Œæ­å»ºåŒºå—é“¾æ¨¡å‹"><a href="#ç¬¬ä¸€æ­¥ï¼Œæ­å»ºåŒºå—é“¾æ¨¡å‹" class="headerlink" title="ç¬¬ä¸€æ­¥ï¼Œæ­å»ºåŒºå—é“¾æ¨¡å‹"></a>ç¬¬ä¸€æ­¥ï¼Œæ­å»ºåŒºå—é“¾æ¨¡å‹</h2><p>æˆ‘ä»¬é¦–å…ˆæ¥æ­ä¸€ä¸ªèƒ½å¤Ÿæ–°å»ºåŒºå—ï¼Œåˆ›å»ºäº¤æ˜“çš„åŒºå—é“¾çš„æ¨¡å‹ã€‚</p><pre><code class="javascript">'use strict';//å®šä¹‰ä¸€ä¸ªclassï¼Œå«BlockChainï¼Œæ¯ä¸€ä¸ªåŒºå—é“¾éƒ½æ˜¯è¿™ä¸ªclassçš„å®ä¾‹class BlockChain {    constructor() {        this.chain = []; // å‚¨å­˜æ‰€æœ‰åŒºå—        this.difficulty = 4; // æŒ–çŸ¿çš„éš¾åº¦    }    isProofValid(tentativeBlock) {        // è¿™é‡Œæˆ‘ä»¬åˆ¤æ–­newProofæ˜¯ä¸æ˜¯ä¸€ä¸ªåˆæ³•çš„proofçš„æ–¹æ³•æ˜¯    }    createBlock(transaction, previousHash = undefined) {        // åˆ›é€ ä¸€ä¸ªæ–°åŒºå—    }    createTransaction(sender, receiver, value) {        // åˆ›å»ºä¸€ä¸ªäº¤æ˜“    }    static hash(block) {        // å¯¹ä¸€ä¸ªåŒºå—è¿›è¡Œå“ˆå¸Œ:    }    lastBlock() {        // å–å¾—é“¾ä¸Šçš„æœ€åä¸€ä¸ªåŒºå—    }    miner() {        // æŒ–çŸ¿ç¨‹åº    }}</code></pre><p>è¿™é‡Œè¦è§£é‡Šä¸€ä¸‹åŒºå—(block)å’Œäº¤æ˜“(transaction)å„è‡ªé•¿ä»€ä¹ˆæ ·ï¼Œè™½ç„¶ä¸åŒåŒºå—é“¾çš„åŒºå—æ¨¡å‹æœ‰å¾ˆå¤§å·®å¼‚ï¼Œä½†æœ€åŸºæœ¬çš„ä¸€äº›å…ƒç´ éƒ½æ˜¯ç›¸é€šçš„ã€‚ä¸€ä¸ªæœ€åŸºæœ¬çš„åŒºå—å¤§æ¦‚é•¿ä¸‹é¢è¿™æ ·ï¼š</p><pre><code class="javascript">var block = {       timestamp: 1516245715528,     id: 0,    proof: 786453290000,    previousBlockHash: "12f79cda4fb3f084531de2034e6b4acf",    transactions: [{        sender: "0xca35b7d915458ef540ade6068dfe2f44e8fa733c",        receiver: "0x14723a09acff6d2a60dcdf7aa4aff308fddc160c",        value: 100    }]}</code></pre><p>å¯ä»¥çœ‹åˆ°ï¼Œä¸€ä¸ªåŒºå—åŒ…å«äº†å®ƒè¢«æŒ–å‡ºæ¥çš„æ—¶é—´æˆ³(timestamp)ï¼Œå®ƒåœ¨åŒºå—é“¾é‡Œçš„ä½ç½®(id)ï¼Œå®ƒçš„è¯æ˜(proof, æ›´å¤šçš„ä¼šåœ¨ä¹‹åè®²åˆ°)ï¼Œå‰ä¸€ä¸ªåŒºå—çš„æ•´ä½“å“ˆå¸Œå€¼(previousBlockHash)ï¼ŒåŒ…å«çš„äº¤æ˜“(transactions)ã€‚ ä½œä¸ºä¸€ä¸ªæœ€åŸºæœ¬çš„äº¤æ˜“æ¨¡å‹ï¼Œæ¯ä¸€ä¸ªäº¤æ˜“åªåŒ…å«äº†å‘é€è€…çš„åœ°å€(sender)ï¼Œæ¥å—è€…çš„åœ°å€(receiver)ï¼Œä»¥åŠè¿™æ¬¡äº¤æ˜“çš„ä»·å€¼(value)ã€‚</p><h2 id="ç¬¬äºŒæ­¥ï¼Œå®ç°åŸºæœ¬åŠŸèƒ½"><a href="#ç¬¬äºŒæ­¥ï¼Œå®ç°åŸºæœ¬åŠŸèƒ½" class="headerlink" title="ç¬¬äºŒæ­¥ï¼Œå®ç°åŸºæœ¬åŠŸèƒ½"></a>ç¬¬äºŒæ­¥ï¼Œå®ç°åŸºæœ¬åŠŸèƒ½</h2><p>å·¥å…·å‡½æ•°<br>è¿™é‡Œæˆ‘ä»¬é¦–å…ˆå®ç°ä¸€ä¸ªå·¥å…·å‡½æ•°Hash(block), å®ƒä¼šå¸®åŠ©æˆ‘ä»¬å°†ä¸€ä¸ªåŒºå—è¿›è¡Œå“ˆå¸Œã€‚è¿™ä¸ªå‡½æ•°ä¼šåœ¨æˆ‘ä»¬è¿›è¡ŒæŒ–çŸ¿(å‘æ˜æ–°åŒºå—)çš„æ—¶å€™ç”¨åˆ°ã€‚</p><pre><code class="javascript">static hash(block) {    // å¯¹ä¸€ä¸ªåŒºå—è¿›è¡Œå“ˆå¸Œ:    // ç°å°†block è½¬æ¢æˆbase64    // å°†å¾—åˆ°çš„ç»“æœè¿›è¡ŒSHAå“ˆå¸Œ    const blockStr = JSON.stringify(block);    const blockB64 = new Buffer(blockStr).toString("base64");    const newHash = crypto.createHash("sha256");    newHash.update(blockB64);    return newHash.digest("hex");}</code></pre><p>è¿™ä¸ªå‡½æ•°å°†ä¸€ä¸ªåŒºå—ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªJavascript objectï¼Œå“ˆå¸Œæˆä¸€æ®µå­—ç¬¦ä¸²ã€‚æˆ‘ä»¬ä½¿ç”¨äº†cryptoè¿™ä¸ªå·¥å…·ï¼Œåœ¨æœ€æ–°ç‰ˆçš„Node.jsé‡Œé¢å·²ç»æ˜¯å†…ç½®äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬å¹¶ä¸éœ€è¦å®‰è£…å®ƒã€‚</p><p>åˆ›å»ºä¸€ä¸ªæ–°äº¤æ˜“<br>ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬å®ç°åˆ›å»ºæ–°äº¤æ˜“çš„æ–¹æ³•ã€‚</p><pre><code class="javascript">createTransaction(sender, receiver, value) {    // åˆ›å»ºä¸€ä¸ªäº¤æ˜“    // æ ¹æ®æä¾›çš„sender, receiveråœ°å€ï¼Œä»¥åŠè½¬è´¦çš„ä»·å€¼ï¼Œå»ºç«‹ä¸€ä¸ªäº¤æ˜“    // å¹¶æŠŠå®ƒåŠ å…¥åˆ°æˆ‘ä»¬çš„åŒºå—é“¾é‡Œ    const transaction = {        sender: sender,        receiver: receiver,        value: value    };    this._packTransactions.push(transaction);    return this.miner();}</code></pre><p>éå¸¸ç›´è§‚ï¼Œæˆ‘ä»¬åªæ˜¯åˆ›å»ºäº†ä¸€ä¸ªobjectï¼ŒåŠ å…¥åˆ°åŒºå—é“¾é‡Œå¹¶è¿”å›è€Œå·²ã€‚</p><p>åˆ›å»ºä¸€ä¸ªæ–°åŒºå—<br>æˆ‘ä»¬ç°åœ¨æ¥å®ç°åˆ›å»ºä¸€ä¸ªåŒºå—çš„ä»£ç ã€‚å½“æˆ‘ä»¬çš„åŒºå—é“¾è¿ä¸€ä¸ªåŒºå—ä¹Ÿæ²¡æœ‰çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦å»ºç«‹ç¬¬ä¸€ä¸ªåŒºå—(genesis block)ï¼Œè¿™ä¸€ç‚¹æˆ‘ä»¬åœ¨constructoré‡Œé¢å®ç°ã€‚</p><pre><code class="javascript">constructor() {    this.chain = []; // å‚¨å­˜æ‰€æœ‰åŒºå—    this.difficulty = 4; // æŒ–çŸ¿çš„éš¾åº¦    this.createBlock(["Genesis Block"], 1); // åˆ›å»ºç¬¬ä¸€ä¸ªåŒºå—    this._packTransactions = []; // å½“å‰éœ€è¦æ‰“åŒ…çš„æ•°æ®}createBlock(transaction, previousHash = undefined) {    // åˆ›é€ ä¸€ä¸ªæ–°åŒºå—    // ä¸€å¼€å§‹çš„proofæ˜¯0ï¼Œä¸ä¸€å®šæ˜¯æœ‰æ•ˆçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦mineProofæ¥æ‰¾åˆ°æœ‰æ•ˆçš„proof    let block = {        timestamp: Date.now(),        id: this.chain.length,        proof: 0,        previousBlockHash: previousHash || this.constructor.hash(this.lastBlock()),        transactions: transaction    };    const hash = this.mineProof(block);    this.chain.push(block);    return hash;}</code></pre><p>åœ¨åˆ›å»ºä¸€ä¸ªæ–°åŒºå—çš„æ—¶å€™ï¼Œæˆ‘ä»¬ç”¨äº†å½“å‰æ—¶é—´çš„æ—¶é—´æˆ³ï¼Œä»¥ç°åœ¨åŒºå—é“¾çš„é•¿åº¦ä½œä¸ºidï¼Œåˆå§‹çš„proofè®¾ç½®ä¸º0(proofä¼šåœ¨ä¸‹ä¸€æ­¥è¯¦ç»†è®²åˆ°)ï¼Œå¹¶å°†ä¸Šä¸€ä¸ªåŒºå—æ•´ä½“è¿›è¡Œå“ˆå¸Œå¹¶èµ‹å€¼ç»™previousBlockHashã€‚åœ¨åˆ›å»ºgenesis åŒºå—çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°†previousBlockHashè®¾ç½®ä¸º1ã€‚ ä¸ºäº†ä¾¿äºç†è§£ï¼Œæˆ‘ä»¬å»ºç«‹æ–°åŒºå—çš„æ—¶å€™æ²¡æœ‰é™„ä¸Šä»»ä½•äº¤æ˜“ï¼Œå®é™…çš„æƒ…å†µæ˜¯çŸ¿å·¥å¯ä»¥è‡ªä¸»é€‰æ‹©åŒ…å«å“ªäº›äº¤æ˜“ï¼Œå¹¶éœ€è¦å¯¹è¿™äº›äº¤æ˜“è¿›è¡Œå¤„ç†å¾—åˆ°ä¸€ä¸ªé»˜å…‹å°”æ ‘ã€‚</p><h2 id="ç†è§£æŒ–çŸ¿ï¼šæ‰¾åˆ°æœ‰æ•ˆçš„Proof"><a href="#ç†è§£æŒ–çŸ¿ï¼šæ‰¾åˆ°æœ‰æ•ˆçš„Proof" class="headerlink" title="ç†è§£æŒ–çŸ¿ï¼šæ‰¾åˆ°æœ‰æ•ˆçš„Proof"></a>ç†è§£æŒ–çŸ¿ï¼šæ‰¾åˆ°æœ‰æ•ˆçš„Proof</h2><p>è¯»è€…æœ‹å‹ä»¬åº”è¯¥éƒ½å¬è¯´è¿‡å·¥ä½œé‡è¯æ˜(Proof of Work)ï¼ŒPOWæ˜¯åŒºå—é“¾ä¸­ç”¨æ¥åˆ›é€ åŒºå—çš„æ ¸å¿ƒç®—æ³•æˆ–è€…æœºåˆ¶ã€‚POWæœ¬èº«çš„ç›®çš„æ˜¯ä¸ºäº†æ‰¾åˆ°ä¸€ä¸ªæ•°å­—æ¥è§£å†³ä¸€ä¸ªæ•°å­¦é—®é¢˜ï¼Œè€Œæ‰¾åˆ°è¿™ä¸ªæ•°å­—çš„éš¾åº¦æ˜¯è¶Šæ¥è¶Šé«˜çš„ï¼Œä½†ä¸€æ—¦æ‰¾åˆ°ä¹‹åï¼Œè¦è¯æ˜å®ƒè§£å†³äº†è¿™ä¸ªæ•°å­¦é—®é¢˜åˆæ˜¯éå¸¸å®¹æ˜“çš„ï¼Œä»»ä½•äººéƒ½èƒ½å¾ˆå¿«åšåˆ°ã€‚ å½“ç„¶é™¤äº†Proof of Workä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜æœ‰Proof of Space, Proof of Stakeï¼Œåœ¨ä»£ç é‡Œæˆ‘ä»¬å°±ç”¨proofæ¥ä»£è¡¨æ‰¾åˆ°çš„è¿™ä¸ªæ•°å­—ã€‚ é‚£ä¹ˆè¿™ä¸ªæ•°å­¦é—®é¢˜åˆ°åº•æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬ç”¨ä¸€ä¸ªä¾‹å­æ¥å›ç­”ã€‚</p><p>ç»™å®šä¸€ä¸ªæ•°å­—Aï¼Œæˆ‘ä»¬æƒ³æ‰¾åˆ°æ•°å­—Bï¼Œä½¿å¾—Hash(A<em>B)çš„ç»“æœCçš„æœ€å1ä½ç­‰äº0ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒCå¯ä»¥æ˜¯Hash(A</em>B)=2ba83â€¦6d0ï¼Œå› ä¸ºå®ƒçš„æœ€åä¸€ä½æ˜¯0ã€‚</p><h2 id="å®ç°æŒ–çŸ¿"><a href="#å®ç°æŒ–çŸ¿" class="headerlink" title="å®ç°æŒ–çŸ¿"></a>å®ç°æŒ–çŸ¿</h2><p>çŸ¥é“äº†å¦‚ä½•æŒ–çŸ¿ä¹‹åï¼Œæˆ‘ä»¬å°†ä¸Šé¢çš„ä»£ç èåˆåˆ°æˆ‘ä»¬çš„åŒºå—é“¾æ¨¡å‹é‡Œã€‚</p><pre><code class="javascript">    isProofValid(tentativeBlock) {        // è¿™é‡Œæˆ‘ä»¬åˆ¤æ–­newProofæ˜¯ä¸æ˜¯ä¸€ä¸ªåˆæ³•çš„proofçš„æ–¹æ³•æ˜¯        // å°†æ•´ä¸ªåŒºå—è¿›è¡Œå“ˆå¸Œ        // å¦‚æœå¾—åˆ°çš„æ•£åˆ—å€¼æŒ‡çš„æœ€ånä½éƒ½æ˜¯0ï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸€ä¸ªvalid proof        // å…¶ä¸­ï¼Œn = difficulty        const result = this.constructor.hash(tentativeBlock);        return result.substr(result.length - this.difficulty) === '0'.repeat(this.difficulty);    }    mineProof(tentativeBlock) {        console.log("miner block start: " + JSON.stringify(tentativeBlock));        while (!this.isProofValid(tentativeBlock)) {            tentativeBlock.proof += 1; // å¦‚æœä¸æ˜¯å¯ç”¨çš„proofï¼Œæˆ‘ä»¬å°±æ¥ç€æšä¸¾        }        const hash = this.constructor.hash(tentativeBlock);        console.log("miner block success. Hash: " + hash);        return hash;    }    createBlock(transaction, previousHash = undefined) {        // åˆ›é€ ä¸€ä¸ªæ–°åŒºå—        // ä¸€å¼€å§‹çš„proofæ˜¯0ï¼Œä¸ä¸€å®šæ˜¯æœ‰æ•ˆçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦mineProofæ¥æ‰¾åˆ°æœ‰æ•ˆçš„proof        let block = {            timestamp: Date.now(),            id: this.chain.length,            proof: 0,            previousBlockHash: previousHash || this.constructor.hash(this.lastBlock()),            transactions: transaction        };        const hash = this.mineProof(block);        this.chain.push(block);        return hash;    }    miner() {        // æŒ–çŸ¿ç¨‹åº        if (this._packTransactions.length &gt; 0) {            const hash = this.createBlock([this._packTransactions[this._packTransactions.length - 1]]);            if (hash) {                this._packTransactions.pop();                return hash            }        }    }</code></pre><p>å®Œæ•´ä»£ç ï¼š<a href="https://github.com/zhangzhishun/sugar-blockchain-js/blob/master/blockchain.js">blockchain</a></p><p>å‚è€ƒï¼š</p><ol><li><a href="https://mp.weixin.qq.com/s/6jwIj_m86dpGk62biEJyIA">30åˆ†é’Ÿè‡ªå·±å†™ä¸€æ¡åŒºå—é“¾(ä¸€)</a></li><li><a href="https://mp.weixin.qq.com/s/UbLx2mHEb9OyPeJBwP2bvg">30åˆ†é’Ÿè‡ªå·±å†™ä¸€æ¡åŒºå—é“¾(äºŒ)</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> éƒ¨ç½²æ–‡æ¡£ </tag>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NFTæ¡†æ¶ OpenZeppelin ERC721æºç åˆ†æ</title>
      <link href="/2022/02/26/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelinERC721%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/02/26/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelinERC721%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>ERC721å®˜æ–¹ç®€ä»‹æ˜¯ï¼šA standard interface for non-fungible tokens, also known as deeds.ä¹Ÿå«éåŒè´¨ä»£å¸ï¼Œæˆ–è€…ä¸å¯ç½®æ¢ä»£å¸ï¼ˆNFTsï¼‰ã€‚æåˆ°ERC721ï¼Œä¸€ä¸ªå¥½ç†è§£çš„ä¾‹å­å°±æ˜¯<a href="https://link.segmentfault.com/?enc=C1N3804jiPfa4j/kbVqQeA==.qKJ3FJzSnC5Qcs2rB15IvrOOttPxdU0dtue8Pk75gJ0=">CryptoKittiesè¿·æ‹çŒ«</a> ,æ¯ä¸€åªçŒ«éƒ½æ˜¯ç‹¬ä¸€æ— äºŒçš„æ‹¥æœ‰ä¸åŒåŸºå› ï¼Œæœ‰æ”¶è—ä»·å€¼å±æ€§ã€‚ERC721å¯¹äºè™šæ‹Ÿèµ„äº§æ”¶è—å“é¢†åŸŸä¼šæœ‰å¾ˆå¥½çš„åº”ç”¨ä»·å€¼å’Œå¸‚åœºéœ€æ±‚ã€‚</p><p>ERC721æ˜¯ä»¥å¤ªåŠå’Œ Wanchain åŒºå—é“¾çš„<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md">ERC-721ä¸å¯æ›¿ä»£ä»¤ç‰Œæ ‡å‡†çš„å®Œæ•´å‚è€ƒå®ç°ã€‚</a>å®ƒè¿˜ä¸å…¶ä»– EVM å…¼å®¹é“¾å…¼å®¹ï¼Œå¦‚ Binance Smart Chain (BSC)ã€Avalanche (AVAX) ç­‰ã€‚è¿™æ˜¯ä¸€ä¸ªå¼€æºé¡¹ç›®ï¼Œå®Œæˆäº†<a href="https://hardhat.org/">Hardhat</a>æµ‹è¯•ã€‚</p><p>æ­¤é¡¹ç›®çš„ç›®çš„æ˜¯ä¸ºä»»ä½•æƒ³è¦åœ¨ä»¥å¤ªåŠå’Œ Wanchain åŒºå—é“¾ä¸Šä½¿ç”¨å’Œå¼€å‘ä¸å¯æ›¿ä»£ä»£å¸çš„äººæä¾›ä¸€ä¸ªè‰¯å¥½çš„èµ·ç‚¹ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ç»è¿‡å¤šæ¬¡å®¡æ ¸çš„ä»£ç ï¼Œè€Œä¸æ˜¯è‡ªå·±é‡æ–°å®ç° ERC-721ï¼Œæ­¤å®ç°æ¯” ERC-721 æ ‡å‡†æ›´å…·é™åˆ¶æ€§ï¼Œå› ä¸ºå®ƒä¸æ”¯æŒ<code>payable</code>å¼€ç®±å³ç”¨çš„å‡½æ•°è°ƒç”¨ã€‚ä½†æ˜¯ï¼Œæ‚¨å¯ä»¥è‡ªå·±æ·»åŠ å®ƒã€‚</p><p>åˆçº¦åˆ—è¡¨ï¼š</p><ul><li><a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token.sol"><code>nf-token.sol</code></a>ï¼šè¿™æ˜¯åŸºæœ¬çš„ ERC-721 tokenå®ç°ï¼ˆæ”¯æŒ ERC-165ï¼‰ã€‚</li><li><a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token-metadata.sol"><code>nf-token-metadata.sol</code></a>ï¼šè¿™ä¸ºä»£å¸åˆçº¦å®ç°äº†å¯é€‰çš„ ERC-721 å…ƒæ•°æ®åŠŸèƒ½ã€‚å®ƒå®ç°äº†ä¸€ä¸ªtokenåç§°ã€ä¸€ä¸ªç¬¦å·å’Œä¸€ä¸ªæŒ‡å‘å…¬å¼€æš´éœ²çš„ ERC-721 JSON å…ƒæ•°æ®æ–‡ä»¶çš„ä¸åŒ URIã€‚</li><li><a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token-enumerable.sol"><code>nf-token-enumerable.sol</code></a>ï¼šè¿™å®ç°äº†å¯¹æšä¸¾çš„å¯é€‰ ERC-721 æ”¯æŒã€‚å¦‚æœæ‚¨æƒ³çŸ¥é“ä»£å¸çš„æ€»ä¾›åº”é‡ã€æŒ‰ç´¢å¼•æŸ¥è¯¢ä»£å¸ç­‰ï¼Œè¿™å¾ˆæœ‰ç”¨</li></ul><p>åˆçº¦ç±»ã€æ¥å£ä¹‹é—´çš„ç»§æ‰¿å…³ç³»ï¼š</p><p><img src="/images/open-zeppelin-erc721/image-20220226171652608.png" alt="image-20220226171652608"></p><h2 id="1-SupportsInterface"><a href="#1-SupportsInterface" class="headerlink" title="1. SupportsInterface"></a>1. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/utils/supports-interface.sol">SupportsInterface</a></h2><p>å®ç°æ£€æµ‹æ™ºèƒ½åˆçº¦æ¥å£çš„æ ‡å‡†ã€‚</p><p>ä¾‹å¦‚åœ¨åˆçº¦çš„æ„é€ å‡½æ•°å®šä¹‰å¦‚ä¸‹å†…å®¹æŒ‡å®šæ£€æµ‹æ ‡å‡†ï¼š</p><pre><code class="javascript">supportedInterfaces[0x01ffc9a7] = true; // ERC165supportedInterfaces[0x780e9d63] = true; // ERC721EnumerablesupportedInterfaces[0x5b5e139f] = true; // ERC721MetadatasupportedInterfaces[0x80ac58cd] = true; // ERC721</code></pre><p>æºç ï¼š</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./erc165.sol";/** * @dev Implementation of standard for detect smart contract interfaces. */contract SupportsInterface is  ERC165{  /**   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.   */  mapping(bytes4 =&gt; bool) internal supportedInterfaces;  /**   * @dev Contract constructor.   */  constructor()  {    supportedInterfaces[0x01ffc9a7] = true; // ERC165  }  /**   * @dev Function to check which interfaces are suported by this contract.   * @param _interfaceID Id of the interface.   * @return True if _interfaceID is supported, false otherwise.   */  function supportsInterface(    bytes4 _interfaceID  )    external    override    view    returns (bool)  {    return supportedInterfaces[_interfaceID];  }}</code></pre><h2 id="2-ERC721"><a href="#2-ERC721" class="headerlink" title="2. ERC721"></a>2. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/erc721.sol">ERC721</a></h2><p>ERC721åˆçº¦å®šä¹‰äº†åŸºæœ¬çš„æ¥å£æ–¹æ³•ï¼š</p><ul><li><p>safeTransferFromï¼šè½¬ç§»ä»£å¸æ‰€æœ‰æƒ</p></li><li><p>transferFromï¼šè½¬ç§»ä»£å¸æ‰€æœ‰æƒ</p></li><li><p>setApprovalForAllï¼šæˆæƒoperatorå…·æœ‰æ‰€æœ‰ä»£å¸çš„æ§åˆ¶æƒ</p></li><li><p>balanceOfï¼šè¿”å›ownerçš„ä»£å¸æ•°é‡</p></li><li><p>ownerOfï¼šæ ¹æ®tokenIdè¿”å›ä»£å¸æŒæœ‰è€…address</p></li><li><p>getApprovedï¼šæŸ¥è¯¢tokenIdçš„æˆæƒäººoperator address</p></li><li><p>approve æˆæƒtokenIdç»™åœ°å€to</p></li><li><p>isApprovedForAllï¼šæŸ¥è¯¢ä¸€ä¸ªåœ°å€æ˜¯å¦ä¸ºå¦ä¸€ä¸ªåœ°å€çš„æˆæƒæ“ä½œè€…ã€‚</p></li></ul><p>æºç ï¼š</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/** * @dev ERC-721 non-fungible token standard. * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md. */interface ERC721{  /**   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any   * number of NFTs may be created and assigned without emitting Transfer. At the time of any   * transfer, the approved address for that NFT (if any) is reset to none.   */  event Transfer(    address indexed _from,    address indexed _to,    uint256 indexed _tokenId  );  /**   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero   * address indicates there is no approved address. When a Transfer event emits, this also   * indicates that the approved address for that NFT (if any) is reset to none.   */  event Approval(    address indexed _owner,    address indexed _approved,    uint256 indexed _tokenId  );  /**   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage   * all NFTs of the owner.   */  event ApprovalForAll(    address indexed _owner,    address indexed _operator,    bool _approved  );  /**   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this   * function checks if `_to` is a smart contract (code size &gt; 0). If so, it calls   * `onERC721Received` on `_to` and throws if the return value is not   * `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.   * @dev Transfers the ownership of an NFT from one address to another address. This function can   * be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   * @param _data Additional data with no specified format, sent in call to `_to`.   */  function safeTransferFrom(    address _from,    address _to,    uint256 _tokenId,    bytes calldata _data  )    external;  /**   * @notice This works identically to the other function with an extra data parameter, except this   * function just sets data to ""   * @dev Transfers the ownership of an NFT from one address to another address. This function can   * be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   */  function safeTransferFrom(    address _from,    address _to,    uint256 _tokenId  )    external;  /**   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else   * they may be permanently lost.   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero   * address. Throws if `_tokenId` is not a valid NFT.  This function can be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   */  function transferFrom(    address _from,    address _to,    uint256 _tokenId  )    external;  /**   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is   * the current NFT owner, or an authorized operator of the current owner.   * @param _approved The new approved NFT controller.   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.   * @param _tokenId The NFT to approve.   */  function approve(    address _approved,    uint256 _tokenId  )    external;  /**   * @notice The contract MUST allow multiple operators per owner.   * @dev Enables or disables approval for a third party ("operator") to manage all of   * `msg.sender`'s assets. It also emits the ApprovalForAll event.   * @param _operator Address to add to the set of authorized operators.   * @param _approved True if the operators is approved, false to revoke approval.   */  function setApprovalForAll(    address _operator,    bool _approved  )    external;  /**   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are   * considered invalid, and this function throws for queries about the zero address.   * @notice Count all NFTs assigned to an owner.   * @param _owner Address for whom to query the balance.   * @return Balance of _owner.   */  function balanceOf(    address _owner  )    external    view    returns (uint256);  /**   * @notice Find the owner of an NFT.   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are   * considered invalid, and queries about them do throw.   * @param _tokenId The identifier for an NFT.   * @return Address of _tokenId owner.   */  function ownerOf(    uint256 _tokenId  )    external    view    returns (address);  /**   * @notice Throws if `_tokenId` is not a valid NFT.   * @dev Get the approved address for a single NFT.   * @param _tokenId The NFT to find the approved address for.   * @return Address that _tokenId is approved for.   */  function getApproved(    uint256 _tokenId  )    external    view    returns (address);  /**   * @notice Query if an address is an authorized operator for another address.   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.   * @param _owner The address that owns the NFTs.   * @param _operator The address that acts on behalf of the owner.   * @return True if approved for all, false otherwise.   */  function isApprovedForAll(    address _owner,    address _operator  )    external    view    returns (bool);}</code></pre><h2 id="3-ERC721Metadata"><a href="#3-ERC721Metadata" class="headerlink" title="3. ERC721Metadata"></a>3. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/erc721-metadata.sol">ERC721Metadata</a></h2><p>ERC-721ä¸å¯æ›¿ä»£ä»¤ç‰Œæ ‡å‡†çš„å¯é€‰å…ƒæ•°æ®æ‰©å±•ã€‚</p><p>ä¸»è¦æ–¹æ³•ï¼š</p><ul><li>nameï¼šè¿”å›NFTçš„æè¿°æ€§åç§°</li><li>symbolï¼šè¿”å›NFTçš„ç¼©å†™åç§°</li><li>tokenURIï¼šè¿”å›_tokenIdå¯¹åº”çš„èµ„æºURI</li></ul><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/** * @dev Optional metadata extension for ERC-721 non-fungible token standard. * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md. */interface ERC721Metadata{  /**   * @dev Returns a descriptive name for a collection of NFTs in this contract.   * @return _name Representing name.   */  function name()    external    view    returns (string memory _name);  /**   * @dev Returns a abbreviated name for a collection of NFTs in this contract.   * @return _symbol Representing symbol.   */  function symbol()    external    view    returns (string memory _symbol);  /**   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file   * that conforms to the "ERC721 Metadata JSON Schema".   * @return URI of _tokenId.   */  function tokenURI(uint256 _tokenId)    external    view    returns (string memory);}</code></pre><h2 id="4-ERC721Enumerable"><a href="#4-ERC721Enumerable" class="headerlink" title="4. ERC721Enumerable"></a>4. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/erc721-enumerable.sol">ERC721Enumerable</a></h2><p>ERC-721ä¸å¯æ›¿ä»£ä»¤ç‰Œæ ‡å‡†çš„å¯é€‰æšä¸¾æ‰©å±•ã€‚</p><p>ä¸»è¦æ–¹æ³•ï¼š</p><ul><li>totalSupplyï¼šè¿”å›ç”±æ­¤å¥‘çº¦è·Ÿè¸ªçš„æœ‰æ•ˆnftçš„è®¡æ•°ï¼ˆä»£å¸æ€»é‡ï¼‰ï¼Œå…¶ä¸­æ¯ä¸ªnftéƒ½æœ‰ä¸€ä¸ªåˆ†é…çš„ã€å¯æŸ¥è¯¢çš„æ‰€æœ‰è€…ï¼Œä¸”æ‰€æœ‰è€…ä¸ç­‰äºé›¶åœ°å€</li><li>tokenByIndexï¼šè¿”å›ç¬¬indexçš„NFTçš„tokenIdã€‚æ²¡æœ‰æŒ‡å®šæ’åºé¡ºåºã€‚</li><li>tokenOfOwnerByIndexï¼šè¿”å›åˆ†é…ç»™æŒ‡å®šäººçš„ç¬¬indexçš„NFTçš„tokenIdã€‚æ²¡æœ‰æŒ‡å®šæ’åºé¡ºåº</li></ul><p>æºç ï¼š</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/** * @dev Optional enumeration extension for ERC-721 non-fungible token standard. * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md. */interface ERC721Enumerable{  /**   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an   * assigned and queryable owner not equal to the zero address.   * @return Total supply of NFTs.   */  function totalSupply()    external    view    returns (uint256);  /**   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.   * @param _index A counter less than `totalSupply()`.   * @return Token id.   */  function tokenByIndex(    uint256 _index  )    external    view    returns (uint256);  /**   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is   * not specified. It throws if `_index` &gt;= `balanceOf(_owner)` or if `_owner` is the zero address,   * representing invalid NFTs.   * @param _owner An address where we are interested in NFTs owned by them.   * @param _index A counter less than `balanceOf(_owner)`.   * @return Token id.   */  function tokenOfOwnerByIndex(    address _owner,    uint256 _index  )    external    view    returns (uint256);}</code></pre><h2 id="5-NFToken"><a href="#5-NFToken" class="headerlink" title="5. NFToken"></a>5. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token.sol">NFToken</a></h2><p>ERC721 æ ‡å‡†åŸºæœ¬å®ç°</p><p>ä¸»è¦æ–¹æ³•ï¼š</p><ul><li>safeTransferFromï¼šå°†NFTçš„æ‰€æœ‰æƒä»ä¸€ä¸ªåœ°å€è½¬ç§»åˆ°å¦ä¸€ä¸ªåœ°å€ã€‚æ­¤åŠŸèƒ½å¯æ›´æ”¹ä¸ºpayable</li><li>transferFromï¼šå°†æŒ‡å®šçš„tokenæ‰€æœ‰æƒè½¬ç§»ç»™å¦å¤–ä¸€ä¸ªåœ°å€ï¼Œä¸é¼“åŠ±ä½¿ç”¨è¿™ä¸ªæ–¹æ³•ï¼Œå°½é‡ä½¿ç”¨<code>safeTransferFrom</code></li><li>approveï¼šæ‰¹å‡†å¦ä¸€ä¸ªäººaddressæ¥äº¤æ˜“æŒ‡å®šçš„ä»£å¸ï¼Œ0 address è¡¨ç¤ºæ²¡æœ‰æˆæƒçš„åœ°å€ï¼Œç»™å®šçš„æ—¶é—´å†…ï¼Œä¸€ä¸ªtokenåªèƒ½æœ‰ä¸€ä¸ªæ‰¹å‡†çš„åœ°å€ï¼Œåªæœ‰tokençš„æŒæœ‰è€…æˆ–è€…æˆæƒçš„æ“ä½œäººæ‰å¯ä»¥è°ƒç”¨ã€‚æ­¤åŠŸèƒ½å¯æ›´æ”¹ä¸ºpayable</li><li>setApprovalForAllï¼šè®¾ç½®æˆ–è€…å–æ¶ˆå¯¹æ“ä½œäººçš„æˆæƒï¼Œä¸€ä¸ªæ“ä½œäººå¯ä»¥ä»£è¡¨ä»–ä»¬è½¬è®©å‘é€è€…çš„æ‰€æœ‰token</li><li>balanceOfï¼šè·å–æŒæœ‰è€…çš„ä»£å¸æ€»æ•°</li><li>ownerOfï¼šæ ¹æ®token IDè·å–æŒæœ‰è€…</li><li>getApprovedï¼šè·å–tokenè¢«æˆæƒçš„åœ°å€ï¼Œå¦‚æœæ²¡æœ‰è®¾ç½®åœ°å€åˆ™ä¸º0</li><li>isApprovedForAllï¼šæŸ¥è¯¢æ˜¯å¦æ“ä½œäººè¢«æŒ‡å®šçš„æŒæœ‰è€…æˆæƒï¼Œè¦æŸ¥è¯¢çš„æˆæƒäººåœ°å€ï¼Œè¦æŸ¥è¯¢çš„æˆæƒæ“ä½œäººåœ°å€</li></ul><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./erc721.sol";import "./erc721-token-receiver.sol";import "../utils/supports-interface.sol";import "../utils/address-utils.sol";/** * @dev Implementation of ERC-721 non-fungible token standard. */contract NFToken is  ERC721,  SupportsInterface{  using AddressUtils for address;  /**   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.   * Based on 0xcert framework error codes.   */  string constant ZERO_ADDRESS = "003001";  string constant NOT_VALID_NFT = "003002";  string constant NOT_OWNER_OR_OPERATOR = "003003";  string constant NOT_OWNER_APPROVED_OR_OPERATOR = "003004";  string constant NOT_ABLE_TO_RECEIVE_NFT = "003005";  string constant NFT_ALREADY_EXISTS = "003006";  string constant NOT_OWNER = "003007";  string constant IS_OWNER = "003008";  /**   * @dev Magic value of a smart contract that can receive NFT.   * Equal to: bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")).   */  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;  /**   * @dev A mapping from NFT ID to the address that owns it.   */  mapping (uint256 =&gt; address) internal idToOwner;  /**   * @dev Mapping from NFT ID to approved address.   */  mapping (uint256 =&gt; address) internal idToApproval;   /**   * @dev Mapping from owner address to count of their tokens.   */  mapping (address =&gt; uint256) private ownerToNFTokenCount;  /**   * @dev Mapping from owner address to mapping of operator addresses.   */  mapping (address =&gt; mapping (address =&gt; bool)) internal ownerToOperators;  /**   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.   * @param _tokenId ID of the NFT to validate.   */  modifier canOperate(    uint256 _tokenId  )  {    address tokenOwner = idToOwner[_tokenId];    require(      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],      NOT_OWNER_OR_OPERATOR    );    _;  }  /**   * @dev Guarantees that the msg.sender is allowed to transfer NFT.   * @param _tokenId ID of the NFT to transfer.   */  modifier canTransfer(    uint256 _tokenId  )  {    address tokenOwner = idToOwner[_tokenId];    require(      tokenOwner == msg.sender      || idToApproval[_tokenId] == msg.sender      || ownerToOperators[tokenOwner][msg.sender],      NOT_OWNER_APPROVED_OR_OPERATOR    );    _;  }  /**   * @dev Guarantees that _tokenId is a valid Token.   * @param _tokenId ID of the NFT to validate.   */  modifier validNFToken(    uint256 _tokenId  )  {    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);    _;  }  /**   * @dev Contract constructor.   */  constructor()  {    supportedInterfaces[0x80ac58cd] = true; // ERC721  }  /**   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this   * function checks if `_to` is a smart contract (code size &gt; 0). If so, it calls   * `onERC721Received` on `_to` and throws if the return value is not   * `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.   * @dev Transfers the ownership of an NFT from one address to another address. This function can   * be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   * @param _data Additional data with no specified format, sent in call to `_to`.   */  function safeTransferFrom(    address _from,    address _to,    uint256 _tokenId,    bytes calldata _data  )    external    override  {    _safeTransferFrom(_from, _to, _tokenId, _data);  }  /**   * @notice This works identically to the other function with an extra data parameter, except this   * function just sets data to "".   * @dev Transfers the ownership of an NFT from one address to another address. This function can   * be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   */  function safeTransferFrom(    address _from,    address _to,    uint256 _tokenId  )    external    override  {    _safeTransferFrom(_from, _to, _tokenId, "");  }  /**   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else   * they may be permanently lost.   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero   * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   */  function transferFrom(    address _from,    address _to,    uint256 _tokenId  )    external    override    canTransfer(_tokenId)    validNFToken(_tokenId)  {    address tokenOwner = idToOwner[_tokenId];    require(tokenOwner == _from, NOT_OWNER);    require(_to != address(0), ZERO_ADDRESS);    _transfer(_to, _tokenId);  }  /**   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is   * the current NFT owner, or an authorized operator of the current owner.   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.   * @param _approved Address to be approved for the given NFT ID.   * @param _tokenId ID of the token to be approved.   */  function approve(    address _approved,    uint256 _tokenId  )    external    override    canOperate(_tokenId)    validNFToken(_tokenId)  {    address tokenOwner = idToOwner[_tokenId];    require(_approved != tokenOwner, IS_OWNER);    idToApproval[_tokenId] = _approved;    emit Approval(tokenOwner, _approved, _tokenId);  }  /**   * @notice This works even if sender doesn't own any tokens at the time.   * @dev Enables or disables approval for a third party ("operator") to manage all of   * `msg.sender`'s assets. It also emits the ApprovalForAll event.   * @param _operator Address to add to the set of authorized operators.   * @param _approved True if the operators is approved, false to revoke approval.   */  function setApprovalForAll(    address _operator,    bool _approved  )    external    override  {    ownerToOperators[msg.sender][_operator] = _approved;    emit ApprovalForAll(msg.sender, _operator, _approved);  }  /**   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are   * considered invalid, and this function throws for queries about the zero address.   * @param _owner Address for whom to query the balance.   * @return Balance of _owner.   */  function balanceOf(    address _owner  )    external    override    view    returns (uint256)  {    require(_owner != address(0), ZERO_ADDRESS);    return _getOwnerNFTCount(_owner);  }  /**   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are   * considered invalid, and queries about them do throw.   * @param _tokenId The identifier for an NFT.   * @return _owner Address of _tokenId owner.   */  function ownerOf(    uint256 _tokenId  )    external    override    view    returns (address _owner)  {    _owner = idToOwner[_tokenId];    require(_owner != address(0), NOT_VALID_NFT);  }  /**   * @notice Throws if `_tokenId` is not a valid NFT.   * @dev Get the approved address for a single NFT.   * @param _tokenId ID of the NFT to query the approval of.   * @return Address that _tokenId is approved for.   */  function getApproved(    uint256 _tokenId  )    external    override    view    validNFToken(_tokenId)    returns (address)  {    return idToApproval[_tokenId];  }  /**   * @dev Checks if `_operator` is an approved operator for `_owner`.   * @param _owner The address that owns the NFTs.   * @param _operator The address that acts on behalf of the owner.   * @return True if approved for all, false otherwise.   */  function isApprovedForAll(    address _owner,    address _operator  )    external    override    view    returns (bool)  {    return ownerToOperators[_owner][_operator];  }  /**   * @notice Does NO checks.   * @dev Actually performs the transfer.   * @param _to Address of a new owner.   * @param _tokenId The NFT that is being transferred.   */  function _transfer(    address _to,    uint256 _tokenId  )    internal    virtual  {    address from = idToOwner[_tokenId];    _clearApproval(_tokenId);    _removeNFToken(from, _tokenId);    _addNFToken(_to, _tokenId);    emit Transfer(from, _to, _tokenId);  }  /**   * @notice This is an internal function which should be called from user-implemented external   * mint function. Its purpose is to show and properly initialize data structures when using this   * implementation.   * @dev Mints a new NFT.   * @param _to The address that will own the minted NFT.   * @param _tokenId of the NFT to be minted by the msg.sender.   */  function _mint(    address _to,    uint256 _tokenId  )    internal    virtual  {    require(_to != address(0), ZERO_ADDRESS);    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);    _addNFToken(_to, _tokenId);    emit Transfer(address(0), _to, _tokenId);  }  /**   * @notice This is an internal function which should be called from user-implemented external burn   * function. Its purpose is to show and properly initialize data structures when using this   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned   * NFT.   * @dev Burns a NFT.   * @param _tokenId ID of the NFT to be burned.   */  function _burn(    uint256 _tokenId  )    internal    virtual    validNFToken(_tokenId)  {    address tokenOwner = idToOwner[_tokenId];    _clearApproval(_tokenId);    _removeNFToken(tokenOwner, _tokenId);    emit Transfer(tokenOwner, address(0), _tokenId);  }  /**   * @notice Use and override this function with caution. Wrong usage can have serious consequences.   * @dev Removes a NFT from owner.   * @param _from Address from which we want to remove the NFT.   * @param _tokenId Which NFT we want to remove.   */  function _removeNFToken(    address _from,    uint256 _tokenId  )    internal    virtual  {    require(idToOwner[_tokenId] == _from, NOT_OWNER);    ownerToNFTokenCount[_from] -= 1;    delete idToOwner[_tokenId];  }  /**   * @notice Use and override this function with caution. Wrong usage can have serious consequences.   * @dev Assigns a new NFT to owner.   * @param _to Address to which we want to add the NFT.   * @param _tokenId Which NFT we want to add.   */  function _addNFToken(    address _to,    uint256 _tokenId  )    internal    virtual  {    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);    idToOwner[_tokenId] = _to;    ownerToNFTokenCount[_to] += 1;  }  /**   *&nbsp;@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable   * extension to remove double storage (gas optimization) of owner NFT count.   * @param _owner Address for whom to query the count.   * @return Number of _owner NFTs.   */  function _getOwnerNFTCount(    address _owner  )    internal    virtual    view    returns (uint256)  {    return ownerToNFTokenCount[_owner];  }  /**   * @dev Actually perform the safeTransferFrom.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   * @param _data Additional data with no specified format, sent in call to `_to`.   */  function _safeTransferFrom(    address _from,    address _to,    uint256 _tokenId,    bytes memory _data  )    private    canTransfer(_tokenId)    validNFToken(_tokenId)  {    address tokenOwner = idToOwner[_tokenId];    require(tokenOwner == _from, NOT_OWNER);    require(_to != address(0), ZERO_ADDRESS);    _transfer(_to, _tokenId);    if (_to.isContract())    {      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);    }  }  /**   * @dev Clears the current approval of a given NFT ID.   * @param _tokenId ID of the NFT to be transferred.   */  function _clearApproval(    uint256 _tokenId  )    private  {    delete idToApproval[_tokenId];  }}</code></pre><h2 id="6-NFTokenMetadata"><a href="#6-NFTokenMetadata" class="headerlink" title="6. NFTokenMetadata"></a>6. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token-metadata.sol">NFTokenMetadata</a></h2><p>ERC-721ä¸å¯æ›¿ä»£ä»¤ç‰Œæ ‡å‡†çš„å¯é€‰å…ƒæ•°æ®å®ç°ï¼Œç»§æ‰¿NFTokenå¹¶å®ç°äº†ERC721Metadataæ¥å£</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./nf-token.sol";import "./erc721-metadata.sol";/** * @dev Optional metadata implementation for ERC-721 non-fungible token standard. */contract NFTokenMetadata is  NFToken,  ERC721Metadata{  /**   * @dev A descriptive name for a collection of NFTs.   */  string internal nftName;  /**   * @dev An abbreviated name for NFTokens.   */  string internal nftSymbol;  /**   * @dev Mapping from NFT ID to metadata uri.   */  mapping (uint256 =&gt; string) internal idToUri;  /**   * @notice When implementing this contract don't forget to set nftName and nftSymbol.   * @dev Contract constructor.   */  constructor()  {    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata  }  /**   * @dev Returns a descriptive name for a collection of NFTokens.   * @return _name Representing name.   */  function name()    external    override    view    returns (string memory _name)  {    _name = nftName;  }  /**   * @dev Returns an abbreviated name for NFTokens.   * @return _symbol Representing symbol.   */  function symbol()    external    override    view    returns (string memory _symbol)  {    _symbol = nftSymbol;  }  /**   * @dev A distinct URI (RFC 3986) for a given NFT.   * @param _tokenId Id for which we want uri.   * @return URI of _tokenId.   */  function tokenURI(    uint256 _tokenId  )    external    override    view    validNFToken(_tokenId)    returns (string memory)  {    return _tokenURI(_tokenId);  }  /**   * @notice This is an internal function that can be overriden if you want to implement a different   * way to generate token URI.   * @param _tokenId Id for which we want uri.   * @return URI of _tokenId.   */  function _tokenURI(    uint256 _tokenId  )    internal    virtual    view    returns (string memory)  {    return idToUri[_tokenId];  }  /**   * @notice This is an internal function which should be called from user-implemented external   * burn function. Its purpose is to show and properly initialize data structures when using this   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned   * NFT.   * @dev Burns a NFT.   * @param _tokenId ID of the NFT to be burned.   */  function _burn(    uint256 _tokenId  )    internal    override    virtual  {    super._burn(_tokenId);    delete idToUri[_tokenId];  }  /**   * @notice This is an internal function which should be called from user-implemented external   * function. Its purpose is to show and properly initialize data structures when using this   * implementation.   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.   * @param _tokenId Id for which we want URI.   * @param _uri String representing RFC 3986 URI.   */  function _setTokenUri(    uint256 _tokenId,    string memory _uri  )    internal    validNFToken(_tokenId)  {    idToUri[_tokenId] = _uri;  }}</code></pre><h2 id="7-NFTokenEnumerable"><a href="#7-NFTokenEnumerable" class="headerlink" title="7. NFTokenEnumerable"></a>7. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token-enumerable.sol">NFTokenEnumerable</a></h2><p>ERC-721ä¸å¯æ›¿ä»£ä»¤ç‰Œæ ‡å‡†çš„å¯é€‰æšä¸¾å®ç°ï¼Œç»§æ‰¿NFTokenå¹¶å®ç°äº†ERC721Enumerableæ¥å£</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./nf-token.sol";import "./erc721-enumerable.sol";/** * @dev Optional enumeration implementation for ERC-721 non-fungible token standard. */contract NFTokenEnumerable is  NFToken,  ERC721Enumerable{  /**   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.   * Based on 0xcert framework error codes.   */  string constant INVALID_INDEX = "005007";  /**   * @dev Array of all NFT IDs.   */  uint256[] internal tokens;  /**   * @dev Mapping from token ID to its index in global tokens array.   */  mapping(uint256 =&gt; uint256) internal idToIndex;  /**   * @dev Mapping from owner to list of owned NFT IDs.   */  mapping(address =&gt; uint256[]) internal ownerToIds;  /**   * @dev Mapping from NFT ID to its index in the owner tokens list.   */  mapping(uint256 =&gt; uint256) internal idToOwnerIndex;  /**   * @dev Contract constructor.   */  constructor()  {    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable  }  /**   * @dev Returns the count of all existing NFTokens.   * @return Total supply of NFTs.   */  function totalSupply()    external    override    view    returns (uint256)  {    return tokens.length;  }  /**   * @dev Returns NFT ID by its index.   * @param _index A counter less than `totalSupply()`.   * @return Token id.   */  function tokenByIndex(    uint256 _index  )    external    override    view    returns (uint256)  {    require(_index &lt; tokens.length, INVALID_INDEX);    return tokens[_index];  }  /**   * @dev returns the n-th NFT ID from a list of owner's tokens.   * @param _owner Token owner's address.   * @param _index Index number representing n-th token in owner's list of tokens.   * @return Token id.   */  function tokenOfOwnerByIndex(    address _owner,    uint256 _index  )    external    override    view    returns (uint256)  {    require(_index &lt; ownerToIds[_owner].length, INVALID_INDEX);    return ownerToIds[_owner][_index];  }  /**   * @notice This is an internal function which should be called from user-implemented external   * mint function. Its purpose is to show and properly initialize data structures when using this   * implementation.   * @dev Mints a new NFT.   * @param _to The address that will own the minted NFT.   * @param _tokenId of the NFT to be minted by the msg.sender.   */  function _mint(    address _to,    uint256 _tokenId  )    internal    override    virtual  {    super._mint(_to, _tokenId);    tokens.push(_tokenId);    idToIndex[_tokenId] = tokens.length - 1;  }  /**   * @notice This is an internal function which should be called from user-implemented external   * burn function. Its purpose is to show and properly initialize data structures when using this   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned   * NFT.   * @dev Burns a NFT.   * @param _tokenId ID of the NFT to be burned.   */  function _burn(    uint256 _tokenId  )    internal    override    virtual  {    super._burn(_tokenId);    uint256 tokenIndex = idToIndex[_tokenId];    uint256 lastTokenIndex = tokens.length - 1;    uint256 lastToken = tokens[lastTokenIndex];    tokens[tokenIndex] = lastToken;    tokens.pop();    // This wastes gas if you are burning the last token but saves a little gas if you are not.    idToIndex[lastToken] = tokenIndex;    idToIndex[_tokenId] = 0;  }  /**   * @notice Use and override this function with caution. Wrong usage can have serious consequences.   * @dev Removes a NFT from an address.   * @param _from Address from wich we want to remove the NFT.   * @param _tokenId Which NFT we want to remove.   */  function _removeNFToken(    address _from,    uint256 _tokenId  )    internal    override    virtual  {    require(idToOwner[_tokenId] == _from, NOT_OWNER);    delete idToOwner[_tokenId];    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];    uint256 lastTokenIndex = ownerToIds[_from].length - 1;    if (lastTokenIndex != tokenToRemoveIndex)    {      uint256 lastToken = ownerToIds[_from][lastTokenIndex];      ownerToIds[_from][tokenToRemoveIndex] = lastToken;      idToOwnerIndex[lastToken] = tokenToRemoveIndex;    }    ownerToIds[_from].pop();  }  /**   * @notice Use and override this function with caution. Wrong usage can have serious consequences.   * @dev Assigns a new NFT to an address.   * @param _to Address to wich we want to add the NFT.   * @param _tokenId Which NFT we want to add.   */  function _addNFToken(    address _to,    uint256 _tokenId  )    internal    override    virtual  {    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);    idToOwner[_tokenId] = _to;    ownerToIds[_to].push(_tokenId);    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;  }  /**   *&nbsp;@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable   * extension to remove double storage(gas optimization) of owner NFT count.   * @param _owner Address for whom to query the count.   * @return Number of _owner NFTs.   */  function _getOwnerNFTCount(    address _owner  )    internal    override    virtual    view    returns (uint256)  {    return ownerToIds[_owner].length;  }}</code></pre><h2 id="8-Ownable"><a href="#8-Ownable" class="headerlink" title="8. Ownable"></a>8. <a href="https://github.com/nibbstack/erc721/blob/master/src/contracts/ownership/ownable.sol">Ownable</a></h2><p>åˆåŒæœ‰ä¸€ä¸ªæ‰€æœ‰è€…åœ°å€ï¼Œå¹¶æä¾›åŸºæœ¬çš„æˆæƒæ§åˆ¶ï¼Œç®€åŒ–äº†ç”¨æˆ·æƒé™çš„å®ç°ã€‚æ­¤åˆåŒåŸºäºä»¥ä¸‹æºä»£ç : <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/access/Ownable.sol">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/access/Ownable.sol</a></p><pre><code class="javascriptscript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/** * @dev The contract has an owner address, and provides basic authorization control whitch * simplifies the implementation of user permissions. This contract is based on the source code at: * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol */contract Ownable{  /**   * @dev Error constants.   */  string public constant NOT_CURRENT_OWNER = "018001";  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = "018002";  /**   * @dev Current owner address.   */  address public owner;  /**   * @dev An event which is triggered when the owner is changed.   * @param previousOwner The address of the previous owner.   * @param newOwner The address of the new owner.   */  event OwnershipTransferred(    address indexed previousOwner,    address indexed newOwner  );  /**   * @dev The constructor sets the original `owner` of the contract to the sender account.   */  constructor()  {    owner = msg.sender;  }  /**   * @dev Throws if called by any account other than the owner.   */  modifier onlyOwner()  {    require(msg.sender == owner, NOT_CURRENT_OWNER);    _;  }  /**   * @dev Allows the current owner to transfer control of the contract to a newOwner.   * @param _newOwner The address to transfer ownership to.   */  function transferOwnership(    address _newOwner  )    public    onlyOwner  {    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);    emit OwnershipTransferred(owner, _newOwner);    owner = _newOwner;  }}</code></pre><p>OpenZeppelin ERC721æºç åˆ†æåˆ°è¿™é‡Œå°±ç»“æŸäº†ã€‚</p><p>å‚è€ƒï¼š</p><ol><li><a href="https://github.com/nibbstack/erc721/tree/2.6.1">ERC721æºç v2.6.1</a></li><li><a href="https://segmentfault.com/a/1190000016070774">ERC721æºç åˆ†æ</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
            <tag> NFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>åŸºäºä»¥å¤ªåŠçš„æˆ˜è‰‡æ¸¸æˆ(Layer2)æºç è§£æ</title>
      <link href="/2022/02/24/blockchain/layer2/%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%88%98%E8%89%87%E6%B8%B8%E6%88%8F(Layer2)/"/>
      <url>/2022/02/24/blockchain/layer2/%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%88%98%E8%89%87%E6%B8%B8%E6%88%8F(Layer2)/</url>
      
        <content type="html"><![CDATA[<h1 id="åŸºäºä»¥å¤ªåŠçš„æˆ˜è‰‡æ¸¸æˆ-Layer2-æºç è§£æ"><a href="#åŸºäºä»¥å¤ªåŠçš„æˆ˜è‰‡æ¸¸æˆ-Layer2-æºç è§£æ" class="headerlink" title="åŸºäºä»¥å¤ªåŠçš„æˆ˜è‰‡æ¸¸æˆ(Layer2)æºç è§£æ"></a>åŸºäºä»¥å¤ªåŠçš„æˆ˜è‰‡æ¸¸æˆ(Layer2)æºç è§£æ</h1><h2 id="ä¸€ã€æ¸¸æˆä»‹ç»"><a href="#ä¸€ã€æ¸¸æˆä»‹ç»" class="headerlink" title="ä¸€ã€æ¸¸æˆä»‹ç»"></a>ä¸€ã€æ¸¸æˆä»‹ç»</h2><p>æ¯ä¸€ä¸ªç©å®¶éƒ½å¯ä»¥çœ‹åˆ°ä¸Šå›¾æ‰€ç¤ºçš„é¡µé¢ã€‚è¯¥é¡µé¢åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸‹é¢éƒ¨åˆ†è¡¨ç¤ºå½“å‰ç©å®¶çš„æ£‹ç›˜ä¿¡æ¯ï¼Œå¼€å§‹çš„æ—¶å€™ï¼Œè¯¥ç©å®¶éšæœºé€‰æ‹©ä¸¤ä¸ªæ ¼å­ï¼Œç”¨äºæ”¾ç½®ä¸¤ä¸ªæˆ˜èˆ°ï¼›ä¸Šé¢éƒ¨åˆ†æ˜¾ç¤ºå¯¹æ–¹ç©å®¶çš„æ£‹ç›˜ä¿¡æ¯ï¼Œé™¤äº†å¯¹æ–¹ç©å®¶çš„æˆ˜èˆ°ä½ç½®ã€‚å¼€å§‹çš„æ—¶å€™ï¼Œä¸Šé¢éƒ¨åˆ†çš„æ£‹ç›˜æ˜¯ç©ºçš„ã€‚æ¸¸æˆå¼€å§‹ä¹‹åï¼Œä¸¤ä¸ªç©å®¶è½®æµçŒœæµ‹å¯¹æ–¹çš„æˆ˜èˆ°çš„ä½ç½®ï¼Œæ¯ä¸€æ¬¡åªèƒ½çŒœä¸€ä¸ªæ–¹æ ¼ã€‚å¦‚æœå¯¹æ–¹çš„æˆ˜èˆ°ä¸åœ¨æ‰€çŒœæµ‹çš„æ–¹æ ¼ä¸­ï¼Œé‚£ä¹ˆå°±ä¼šåœ¨å¯¹åº”ä½ç½®æ˜¾ç¤ºä¸€ä¸ªæ°´èŠ±çš„å›¾åƒï¼›åä¹‹ï¼Œåˆ™å‡ºç°ä¸€å›¢ç«çš„å›¾åƒã€‚å› ä¸ºåŒæ–¹çœ‹ä¸åˆ°å¯¹æ–¹çš„æ£‹ç›˜ï¼Œå› æ­¤ï¼Œæ¯ä¸€æ¬¡éƒ½éœ€è¦å¯¹æ–¹ç©å®¶å›å¤â€œæ‰€çŒœæµ‹çš„æ–¹æ ¼æ˜¯å¦æœ‰æˆ˜èˆ°â€ï¼ˆæˆ‘ä»¬å¯ä»¥é‡‡ç”¨å¯†ç å­¦çš„æŠ€æœ¯æ£€æµ‹å‡ºå¯¹æ–¹æ˜¯å¦æ’’è°ï¼‰ã€‚å½“æŸä¸€ä¸ªç©å®¶ç‡å…ˆçŒœä¸­äº†å¯¹æ–¹ä¸¤ä¸ªæˆ˜èˆ°çš„ä½ç½®ï¼Œè¯¥ç©å®¶å°±èµ¢äº†ï¼Œå¹¶å¯ä»¥æ”¶å–è‡ªå·±å’Œå¯¹æ–¹çš„èµŒæ³¨ã€‚</p><h2 id="äºŒã€æ¶‰åŠæŠ€æœ¯"><a href="#äºŒã€æ¶‰åŠæŠ€æœ¯" class="headerlink" title="äºŒã€æ¶‰åŠæŠ€æœ¯"></a>äºŒã€æ¶‰åŠæŠ€æœ¯</h2><p>ä½¿ç”¨çš„ç¼–ç¨‹æŠ€æœ¯æœ‰ï¼š</p><ul><li>HTMLï¼› Javascript; CCS; (ç½‘é¡µå‰ç«¯)</li><li>Web3 ï¼ˆæä¾›äº†è°ƒç”¨æ™ºèƒ½åˆçº¦çš„jsæ¥å£ï¼‰</li><li>ganache-cli ï¼ˆåœ¨æœ¬åœ°æ¨¡æ‹Ÿä»¥å¤ªåŠèŠ‚ç‚¹ï¼‰</li><li>remix ï¼ˆä»¥å¤ªåŠæ™ºèƒ½åˆçº¦çš„IDEï¼‰</li><li>Solidity ï¼ˆæ™ºèƒ½åˆçº¦ç¼–ç¨‹è¯­è¨€ï¼‰</li></ul><h2 id="ä¸‰ã€æŠ€æœ¯æ¦‚æ‹¬"><a href="#ä¸‰ã€æŠ€æœ¯æ¦‚æ‹¬" class="headerlink" title="ä¸‰ã€æŠ€æœ¯æ¦‚æ‹¬"></a>ä¸‰ã€æŠ€æœ¯æ¦‚æ‹¬</h2><p>ä¸‹å›¾æ˜¾ç¤ºï¼Œå¦‚æœä½¿ç”¨layer1çš„åŒºå—é“¾æŠ€æœ¯ï¼Œæ¯èµ°ä¸€æ­¥æ£‹éƒ½éœ€è¦å‘åŒºå—é“¾å‘å¸ƒä¸€ä¸ªäº¤æ˜“ã€‚</p><p><img src="/images/battle-ship-layer2/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5neWlodWFp,size_16,color_FFFFFF,t_70.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>ä¸‹å›¾æ‰€ç¤ºçš„æ­£æ˜¯æˆ‘ä»¬ä½¿ç”¨çš„æ–¹å¼ã€‚</p><p><img src="/images/battle-ship-layer2/watermark,type_W5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5neWlodWFp,size_16,color_FFFFFF,t_70.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>ä¸€ä¸ªé—®é¢˜ï¼šå¦‚ä½•æ£€æµ‹å¯¹æ–¹ç©å®¶æ’’è°ï¼Ÿ<br>å…·ä½“ä¸ºï¼Œæ¯ä¸€ä¸ªç©å®¶åœ¨æ¸¸æˆå¼€å§‹å‰éƒ½éœ€è¦éšæœºæŒ‡å®šä¸¤ä¸ªæ ¼å­ï¼Œè¡¨ç¤ºä¸¤ä¸ªæˆ˜èˆ°çš„ä½ç½®ï¼Œå¦‚æœæŸç©å®¶ä¸­é€”å˜å¦ï¼Œä¸æ‰¿è®¤è‡ªå·±æ‰€æŒ‡å®šçš„é‚£ä¸¤ä¸ªæ ¼å­å‘¢ï¼Ÿå†è€…ï¼Œå½“å‰ç©å®¶çŒœæµ‹å¯¹æ–¹ç©å®¶æˆ˜èˆ°æ‰€åœ¨çš„æ–¹æ ¼ä½ç½®ï¼Œå¯¹æ–¹ç©å®¶éœ€è¦å›å¤è¯¥æ–¹æ ¼ä¸‹æ˜¯å¦æœ‰æˆ˜èˆ°ï¼Œå¦‚æœå¯¹æ–¹ç©å®¶ä¸è¯šä¿¡å‘¢ï¼Ÿæˆ‘ä»¬ä½¿ç”¨äº†Merkle<br>treeè¿›è¡Œcommitï¼ˆæ‰¿è¯ºï¼‰ã€‚ä»‹ç»merkle treeï¼ˆå½¢å¦‚ä¸‹å›¾ï¼‰ä¸å±äºæœ¬æ–‡çš„èŒƒå›´ã€‚</p><p>æ ¹æ®å¯†ç å­¦ä¸­çš„hashå‡½æ•°çš„ç‰¹ç‚¹ï¼Œä»»æ„ä¸€ä¸ªèŠ‚ç‚¹çš„å˜åŒ–éƒ½ä¼šå¯¼è‡´æ ¹èŠ‚ç‚¹å˜åŒ–ã€‚å¹¶ä¸”ï¼Œæˆ‘ä»¬èƒ½å¤Ÿå¾ˆå®¹æ˜“è¯æ˜æŸä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦å±äºè¯¥merkle treeã€‚</p><p><img src="/images/battle-ship-layer2/watermark,type_oZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5neWlodWFp,size_16,color_FFFFFF,t_70.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>è¿™é‡Œï¼Œæˆ‘ä»¬å¯¹ä¸¤ä½ç©å®¶çš„æ‰€æœ‰çš„æ¸¸æˆæ–¹æ ¼åˆ†åˆ«ç”Ÿæˆä¸¤æ£µmerkle treeï¼Œå¶å­èŠ‚ç‚¹è¡¨ç¤ºæ–¹æ ¼çš„ç¼–å·ã€‚è¿™é‡Œä¸ºäº†ä¿å¯†æ€§ï¼Œåœ¨ç¼–å·åé¢åˆå¹¶ä¸€ä¸ªéšæœºæ•°ï¼ˆåˆå¹¶åçš„æ•°æ®ä½œä¸ºhashå‡½æ•°çš„è¾“å…¥ï¼‰ã€‚</p><p>å› æ­¤ï¼Œè§£å†³æ–¹æ³•æ˜¯ï¼Œåœ¨ç©å®¶æŒ‡å®šä¸¤ä¸ªæˆ˜èˆ°çš„ä½ç½®ä¹‹åï¼Œéœ€è¦ç”Ÿæˆä¸€æ£µmerkle<br>treeï¼Œå¹¶å‘å¯¹æ–¹å‘é€æ ¹èŠ‚ç‚¹ã€‚è¯¥æ ¹èŠ‚ç‚¹ä¾¿æ˜¯å¯¹æ–¹çš„æ‰¿è¯ºï¼Œä¸”å®ƒä¸ä¼šæ³„éœ²æˆ˜èˆ°çš„ä½ç½®ä¿¡æ¯ã€‚åœ¨æ¸¸æˆè¿‡ç¨‹ä¸­ï¼Œå¦‚æœè¦æ­éœ²æŸä¸€ä¸ªæ–¹æ ¼ä¸‹æ˜¯å¦å­˜åœ¨æˆ˜èˆ°ï¼Œéœ€è¦å°†å¯¹åº”ç¼–å·çš„å¶å­èŠ‚ç‚¹å’Œä»è¯¥èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„ä¿¡æ¯å‘é€ç»™å¯¹æ–¹ã€‚è‹¥å¯¹æ–¹èƒ½å¤Ÿæ„é€ å‡ºç›¸åŒçš„æ ¹èŠ‚ç‚¹ï¼Œè¯æ˜è¯¥ç©å®¶æ˜¯è¯šä¿¡çš„ã€‚ï¼ˆè¿™é‡Œæ¶‰åŠåˆ°äº†å¯†ç å­¦hashå‡½æ•°çš„çŸ¥è¯†ï¼‰ã€‚</p><p>å¦ä¸€ä¸ªé—®é¢˜ï¼šå¦‚æœä¸€ä¸ªç©å®¶aä¸­é€”ç¦»å¼€ï¼Œæ€ä¹ˆåŠï¼Ÿ å½“å‰å®ç°çš„åŠŸèƒ½ï¼šéœ€è¦ç©å®¶bå‘æ™ºèƒ½åˆçº¦ä¸­æäº¤ä¸€ä¸ªæ§å‘Šã€‚ä¸ºäº†å›åº”è¯¥æ§å‘Šï¼Œç©å®¶aè¦åœ¨ä¸€åˆ†é’Ÿä¹‹å†…è°ƒç”¨æ™ºèƒ½åˆçº¦ï¼Œå–æ¶ˆæ‰è¯¥æ§å‘Šã€‚å¦‚æœä¸€åˆ†é’Ÿä¹‹åç©å®¶aä¸å›å¤ï¼Œé‚£ä¹ˆç©å®¶bå°±å¯ä»¥å–èµ°æ‰€æœ‰çš„èµŒæ³¨ã€‚</p><h2 id="å››ã€åŒºå—é“¾å’Œæ™ºèƒ½åˆçº¦çš„ä½œç”¨"><a href="#å››ã€åŒºå—é“¾å’Œæ™ºèƒ½åˆçº¦çš„ä½œç”¨" class="headerlink" title="å››ã€åŒºå—é“¾å’Œæ™ºèƒ½åˆçº¦çš„ä½œç”¨"></a>å››ã€åŒºå—é“¾å’Œæ™ºèƒ½åˆçº¦çš„ä½œç”¨</h2><p>åœ¨è¿™ä¸ªæ¸¸æˆä¸­ï¼Œæ™ºèƒ½åˆçº¦å……å½“äº†è£åˆ¤çš„è§’è‰²ï¼šè‹¥æŸä¸ªç©å®¶æ’’è°æˆ–è€…ä¸­é€”ç¦»å¼€ï¼Œé‚£ä¹ˆæ™ºèƒ½åˆçº¦å°±ä¼šæŠŠèµŒæ³¨ç»™å¦ä¸€ä¸ªç©å®¶ã€‚å› æ­¤ï¼Œæœ¬è´¨ä¸ŠåŒºå—é“¾ä¸­çš„æ™ºèƒ½åˆçº¦è§£å†³äº†ä¿¡ç”¨é—®é¢˜ï¼Œå¹¶ä¸”ï¼Œé‡è¦çš„æ˜¯ï¼Œä¸éœ€è¦ä¾èµ–ä»»ä½•å¯ä¿¡çš„ç¬¬ä¸‰æ–¹ã€‚æ¸¸æˆç©å®¶ä¸éœ€è¦ç›¸ä¿¡ä»»ä½•äººï¼šä¸ç”¨æ‹…å¿ƒå¯¹æ–¹ä¸è¯šä¿¡ï¼Œä¸ç”¨æ‹…å¿ƒæ¸¸æˆå¹³å°å’Œå¯¹æ–¹ç©å®¶å‹¾ç»“ï¼›ä¸ç”¨æ‹…å¿ƒè‡ªå·±çš„èµŒæ³¨è«åå¥‡å¦™å°±è¢«å–èµ°ï¼›ä¸ç”¨æ‹…å¿ƒæ¸¸æˆå¹³å°å®•æœºã€‚</p><p>ä¸‹å›¾è¡¨ç¤ºçš„æ˜¯æ™ºèƒ½åˆçº¦çš„fieldsï¼Œä¹Ÿå³æ˜¯æ™ºèƒ½åˆçº¦éœ€è¦ä¿å­˜çš„æ•°æ®ã€‚æˆ‘ä»¬ä¿å­˜äº†ä¸¤ä¸ªç©å®¶çš„åœ°å€ï¼ŒèµŒæ³¨çš„æ•°é‡ï¼Œæ¸¸æˆçŠ¶æ€ï¼Œæœ€ç»ˆèµ¢å®¶çš„åœ°å€ï¼Œä¸¤ä¸ªmerkle treeçš„è·ŸèŠ‚ç‚¹ï¼Œè¶…æ—¶ä¸å›å¤çš„æ•°æ®ç­‰ç­‰ã€‚</p><p>è¯¥é¡¹ç›®è¿˜å®ç°äº†ä¸‹è¿°åŠŸèƒ½ï¼š</p><ul><li>Forfeit Gameï¼Œè¡¨ç¤ºå½“å‰ç©å®¶æ”¾å¼ƒè¯¥æ¸¸æˆï¼ŒåŒ…æ‹¬èµŒæ³¨ã€‚ï¼ˆå·²å®ç°ï¼‰</li><li>Claim Winï¼Œåœ¨å½“å‰ç©å®¶çŒœä¸­å¯¹æ–¹ä¸¤ä¸ªæˆ˜èˆ°ä¹‹åï¼Œç‚¹å‡»è¯¥æŒ‰é’®å°±å¯ä»¥å–èµ°æ‰€æœ‰çš„èµŒæ³¨ã€‚ï¼ˆå·²å®ç°ï¼‰</li><li>Accuse<br>Cheatingï¼ŒåŸæœ¬çš„åŠŸèƒ½æ˜¯å½“å‘ç°å¯¹æ–¹ç©å®¶æ’’è°æ—¶ï¼Œå°†æ’’è°çš„æ•°æ®å‘å¸ƒåˆ°æ™ºèƒ½åˆçº¦ä¸­ï¼Œè®©æ™ºèƒ½åˆçº¦è£å†³ã€‚å¦‚æœè¯»è€…æƒ³è¦å®ç°è¯¥åŠŸèƒ½ï¼Œéœ€è¦æ³¨æ„ï¼ŒæŸä¸€ä¸ªç©å®¶åœ¨å‘å¯¹æ–¹å‘é€æ•°æ®å‰ï¼Œéœ€è¦å¯¹è¯¥æ•°æ®ç­¾åï¼Œä»¥é¿å…è€èµ–ã€‚å› æ­¤ï¼Œå½“æŸä¸€ä¸ªç©å®¶è¦æ±‚æ™ºèƒ½åˆçº¦è£å†³æ—¶ï¼Œæ™ºèƒ½åˆçº¦éœ€è¦éªŒè¯ç›¸å…³ç­¾åã€‚ï¼ˆæœªå®ç°ï¼‰</li><li>Accuse Timeoutï¼Œæ§å‘Šå¯¹æ–¹ç©å®¶ä¸­é€”ç¦»å¼€ï¼›ï¼ˆå·²å®ç°ï¼‰</li><li>Respond to Accusationï¼Œ å½“å½“å‰ç©å®¶è¢«æ§å‘Šæ—¶ï¼Œè¯¥ç©å®¶éœ€è¦åœ¨ä¸€åˆ†é’Ÿå†…ç‚¹å‡»è¯¥æŒ‰é’®ï¼Œè¡¨ç¤ºè‡ªå·±åœ¨çº¿ï¼Œæ¥å›å¤æ§å‘Šã€‚ï¼ˆå·²å®ç°ï¼‰</li><li>claim timeout winningsï¼Œå¦‚æœè¢«å‘Šäººæ²¡æœ‰åœ¨ä¸€åˆ†é’Ÿä¹‹å†…å›å¤ï¼Œå°±å¯ä»¥ç‚¹å‡»è¯¥æŒ‰é’®æ¥å–èµ°æ‰€æœ‰çš„èµŒæ³¨ã€‚ï¼ˆå·²å®ç°ï¼‰</li></ul><h2 id="äº”ã€æºç åˆ†æ"><a href="#äº”ã€æºç åˆ†æ" class="headerlink" title="äº”ã€æºç åˆ†æ"></a>äº”ã€æºç åˆ†æ</h2><h3 id="1-æ„é€ Merkleæ ‘"><a href="#1-æ„é€ Merkleæ ‘" class="headerlink" title="1. æ„é€ Merkleæ ‘"></a>1. æ„é€ Merkleæ ‘</h3><p>ä½¿ç”¨JavaScriptä»£ç å®ç°æ„é€ æ ‘ï¼Œé¦–å…ˆè®¡ç®—æ¯ä¸ªä½ç½®å¦å­˜åœ¨èˆ°è‰‡+éšæœºæ•°ç»„åˆåå–sha3ï¼Œä½œä¸ºæ¯ä¸ªä½ç½®çš„hashï¼Œç„¶åæ¯ä¸¤ä¸ªé¡µèŠ‚ç‚¹å–ä¸€æ¬¡hashï¼Œå¾ªç¯æœ€ç»ˆå½¢æˆä¸€ä¸ªæ ¹èŠ‚ç‚¹ã€‚</p><p><img src="/images/battle-ship-layer2/merkle.png" alt="img"></p><p>æœ€ç»ˆæ„é€ åçš„merkleæ ‘ä¸º5å±‚ï¼Œæ¯å±‚èŠ‚ç‚¹æ•°ä¸º1ã€2ã€4ã€8ã€16</p><p>å†…å®¹å¦‚ä¸‹ï¼š</p><p><img src="/images/battle-ship-layer2/image-20220223205315073.png" alt="image-20220223205315073"></p><p>JSä»£ç ï¼š</p><pre><code class="javascript">/* build_merkle  builds a Merkle Tree from the given initial_board and nonces  \args:    initial_board - [[]] - åˆå§‹åŒ–ç”²æ¿ä½œä¸ºçŸ©é˜µä¼ é€’ï¼ŒäºŒç»´æ•°ç»„ï¼Œå¯¹åº”æ¨ªçºµåæ ‡ï¼Œå€¼ä¸ºæ˜¯å¦å«æœ‰èˆ°è‰‡ï¼ˆboolï¼‰    nonces - [[Uint32]] - éšæœºå€¼çŸ©é˜µ*/function build_merkle(initial_board, nonces) {    check_correct_sizes(initial_board, nonces);    let merkle = [[]];    // add all leaf nodes    for (let i = 0; i &lt; BOARD_LEN; i++) {        for (let j = 0; j &lt; BOARD_LEN; j++) {            merkle[0].push(                web3.utils.keccak256(                    web3.utils.fromAscii(JSON.stringify(initial_board[i][j]) + JSON.stringify(nonces[i][j]))                )            );        }    }    // build tree from leaves    // while, current level of merkle has length &gt; 1, add more levels    let curr_level = 0;    while (merkle[curr_level].length &gt; 1) {        merkle.push([]);        curr_level += 1;        // build new layer of tree        for (let i = 0; i + 1 &lt; merkle[curr_level - 1].length; i += 2) {            // have new_node represent another node in the Merkle tree            let new_node = web3.utils.keccak256(merkle[curr_level - 1][i] + merkle[curr_level - 1][i + 1].substring(2), {encoding: 'hex'});            // finalize finally computes the hash for every argument passed in update            merkle[curr_level].push(new_node);        }        // if this most recent merkle level has an odd length, we need        // to just hoist the last element into the next level        if (merkle[curr_level - 1].length % 2 !== 0) {            merkle[curr_level].push(merkle[curr_level - 1][merkle[curr_level - 1].length - 1]);        }    }    return merkle;}</code></pre><h3 id="2-çŒœæµ‹èˆ°è‰‡ä½ç½®"><a href="#2-çŒœæµ‹èˆ°è‰‡ä½ç½®" class="headerlink" title="2. çŒœæµ‹èˆ°è‰‡ä½ç½®"></a>2. çŒœæµ‹èˆ°è‰‡ä½ç½®</h3><p>é¦–å…ˆå‘é€çŒœæµ‹ç»™å¯¹æ‰‹ï¼Œå¯¹æ‰‹å›åº”æ˜¯å¦çŒœä¸­ï¼Œå¦‚æœçŒœä¸­äº†çŒœæµ‹è€…å‘èµ·åˆçº¦éªŒè¯ã€‚</p><p>JSä»£ç ï¼š</p><pre><code class="javascript">// function called when a user guesses a squareasync function guess_square(i, j, player, opponent, callback) {    // ç­¾å    let signed_guess = await player.build_guess(i, j);    // å‘é€ç­¾åå’ŒçŒœæµ‹ç»™å¯¹æ‰‹è·å–å¯¹æ‰‹å›åº”æ˜¯å¦çŒœä¸­ã€éšæœºæ•°ã€merkleéªŒè¯ä½¿ç”¨çš„èŠ‚ç‚¹æ•°ç»„    let [opening, nonce, proof] = await opponent.respond_to_guess(i, j, signed_guess);    // æ›´æ–°é¡µé¢    $('#' + opponent.my_name + ' &gt; .my-board #' + i + '-' + j)        .css('background-image', 'url(' + (opening ? EXPLOSION_IMG : SPLASH_IMG) + ')');    // interpret response    await player.receive_response_to_guess(i, j, [opening, nonce, proof]);    // return if the guess hit a ship    callback(opening);}</code></pre><p>respond_to_guessæ–¹æ³•è·å–nonce, proofæ–¹æ³•ï¼ŒJSä»£ç ï¼š</p><pre><code class="javascript">/* è·å–é›¶çŸ¥è¯†è¯æ˜éœ€è¦çš„èŠ‚ç‚¹hash  /args:    initial_board - matrix representing my-board state    nonces - nonces for your board    guess - [i, j] - guess building proof for*/function get_proof_for_board_guess(initial_board, nonces, guess) {    let merkle_tree = build_merkle(initial_board, nonces);    let index_in_merkle = guess[0] * BOARD_LEN + guess[1];    let proof = [];    for (let i = 0; i &lt; merkle_tree.length - 1; i++) {        let merkle_group = Math.floor(index_in_merkle / Math.pow(2, i)); // goodod        let index_in_group = merkle_group % 2;        let sibling = Math.min(merkle_group - index_in_group + (index_in_group + 1) % 2, merkle_tree[i].length - 1);        if (sibling == merkle_group) continue;        proof.push(merkle_tree[i][sibling]);    }    return proof;}</code></pre><p>éªŒè¯æ˜¯å¦å‡»ä¸­ï¼ŒSolidityä»£ç ï¼š</p><pre><code class="solidity">// éªŒè¯å•ä¸ªå•æ¿ä¸Šçš„å•ä¸ªç‚¹çš„è¯æ˜// args:// - opening_nonce - å¯¹åº”äºweb3.utils.fromAscii(JSON.stringify(open) + JSON.stringify(nonce)));// - proof - sha256å“ˆå¸Œè¡¨ï¼Œå¯¹åº”äº get_proof_for_board_guess()çš„è¾“å‡º// - guess - [i, j] - guesså¼€å£å¯¹åº”ï¼ˆguess that opening corresponds toï¼‰// - commit - boardçš„é»˜å…‹å°”æ ¹function verify_opening(bytes memory opening_nonce, bytes32[] memory proof, uint guess_leaf_index, bytes32 commit) public pure returns (bool result) {    bytes32 curr_commit = keccak256(opening_nonce); // see if this changes hash    uint index_in_leaves = guess_leaf_index;    uint curr_proof_index = 0;    uint i = 0;    while (curr_proof_index &lt; proof.length) {        // å¯¹äºé»˜å…‹å°”æ ‘çš„å½“å‰å±‚çº§ï¼ŒçŒœæµ‹çš„èŠ‚ç‚¹åœ¨å“ªä¸ªç»„çš„ç´¢å¼•(ç›¸å½“äºé»˜å…‹å°”æ ‘ä¸‹ä¸€å±‚çº§parentçš„ç´¢å¼•)        // index of which group the guess is in for the current level of Merkle tree        // (equivalent to index of parent in next level of Merkle tree)        uint group_in_level_of_merkle = index_in_leaves / (2**i);        // Merkleåˆ†ç»„ï¼ˆä¸¤ä¸ªä¸ºä¸€ç»„åˆ†ç»„ï¼‰ç´¢å¼•æ•°ï¼Œåªæœ‰(0, 1)        uint index_in_group = group_in_level_of_merkle % 2;        // å½“å‰é»˜å…‹å°”å±‚çº§çš„æœ€å¤§èŠ‚ç‚¹ç´¢å¼•        uint max_node_index = ((BOARD_LEN * BOARD_LEN + (2**i) - 1) / (2**i)) - 1;        // curr_commitçš„åŒçº§ç´¢å¼•        uint sibling = group_in_level_of_merkle - index_in_group + (index_in_group + 1) % 2;        i++;        if (sibling &gt; max_node_index) continue;        if (index_in_group % 2 == 0) {            curr_commit = keccak256(merge_bytes32(curr_commit, proof[curr_proof_index]));            curr_proof_index++;        } else {            curr_commit = keccak256(merge_bytes32(proof[curr_proof_index], curr_commit));            curr_proof_index++;        }    }    return (curr_commit == commit);}</code></pre><h3 id="3-åˆ¤å®šèµ¢"><a href="#3-åˆ¤å®šèµ¢" class="headerlink" title="3. åˆ¤å®šèµ¢"></a>3. åˆ¤å®šèµ¢</h3><p>leaf_index_check_p2ä¸­è®°å½•ç€å·²ç»å‡»ä¸­äº†å¤šå°‘èˆ°è‰‡</p><p>Solidityä»£ç ï¼š</p><pre><code class="solidity">// å®£å¸ƒä½ èµ¢äº†æ¯”èµ›// å¦‚æœä½ å‡»ä¸­äº†2ä¸ªèˆ°è‰‡ï¼Œç„¶åè¿™ä¸ªå‡½æ•°ä¼šè½¬ç§»èµ¢é’±ç»™ä½ å’Œç»“æŸæ¸¸æˆã€‚function claim_win() public{    assert(msg.sender == p1 || msg.sender == p2);    bool    isP1Win = true;    if (msg.sender == p2) {        isP1Win = false;    }    if (isP1Win) {        require(leaf_index_check_p2.length &gt;= 2);        winner = p1;    } else {        require(leaf_index_check_p1.length &gt;= 2);        winner = p2;    }    // transfer all the tokens from this contract to the winner (i.e., msg sender)    msg.sender.transfer(address(this).balance);    state = 2;}</code></pre><h3 id="4-æ§å‘Šå¯¹æ‰‹ä½œå¼Š"><a href="#4-æ§å‘Šå¯¹æ‰‹ä½œå¼Š" class="headerlink" title="4. æ§å‘Šå¯¹æ‰‹ä½œå¼Š"></a>4. æ§å‘Šå¯¹æ‰‹ä½œå¼Š</h3><p>è°ƒç”¨ä¸Šé¢çš„verify_openingæ–¹æ³•éªŒè¯æ˜¯å¦æ»¡è¶³Merkleæ ‘ï¼Œä¸æ»¡è¶³è¯´æ˜å¯¹æ–¹ä½œå¼Šã€‚</p><p>Solidityä»£ç ï¼š</p><pre><code class="solidity">// æ§å‘Šå¯¹æ‰‹ä½œå¼Š â€” å¦‚æœæ˜¯çœŸçš„ï¼Œä½ å°±èµ¢äº†ã€‚// opening_nonce - å¯¹åº”äºJSä¸­çš„web3.utils.fromAscii(JSON.stringify(opening) + JSON.stringify(nonce))// proof - ä¸€ä¸ªsha256å“ˆå¸Œåˆ—è¡¨ï¼Œä½ å¯ä»¥ä»get_proof_for_board_guess(è¿™æ˜¯å‘é€è€…è®¤ä¸ºæ˜¯ä¸€ä¸ªè°è¨€)// guess_leaf_index - çŒœæµ‹èˆ¹åªä½ç½®çš„ç´¢å¼•// owner - è¿™è‰˜èˆ¹æ‰€åœ¨çš„boardçš„æ‰€æœ‰è€…çš„åœ°å€function accuse_cheating (    bytes memory opening_nonce,    bytes32[] memory proof,    uint256 guess_leaf_index,    address owner) public returns (bool result) {    assert((msg.sender == p1 &amp;&amp; owner == p2) || (msg.sender == p2 &amp;&amp; owner == p1));    bytes32 com = merkle_root_p1;    if(owner == p2){        com = merkle_root_p2;    }    if(!verify_opening(opening_nonce, proof, guess_leaf_index, com)){        msg.sender.transfer(address(this).balance);        state = 2;        winner = msg.sender;        return true;    }    return false;}</code></pre><h2 id="å…­ã€å‚è€ƒé“¾æ¥"><a href="#å…­ã€å‚è€ƒé“¾æ¥" class="headerlink" title="å…­ã€å‚è€ƒé“¾æ¥"></a>å…­ã€å‚è€ƒé“¾æ¥</h2><ol><li>æºä»£ç æä¾›ï¼š<a href="https://blog.csdn.net/liangyihuai/article/details/116459829">https://blog.csdn.net/liangyihuai/article/details/116459829</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
            <tag> Layer2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>é›ªå´©å…±è¯†</title>
      <link href="/2022/02/08/blockchain/avalanche/%E9%9B%AA%E5%B4%A9%E5%85%B1%E8%AF%86/"/>
      <url>/2022/02/08/blockchain/avalanche/%E9%9B%AA%E5%B4%A9%E5%85%B1%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><strong>1.å¼•è¨€</strong></p><p>Avalancheä¸»ç½‘æ­£å¼ä¸Šçº¿ï¼ŒOKExä¹Ÿå·²ç»ä¸Šæ¶AvalancheåŸç”Ÿä»£å¸AVAXï¼Œæ›¾è·å¾—â€œå…±è¯†åè®®3.0â€ä¹‹ç§°çš„Avalancheé‡å›å¤§ä¼—è§†é‡ï¼Œä¸ºä½•Avalancheä¸€ä¸¾ä¸€åŠ¨å—åˆ°å¦‚æ­¤å¤§çš„å¸‚åœºå…³æ³¨ï¼Ÿ</p><p>è¿™ä¸€åˆ‡è¦ä»2015å¹´5æœˆè¯´èµ·ï¼Œåº·å¥ˆå°”å¤§å­¦å‡ºç°äº†ä¸€ç¯‡ã€Šä»â€œé›ªèŠ±â€åˆ°â€œé›ªå´©â€ï¼šä¸€ç§æ–°å‹çš„äºšç¨³æ€å…±è¯†åè®®æ—ã€‹çš„è®ºæ–‡ï¼Œåœ¨å¸‚åœºä¸Šå¼•å‘äº†é›ªå´©å¼çš„è¿…é€Ÿåå“ï¼Œæˆä¸ºå¯ä»¥å’Œä¸­æœ¬èªçš„PoWæœºåˆ¶ã€ä»¥å¤ªåŠæ™ºèƒ½åˆçº¦ç›¸åª²ç¾çš„é¢ è¦†æ€§æŠ€æœ¯åˆ›æ–°ã€‚</p><p><strong>2.ç»“åˆæ—©æœŸåè®®ä¼˜ç‚¹å¹¶æ”¹è¿›ç¼ºç‚¹</strong></p><p>æ­£å¦‚åº·å¥ˆå°”å¤§å­¦æ•™æˆåŸƒç±³Â·å†ˆÂ·ç‘Ÿå‹’ï¼ˆEmin Gun Sirerï¼‰æ‰€è¨€ï¼šâ€œAvalancheæè¿°äº†ä¸€ç§æ–°çš„å…±è¯†åè®®ï¼Œå®ƒå°†ä¸­æœ¬èªå…±è¯†åè®®ä¸ç»å…¸å…±è¯†åè®®ç›¸ç»“åˆï¼Œè¿™æ˜¯ä¸€æ¬¡é‡å¤§çš„çªç ´â€ã€‚åœ¨æ­¤ä¹‹å‰ï¼Œç»å…¸å…±è¯†åè®®å’Œä¸­æœ¬èªå…±è¯†åè®®æ˜¯æ—©æœŸä¸¤ç±»è§£å†³åˆ†å¸ƒå¼ç³»ç»Ÿæ‹œå åº­é—®é¢˜çš„ä¸»è¦å…±è¯†åè®®ã€‚</p><p>åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„å…±è¯†é—®é¢˜ä¸€ç›´æ˜¯è®¡ç®—æœºç§‘å­¦é¢†åŸŸçš„é‡è¦è¯é¢˜ï¼Œè€Œæ‹œå åº­å°†å†›é—®é¢˜åˆ™æ˜¯é‡ä¸­ä¹‹é‡ã€‚æˆ˜äº‰æ—¶æœŸï¼Œåœ¨å†›é˜Ÿå¯èƒ½æœ‰å›å¾’å’Œé—´è°çš„æƒ…å†µä¸‹å¿ è¯šçš„å°†å†›å¦‚ä½•è¾¾æˆä¸€è‡´çš„æ„è§ï¼Œè¿™ä¾¿æ˜¯æ‹œå åº­å°†å†›é—®é¢˜ã€‚ç»å…¸å…±è¯†åè®®ç”±å›¾çµå¥–å¾—ä¸»å…°ä¼¯ç‰¹æå‡ºï¼Œå…·æœ‰å¼ºä¸€è‡´æ€§ã€é«˜æ•ˆçš„ç‰¹ç‚¹ï¼Œä½†ä¹Ÿæœ‰é€šä¿¡æˆæœ¬é«˜ã€èŠ‚ç‚¹æ— æ³•è‡ªç”±è¿›å‡ºçš„ç¼ºç‚¹ã€‚</p><p><strong>å›¾1ï¼šç»å…¸å…±è¯†åè®®ï¼ˆPBFTï¼‰å·¥ä½œåŸç†</strong></p><p><img src="https://hx24.huoxing24.com/image/crawler/2020/09/28/1601261161638216.jpg" alt="æ‹œå åº­">èµ„æ–™æ¥æºï¼šã€ŠåŒºå—é“¾æŠ€æœ¯æŒ‡å—ã€‹ï¼ŒOKEx Research</p><p>è€Œè‘—åçš„ä¸­æœ¬èªå…±è¯†åè®®åˆ™åˆ›é€ æ€§åœ°ç”¨æ¦‚ç‡ä¿è¯å®é™…è¿è¡Œçš„å…±è¯†ï¼Œè§£å†³äº†èŠ‚ç‚¹æ— æ³•è‡ªç”±è¿›å‡ºçš„é—®é¢˜ï¼Œä½†æ˜¯æˆæœ¬é«˜æ˜‚é—®é¢˜ä»æœªè¢«è§£å†³ã€‚</p><p><strong>å›¾2ï¼šä¸­æœ¬èªå…±è¯†åè®®å·¥ä½œåŸç†</strong></p><p><img src="https://hx24.huoxing24.com/image/crawler/2020/09/28/1601261161662703.jpg" alt="æ‹œå åº­">èµ„æ–™æ¥æºï¼šOKEx Research</p><p>Avalancheå…±è¯†åè®®åˆ™ç»“åˆäº†ä¸¤ç±»åè®®çš„ä¼˜ç‚¹ï¼šå€Ÿé‰´äº†ä¸­æœ¬èªåè®®æ¦‚ç‡æ€§å®‰å…¨ä¿éšœçš„è®¾è®¡ï¼ŒåŒæ—¶åŠ å…¥äº†BFTå±æ€§ï¼Œå¢åŠ ç³»ç»Ÿçš„æ•ˆç‡å’Œå®‰å…¨æ€§ã€‚</p><p><strong>3.AvalancheåŸç†ï¼šâ€œé›ªèŠ±â€åˆ°â€œé›ªå´©â€çš„å±‚å±‚å®Œå–„</strong></p><p>æ­£å¦‚Avalancheç™½çš®ä¹¦æåˆ°çš„â€œé›ªèŠ±â€åˆ°â€œé›ªå´©â€è¿‡ç¨‹ï¼ŒAvalancheçš„4ä¸ªå­åè®®ç»„æˆæ­£æ˜¯ä»æœ€ç®€å•çš„Slushåè®®ï¼Œåˆ°Snowflakeã€Snowball å’Œ Avalanchï¼Œé€æ­¥å®Œå–„ï¼Œå½¢æˆäº†â€œé›ªèŠ±â€åˆ°â€œé›ªå´©â€çš„è´¨å˜ã€‚</p><p><strong>3.1. â€œé›ªæ³¥â€Slush åè®®ï¼šä¸‡ç‰©ä¹‹åˆ</strong></p><p>Slushåè®®æ˜¯æœ€åŸºç¡€çš„â€œé›ªæ³¥â€ï¼Œé€šè¿‡å¤šæ¬¡éšæœºæŠ½æ ·æ¥è¾¾æˆå…±è¯†ã€‚ä¸ºä¾¿äºç†è§£ï¼Œè¿™é‡Œæˆ‘ä»¬ä»¥æŠ•ç¥¨ç¡®è®¤é¢œè‰²ä¸ºä¾‹ã€‚èŠ‚ç‚¹è¾¾æˆå…±è¯†çš„æ­¥éª¤å¦‚ä¸‹ï¼š</p><p>ï¼ˆ1ï¼‰åˆå§‹çŠ¶æ€æ—¶æ‰€æœ‰çš„èŠ‚ç‚¹å‡æœªç€è‰²ï¼›</p><p>ï¼ˆ2ï¼‰å½“èŠ‚ç‚¹Aæ”¶åˆ°ä¿¡æ¯æ—¶ï¼Œæœªç€è‰²çš„èŠ‚ç‚¹å°†ä¿¡æ¯é¢œè‰²è®¾ä¸ºè‡ªå·±çš„é¢œè‰²ï¼Œå¹¶è¯¢é—®å…¶ä»–èŠ‚ç‚¹çš„é¢œè‰²ï¼›</p><p>ï¼ˆ3ï¼‰æœªç€è‰²çš„èŠ‚ç‚¹Bæ”¶åˆ°è¯¢é—®ï¼Œå°†è‡ªå·±æŸ“æˆç›¸åŒé¢œè‰²å¹¶å›å¤ï¼›å·²ç€è‰²çš„èŠ‚ç‚¹Cæ”¶åˆ°è¯¢é—®ä¼šå›å¤è‡ªå·±çš„é¢œè‰²ï¼›</p><p>ï¼ˆ4ï¼‰èŠ‚ç‚¹Aæ”¶åˆ°å¤šä¸ªå“åº”åï¼Œå¦‚æœå¤§å¤šæ•°é¢œè‰²å’Œè‡ªå·±çš„ä¸€ç›´ï¼Œåˆ™ä¸æ”¹å˜é¢œè‰²ï¼Œå¦åˆ™æ”¹å˜é¢œè‰²ï¼Œå³ä»¥å¤§å¤šæ•°å…¶ä»–èŠ‚ç‚¹çš„é¢œè‰²åé¦ˆæ¥æ ¡æ­£è‡ªå·±çš„é¢œè‰²ã€‚</p><p>Slushåè®®å°±å·²ç»è§£å†³äº†ç»å…¸å…±è¯†åè®®é€šè®¯æˆæœ¬é«˜çš„é—®é¢˜ï¼Œè¿˜ç”¨éƒ¨åˆ†æŠ½æ ·ç­‰æ–¹å¼é¿å…äº†ä¸­æœ¬èªå…±è¯†åè®®é«˜èƒ½è€—çš„é—®é¢˜ã€‚åç»­åè®®çš„æ”¹è¿›ä¸»è¦ä¸ºäº†æå‡å…±è¯†åè®®å®‰å…¨æ€§ã€‚</p><p><strong>3.2. â€œé›ªèŠ±â€Snowflakeåè®®ï¼šåˆæ­¥æ”¹å–„</strong></p><p>åœ¨æ‹œå åº­èŠ‚ç‚¹å­˜åœ¨çš„æƒ…å†µä¸‹ï¼ŒSlushä¸èƒ½æä¾›å¼ºå¤§çš„å®‰å…¨ä¿è¯ã€‚ä¸ºæ­¤ï¼ŒSnowflakeä½œä¸ºå‡çº§ç‰ˆåè®®å¼•å…¥äº†è®¡æ•°å™¨ï¼ˆCounterï¼‰æ¥å¢åŠ ç³»ç»Ÿçš„å®‰å…¨æ€§ã€‚</p><p>å…·ä½“è€Œè¨€ï¼Œç½‘ç»œä¸­çš„æ”»å‡»èŠ‚ç‚¹æ•…æ„æ•£æ’­é”™è¯¯çš„é¢œè‰²ï¼Œå¯èƒ½å¯¼è‡´SlushæŸä¸€è½®ç»Ÿè®¡å¾—åˆ°é”™è¯¯çš„é¢œè‰²ï¼Œè€ŒSnowflakeçš„è®¡æ•°å™¨ç»Ÿè®¡äº†æŸç§é¢œè‰²è¿ç»­å‡ºç°çš„æ¬¡æ•°ï¼Œåªæœ‰æŸç§é¢œè‰²è¿ç»­å‡ºç°å¤šæ¬¡ï¼ŒèŠ‚ç‚¹æ‰ä¼šæ”¹å˜è‡ªå·±çš„é¢œè‰²ã€‚å¦‚æ­¤é¿å…äº†æ‹œå åº­èŠ‚ç‚¹å¸¦æ¥çš„å¹²æ‰°ï¼Œç¡®ä¿äº†ç³»ç»Ÿçš„å®‰å…¨æ€§å’Œæ´»è·ƒåº¦ã€‚</p><p><strong>3.3. â€œé›ªçƒâ€Snowballåè®®ï¼šæ·±å…¥å‡çº§</strong></p><p>Snowballåœ¨Snowflakeçš„åŸºç¡€ä¸Šæ›´è¿›ä¸€æ­¥åœ°ã€‚å¼•å…¥äº†ç±»ä¼¼ä¿¡èª‰ç§¯åˆ†çš„åˆ¶åº¦â€”â€”ä¿¡ä»»åº¦ï¼Œä»¥æé«˜å®‰å…¨æ€§ã€‚</p><p>å…·ä½“è€Œè¨€ï¼ŒSnowflakeåè®®çš„æ”¹è¿›å¦‚ä¸‹ï¼š</p><p>ï¼ˆ1ï¼‰æ¯æˆåŠŸæŸ¥è¯¢ä¸€æ¬¡ï¼ŒèŠ‚ç‚¹å°±ä¸ºè¯¥é¢œè‰²çš„ä¿¡ä»»åº¦åŠ 1åˆ†ï¼›</p><p>ï¼ˆ2ï¼‰èŠ‚ç‚¹ä¼šåˆ‡æ¢ä¸ºä¿¡ä»»åº¦è¾ƒé«˜çš„é¢œè‰²ã€‚</p><p>Snowballåè®®ä¸ä»…æ¯”Snowflakeæ›´éš¾é­å—æ”»å‡»ï¼Œè€Œä¸”æ›´å®¹æ˜“æ¨å¹¿åˆ°å¤šå‘½ä»¤åè®®ã€‚</p><p><strong>3.4. â€œé›ªå´©â€Avalancheåè®®ï¼šé‡å˜åˆ°è´¨å˜</strong></p><p>ç»ˆæBossâ€œé›ªå´©â€â€”â€”Avalancheåˆåœ¨Snowballçš„åŸºç¡€ä¸Šå¢åŠ äº†æœ‰å‘æ— å¾ªç¯å›¾ï¼ˆDAGï¼‰æ¥è®°å½•æ‰€æœ‰çš„äº¤æ˜“çŠ¶æ€ã€‚åœ¨DAGä¸­ï¼Œå¦‚æœæƒ³ç»™ä»åˆ›ä¸–ç‚¹åˆ°æŸèŠ‚ç‚¹è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æŠ•ç¥¨åªéœ€è¦ç»™è¯¥èŠ‚ç‚¹æŠ•ç¥¨ï¼Œå¤§å¤§æé«˜äº†æ•ˆç‡ã€‚å…¶æ¬¡ï¼ŒDAGæœ‰ç€ç±»ä¼¼äºåŒºå—é“¾çš„é“¾å¼ç»“æ„è®°å½•äº¤æ˜“ä¿¡æ¯ï¼Œä½¿å¾—è¿‡å»çš„äº¤æ˜“ä¿¡æ¯å¾ˆéš¾è¢«ç¯¡æ”¹ï¼Œè¿›ä¸€æ­¥æå‡äº†å®‰å…¨æ€§ã€‚</p><p>å›¾3ï¼šDAGç¤ºæ„å›¾</p><p><img src="https://hx24.huoxing24.com/image/crawler/2020/09/28/1601261161723758.jpg" alt="æ‹œå åº­">èµ„æ–™æ¥æºï¼šã€ŠåŒºå—é“¾æ–°å…±è¯†ç®—æ³• Snowflake to Avalancheã€‹ï¼ŒOKEx Research</p><p><strong>3.5. Avalancheåè®®ï¼šé›†å‰æœŸåè®®ä¹‹å¤§æˆ</strong></p><p>å¸å–äº†æ—©æœŸä¸¤ä¸ªå…±è¯†åè®®çš„ä¼˜ç‚¹ï¼Œå¹¶ç»è¿‡4ä¸ªåè®®å±‚æ¬¡é€’è¿›ã€é€æ­¥æ”¹å–„ï¼ŒAvalancheåè®®å…·æœ‰è®¸å¤šä¼˜è‰¯ç‰¹æ€§ã€‚</p><p>ï¼ˆ1ï¼‰é«˜æ•ˆçš„å¯æ‰©å±•æ€§ï¼šè½»é‡çº§ï¼Œå¯æ‰©å±•ï¼Œä½å»¶è¿Ÿï¼›</p><p>ï¼ˆ2ï¼‰é«˜æ‹œå åº­å®¹é”™ï¼šå³ä½¿ç½‘ç»œä¸­æœ‰è¶…è¿‡50%çš„èŠ‚ç‚¹æ˜¯æ‹œå åº­èŠ‚ç‚¹ï¼Œç½‘ç»œä¾ç„¶æ˜¯å®‰å…¨çš„;</p><p>ï¼ˆ3ï¼‰é™æ€ç»¿è‰²ï¼šä¸PoWæœºåˆ¶ä¸åŒï¼ŒAvalancheåè®®ä¸ä¼šæµªè´¹ä»»ä½•èµ„æº;</p><p>ï¼ˆ4ï¼‰ä½é€šä¿¡æˆæœ¬ï¼šAvalancheåè®®æ¯”ä¼ ç»Ÿå…±è¯†åè®®çš„é€šè®¯å¤æ‚åº¦æ›´ä½ã€‚</p><p><strong>4. é›¶ç¡®è®¤äº¤æ˜“ä¸Avalancheåè®®</strong></p><p>Avalancheåˆšé¢ä¸–æ—¶ï¼Œäººä»¬è¿˜æ²¡æœ‰å‘ç°Avalancheåè®®ä¸é›¶ç¡®è®¤äº¤æ˜“ä¹‹é—´æœ‰ä»€ä¹ˆå…³ç³»ã€‚ç„¶è€Œåœ¨2018å¹´12æœˆå·¦å³ï¼ŒBCHç¤¾åŒºçš„æŠ€æœ¯äººå‘˜Chris Paciaå‘è¡¨ä¸€ç¯‡æ–‡ç« ï¼Œè®¤ä¸ºå¯ä»¥ä½¿ç”¨Avalancheåè®®æ¥ä¿è¯é›¶ç¡®è®¤äº¤æ˜“çš„å®‰å…¨æ€§ï¼Œä¸€æ—¶èµ·åƒå±‚æµªï¼Œå¼•å‘äº†å¸‚åœºçš„å¹¿æ³›å…´è¶£ã€‚</p><p>Avalancheåè®®çš„ç¡®è®¤éœ€è¦å¤šæ¬¡æŠ½æ ·ï¼Œä¸ºç¼©çŸ­ç¡®è®¤æ—¶é—´ï¼Œåˆ™æŠ½æ ·æ¬¡æ•°å¿…é¡»å—åˆ°é™åˆ¶ï¼Œè¿™æ„å‘³ç€ï¼Œæ¶æ„èŠ‚ç‚¹è¶…è¿‡ä¸€å®šæ¯”ä¾‹åï¼Œåœ¨æœ‰é™æŠ½æ ·é‡Œè¯šå®èŠ‚ç‚¹æ— æ³•è¾¾æˆå…±è¯†ã€‚ä¸ºæ­¤ï¼ŒChris Paciaè®¤ä¸ºå¯ä»¥å¼•å…¥PoWæœºåˆ¶æ¥ä¿æŠ¤ç½‘ç»œçš„å®‰å…¨ï¼Œé˜²æ­¢é»‘å®¢çš„æ”»å‡»èŠ‚ç‚¹æ•°é‡å¤ªå¤šã€‚</p><p><strong>5. Avalancheç°çŠ¶ï¼šä¼—æœ›æ‰€å½’</strong></p><p>è‡ª2018å¹´Avalancheç™½çš®ä¹¦å‘å¸ƒä»¥æ¥ï¼Œå—åˆ°äº†å¹¿æ³›çš„é¦–è‚¯å¿ƒæŠ˜ï¼Œè®¸å¤šVCç›¸ç«ä¸ºä¹‹æŠ˜è…°ã€‚2019 å¹´ï¼Œé›ªå´©åè®®Avaè·å¾—äº† a16zã€Polychain Capital ç­‰æœºæ„ 600 ä¸‡ç¾å…ƒèèµ„ã€‚2020å¹´6æœˆï¼ŒAVA Labåˆå®Œæˆäº†ä¸€ç¬”1200ä¸‡ç¾å…ƒçš„ä»£å¸ç§å‹Ÿèèµ„ï¼ŒåŒå¹´7æœˆï¼Œåˆè·å¾—IOSG Venturesçš„æˆ˜ç•¥æŠ•èµ„ï¼Œå¹¶å°±ä¸­å›½å¸‚åœºæœªæ¥å‘å±•è¾¾æˆç‹¬å®¶æˆ˜ç•¥åˆä½œåè®®ã€‚æ ¹æ®æœ€æ–°æ¶ˆæ¯ï¼ŒAVAçš„å…¬å‹Ÿäº7æœˆ8æ—¥å¼€å¯ã€‚</p><p><strong>6. ç»“è¯­</strong></p><p>Avalancheç»“åˆäº†æ—©æœŸä¸¤ç§å…±è¯†åè®®çš„ä¼˜ç‚¹å¹¶æ”¹è¿›å…¶ç¼ºç‚¹ï¼Œå…·æœ‰é«˜æ‹“å±•æ€§ã€é™æ€ç»¿è‰²ä»¥åŠä½é€šä¿¡æˆæœ¬çš„ä¼˜ç‚¹ã€‚åŒæ—¶ï¼Œä»Slushåˆ°Avalancheå±‚å±‚é€’è¿›ã€é€æ­¥å®Œå–„ï¼Œå¼•å…¥è®¡æ•°å™¨ã€å¯ä¿¡åº¦ã€DAGç­‰ï¼Œæ—¥è‡»å®Œå–„ã€‚</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.avalabs.org/whitepapers">Avalanche writepaper</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Avalanche </tag>
            
            <tag> å…±è¯†ç®—æ³• </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What&#39;s Avalanche?</title>
      <link href="/2022/02/07/blockchain/avalanche/What&#39;s%20Avalanche/"/>
      <url>/2022/02/07/blockchain/avalanche/What&#39;s%20Avalanche/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-Avalanche"><a href="#What-is-Avalanche" class="headerlink" title="What is Avalanche?"></a>What is Avalanche?</h1><p>Avalanche is an open-source platform for launching decentralized applications and enterprise blockchain deployments in one interoperable, highly scalable ecosystem. Avalanche is the first decentralized smart contracts platform built for the scale of global finance, with near-instant transaction finality. Ethereum developers can quickly build on Avalanche as Solidity works out-of-the-box.</p><p>A key difference between Avalanche and other decentralized networks is the <font color="red">consensus protocol</font>. Over time, people have come to a false understanding that blockchains have to be slow and not scalable. The Avalanche protocol employs a novel approach to consensus to achieve its <font color="red">strong safety guarantees, quick finality, and high-throughput</font> without compromising decentralization.</p><h1 id="Consensus-protocol"><a href="#Consensus-protocol" class="headerlink" title="Consensus protocol"></a>Consensus protocol</h1><p><img src="https://docs.avax.network/assets/images/Consensus-protocol-comparison-aa555b20f36947d6a5ff869d8758fa6e.png" alt="image"></p><p>Protocols in the Avalanche family operate through repeated sub-sampled voting. When a <a href="http://support.avalabs.org/en/articles/4064704-what-is-a-blockchain-validator">validator</a> is determining whether a <a href="http://support.avalabs.org/en/articles/4587384-what-is-a-transaction">transaction</a> should be accepted or rejected, it asks a small, random subset of validators whether they think the transaction should be accepted or rejected. If the queried validator thinks the transaction is invalid, has already rejected the transaction, or prefers a conflicting transaction, it replies that it thinks the transaction should be rejected. Otherwise, it replies that it thinks the transaction should be accepted.</p><p>If a sufficiently large portion (<em>alpha</em> Î±) of the validators sampled reply that they think the transaction should be accepted, the validator prefers to accept the transaction. That is, when it is queried about the transaction in the future, it will reply that it thinks the transaction should be accepted. Similarly, the validator will prefer to reject the transaction if a sufficiently large portion of the validators replies that they think the transaction should be rejected.</p><p>The validator repeats this sampling process until <em>alpha</em> of the validators queried reply the same way (accept or reject) for <em>beta</em> Î² consecutive rounds.</p><p>In the common case when a transaction has no conflicts, finalization happens very quickly. When conflicts exist, honest validators quickly cluster around conflicting transactions, entering a positive feedback loop until all correct validators prefer that transaction. This leads to the acceptance of non-conflicting transactions and the rejection of conflicting transactions.</p><p><img src="https://docs.avax.network/assets/images/howavalancheconsensusworks-a37dc2bdf67c7c2997dcbfd01ee28e64.png" alt="image"></p><p>It is guaranteed (with high probability based on system parameters) that if any honest validator accepts or rejects a transaction, all honest validators will accept or reject that transaction.</p><h2 id="Key-Features"><a href="#Key-Features" class="headerlink" title="Key Features"></a>Key Features</h2><h3 id="Speed"><a href="#Speed" class="headerlink" title="Speed"></a>Speed</h3><p>Uses a novel consensus protocol, developed by a team of Cornell computer scientists, and is able to permanently confirm transactions in under <font color="red">1 second</font>.</p><h3 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h3><p>Capable of <font color="red">4,500 transactions per second</font>â€“an order of magnitude greater than existing blockchains.</p><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p><font color="red">Ensures stronger security guarantees well</font>-above the 51% standard of other networks.</p><h3 id="Flexibility"><a href="#Flexibility" class="headerlink" title="Flexibility"></a>Flexibility</h3><p><font color="red">Easily</font> create custom blockchains and decentralized apps that contain almost any arbitrary logic.</p><h3 id="Sustainability"><a href="#Sustainability" class="headerlink" title="Sustainability"></a>Sustainability</h3><p>Uses energy-efficient <font color="red">proof-of-stake</font> consensus algorithm rather than proof-of-work.</p><h3 id="Smart-Contract-Support"><a href="#Smart-Contract-Support" class="headerlink" title="Smart Contract Support"></a>Smart Contract Support</h3><p>Supports the creation of <font color="red">Solidity smart contracts</font> and your favorite Ethereum tools like Remix, Metamask, Truffle, and more.</p><h3 id="Private-and-Public-Blockchains"><a href="#Private-and-Public-Blockchains" class="headerlink" title="Private and Public Blockchains"></a>Private and Public Blockchains</h3><p>Create your own public or private blockchains.</p><h3 id="Designed-for-Finance"><a href="#Designed-for-Finance" class="headerlink" title="Designed for Finance"></a>Designed for Finance</h3><p>Native support for easily creating and trading <font color="red">digital smart assets</font> with complex, custom rulesets.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><p><a href="https://docs.avax.network/">Avalanche website</a></p></li><li><p><a href="https://github.com/ava-labs/avalanchego">Avalanche source code</a></p></li><li><p><a href="https://academy.binance.com/zh/articles/what-is-avalanche-avax">Whatâ€™s is Avalanche?</a></p></li><li><p><a href="https://www.avalabs.org/whitepapers">Avalanche writepaper</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Avalanche </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockeræ–¹å¼æ­å»ºä»¥å¤ªåŠç½‘ç»œ-ç§æœ‰é“¾</title>
      <link href="/2022/01/29/blockchain/ethereum/Docker%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A---%E7%A7%81%E6%9C%89%E9%93%BE/"/>
      <url>/2022/01/29/blockchain/ethereum/Docker%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A---%E7%A7%81%E6%9C%89%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>æœ¬æ–‡æ¶‰åŠçš„çŸ¥è¯†å’ŒæŠ€æœ¯æœ‰ï¼š</p><ul><li>Dockerï¼šä¸€ç§æ—¶ä¸‹æµè¡Œçš„å®¹å™¨</li><li>gethï¼šä»¥å¤ªåŠå®¢æˆ·ç«¯çš„goå®ç°</li><li>truffleï¼šä»¥å¤ªåŠåˆçº¦éƒ¨ç½²å·¥å…·</li></ul><h2 id="ä¸»æœºé…ç½®"><a href="#ä¸»æœºé…ç½®" class="headerlink" title="ä¸»æœºé…ç½®"></a>ä¸»æœºé…ç½®</h2><p>æ­¤å¤„éœ€è¦è¡¥å……ä¸€ç‚¹çš„æ˜¯ï¼Œå¦‚æœæ‚¨ä½¿ç”¨çš„æ˜¯è™šæ‹Ÿæœºã€äº‘ä¸»æœºæˆ–è€…è€ç ´å°æœºå™¨ï¼Œéœ€è¦ç¡®ä¿åˆ†é…ç»™ä¸»æœºçš„å†…å­˜è‡³å°‘2GBã€‚å› ä¸ºä»¥å¤ªåŠä¸ºäº†æŠµå¾¡æ¯”ç‰¹å¤§é™†è¿™æ ·çš„ASICçŸ¿æœºå¯¹ç®—åŠ›çš„å„æ–­ï¼Œé‡‡ç”¨äº†å’Œæ¯”ç‰¹å¸å®Œå…¨ä¸åŒçš„PoWç®—æ³•â€”â€”ethashã€‚è¯¥ç®—æ³•çš„ç‰¹ç‚¹æ˜¯ç®—åŠ›ä¸æ•æ„Ÿï¼Œå†…å­˜æ•æ„Ÿã€‚è¯¥ç®—æ³•ç›®å‰éœ€è¦åœ¨å†…å­˜åˆ›å»ºå¤§çº¦1GBçš„DAGç”¨æ¥åšPoWè¿ç®—ï¼Œä¸”DAGä¼šéšç€åŒºå—çš„å¢åŠ å‘ˆé˜¶æ¢¯çŠ¶å¢é•¿ï¼Œå› æ­¤å»ºè®®è‡³å°‘ç»™æŒ–çŸ¿èŠ‚ç‚¹çš„å®¿ä¸»æœºå™¨åˆ†é…è‡³å°‘2GBçš„å†…å­˜ï¼Œä¸”ä¿ç•™æ‰©å¤§å†…å­˜å®¹é‡çš„çµæ´»æ€§ã€‚</p><h2 id="è·å–gethé•œåƒ"><a href="#è·å–gethé•œåƒ" class="headerlink" title="è·å–gethé•œåƒ"></a>è·å–gethé•œåƒ</h2><p>docker hubä¸Šæœ‰ç°æˆçš„gethé•œåƒã€‚ç›´æ¥è·å–ï¼š</p><pre><code class="bash">docker pull ethereum/client-go:v1.8.12</code></pre><h2 id="åˆ›å»ºDockerç½‘ç»œ"><a href="#åˆ›å»ºDockerç½‘ç»œ" class="headerlink" title="åˆ›å»ºDockerç½‘ç»œ"></a>åˆ›å»ºDockerç½‘ç»œ</h2><p>æ—§ç‰ˆæœ¬çš„dockerå®¹å™¨ç›¸äº’ä¹‹é—´æ˜¯ä¾é linkå»ºç«‹å…³ç³»ã€‚<br>æ–°ç‰ˆæœ¬dockeræ¨èåˆ›å»ºè‡ªæœ‰ç½‘è·¯ï¼Œå†å°†éœ€è¦äº’è”çš„å®¹å™¨é…ç½®åˆ°ç›¸åŒçš„ç½‘ç»œä¸­ã€‚<br>äºæ˜¯ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªåä¸ºâ€œethnetâ€œçš„ç½‘ç»œã€‚è¯¥ç½‘ç»œé…ç½®å¦‚ä¸‹ï¼š</p><ul><li>å­ç½‘172.19.0.0/16<ul><li>IPæ®µ172.19.0.0</li><li>æ©ç 255.255.0.0</li><li>IPèŒƒå›´172.19.0.1~172.19.255.254</li><li>IPå¹¿æ’­172.19.255.255</li></ul></li></ul><pre><code class="bash">docker network create -d bridge --subnet=172.19.0.0/16 ethnetdocker network ls</code></pre><h1 id="é…ç½®ä»¥å¤ªåŠç½‘ç»œ"><a href="#é…ç½®ä»¥å¤ªåŠç½‘ç»œ" class="headerlink" title="é…ç½®ä»¥å¤ªåŠç½‘ç»œ"></a>é…ç½®ä»¥å¤ªåŠç½‘ç»œ</h1><p>è¿è¡Œå¦‚ä¸‹å‘½ä»¤è¿›å…¥ä¸€ä¸ªå®¹å™¨ï¼š</p><pre><code class="bash">docker run -it --rm --network ethnet --ip 172.19.0.50 -v /opt/docker-project/eth/workspace:/workspace --entrypoint /bin/sh ethereum/client-go:v1.8.12</code></pre><blockquote><p>â€“network ethnetå‚æ•°æŒ‡å®šäº†è¯¥å®¹å™¨åŠ å…¥åˆšæ‰åˆ›å»ºçš„ethnetç½‘ç»œ<br> â€“ip 172.19.0.50æŒ‡å®šäº†ä¸€ä¸ªå›ºå®šIPç»™è¯¥å®¹å™¨ã€‚</p></blockquote><h2 id="åˆ›å»ºè´¦æˆ·"><a href="#åˆ›å»ºè´¦æˆ·" class="headerlink" title="åˆ›å»ºè´¦æˆ·"></a>åˆ›å»ºè´¦æˆ·</h2><p>é¦–å…ˆï¼Œåœ¨å®¹å™¨å†…çš„/workspaceç›®å½•åˆ›å»ºç›®å½•å’Œæ–‡ä»¶</p><p>æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š</p><pre><code class="bash">mkdir -p /workspacedappmkdir -p /workspace/dapp/minermkdir -p /workspace/dapp/datatouch /workspace/dapp/genesis.json</code></pre><p>ç„¶åè¿è¡Œå¦‚ä¸‹å‘½ä»¤åˆ›å»ºè´¦æˆ·ï¼š</p><pre><code class="bash">geth -datadir /workspace/dapp/miner/data account new</code></pre><p>è¾“å…¥ä¸¤æ¬¡passwordï¼Œè·å¾—åœ°å€ã€‚å°†åœ°å€è®°å½•ä¸‹æ¥ï¼Œåé¢è¦ç”¨åˆ°ã€‚</p><blockquote><p>é‡å¤å¦‚ä¸Šæ­¥éª¤å¯ä»¥åˆ›å»ºå¤šä¸ªè´¦æˆ·ã€‚</p></blockquote><h2 id="åˆ›å»ºåˆ›ä¸–åŒºå—"><a href="#åˆ›å»ºåˆ›ä¸–åŒºå—" class="headerlink" title="åˆ›å»ºåˆ›ä¸–åŒºå—"></a>åˆ›å»ºåˆ›ä¸–åŒºå—</h2><p>ç¼–è¾‘åˆšæ‰åˆ›å»ºçš„æ–‡ä»¶</p><pre><code class="bash">vi /workspace/dapp/data/genesis.json</code></pre><p>æ–‡ä»¶å†…å®¹ï¼š</p><pre><code class="json">{  "config": {    "chainId": 88,    "homesteadBlock": 0,    "eip155Block": 0,    "eip158Block": 0  },  "alloc"      : {    "b126d89780d2221ceffe5c94efd9ca6a005a9f0c": {"balance": "100000000000000000000"},    "93415bb68da6816c581537a4fa74727ddf6f4f4d": {"balance": "1000000000000000000"},    "fa5773a704ee9e91e60ffb8fe4207e934f70619f": {"balance": "1000000000000000000"}  },  "coinbase"   : "0x0000000000000000000000000000000000000000",  "difficulty" : "0x400",  "extraData"  : "",  "gasLimit"   : "0x2fefd8",  "nonce"      : "0x0000000000000000",  "mixhash"    :  "0x0000000000000000000000000000000000000000000000000000000000000000",  "parentHash" :  "0x0000000000000000000000000000000000000000000000000000000000000000",  "timestamp"  : "0x00"}</code></pre><ul><li>genesis.jsonæ˜¯ç”¨æ¥åˆ›å»ºåˆ›ä¸–åŒºå—çš„é…ç½®æ–‡ä»¶</li><li>åŠ å…¥åŒä¸€ç§é“¾çš„èŠ‚ç‚¹å¿…é¡»ä½¿ç”¨åŒä¸€é…ç½®æ–‡ä»¶</li><li>chainidæ˜¯ç§é“¾ç½‘ç»œçš„æ ‡è¯†ï¼Œå¯ä»¥æ˜¯ä»»æ„æ•°å­—ã€‚</li><li>å³ä½¿chainidç›¸åŒï¼Œå¦‚æœgenesis.jsoné…ç½®ä¸ä¸€æ ·ï¼Œä¹Ÿå°†æ˜¯ä¸¤ä¸ªä¸å…¼å®¹çš„ç½‘ç»œ</li><li>allocä¸‹é¢åˆ—ä¸¾äº†4ä¸ªè´¦æˆ·åœ°å€ï¼Œåˆ†åˆ«æ˜¯ä¸Šä¸€æ­¥åˆ›å»ºå¹¶è®°å½•ä¸‹æ¥çš„åœ°å€ã€‚</li><li>balanceæ˜¯åˆ›ä¸–åŒºå—ä¸ºæ¯ä¸ªè´¦æˆ·åˆ†é…çš„åˆå§‹ä»¥å¤ªå¸ã€‚è¿™é‡Œçœ‹ä¼¼åˆ†é…äº†å¾ˆå¤šï¼Œå…¶å®å•ä½æ˜¯weiã€‚1eth=10^18weiã€‚ä¹Ÿå°±æ˜¯é™¤äº†ç¬¬ä¸€ä¸ªè´¦æˆ·ç»™äº†100ethå¤–ï¼Œå…¶å®ƒå‡ ä¸ªè´¦æˆ·åˆ†åˆ«åªæ‹¥æœ‰1ethã€‚è¿™é‡Œç»™ç¬¬ä¸€ä¸ªè´¦æˆ·å¤šåˆ†ç‚¹ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬ä¹‹åéœ€è¦ç”¨å®ƒæ¥éƒ¨ç½²åˆçº¦ã€‚</li></ul><h2 id="å®Œæˆä»¥å¤ªåŠç½‘ç»œé…ç½®"><a href="#å®Œæˆä»¥å¤ªåŠç½‘ç»œé…ç½®" class="headerlink" title="å®Œæˆä»¥å¤ªåŠç½‘ç»œé…ç½®"></a>å®Œæˆä»¥å¤ªåŠç½‘ç»œé…ç½®</h2><p>æ­¤æ—¶å¯ä»¥é€€å‡ºåˆšæ‰çš„å®¹å™¨ã€‚ç”±äºæˆ‘ä»¬è¿è¡Œå®¹å™¨æ˜¯åŠ äº†â€“rmå‚æ•°ï¼Œåˆšæ‰çš„å®¹å™¨ä¼šè¢«åˆ é™¤ï¼Œä½†å®¿ä¸»æœºçš„/workspaceä¸‹çš„æ–‡ä»¶ä¼šè¢«ä¿å­˜ä¸‹æ¥ã€‚</p><h1 id="æŒ–çŸ¿"><a href="#æŒ–çŸ¿" class="headerlink" title="æŒ–çŸ¿"></a>æŒ–çŸ¿</h1><p>ä¸Šè¿°æ­¥éª¤åªæ˜¯é…ç½®å¥½äº†ä¸€ä¸ªä»¥å¤ªåŠç§æœ‰ç½‘ç»œï¼Œå¹¶æ²¡æœ‰çœŸæ­£åˆ›å»ºç½‘ç»œã€‚æˆ‘ä»¬çŸ¥é“ï¼Œä»¥å¤ªåŠç½‘ç»œæ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼çš„ç½‘ç»œï¼Œæœ‰äº†çŸ¿å·¥ï¼Œæ‰æœ‰çš„ç½‘ç»œã€‚äºæ˜¯ï¼Œæˆ‘ä»¬é¦–å…ˆå¾—æœ‰ä¸€ä¸ªçŸ¿å·¥ã€‚</p><h2 id="åˆ›å»ºâ€œä¸»â€çŸ¿å·¥èŠ‚ç‚¹"><a href="#åˆ›å»ºâ€œä¸»â€çŸ¿å·¥èŠ‚ç‚¹" class="headerlink" title="åˆ›å»ºâ€œä¸»â€çŸ¿å·¥èŠ‚ç‚¹"></a>åˆ›å»ºâ€œä¸»â€çŸ¿å·¥èŠ‚ç‚¹</h2><p>æˆ‘ä»¬æ¥ä¸‹æ¥æ‰“ç®—åˆ›å»ºçš„çŸ¿å·¥èŠ‚ç‚¹ï¼Œæˆä¸ºâ€œä¸»â€çŸ¿å·¥ï¼Œå› ä¸ºå®ƒéœ€è¦æ‹¥æœ‰å¦‚ä¸‹ç‰¹æ€§ï¼š</p><ul><li>å®ƒæ˜¯ä¸€ä¸ªå®¹å™¨ï¼Œå¹¶ä¸”æ˜¯æŒä¹…çš„å®¹å™¨</li><li>å®ƒä¼šè‡ªåŠ¨è¯»å–genesis.jsonæ–‡ä»¶ï¼Œå¹¶åˆå§‹åŒ–ä»¥å¤ªåŠç½‘ç»œ</li><li>å®ƒèƒ½å¤Ÿè¿æ¥å…¶å®ƒèŠ‚ç‚¹ï¼ˆå®¹å™¨ï¼‰</li><li>å®ƒèƒ½å¤Ÿæ¥å—å„ç§rpcè°ƒç”¨ï¼Œå¹¶èƒ½å¤Ÿéƒ¨ç½²åˆçº¦</li><li>å®ƒå·²ç»é…ç½®å¥½æŒ–çŸ¿è´¦æˆ·ï¼Œå¯ä»¥ä¸€é”®æŒ–çŸ¿</li></ul><p>äºæ˜¯ï¼Œæˆ‘ä»¬æŒ‰ç…§è¿™ä¸ªè¦æ±‚ï¼Œå¼€å§‹ä¸€æ­¥æ­¥åˆ›å»ºçŸ¿å·¥èŠ‚ç‚¹ã€‚</p><h3 id="åˆ›å»ºentrypointè„šæœ¬"><a href="#åˆ›å»ºentrypointè„šæœ¬" class="headerlink" title="åˆ›å»ºentrypointè„šæœ¬"></a>åˆ›å»ºentrypointè„šæœ¬</h3><p>åˆ›å»ºä¸€ä¸ªæ–‡ä»¶ï¼š</p><pre><code class="bash">vi /opt/docker-project/eth/workspace/dapp/init.sh</code></pre><p> æ–‡ä»¶å†…å®¹å¦‚ä¸‹ï¼š</p><pre><code class="bash">#!/bin/shgeth -datadir ~/data/ init /workspace/dapp/data/genesis.jsonif [  $# -lt 1 ]; then   exec "/bin/sh"else  exec /bin/sh -c "$@"fi</code></pre><blockquote><p>è¯¥è„šæœ¬çš„åŠŸèƒ½æ˜¯è®©ä»¥å¤ªåŠèŠ‚ç‚¹ï¼ˆå®¹å™¨ï¼‰è‡ªåŠ¨åˆå§‹åŒ–ä»¥å¤ªåŠç½‘ç»œï¼Œå¹¶ä¸”æ¥å—ä¸€ä¸ªè‡ªåŠ¨è¿è¡Œè„šæœ¬ä½œä¸ºè¾“å…¥ã€‚</p></blockquote><h3 id="åˆ›å»ºè‡ªåŠ¨è¿è¡Œè„šæœ¬"><a href="#åˆ›å»ºè‡ªåŠ¨è¿è¡Œè„šæœ¬" class="headerlink" title="åˆ›å»ºè‡ªåŠ¨è¿è¡Œè„šæœ¬"></a>åˆ›å»ºè‡ªåŠ¨è¿è¡Œè„šæœ¬</h3><p>åˆ›å»ºä¸€ä¸ªæ–‡ä»¶ï¼š</p><pre><code class="bash">vi /opt/docker-project/eth/workspace/dapp/mine.sh</code></pre><p>å†…å®¹å¦‚ä¸‹ï¼š</p><pre><code class="bash">#!/bin/shaccount='b126d89780d2221ceffe5c94efd9ca6a005a9f0c'cp -r /workspace/dapp/miner/data/keystore/* ~/data/keystore/geth -datadir ~/data/ --networkid 88 --rpc --rpcaddr "172.19.0.50" --rpcapi admin,eth,miner,web3,personal,net,txpool --unlock ${account} --etherbase ${account} console</code></pre><ul><li>ç¬¬ä¸€è¡Œå‘½ä»¤æ˜¯å°†åˆšæ‰ç”Ÿæˆçš„è´¦æˆ·ç§é’¥æ–‡ä»¶æ‹·è´åˆ°å®¹å™¨çš„homeç›®å½•ä¸‹ã€‚å› ä¸º/workspaceæ˜¯å®¿ä¸»ç›®å½•æŒ‚è½½çš„ï¼Œå¹¶ä¸æ˜¯linuxæ–‡ä»¶ç³»ç»Ÿï¼Œç›´æ¥å°†datadiræŒ‡å®šåˆ°è¯¥ç›®å½•ä¼šå¯¼è‡´gethæŠ¥é”™ã€‚</li><li>ç¬¬äºŒè¡Œå‘½ä»¤æ˜¯å¯åŠ¨ä»¥å¤ªåŠèŠ‚ç‚¹çš„å‘½ä»¤ã€‚<ul><li>â€“networkid 88æŒ‡å®šäº†networkidï¼Œè¿™ä¸ªå¿…é¡»ä¸genesis.jsonå†…è®¾ç½®ä¿æŒä¸€è‡´</li><li>â€“rpc â€“rpcaddr â€œ172.19.0.50â€ â€“rpcapi â€¦. è¿™äº›å‚æ•°è¡¨ç¤ºè¯¥èŠ‚ç‚¹æ¥å—rpcï¼Œå¹¶ä¸”æŒ‡å®šäº†rpcçš„åè®®</li><li>â€“unlock â€œ0xâ€¦â€ åŠ å…¥è¯¥å‚æ•°ä¼šéœ€è¦ç”¨æˆ·è¾“å…¥è´¦æˆ·å¯†ç ã€‚å¯†ç æ ¡éªŒåä¼šè§£é”è¯¥è´¦æˆ·ã€‚è´¦æˆ·è§£é”åï¼Œè¯¥èŠ‚ç‚¹å°±èƒ½ä½¿ç”¨æ­¤è´¦æˆ·çš„ç§é’¥è¿›è¡Œç­¾ååŠ å¯†ç­‰åŠ¨ä½œï¼Œç”¨ä»¥è¿›è¡Œäº¤æ˜“ã€å‘å¸ƒåˆçº¦ç­‰ã€‚</li><li>â€“etherbase å‚æ•°æŒ‡å®šäº†æŒ–çŸ¿æ”¶ç›Šè´¦æˆ·</li></ul></li></ul><h3 id="åˆ›å»ºå®¹å™¨"><a href="#åˆ›å»ºå®¹å™¨" class="headerlink" title="åˆ›å»ºå®¹å™¨"></a>åˆ›å»ºå®¹å™¨</h3><pre><code class="bash">chmod +x /opt/docker-project/eth/workspace/dapp/init.shchmod +x /opt/docker-project/eth/workspace/dapp/mine.shdocker run -it --name=miner --network ethnet --ip 172.19.0.50 --hostname node -v /opt/docker-project/eth/workspace:/workspace --entrypoint /workspace/dapp/init.sh ethereum/client-go:v1.8.12 /workspace/dapp/mine.sh</code></pre><blockquote><p>è¯¥å‘½ä»¤ä¼šåˆ›å»ºä¸€ä¸ªæŒä¹…åŒ–çš„å®¹å™¨ã€‚å®¹å™¨çš„entrypointå’Œè‡ªåŠ¨è¿è¡Œè„šæœ¬æŒ‡å®šä¸ºæˆ‘ä»¬åˆšåˆ›å»ºçš„é‚£ä¸¤ä¸ªè„šæœ¬ã€‚</p></blockquote><p>å¦‚æœæŠ¥é”™ï¼š</p><pre><code class="bash">Fatal: Failed to unlock account (no key for given address or file)</code></pre><p>å¯èƒ½åŸå› æ˜¯æ²¡æœ‰ä¿®æ”¹ä¸Šé¢çš„mine.shè„šæœ¬çš„accountå‚æ•°ä¸ºç¬¬ä¸€ä¸ªè´¦æˆ·åœ°å€</p><h2 id="åˆ›å»ºâ€œä»â€çŸ¿å·¥èŠ‚ç‚¹"><a href="#åˆ›å»ºâ€œä»â€çŸ¿å·¥èŠ‚ç‚¹" class="headerlink" title="åˆ›å»ºâ€œä»â€çŸ¿å·¥èŠ‚ç‚¹"></a>åˆ›å»ºâ€œä»â€çŸ¿å·¥èŠ‚ç‚¹</h2><p>åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„ç½‘ç»œï¼Œæ€ä¹ˆçœ‹éƒ½ä¸åƒâ€œåˆ†å¸ƒå¼â€ç½‘ç»œã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦åˆ›å»ºæ›´å¤šçš„èŠ‚ç‚¹æ¥å½¢æˆä¸€ä¸ªâ€œåˆ†å¸ƒå¼ç½‘ç»œâ€ã€‚æˆ‘ä»¬ç§°è¿™äº›èŠ‚ç‚¹å«åšâ€œä»â€çŸ¿å·¥ã€‚<br> è¿™ç±»çŸ¿å·¥ä¸éœ€è¦äº¤æ˜“ï¼Œä¸éœ€è¦å‘å¸ƒåˆçº¦ï¼Œå› æ­¤ä¸éœ€è¦unlockè´¦æˆ·ï¼Œä¹Ÿä¸éœ€è¦æ¥å—rpcã€‚å®ƒä»¬åªçŸ¥é“åŸ‹å¤´æŒ–çŸ¿ã€‚</p><h3 id="åˆ›å»ºè‡ªåŠ¨è¿è¡Œè„šæœ¬-1"><a href="#åˆ›å»ºè‡ªåŠ¨è¿è¡Œè„šæœ¬-1" class="headerlink" title="åˆ›å»ºè‡ªåŠ¨è¿è¡Œè„šæœ¬"></a>åˆ›å»ºè‡ªåŠ¨è¿è¡Œè„šæœ¬</h3><p>â€œä»â€çŸ¿å·¥èŠ‚ç‚¹å’Œâ€œä¸»â€çŸ¿å·¥èŠ‚ç‚¹å…±äº«entrypointï¼Œä»¥ä¿è¯å®ƒä»¬åˆ›å»ºå‡ºå®Œå…¨ç›¸åŒçš„ç½‘ç»œã€‚<br> åªæœ‰è‡ªåŠ¨è¿è¡Œè„šæœ¬ä¸å¤ªä¸€æ ·ï¼Œ</p><pre><code class="bash">vi /opt/docker-project/eth/workspace/dapp/node.sh</code></pre><p>æ–‡ä»¶å†…å®¹ï¼š</p><pre><code class="bash">#!/bin/shcp -r /workspace/dapp/miner/data/keystore/* ~/data/keystore/geth -datadir ~/data/ --networkid 88 console </code></pre><p>åˆ›å»ºå®¹å™¨:</p><pre><code class="bash">chmod +x /opt/docker-project/eth/workspace/dapp/node.shdocker run -it --name=node1 --network ethnet --ip 172.19.0.51 --hostname node1 -v /opt/docker-project/eth/workspace:/workspace --entrypoint /workspace/dapp/init.sh ethereum/client-go:v1.8.12 /workspace/dapp/node.sh</code></pre><h1 id="æ“ä½œèŠ‚ç‚¹"><a href="#æ“ä½œèŠ‚ç‚¹" class="headerlink" title="æ“ä½œèŠ‚ç‚¹"></a>æ“ä½œèŠ‚ç‚¹</h1><p>ä»¥ä¸Šåˆ›å»ºå‡ºäº†å¤šä¸ªä»¥å¤ªåŠèŠ‚ç‚¹ï¼Œè¿è¡Œåœ¨åŒä¸€ç½‘ç»œä¸‹ã€‚æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥æ‰§è¡Œå¦‚ä¸‹æ“ä½œã€‚ä¾›å‚è€ƒã€‚</p><h2 id="èŠ‚ç‚¹å‘ç°"><a href="#èŠ‚ç‚¹å‘ç°" class="headerlink" title="èŠ‚ç‚¹å‘ç°"></a>èŠ‚ç‚¹å‘ç°</h2><h3 id="æŸ¥çœ‹èŠ‚ç‚¹ä¿¡æ¯"><a href="#æŸ¥çœ‹èŠ‚ç‚¹ä¿¡æ¯" class="headerlink" title="æŸ¥çœ‹èŠ‚ç‚¹ä¿¡æ¯"></a>æŸ¥çœ‹èŠ‚ç‚¹ä¿¡æ¯</h3><pre><code class="bash">geth -datadir ~/data/ --networkid 88 console&gt;admin.nodeInfo.enode# è¾“å‡º"enode://708b66364c83af2d3725c309f2bdc0e7d4e395c6ac7310e1a1147b9dfe084649e6c6a3ce6c483c51ab6e924f6abade647246c2b57ecc49d9a573cea896cdf0e6@[::]:30303"</code></pre><h3 id="é…ç½®é™æ€èŠ‚ç‚¹æ–‡ä»¶"><a href="#é…ç½®é™æ€èŠ‚ç‚¹æ–‡ä»¶" class="headerlink" title="é…ç½®é™æ€èŠ‚ç‚¹æ–‡ä»¶"></a>é…ç½®é™æ€èŠ‚ç‚¹æ–‡ä»¶</h3><p>~/data/geth/static-nodes.json</p><pre><code class="json">[    "enode://&lt;node public key&gt;@&lt;node IP address&gt;:&lt;node port&gt;"]</code></pre><h3 id="æŸ¥çœ‹è¿æ¥ä¸Šçš„èŠ‚ç‚¹"><a href="#æŸ¥çœ‹è¿æ¥ä¸Šçš„èŠ‚ç‚¹" class="headerlink" title="æŸ¥çœ‹è¿æ¥ä¸Šçš„èŠ‚ç‚¹"></a>æŸ¥çœ‹è¿æ¥ä¸Šçš„èŠ‚ç‚¹</h3><pre><code class="bash">geth -datadir ~/data/ --networkid 88 console&gt;admin.peers</code></pre><h3 id="åŠ¨æ€æ·»åŠ èŠ‚ç‚¹"><a href="#åŠ¨æ€æ·»åŠ èŠ‚ç‚¹" class="headerlink" title="åŠ¨æ€æ·»åŠ èŠ‚ç‚¹"></a>åŠ¨æ€æ·»åŠ èŠ‚ç‚¹</h3><pre><code class="bash">&gt;admin.addPeer("enode://&lt;node public key&gt;@&lt;node IP address&gt;:&lt;node port&gt;")</code></pre><h2 id="æŒ–çŸ¿-1"><a href="#æŒ–çŸ¿-1" class="headerlink" title="æŒ–çŸ¿"></a>æŒ–çŸ¿</h2><p>å¯åŠ¨minerå®¹å™¨</p><pre><code class="bash">&gt;miner.start(1)</code></pre><ul><li>å‚æ•°1æŒ‡å®šäº†æŒ–çŸ¿çš„çº¿ç¨‹æ•°ã€‚</li><li>é¦–æ¬¡å¯åŠ¨èŠ‚ç‚¹ä¼šæ¶ˆè€—å¤§çº¦20~30åˆ†é’Ÿäº§ç”ŸDAG</li><li>æŸå¼€å§‹æŒ–çŸ¿åï¼Œå…¶å®ƒèŠ‚ç‚¹å°†ä¼šæ”¶åˆ°æ–°åŒºå—å¹¶æ‰“å°</li></ul><h1 id="éƒ¨ç½²åˆçº¦"><a href="#éƒ¨ç½²åˆçº¦" class="headerlink" title="éƒ¨ç½²åˆçº¦"></a>éƒ¨ç½²åˆçº¦</h1><h2 id="åˆ›å»ºtruffleé•œåƒ"><a href="#åˆ›å»ºtruffleé•œåƒ" class="headerlink" title="åˆ›å»ºtruffleé•œåƒ"></a>åˆ›å»ºtruffleé•œåƒ</h2><p>ç”±äºæ²¡æœ‰æ‰¾åˆ°å¥½ç”¨çš„truffleé•œåƒï¼Œæˆ‘è‡ªå·±åˆ›å»ºäº†ä¸€ä¸ªã€‚Dockerfileå†…å®¹å¦‚ä¸‹ï¼š</p><pre><code class="ruby">FROM alpine:3.8MAINTAINER Cary Tan hbuzzs@163.comENV PS1='[truffle@docker $PWD]\$ 'RUN echo "http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.8/main" &gt; /etc/apk/repositories \      &amp;&amp; echo "http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.8/community" &gt;&gt; /etc/apk/repositories \      &amp;&amp; apk update \          &amp;&amp; apk add curl \      &amp;&amp; apk add npm \      &amp;&amp; apk add git \      &amp;&amp; mkdir -p /workspace \      &amp;&amp; npm config set registry https://registry.npm.taobao.org \      &amp;&amp; npm install -g truffleWORKDIR /workspaceCMD /bin/sh</code></pre><p>ä¹Ÿå¯ä½¿ç”¨ä»–äººä¸Šä¼ çš„é•œåƒï¼š</p><pre><code class="bash">docker pull txcary/truffle:180806# è¿™ä¸ªé•œåƒæ²¡æœ‰curl éœ€è¦å®‰è£…apk add curl</code></pre><h2 id="æ–°å»ºtruffleå·¥ç¨‹"><a href="#æ–°å»ºtruffleå·¥ç¨‹" class="headerlink" title="æ–°å»ºtruffleå·¥ç¨‹"></a>æ–°å»ºtruffleå·¥ç¨‹</h2><pre><code class="bash">mkdir -p /opt/docker-project/truffle/workspace/VanTokencd /opt/docker-project/truffle/workspace/VanTokengit clone https://github.com/trufflesuite/truffle-init-bare.git</code></pre><h2 id="å¯åŠ¨truffleå®¹å™¨"><a href="#å¯åŠ¨truffleå®¹å™¨" class="headerlink" title="å¯åŠ¨truffleå®¹å™¨"></a>å¯åŠ¨truffleå®¹å™¨</h2><pre><code class="bash">docker run -it --rm -v /opt/docker-project/truffle/workspace:/workspace --network ethnet txcary/truffle:180806</code></pre><h3 id="æµ‹è¯•èŠ‚ç‚¹RPC"><a href="#æµ‹è¯•èŠ‚ç‚¹RPC" class="headerlink" title="æµ‹è¯•èŠ‚ç‚¹RPC"></a>æµ‹è¯•èŠ‚ç‚¹RPC</h3><pre><code class="bash">curl 172.19.0.50:8545 -X POST --data '{"id":1,"jsonrpc":"2.0","method":"eth_accounts", "params":[]}' -H "Content-Type: application/json"curl 172.19.0.50:8545 -X POST --data '{"id":1,"jsonrpc":"2.0","method":"eth_getBalance", "params":["0x4c283287839fd441b8c8d18771321bc06a81edae","latest"]}' -H "Content-Type: application/json"</code></pre><ul><li>ç¬¬ä¸€æ¡å‘½ä»¤è·å–èŠ‚ç‚¹ä¸Šçš„è´¦æˆ·</li><li>ç¬¬äºŒæ¡å‘½ä»¤è·å–è´¦æˆ·ä½™é¢</li><li>å¦‚æœè¿™ä¸¤æ¡å‘½ä»¤æˆåŠŸäº†ï¼Œè¯´æ˜ä»¥å¤ªåŠç§æœ‰ç½‘ç»œæ­å»ºæˆåŠŸï¼Œå¹¶ä¸”èŠ‚ç‚¹rpcè°ƒç”¨æˆåŠŸ</li></ul><h3 id="ä¿®æ”¹truffle-js"><a href="#ä¿®æ”¹truffle-js" class="headerlink" title="ä¿®æ”¹truffle.js"></a>ä¿®æ”¹truffle.js</h3><pre><code class="javascript">module.exports = {        networks: {            development: {                host: "172.19.0.50",                port: 8545,                network_id: 88,                gas: 2900000,                gasPrice: 10000000000            }        }};</code></pre><ul><li>gasä½¿ç”¨é»˜è®¤å€¼ä¼šå¯¼è‡´è¶…é™é”™è¯¯ï¼Œç ”ç©¶åŠå¤©ä¸çŸ¥é“ä¸ºä»€ä¹ˆã€‚è¦æ˜¯ææ˜ç™½çš„å¯ä»¥ç»™æˆ‘ç•™è¨€ï¼Œè°¢è°¢ï¼</li><li>gasPriceä¸ºé»˜è®¤å€¼</li></ul><h2 id="ç¼–å†™åˆçº¦Migrations-solï¼ˆtruffleå†…ç½®ï¼‰"><a href="#ç¼–å†™åˆçº¦Migrations-solï¼ˆtruffleå†…ç½®ï¼‰" class="headerlink" title="ç¼–å†™åˆçº¦Migrations.solï¼ˆtruffleå†…ç½®ï¼‰"></a>ç¼–å†™åˆçº¦Migrations.solï¼ˆtruffleå†…ç½®ï¼‰</h2><pre><code class="solidity">pragma solidity &gt;=0.4.22 &lt;0.6.0;contract Migrations {    address public owner;    uint public lastCompletedMigration;    modifier restricted() {        if (msg.sender == owner) _;    }    constructor() public {        owner = msg.sender;    }    function setCompleted(uint completed) public restricted {        lastCompletedMigration = completed;    }    function upgrade(address newAddress) public restricted {        Migrations upgraded = Migrations(newAddress);        upgraded.setCompleted(lastCompletedMigration);    }}</code></pre><h2 id="æ–°å»ºéƒ¨ç½²è„šæœ¬"><a href="#æ–°å»ºéƒ¨ç½²è„šæœ¬" class="headerlink" title="æ–°å»ºéƒ¨ç½²è„šæœ¬"></a>æ–°å»ºéƒ¨ç½²è„šæœ¬</h2><p>deploy_contracts.js</p><pre><code class="javascript">var contractsName = artifacts.require("./Storage.sol");module.exports = function(deployer) {  deployer.deploy(contractsName);};</code></pre><h2 id="ç¼–è¯‘åˆçº¦"><a href="#ç¼–è¯‘åˆçº¦" class="headerlink" title="ç¼–è¯‘åˆçº¦"></a>ç¼–è¯‘åˆçº¦</h2><pre><code class="bash">truffle compile</code></pre><h2 id="éƒ¨ç½²åˆçº¦-1"><a href="#éƒ¨ç½²åˆçº¦-1" class="headerlink" title="éƒ¨ç½²åˆçº¦"></a>éƒ¨ç½²åˆçº¦</h2><pre><code class="bash">truffle migrate --network development --verbose-rpc</code></pre><p>éƒ¨ç½²æˆåŠŸ</p><p><img src="/images/eth_network_set_up/image-20220204103544178.png" alt="image-20220204103544178"></p><h1 id="å‚è€ƒé“¾æ¥ï¼š"><a href="#å‚è€ƒé“¾æ¥ï¼š" class="headerlink" title="å‚è€ƒé“¾æ¥ï¼š"></a>å‚è€ƒé“¾æ¥ï¼š</h1><ul><li><a href="https://www.jianshu.com/p/7994db7a2b89?from=singlemessage">https://www.jianshu.com/p/7994db7a2b89?from=singlemessage</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> éƒ¨ç½²æ–‡æ¡£ </tag>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>æ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æ</title>
      <link href="/2022/01/18/data_struct_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/18/data_struct_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="æ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æ"><a href="#æ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æ" class="headerlink" title="æ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æ"></a>æ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æ</h1><h1 id="ç›®æ ‡"><a href="#ç›®æ ‡" class="headerlink" title="ç›®æ ‡"></a>ç›®æ ‡</h1><ul><li>äº†è§£ç®—æ³•åˆ†ææ–¹æ³•ï¼ˆç¬¬äºŒç« -13ï¼‰</li><li>ç²¾é€šè¡¨ã€æ ˆå’Œé˜Ÿåˆ—ï¼ˆç¬¬ä¸‰ç« -27ï¼‰ã€æ ‘ï¼ˆç¬¬å››ç« -40ï¼‰ã€æ•£åˆ—ï¼ˆç¬¬äº”ç« -36ï¼‰ã€ä¼˜å…ˆé˜Ÿåˆ—ã€å †ï¼ˆç¬¬å…­ç« -28ï¼‰ã€æ’åºï¼ˆç¬¬ä¸ƒç« -50ï¼‰ã€ä¸ç›¸äº¤é›†ç±»ï¼ˆç¬¬å…«ç« -17ï¼‰</li><li>ç²¾é€šå›¾è®ºï¼ˆç¬¬ä¹ç« -38ï¼‰ã€ç®—æ³•è®¾è®¡æŠ€å·§ï¼ˆç¬¬åç« -50ï¼‰ã€çº¢é»‘æ ‘ï¼ˆç¬¬åäºŒç« ç¬¬äºŒèŠ‚-5ï¼‰</li></ul><h1 id="ç¬¬-2-ç« -ç®—æ³•åˆ†ææ–¹æ³•"><a href="#ç¬¬-2-ç« -ç®—æ³•åˆ†ææ–¹æ³•" class="headerlink" title="ç¬¬ 2 ç«  ç®—æ³•åˆ†ææ–¹æ³•"></a>ç¬¬ 2 ç«  ç®—æ³•åˆ†ææ–¹æ³•</h1><h2 id="2-4-è¿è¡Œæ—¶é—´è®¡ç®—"><a href="#2-4-è¿è¡Œæ—¶é—´è®¡ç®—" class="headerlink" title="2.4 è¿è¡Œæ—¶é—´è®¡ç®—"></a>2.4 è¿è¡Œæ—¶é—´è®¡ç®—</h2><h3 id="2-4-1-ä¸€èˆ¬æ³•åˆ™"><a href="#2-4-1-ä¸€èˆ¬æ³•åˆ™" class="headerlink" title="2.4.1 ä¸€èˆ¬æ³•åˆ™"></a>2.4.1 ä¸€èˆ¬æ³•åˆ™</h3><ol><li>æ³•åˆ™1 â€”â€” forå¾ªç¯</li></ol><p>ä¸€ä¸ªforå¾ªç¯çš„è¿è¡Œæ—¶é—´è‡³å¤šæ˜¯è¯¥forå¾ªç¯å†…éƒ¨é‚£äº›è¯­å¥ï¼ˆåŒ…æ‹¬æµ‹è¯•ï¼‰çš„è¿è¡Œæ—¶é—´ä¹˜ä»¥è¿­ä»£çš„æ¬¡æ•°</p><ol><li>æ³•åˆ™2 â€”â€” åµŒå¥—çš„forå¾ªç¯</li></ol><p>åœ¨ä¸€ç»„åµŒå¥—å¾ªç¯å†…éƒ¨çš„ä¸€æ¡è¯­å¥çš„è¿è¡Œæ—¶é—´ä¸ºè¯¥è¯­å¥çš„è¿è¡Œæ—¶é—´ä¹˜ä»¥è¯¥ç»„æ‰€æœ‰çš„forå¾ªç¯çš„å¤§å°çš„ä¹˜ç§¯</p><ol><li>æ³•åˆ™3 â€”â€” é¡ºåºè¯­å¥</li></ol><p>å°†å„ä¸ªè¯­å¥çš„è¿è¡Œæ—¶é—´æ±‚å’Œå³å¯ã€‚è¿™æ„å‘³ç€å…¶ä¸­çš„æœ€å¤§å€¼å°±æ˜¯æ‰€å¾—çš„è¿è¡Œæ—¶é—´ã€‚</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled.png" alt="Untitled"></p><ol><li>æ³•åˆ™4 â€”â€” if/elseè¯­å¥</li></ol><p>ä¸€ä¸ªif/elseè¯­å¥çš„è¿è¡Œæ—¶é—´ä»ä¸è¶…è¿‡åˆ¤æ–­çš„è¿è¡Œæ—¶é—´å†åŠ ä¸ŠS1å’ŒS2ä¸­è¿è¡Œæ—¶é—´é•¿è€…çš„æ€»çš„è¿è¡Œæ—¶é—´ã€‚</p><h1 id="ç¬¬-3-ç« -è¡¨ã€æ ˆå’Œé˜Ÿåˆ—"><a href="#ç¬¬-3-ç« -è¡¨ã€æ ˆå’Œé˜Ÿåˆ—" class="headerlink" title="ç¬¬ 3 ç«  è¡¨ã€æ ˆå’Œé˜Ÿåˆ—"></a>ç¬¬ 3 ç«  è¡¨ã€æ ˆå’Œé˜Ÿåˆ—</h1><h2 id="3-1-æŠ½è±¡æ•°æ®ç±»å‹"><a href="#3-1-æŠ½è±¡æ•°æ®ç±»å‹" class="headerlink" title="3.1 æŠ½è±¡æ•°æ®ç±»å‹"></a>3.1 æŠ½è±¡æ•°æ®ç±»å‹</h2><p>æŠ½è±¡æ•°æ®ç±»å‹ï¼ˆADTï¼‰æ˜¯å¸¦æœ‰ä¸€ç»„æ“ä½œçš„ä¸€äº›å¯¹è±¡çš„é›†åˆã€‚</p><h2 id="3-2-è¡¨ADT"><a href="#3-2-è¡¨ADT" class="headerlink" title="3.2 è¡¨ADT"></a>3.2 è¡¨ADT</h2><p>æˆ‘ä»¬ç§°å½¢å¦‚$A_0$$,A_1,A_2,â€¦,A_{N-1}$çš„ä¸ºè¡¨ï¼Œè¯¥è¡¨å¤§å°ä¸ºN</p><h3 id="3-2-1-è¡¨çš„ç®€å•æ•°ç»„å®ç°"><a href="#3-2-1-è¡¨çš„ç®€å•æ•°ç»„å®ç°" class="headerlink" title="3.2.1 è¡¨çš„ç®€å•æ•°ç»„å®ç°"></a>3.2.1 è¡¨çš„ç®€å•æ•°ç»„å®ç°</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%201.png" alt="Untitled"></p><h3 id="3-2-2-ç®€å•é“¾è¡¨"><a href="#3-2-2-ç®€å•é“¾è¡¨" class="headerlink" title="3.2.2 ç®€å•é“¾è¡¨"></a>3.2.2 ç®€å•é“¾è¡¨</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%202.png" alt="Untitled"></p><h2 id="3-6-æ ˆADT"><a href="#3-6-æ ˆADT" class="headerlink" title="3.6 æ ˆADT"></a>3.6 æ ˆADT</h2><h3 id="3-6-1-æ ˆæ¨¡å‹"><a href="#3-6-1-æ ˆæ¨¡å‹" class="headerlink" title="3.6.1 æ ˆæ¨¡å‹"></a>3.6.1 æ ˆæ¨¡å‹</h3><p>æ ˆæ˜¯é™åˆ¶æ’å…¥å’Œåˆ é™¤åªèƒ½åœ¨ä¸€ä¸ªä½ç½®ä¸Šè¿›è¡Œçš„è¡¨ï¼Œè¯¥ä½ç½®æ˜¯è¡¨çš„æœ«ç«¯ï¼Œå«åšç«™çš„é¡¶ï¼ˆtopï¼‰ã€‚</p><p>æ ˆçš„åŸºæœ¬æ“ä½œæœ‰pushï¼ˆè¿›æ ˆï¼‰ã€popï¼ˆå‡ºæ ˆï¼‰</p><p>æ ˆæœ‰æ—¶åˆå«LIFOï¼ˆåè¿›å…ˆå‡ºï¼‰è¡¨</p><h3 id="3-6-3-åº”ç”¨"><a href="#3-6-3-åº”ç”¨" class="headerlink" title="3.6.3 åº”ç”¨"></a>3.6.3 åº”ç”¨</h3><ul><li>å¹³è¡¡ç¬¦å·</li><li>åç¼€è¡¨è¾¾å¼</li><li>æ–¹æ³•è°ƒç”¨</li></ul><h2 id="3-7-é˜Ÿåˆ—ADT"><a href="#3-7-é˜Ÿåˆ—ADT" class="headerlink" title="3.7 é˜Ÿåˆ—ADT"></a>3.7 é˜Ÿåˆ—ADT</h2><h3 id="3-7-1-é˜Ÿåˆ—æ¨¡å‹"><a href="#3-7-1-é˜Ÿåˆ—æ¨¡å‹" class="headerlink" title="3.7.1 é˜Ÿåˆ—æ¨¡å‹"></a>3.7.1 é˜Ÿåˆ—æ¨¡å‹</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%203.png" alt="Untitled"></p><h1 id="ç¬¬-4-ç« -æ ‘"><a href="#ç¬¬-4-ç« -æ ‘" class="headerlink" title="ç¬¬ 4 ç«  æ ‘"></a>ç¬¬ 4 ç«  æ ‘</h1><h2 id="4-1-é¢„å¤‡çŸ¥è¯†"><a href="#4-1-é¢„å¤‡çŸ¥è¯†" class="headerlink" title="4.1 é¢„å¤‡çŸ¥è¯†"></a>4.1 é¢„å¤‡çŸ¥è¯†</h2><h2 id="4-2-äºŒå‰æ ‘"><a href="#4-2-äºŒå‰æ ‘" class="headerlink" title="4.2 äºŒå‰æ ‘"></a>4.2 äºŒå‰æ ‘</h2><h2 id="4-3-æŸ¥æ‰¾æ ‘ADT-â€”â€”-äºŒå‰æŸ¥æ‰¾æ ‘"><a href="#4-3-æŸ¥æ‰¾æ ‘ADT-â€”â€”-äºŒå‰æŸ¥æ‰¾æ ‘" class="headerlink" title="4.3 æŸ¥æ‰¾æ ‘ADT â€”â€”  äºŒå‰æŸ¥æ‰¾æ ‘"></a>4.3 æŸ¥æ‰¾æ ‘ADT â€”â€”  äºŒå‰æŸ¥æ‰¾æ ‘</h2><h2 id="4-4-AVLæ ‘"><a href="#4-4-AVLæ ‘" class="headerlink" title="4.4 AVLæ ‘"></a>4.4 AVLæ ‘</h2><p>AVLæ ‘æ˜¯å¸¦æœ‰å¹³è¡¡æ¡ä»¶çš„äºŒå‰æŸ¥æ‰¾æ ‘</p><p>ç‰¹ç‚¹ï¼š</p><ul><li>æœ¬èº«é¦–å…ˆæ˜¯ä¸€æ£µäºŒå‰æœç´¢æ ‘ã€‚</li><li>æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„é«˜åº¦ä¹‹å·®çš„ç»å¯¹å€¼ï¼ˆå¹³è¡¡å› å­ï¼‰æœ€å¤šä¸º1</li></ul><h3 id="4-4-1-å•æ—‹è½¬"><a href="#4-4-1-å•æ—‹è½¬" class="headerlink" title="4.4.1 å•æ—‹è½¬"></a>4.4.1 å•æ—‹è½¬</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%204.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%205.png" alt="Untitled"></p><h3 id="4-4-2-åŒæ—‹è½¬"><a href="#4-4-2-åŒæ—‹è½¬" class="headerlink" title="4.4.2 åŒæ—‹è½¬"></a>4.4.2 åŒæ—‹è½¬</h3><h2 id="4-5-ä¼¸å±•æ ‘"><a href="#4-5-ä¼¸å±•æ ‘" class="headerlink" title="4.5 ä¼¸å±•æ ‘"></a>4.5 ä¼¸å±•æ ‘</h2><p>ä¼¸å±•æ ‘ä¿è¯ä»ç©ºæ ‘å¼€å§‹è¿ç»­Mæ¬¡å¯¹æ ‘çš„æ“ä½œæœ€å¤šèŠ±è´¹*O(M log N)*æ—¶é—´</p><p>ä¼¸å±•æ ‘åŸºäºè¿™æ ·çš„äº‹å®ï¼šå¯¹äºäºŒå‰æŸ¥æ‰¾æ ‘æ¥è¯´ï¼Œæ¯æ¬¡æ“ä½œæœ€åæƒ…å½¢æ—¶é—´*O(N)*å¹¶ä¸åï¼Œåªè¦å®ƒç›¸å¯¹ä¸å¸¸å‘ç”Ÿå°±è¡Œã€‚</p><h2 id="4-6-æ ‘çš„éå†"><a href="#4-6-æ ‘çš„éå†" class="headerlink" title="4.6 æ ‘çš„éå†"></a>4.6 æ ‘çš„éå†</h2><ul><li>å…ˆåºéå†</li><li>ä¸­åºéå†</li><li>ååºéå†</li><li>å±‚åºéå†</li></ul><h2 id="4-7-B-æ ‘"><a href="#4-7-B-æ ‘" class="headerlink" title="4.7 B+æ ‘**"></a>4.7 B+æ ‘**</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%206.png" alt="Untitled"></p><p>é˜¶ä¸ºMçš„B+æ ‘çš„ç‰¹æ€§ï¼š</p><ul><li>æ•°æ®é¡¹å­˜å‚¨åœ¨æ ‘å¶ä¸Š</li><li>éå¶å­èŠ‚ç‚¹å­˜å‚¨ç›´åˆ°M-1ä¸ªå…³é”®å­—ä»¥æŒ‡ç¤ºæœç´¢çš„æ–¹å‘ï¼›å…³é”®å­—iä»£è¡¨å­æ ‘i+1ä¸­çš„æœ€å°çš„å…³é”®å­—</li><li>æ ‘çš„æ ¹æˆ–è€…æ˜¯ä¸€ç‰‡æ ‘å¶ï¼Œæˆ–è€…å…¶å„¿å­æ•°åœ¨2å’ŒMä¹‹é—´</li><li>é™¤æ ¹å¤–ï¼Œæ‰€æœ‰éæ ‘å¶èŠ‚ç‚¹çš„å„¿å­æ•°åœ¨<code>âŒˆM/2âŒ‰</code>å’Œ<code>M</code>ä¹‹é—´</li><li>æ‰€æœ‰çš„æ ‘å¶éƒ½åœ¨ç›¸åŒçš„æ·±åº¦ä¸Šå¹¶æœ‰<code>âŒˆL/2âŒ‰</code>å’Œ<code>L</code> ä¹‹é—´ä¸ªæ•°æ®é¡¹</li></ul><p>Bæ ‘ä¸B+æ ‘ä¸åŒç‚¹ï¼š</p><ul><li>å•ä¸€èŠ‚ç‚¹å­˜å‚¨çš„å…ƒç´ æ›´å¤šï¼Œä½¿å¾—æŸ¥è¯¢çš„IOæ¬¡æ•°æ›´å°‘ï¼Œæ‰€ä»¥ä¹Ÿå°±ä½¿å¾—å®ƒæ›´é€‚åˆåšä¸ºæ•°æ®åº“MySQLçš„åº•å±‚æ•°æ®ç»“æ„äº†ã€‚</li><li>æ‰€æœ‰çš„æŸ¥è¯¢éƒ½è¦æŸ¥æ‰¾åˆ°å¶å­èŠ‚ç‚¹ï¼ŒæŸ¥è¯¢æ€§èƒ½æ˜¯ç¨³å®šçš„ï¼Œè€ŒBæ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥æŸ¥æ‰¾åˆ°æ•°æ®ï¼Œæ‰€ä»¥ä¸ç¨³å®šã€‚</li><li>æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹å½¢æˆäº†ä¸€ä¸ªæœ‰åºé“¾è¡¨ï¼Œæ›´åŠ ä¾¿äºæŸ¥æ‰¾ã€‚</li></ul><h1 id="ç¬¬-5-ç« -æ•£åˆ—"><a href="#ç¬¬-5-ç« -æ•£åˆ—" class="headerlink" title="ç¬¬ 5 ç«  æ•£åˆ—"></a>ç¬¬ 5 ç«  æ•£åˆ—</h1><h2 id="5-1-ä¸€èˆ¬æƒ³æ³•"><a href="#5-1-ä¸€èˆ¬æƒ³æ³•" class="headerlink" title="5.1 ä¸€èˆ¬æƒ³æ³•"></a>5.1 ä¸€èˆ¬æƒ³æ³•</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%207.png" alt="Untitled"></p><h2 id="5-2-æ•£åˆ—å‡½æ•°"><a href="#5-2-æ•£åˆ—å‡½æ•°" class="headerlink" title="5.2 æ•£åˆ—å‡½æ•°"></a>5.2 æ•£åˆ—å‡½æ•°</h2><p>å¦‚æœå…³é”®å­—æ˜¯æ•´æ•°ä¸€èˆ¬åˆç†çš„æ–¹æ³•å°±æ˜¯ç›´æ¥è¿”å›<em>key mod Tablesize</em></p><p>å¦‚æœå…³é”®å­—æ˜¯å­—ç¬¦ä¸²ï¼Œ</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%208.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%209.png" alt="Untitled"></p><h2 id="5-3-åˆ†ç¦»é“¾æ¥æ³•"><a href="#5-3-åˆ†ç¦»é“¾æ¥æ³•" class="headerlink" title="5.3 åˆ†ç¦»é“¾æ¥æ³•"></a>5.3 åˆ†ç¦»é“¾æ¥æ³•</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2010.png" alt="Untitled"></p><p>åˆ†ç¦»é“¾æ¥æ³•ï¼šå…¶åšæ³•æ˜¯å°†æ•£åˆ—åˆ°åŒä¸€ä¸ªå€¼çš„æ‰€æœ‰å…ƒç´ ä¿ç•™åˆ°ä¸€ä¸ªè¡¨ä¸­</p><h2 id="5-4-ä¸åŒé“¾è¡¨çš„æ•£åˆ—è¡¨"><a href="#5-4-ä¸åŒé“¾è¡¨çš„æ•£åˆ—è¡¨" class="headerlink" title="5.4 ä¸åŒé“¾è¡¨çš„æ•£åˆ—è¡¨"></a>5.4 ä¸åŒé“¾è¡¨çš„æ•£åˆ—è¡¨</h2><h3 id="5-4-1-çº¿æ€§æ¢æµ‹æ³•"><a href="#5-4-1-çº¿æ€§æ¢æµ‹æ³•" class="headerlink" title="5.4.1 çº¿æ€§æ¢æµ‹æ³•"></a>5.4.1 çº¿æ€§æ¢æµ‹æ³•</h3><p>åœ¨çº¿æ€§æ¢æµ‹æ³•ä¸­ï¼Œå‡½æ•°fæ˜¯içš„çº¿æ€§å‡½æ•°ï¼Œå…¸å‹æƒ…å½¢æ˜¯$f(i) = i$</p><h3 id="5-4-2-å¹³æ–¹æ¢æµ‹æ³•"><a href="#5-4-2-å¹³æ–¹æ¢æµ‹æ³•" class="headerlink" title="5.4.2 å¹³æ–¹æ¢æµ‹æ³•"></a>5.4.2 å¹³æ–¹æ¢æµ‹æ³•</h3><p>å¹³æ–¹æ¢æµ‹æ˜¯æ¶ˆé™¤çº¿æ€§æ¢æµ‹ä¸­ä¸€æ¬¡èšé›†é—®é¢˜çš„å†²çªè§£å†³æ–¹æ³•ã€‚</p><p>å¹³æ–¹æ¢æµ‹å°±æ˜¯å†²çªå‡½æ•°ä¸ºäºŒæ¬¡çš„æ¢æµ‹æ–¹æ³•ï¼Œæµè¡Œçš„é€‰æ‹©æ˜¯$f(i)=i^2$</p><p>å®šç†ï¼šå¦‚æœä½¿ç”¨å¹³æ–¹æ¢æµ‹ï¼Œä¸”è¡¨çš„å¤§å°æ˜¯ç´ æ•°ï¼Œé‚£ä¹ˆå½“è¡¨è‡³å°‘æœ‰ä¸€åŠæ˜¯ç©ºçš„æ—¶å€™æ€»èƒ½å¤Ÿæ’å…¥ä¸€ä¸ªæ–°å…ƒç´ </p><h3 id="5-4-3-åŒæ•£åˆ—"><a href="#5-4-3-åŒæ•£åˆ—" class="headerlink" title="5.4.3 åŒæ•£åˆ—"></a>5.4.3 åŒæ•£åˆ—</h3><p>å¯¹äºåŒæ•£åˆ—ï¼Œä¸€ç§æµè¡Œçš„é€‰æ‹©æ˜¯$f(i)=i*hash_2(x)$</p><h2 id="5-5-å†æ•£åˆ—"><a href="#5-5-å†æ•£åˆ—" class="headerlink" title="5.5 å†æ•£åˆ—"></a>5.5 å†æ•£åˆ—</h2><p>å»ºç«‹å¦å¤–ä¸€ä¸ªå¤§çº¦ä¸¤å€å¤§çš„è¡¨ï¼ˆè€Œä¸”ä½¿ç”¨ä¸€ä¸ªç›¸å…³çš„æ–°æ•£åˆ—å‡½æ•°ï¼‰ï¼Œæ‰«ææ•´ä¸ªåŸå§‹æ•£åˆ—è¡¨ï¼Œè®¡ç®—æ¯ä¸ªï¼ˆæœªåˆ é™¤çš„ï¼‰å…ƒç´ çš„æ–°æ•£åˆ—å€¼å¹¶å°†å…¶æ’å…¥åˆ°æ–°è¡¨ä¸­</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2011.png" alt="Untitled"></p><h2 id="5-6-æ ‡å‡†åº“ä¸­çš„æ•£åˆ—è¡¨"><a href="#5-6-æ ‡å‡†åº“ä¸­çš„æ•£åˆ—è¡¨" class="headerlink" title="5.6 æ ‡å‡†åº“ä¸­çš„æ•£åˆ—è¡¨"></a>5.6 æ ‡å‡†åº“ä¸­çš„æ•£åˆ—è¡¨</h2><h2 id="5-7-æœ€åæƒ…å½¢ä¸‹O-1-è®¿é—®çš„æ•£åˆ—è¡¨"><a href="#5-7-æœ€åæƒ…å½¢ä¸‹O-1-è®¿é—®çš„æ•£åˆ—è¡¨" class="headerlink" title="5.7 æœ€åæƒ…å½¢ä¸‹O(1)è®¿é—®çš„æ•£åˆ—è¡¨"></a>5.7 æœ€åæƒ…å½¢ä¸‹O(1)è®¿é—®çš„æ•£åˆ—è¡¨</h2><h3 id="5-7-1-å®Œç¾æ•£åˆ—"><a href="#5-7-1-å®Œç¾æ•£åˆ—" class="headerlink" title="5.7.1 å®Œç¾æ•£åˆ—"></a>5.7.1 å®Œç¾æ•£åˆ—</h3><h3 id="5-7-2-å¸ƒè°·é¸Ÿæ•£åˆ—"><a href="#5-7-2-å¸ƒè°·é¸Ÿæ•£åˆ—" class="headerlink" title="5.7.2 å¸ƒè°·é¸Ÿæ•£åˆ—"></a>5.7.2 å¸ƒè°·é¸Ÿæ•£åˆ—</h3><p>åœ¨å¸ƒè°·é¸Ÿæ•£åˆ—ä¸­ï¼Œå‡è®¾æœ‰Nä¸ªé¡¹ã€‚æˆ‘ä»¬ç»´æŠ¤ä¸¤ä¸ªåˆ†åˆ«è¶…è¿‡åŠç©ºçš„è¡¨ï¼Œä¸”æœ‰ä¸¤ä¸ªç‹¬ç«‹çš„æ•£åˆ—å‡½æ•°ï¼Œå¯ä»¥æŠŠæ¯ä¸ªé¡¹åˆ†é…åˆ°æ¯ä¸ªè¡¨ä¸­çš„ä¸€ä¸ªä½ç½®ã€‚å¸ƒè°·é¸Ÿæ•£åˆ—ä¿æŒä¸å˜çš„æ˜¯ä¸€ä¸ªé¡¹æ€»ä¼šè¢«å­˜å‚¨åœ¨è¿™ä¸¤ä¸ªä½ç½®ä¹‹ä¸€ã€‚</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2012.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2013.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2014.png" alt="Untitled"></p><h3 id="5-7-3-è·³æˆ¿å­æ•£åˆ—"><a href="#5-7-3-è·³æˆ¿å­æ•£åˆ—" class="headerlink" title="5.7.3 è·³æˆ¿å­æ•£åˆ—"></a>5.7.3 è·³æˆ¿å­æ•£åˆ—</h3><p>è·³æˆ¿å­æ•£åˆ—çš„æ€è·¯æ˜¯ç”¨äº‹å…ˆç¡®å®šçš„ã€å¯¹è®¡ç®—æœºçš„åº•å±‚ä½“ç³»ç»“æ„è€Œè¨€æ˜¯æœ€ä¼˜çš„ä¸€ä¸ªå¸¸æ•°ï¼Œç»™æ¢æµ‹åºåˆ—çš„æœ€å¤§é•¿åº¦åŠ ä¸ªä¸Šç•Œã€‚è¿™æ ·åšå¯ä»¥ç»™å‡ºå¸¸æ•°é›†çš„æœ€åæŸ¥è¯¢æ—¶é—´ï¼Œå¹¶ä¸”ä¸å¸ƒè°·é¸Ÿæ•£åˆ—ä¸€æ ·ï¼ŒæŸ¥è¯¢å¯ä»¥å¹¶è¡ŒåŒ–ï¼Œä»¥åŒæ—¶æ£€æŸ¥å¯ç”¨ä½ç½®çš„æœ‰é™é›†ã€‚</p><h2 id="5-8-é€šç”¨æ•£åˆ—æ³•"><a href="#5-8-é€šç”¨æ•£åˆ—æ³•" class="headerlink" title="5.8 é€šç”¨æ•£åˆ—æ³•"></a>5.8 é€šç”¨æ•£åˆ—æ³•</h2><h1 id="ç¬¬-6-ç« -ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰"><a href="#ç¬¬-6-ç« -ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰" class="headerlink" title="ç¬¬ 6 ç«  ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰"></a>ç¬¬ 6 ç«  ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰</h1><h2 id="6-1-æ¨¡å‹"><a href="#6-1-æ¨¡å‹" class="headerlink" title="6.1 æ¨¡å‹"></a>6.1 æ¨¡å‹</h2><p>ä¼˜å…ˆé˜Ÿåˆ—æ˜¯å…è®¸è‡³å°‘ä¸‹åˆ—ä¸¤ç§æ“ä½œçš„æ•°æ®ç»“æ„ï¼šæ’å…¥å’Œåˆ é™¤æœ€å°è€…ã€‚</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2015.png" alt="Untitled"></p><h2 id="6-2-ä¸€äº›ç®€å•çš„å®ç°"><a href="#6-2-ä¸€äº›ç®€å•çš„å®ç°" class="headerlink" title="6.2 ä¸€äº›ç®€å•çš„å®ç°"></a>6.2 ä¸€äº›ç®€å•çš„å®ç°</h2><ol><li>ä½¿ç”¨ç®€å•é“¾è¡¨</li><li>ä½¿ç”¨äºŒå‰æŸ¥æ‰¾æ ‘</li></ol><h2 id="6-3-äºŒå‰å †"><a href="#6-3-äºŒå‰å †" class="headerlink" title="6.3 äºŒå‰å †"></a>6.3 äºŒå‰å †</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2016.png" alt="Untitled"></p><h3 id="6-3-1-ç»“æ„æ€§è´¨"><a href="#6-3-1-ç»“æ„æ€§è´¨" class="headerlink" title="6.3.1 ç»“æ„æ€§è´¨"></a>6.3.1 ç»“æ„æ€§è´¨</h3><p>å †æ˜¯ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2017.png" alt="Untitled"></p><ol><li>æ’å…¥</li></ol><p>ä¸ºå°†ä¸€ä¸ªå…ƒç´ Xæ’å…¥åˆ°å †ä¸­ï¼Œæˆ‘ä»¬åœ¨ä¸€ä¸ªå¯ç”¨ä½ç½®åˆ›å»ºä¸€ä¸ªç©ºç©´ï¼Œå¦åˆ™è¯¥å †å°†ä¸æ˜¯å®Œå…¨ç†Ÿï¼Œå¦‚æœå¯ä»¥æ”¾åœ¨è¯¥ç©ºç©´ä¸­è€Œä¸ç ´åå †çš„åºï¼Œé‚£ä¹ˆæ’å…¥å®Œæˆã€‚å¦åˆ™æˆ‘ä»¬æŠŠç©ºç©´çš„çˆ¶èŠ‚ç‚¹ä¸Šçš„å…ƒç´ ç§»å…¥è¯¥ç©ºç©´ä¸­ï¼Œè¿™æ ·ç©ºç©´å°±æœç€æ ¹çš„æ–¹å‘ä¸Šå†’ä¸€æ­¥ã€‚ç»§ç»­è¯¥è¿‡ç¨‹ç›´åˆ°Xèƒ½è¢«æ”¾å…¥ç©ºç©´ä¸­ä¸ºæ­¢ã€‚</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2018.png" alt="Untitled"></p><ol><li>åˆ é™¤æœ€å°å…ƒ</li></ol><p>åˆ é™¤æœ€å°å…ƒä»¥ç±»ä¼¼äºæ’å…¥çš„æ–¹å¼å¤„ç†ã€‚å½“åˆ é™¤ä¸€ä¸ªæœ€å°å…ƒæ—¶ï¼Œè¦åœ¨è·ŸèŠ‚ç‚¹å»ºç«‹ä¸€ä¸ªç©ºç©´ã€‚ç”±äºç°åœ¨å †å°‘äº†ä¸€ä¸ªå…ƒç´ ï¼Œå› æ­¤å †ä¸­æœ€åä¸€ä¸ªå…ƒç´ Xå¿…é¡»ç§»åŠ¨åˆ°è¯¥å †çš„æŸä¸ªåœ°æ–¹ã€‚å¦‚æœXå¯ä»¥è¢«æ”¾å€’ç©ºç©´ä¸­ï¼Œé‚£ä¹ˆdeleteMinå®Œæˆï¼Œå¦åˆ™æˆ‘ä»¬å°†ç©ºç©´çš„ä¸¤ä¸ªå„¿å­ä¸­è¾ƒå°è€…ç§»å…¥ç©ºç©´ï¼Œè¿™æ ·å°±æŠŠç©ºç©´å‘ä¸‹æ¨äº†ä¸€å±‚ï¼Œé‡å¤è¯¥æ­¥éª¤ç›´åˆ°Xå¯ä»¥è¢«æ”¾å…¥ç©ºç©´ä¸­ã€‚</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2019.png" alt="Untitled"></p><h2 id="6-4-ä¼˜å…ˆé˜Ÿåˆ—çš„åº”ç”¨"><a href="#6-4-ä¼˜å…ˆé˜Ÿåˆ—çš„åº”ç”¨" class="headerlink" title="6.4 ä¼˜å…ˆé˜Ÿåˆ—çš„åº”ç”¨"></a>6.4 ä¼˜å…ˆé˜Ÿåˆ—çš„åº”ç”¨</h2><h2 id="6-5-d-å †"><a href="#6-5-d-å †" class="headerlink" title="6.5 d-å †"></a>6.5 d-å †</h2><p>d-å †æ˜¯äºŒå‰å †çš„ç®€å•æ¨å¹¿ï¼Œå°±åƒä¸€ä¸ªäºŒå‰å †ï¼Œåªæ˜¯æ‰€æœ‰çš„èŠ‚ç‚¹éƒ½æœ‰dä¸ªå„¿å­ï¼ˆå› æ­¤ï¼ŒäºŒå‰å †æ˜¯2-å †ï¼‰</p><h2 id="6-6-å·¦å¼å †"><a href="#6-6-å·¦å¼å †" class="headerlink" title="6.6 å·¦å¼å †"></a>6.6 å·¦å¼å †</h2><p>å·¦å¼å †åƒäºŒå‰å †é‚£æ ·ä¹Ÿå…·æœ‰ç»“æ„æ€§å’Œæœ‰åºæ€§ã€‚å·¦å¼å †å…·æœ‰ç›¸åŒçš„å †åºæ€§è´¨ï¼Œå·¦å¼å †ä¹Ÿæ˜¯äºŒå‰æ ‘ï¼Œå·¦å¼å †å’Œå‰äºŒæ ‘å”¯ä¸€çš„åŒºåˆ«æ˜¯ï¼šå·¦å¼å †ä¸æ˜¯ç†æƒ³å¹³è¡¡çš„ï¼Œè€Œå®é™…ä¸Šè¶‹å‘äºéå¸¸ä¸å¹³è¡¡ã€‚</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2020.png" alt="Untitled"></p><h2 id="6-7-æ–œå †"><a href="#6-7-æ–œå †" class="headerlink" title="6.7 æ–œå †"></a>6.7 æ–œå †</h2><p>æ–œå †æ˜¯å·¦å¼å †çš„è‡ªè°ƒèŠ‚å½¢å¼ï¼Œå®ç°èµ·æ¥æå…¶ç®€å•ã€‚</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2021.png" alt="Untitled"></p><h2 id="6-8-äºŒé¡¹é˜Ÿåˆ—"><a href="#6-8-äºŒé¡¹é˜Ÿåˆ—" class="headerlink" title="6.8 äºŒé¡¹é˜Ÿåˆ—"></a>6.8 äºŒé¡¹é˜Ÿåˆ—</h2><h3 id="6-8-1-äºŒé¡¹é˜Ÿåˆ—ç»“æ„"><a href="#6-8-1-äºŒé¡¹é˜Ÿåˆ—ç»“æ„" class="headerlink" title="6.8.1 äºŒé¡¹é˜Ÿåˆ—ç»“æ„"></a>6.8.1 äºŒé¡¹é˜Ÿåˆ—ç»“æ„</h3><p>ä¸€ä¸ªäºŒé¡¹é˜Ÿåˆ—ä¸æ˜¯ä¸€é¢—å †åºçš„æ ‘ï¼Œè€Œæ˜¯å †åºçš„æ ‘çš„é›†åˆï¼Œç§°ä¸ºæ£®æ—ã€‚</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2022.png" alt="Untitled"></p><h1 id="ç¬¬-7-ç« -æ’åº"><a href="#ç¬¬-7-ç« -æ’åº" class="headerlink" title="ç¬¬ 7 ç«  æ’åº"></a>ç¬¬ 7 ç«  æ’åº</h1><h2 id="7-2-æ’å…¥æ’åº"><a href="#7-2-æ’å…¥æ’åº" class="headerlink" title="7.2 æ’å…¥æ’åº"></a>7.2 æ’å…¥æ’åº</h2><p>æ’å…¥æ’åºç”±N-1è¶Ÿæ’åºç»„æˆã€‚å¯¹äºp=1åˆ°N-1è¶Ÿï¼Œæ’å…¥æ’åºä¿è¯ä»ä½ç½®0åˆ°ä½ç½®pä¸Šçš„å…ƒç´ ä¸ºå·²æ’åºçŠ¶æ€ã€‚</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2023.png" alt="Untitled"></p><p>æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$</p><p>å®šç†ï¼šé€šè¿‡äº¤æ¢ç›¸é‚»å…ƒç´ è¿›è¡Œæ’åºçš„ä»»ä½•ç®—æ³•å¹³å‡éƒ½éœ€è¦$Î©(N^2)$æ—¶é—´</p><h2 id="7-4-å¸Œå°”æ’åº"><a href="#7-4-å¸Œå°”æ’åº" class="headerlink" title="7.4 å¸Œå°”æ’åº"></a>7.4 å¸Œå°”æ’åº</h2><p>å®šç†ï¼šä½¿ç”¨å¸Œå°”æ’åºæœ€åæƒ…å½¢è¿è¡Œæ—¶é—´ä¸º$O(N^2)$</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2024.png" alt="Untitled"></p><h2 id="7-5-å †æ’åº"><a href="#7-5-å †æ’åº" class="headerlink" title="7.5 å †æ’åº"></a>7.5 å †æ’åº</h2><p>ä¼˜å…ˆé˜Ÿåˆ—å¯ä»¥ç”¨ä»¥$O(NlogN)$æ—¶é—´çš„æ’åºã€‚åŸºäºè¯¥æ€æƒ³çš„ç®—æ³•å«åšå †æ’åºã€‚</p><h2 id="7-6-å½’å¹¶æ’åº"><a href="#7-6-å½’å¹¶æ’åº" class="headerlink" title="7.6 å½’å¹¶æ’åº"></a>7.6 å½’å¹¶æ’åº</h2><p>å½’å¹¶æ’åºä»¥O(NlogN)æœ€åæƒ…å½¢æ—¶é—´è¿è¡Œã€‚å®ƒæ˜¯é€’å½’ç®—æ³•ä¸€ä¸ªå¥½çš„å®ä¾‹ã€‚</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2025.png" alt="Untitled"></p><h2 id="7-7-å¿«é€Ÿæ’åº"><a href="#7-7-å¿«é€Ÿæ’åº" class="headerlink" title="7.7 å¿«é€Ÿæ’åº"></a>7.7 å¿«é€Ÿæ’åº</h2><p>å¿«é€Ÿæ’åºæ˜¯äº‹ä»¶ä¸­ä¸€ç§å¿«é€Ÿçš„æ’åºç®—æ³•ï¼Œåœ¨C++æˆ–å¯¹JavaåŸºæœ¬ç±»å‹çš„æ’åºæ±‡æ€»ç‰¹åˆ«æœ‰ç”¨ã€‚å¹³å‡è¿è¡Œæ—¶é—´æ˜¯$O(NlogN)$ã€‚</p><h1 id="ç¬¬-9-ç« -å›¾è®º"><a href="#ç¬¬-9-ç« -å›¾è®º" class="headerlink" title="ç¬¬ 9 ç«  å›¾è®º"></a>ç¬¬ 9 ç«  å›¾è®º</h1><h2 id="9-1-å®šä¹‰"><a href="#9-1-å®šä¹‰" class="headerlink" title="9.1 å®šä¹‰"></a>9.1 å®šä¹‰</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2026.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2027.png" alt="Untitled"></p><h2 id="9-2-æ‹“æ‰‘æ’åº"><a href="#9-2-æ‹“æ‰‘æ’åº" class="headerlink" title="9.2 æ‹“æ‰‘æ’åº"></a>9.2 æ‹“æ‰‘æ’åº</h2><h2 id="9-3-æœ€çŸ­è·¯å¾„ç®—æ³•"><a href="#9-3-æœ€çŸ­è·¯å¾„ç®—æ³•" class="headerlink" title="9.3 æœ€çŸ­è·¯å¾„ç®—æ³•"></a>9.3 æœ€çŸ­è·¯å¾„ç®—æ³•</h2><h3 id="9-3-1-æ— æƒæœ€çŸ­è·¯å¾„"><a href="#9-3-1-æ— æƒæœ€çŸ­è·¯å¾„" class="headerlink" title="9.3.1 æ— æƒæœ€çŸ­è·¯å¾„"></a>9.3.1 æ— æƒæœ€çŸ­è·¯å¾„</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2028.png" alt="Untitled"></p><h2 id="æœªå®Œ"><a href="#æœªå®Œ" class="headerlink" title="æœªå®Œ"></a>æœªå®Œ</h2><h1 id="ç¬¬-9-ç« -ç®—æ³•è®¾è®¡æŠ€å·§"><a href="#ç¬¬-9-ç« -ç®—æ³•è®¾è®¡æŠ€å·§" class="headerlink" title="ç¬¬ 9 ç«  ç®—æ³•è®¾è®¡æŠ€å·§"></a>ç¬¬ 9 ç«  ç®—æ³•è®¾è®¡æŠ€å·§</h1><h2 id="10-1-è´ªå©ªç®—æ³•"><a href="#10-1-è´ªå©ªç®—æ³•" class="headerlink" title="10.1 è´ªå©ªç®—æ³•"></a>10.1 è´ªå©ªç®—æ³•</h2><p>è´ªå©ªç®—æ³•åˆ†é˜¶æ®µåœ°å·¥ä½œï¼Œåœ¨æ¯ä¸€ä¸ªé˜¶æ®µå¯ä»¥è®¤ä¸ºæ‰€åšå†³å®šæ˜¯å¥½çš„ã€‚è€Œä¸è€ƒè™‘å°†æ¥çš„åæœã€‚</p><h2 id="10-2-åˆ†æ²»ç®—æ³•"><a href="#10-2-åˆ†æ²»ç®—æ³•" class="headerlink" title="10.2 åˆ†æ²»ç®—æ³•"></a>10.2 åˆ†æ²»ç®—æ³•</h2><p>åˆ†æ²»ç®—æ³•ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼š</p><ul><li>åˆ†ï¼šé€’å½’è§£å†³è¾ƒå°çš„é—®é¢˜</li><li>æ²»ï¼šç„¶åä»å­é—®é¢˜çš„è§£æ„å»ºåŸé—®é¢˜çš„è§£</li></ul><h2 id="10-3-åŠ¨æ€è§„åˆ’"><a href="#10-3-åŠ¨æ€è§„åˆ’" class="headerlink" title="10.3 åŠ¨æ€è§„åˆ’"></a>10.3 åŠ¨æ€è§„åˆ’</h2><p>å°†é€’å½’ç®—æ³•é‡æ–°å†™æˆéé€’å½’ç®—æ³•ï¼Œè®©åè€…æŠŠé‚£äº›å­é—®é¢˜çš„ç­”æ¡ˆç³»ç»Ÿç¬¬è®°å½•åœ¨ä¸€ä¸ªè¡¨å†…ï¼Œåˆ©ç”¨è¿™ç§æ–¹æ³•çš„ä¸€ç§æŠ€å·§å«åšåŠ¨æ€è§„åˆ’</p><h2 id="10-4-éšæœºæ•°ç®—æ³•"><a href="#10-4-éšæœºæ•°ç®—æ³•" class="headerlink" title="10.4 éšæœºæ•°ç®—æ³•"></a>10.4 éšæœºæ•°ç®—æ³•</h2><h2 id="10-5-å›æº¯ç®—æ³•"><a href="#10-5-å›æº¯ç®—æ³•" class="headerlink" title="10.5 å›æº¯ç®—æ³•"></a>10.5 å›æº¯ç®—æ³•</h2><h1 id="ç¬¬-12-ç« -é«˜çº§æ•°æ®ç»“æ„åŠå…¶å®ç°"><a href="#ç¬¬-12-ç« -é«˜çº§æ•°æ®ç»“æ„åŠå…¶å®ç°" class="headerlink" title="ç¬¬ 12 ç«  é«˜çº§æ•°æ®ç»“æ„åŠå…¶å®ç°"></a>ç¬¬ 12 ç«  é«˜çº§æ•°æ®ç»“æ„åŠå…¶å®ç°</h1><h2 id="12-2-çº¢é»‘æ ‘"><a href="#12-2-çº¢é»‘æ ‘" class="headerlink" title="12.2 çº¢é»‘æ ‘"></a>12.2 çº¢é»‘æ ‘</h2><p>å¯¹çº¢é»‘æ ‘çš„æ“ä½œåœ¨æœ€åæƒ…å½¢ä¸‹èŠ±è´¹O(logN)æ—¶é—´</p><p>çº¢é»‘æ ‘æ˜¯å…·æœ‰ä¸‹åˆ—ç€è‰²æ€§è´¨çš„äºŒå‰æŸ¥æ‰¾æ ‘ï¼š</p><ul><li>æ¯ä¸€ä¸ªèŠ‚ç‚¹æˆ–è€…ç€æˆçº¢è‰²ï¼Œæˆ–è€…ç€æˆé»‘è‰²</li><li>æ ¹æ˜¯é»‘è‰²çš„</li><li>å¦‚æœä¸€ä¸ªèŠ‚ç‚¹æ˜¯çº¢è‰²ï¼Œé‚£ä¹ˆå®ƒçš„å­èŠ‚ç‚¹å¿…é¡»æ˜¯é»‘è‰²çš„</li><li>ä»ä¸€ä¸ªèŠ‚ç‚¹åˆ°ä¸€ä¸ªnullå¼•ç”¨çš„æ¯ä¸€æ¡è·¯å¾„å¿…é¡»åŒ…å«ç›¸åŒæ•°ç›®çš„é»‘è‰²èŠ‚ç‚¹</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> æ•°æ®ç»“æ„ä¸ç®—æ³• </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPFSåŸç†æ·±å…¥åˆ†æ</title>
      <link href="/2022/01/18/distributed_storage/IPFS%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/18/distributed_storage/IPFS%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ã€‡ã€ç›®æ ‡"><a href="#ã€‡ã€ç›®æ ‡" class="headerlink" title="ã€‡ã€ç›®æ ‡"></a>ã€‡ã€ç›®æ ‡</h1><ol><li>ç†Ÿæ‚‰IPFSæ¦‚å¿µ</li><li>ç†Ÿæ‚‰IPFSä¸Šä¼ æ–‡ä»¶ã€ä¸‹è½½æ–‡ä»¶è¿‡ç¨‹</li></ol><h1 id="ä¸€ã€æ¦‚å¿µ"><a href="#ä¸€ã€æ¦‚å¿µ" class="headerlink" title="ä¸€ã€æ¦‚å¿µ"></a>ä¸€ã€æ¦‚å¿µ</h1><h2 id="2-BACKGROUND"><a href="#2-BACKGROUND" class="headerlink" title="2. BACKGROUND"></a>2. BACKGROUND</h2><h3 id="Distributed-Hash-Tables-DHTs"><a href="#Distributed-Hash-Tables-DHTs" class="headerlink" title="Distributed Hash Tables(DHTs)"></a>Distributed Hash Tables(DHTs)</h3><ol><li><p>Kademlia DHT</p><p> ä¼˜ç‚¹</p><ul><li>ã€é€šä¿¡æ€§èƒ½ã€‘é€šè¿‡å¤§è§„æ¨¡ç½‘ç»œé«˜æ•ˆæŸ¥æ‰¾:æŸ¥è¯¢å¹³å‡éœ€è¦é€šä¿¡$log_2(n)$å‘ä¸Šå–æ•´èŠ‚ç‚¹ã€‚(ä¾‹å¦‚ï¼Œä¸€ä¸ªç”±10,000,000ä¸ªèŠ‚ç‚¹ç»„æˆçš„ç½‘ç»œéœ€è¦20ä¸ªè·³æ•°)</li><li>ã€é€šä¿¡æ€§èƒ½ã€‘ä½åè°ƒå¼€é”€:ä¼˜åŒ–äº†å‘é€ç»™å…¶ä»–èŠ‚ç‚¹çš„æ§åˆ¶æ¶ˆæ¯çš„æ•°é‡</li><li>ã€å®‰å…¨ã€‘é€šè¿‡é€‰æ‹©é•¿æœŸå­˜åœ¨çš„èŠ‚ç‚¹æ¥æŠµæŠ—å„ç§æ”»å‡»</li><li>ã€åº”ç”¨ã€‘åœ¨å¯¹ç­‰åº”ç”¨ç¨‹åºä¸­å¹¿æ³›ä½¿ç”¨ï¼ŒåŒ…æ‹¬Gnutellaå’ŒBitTorrentï¼Œå½¢æˆäº†è¶…è¿‡2000ä¸‡ä¸ªèŠ‚ç‚¹çš„ç½‘ç»œã€‚</li></ul></li><li><p>Coral DSHT</p><p> ä¼˜ç‚¹</p><ul><li>ã€é€šä¿¡æ€§èƒ½ã€‘Kademliaå°†å€¼å­˜å‚¨åœ¨idä¸é”®æœ€æ¥è¿‘(ä½¿ç”¨XOR-distance)çš„èŠ‚ç‚¹ä¸­ã€‚è¿™å¹¶ä¸è€ƒè™‘åº”ç”¨ç¨‹åºæ•°æ®çš„å±€åŸŸæ€§ï¼Œå¿½ç•¥å¯èƒ½å·²ç»æ‹¥æœ‰æ•°æ®çš„è¿œèŠ‚ç‚¹ï¼Œå¹¶ä¸ç®¡æœ€è¿‘èŠ‚ç‚¹æ˜¯å¦éœ€è¦è¿™ä»½æ•°æ®è€Œå»å¼ºåˆ¶å®ƒä»¬å­˜å‚¨æ•°æ®ã€‚è¿™æµªè´¹äº†å¤§é‡çš„å­˜å‚¨å’Œå¸¦å®½ã€‚ç›¸åï¼ŒCoralåœ¨èƒ½å¤Ÿæä¾›æ•°æ®å—çš„å¯¹ç­‰èŠ‚ç‚¹å­˜å‚¨åœ°å€ä¿¡æ¯</li><li>ã€é€šä¿¡æ€§èƒ½ã€‘Coralå°†DHT APIä»get_value(key)æ”¾å®½ä¸ºget_any_values(key) (DSHTä¸­çš„â€œsloppyâ€)ã€‚è¿™ä»ç„¶å·¥ä½œç›´åˆ°Coralç”¨æˆ·åªéœ€è¦ä¸€ä¸ª(å·¥ä½œ)peerï¼Œè€Œä¸æ˜¯å®Œæ•´çš„åˆ—è¡¨ã€‚ä½œä¸ºäº¤æ¢ï¼ŒCoralåªèƒ½å°†å€¼çš„å­é›†åˆ†å‘åˆ°æœ€è¿‘çš„èŠ‚ç‚¹ï¼Œä»è€Œé¿å…äº†çƒ­ç‚¹(å½“ä¸€ä¸ªé”®å˜å¾—æµè¡Œæ—¶ï¼Œä¼šé‡è½½æ‰€æœ‰æœ€è¿‘çš„èŠ‚ç‚¹)</li><li>ã€é€šä¿¡æ€§èƒ½ã€‘Coralæ ¹æ®åŒºåŸŸå’Œå¤§å°ç»„ç»‡äº†ä¸€ä¸ªç§°ä¸ºç°‡çš„ç‹¬ç«‹DSHTå±‚æ¬¡ç»“æ„ã€‚è¿™ä½¿å¾—èŠ‚ç‚¹å¯ä»¥é¦–å…ˆæŸ¥è¯¢å…¶åŒºåŸŸå†…çš„å¯¹ç­‰èŠ‚ç‚¹ï¼Œåœ¨ä¸æŸ¥è¯¢è¿œå¤„èŠ‚ç‚¹çš„æƒ…å†µä¸‹æŸ¥æ‰¾é™„è¿‘çš„æ•°æ®ï¼Œå¤§å¤§å‡å°‘äº†æŸ¥æ‰¾çš„å»¶è¿Ÿ</li></ul></li><li><p>S/Kademlia DHT</p><p>S/Kademliaæ‰©å±•äº†Kademliaä»¥ä¸¤ç§ç‰¹åˆ«é‡è¦çš„æ–¹å¼æ¥æŠµå¾¡æ¶æ„æ”»å‡»:</p><ul><li>ã€å®‰å…¨ã€‘S/Kademliaæä¾›äº†å®‰å…¨çš„NodeIdç”Ÿæˆæ–¹æ¡ˆï¼Œå¹¶é˜²æ­¢å¥³å·«æ”»å‡»ã€‚å®ƒè¦æ±‚èŠ‚ç‚¹åˆ›å»ºä¸€ä¸ªPKIå¯†é’¥å¯¹ï¼Œä»å¯†é’¥å¯¹ä¸­è·å¾—è‡ªå·±çš„èº«ä»½ï¼Œå¹¶å¯¹å½¼æ­¤çš„æ¶ˆæ¯è¿›è¡Œç­¾åã€‚ä¸€ç§æ–¹æ¡ˆåŒ…æ‹¬ä¸€ä¸ªå·¥ä½œè¯æ˜åŠ å¯†è°œé¢˜ï¼Œä»¥ä½¿ç”Ÿæˆå¥³å·«æ”»å‡»çš„æˆæœ¬å¾ˆé«˜</li><li>ã€å®‰å…¨ã€‘S/KademliaèŠ‚ç‚¹åœ¨ä¸ç›¸äº¤çš„è·¯å¾„ä¸ŠæŸ¥æ‰¾å€¼ï¼Œä»¥ç¡®ä¿åœ¨ç½‘ç»œä¸­å­˜åœ¨å¤§é‡å¯¹æ‰‹çš„æƒ…å†µä¸‹ï¼Œè¯šå®çš„èŠ‚ç‚¹å¯ä»¥ç›¸äº’è¿æ¥ã€‚å³ä½¿å¯¹æŠ—åˆ†æ•°é«˜è¾¾ä¸€åŠçš„èŠ‚ç‚¹S/Kademliaå®ç°äº†0.85çš„æˆåŠŸç‡ï¼Œ</li></ul></li></ol><h3 id="Block-Exchanges-BitTorrentc"><a href="#Block-Exchanges-BitTorrentc" class="headerlink" title="Block Exchanges - BitTorrentc"></a>Block Exchanges - BitTorrentc</h3><p>BitTorrentï¼ˆç®€ç§°BTï¼‰æ˜¯ä¸€ä¸ªæ–‡ä»¶åˆ†å‘åè®®ï¼Œæ¯ä¸ªä¸‹è½½è€…åœ¨ä¸‹è½½çš„åŒæ—¶ä¸æ–­å‘å…¶ä»–ä¸‹è½½è€…ä¸Šä¼ å·²ä¸‹è½½çš„æ•°æ®ã€‚</p><p>BitTorrentæ˜¯ä¸€ä¸ªå¹¿æ³›æˆåŠŸçš„ç‚¹å¯¹ç‚¹æ–‡ä»¶å¤„ç†ç³»ç»Ÿï¼Œå®ƒæˆåŠŸåœ°åè°ƒäº†äº’ä¸ä¿¡ä»»çš„ç‚¹(ç¾¤)ç½‘ç»œï¼Œåœ¨ç›¸äº’åˆ†å‘æ–‡ä»¶çš„è¿‡ç¨‹ä¸­è¿›è¡Œåˆä½œã€‚BitTorrentåŠå…¶ç”Ÿæ€ç³»ç»Ÿä¸­IPFSè®¾è®¡çš„å…³é”®ç‰¹æ€§åŒ…æ‹¬:</p><ol><li>BitTorrentçš„æ•°æ®äº¤æ¢åè®®ä½¿ç”¨äº†ä¸€ç§ç±»ä¼¼äºtit-for-tatçš„ç­–ç•¥ï¼Œå¥–åŠ±é‚£äº›ç›¸äº’è´¡çŒ®çš„èŠ‚ç‚¹ï¼Œæƒ©ç½šé‚£äº›åªçªƒå–åˆ«äººèµ„æºçš„èŠ‚ç‚¹</li><li>BitTorrentåŒè¡Œè·Ÿè¸ªæ–‡ä»¶ç‰‡æ®µçš„å¯ç”¨æ€§ï¼Œä¼˜å…ˆå‘é€æœ€ç½•è§çš„ç‰‡æ®µã€‚è¿™å‡è½»äº†ç§å­çš„è´Ÿæ‹…ï¼Œä½¿éç§å­åŒä¼´èƒ½å¤Ÿç›¸äº’äº¤æ˜“</li><li>BitTorrentæ ‡å‡†çš„tit-for-tatæ˜“å—æŸäº›åˆ©ç”¨å¸¦å®½å…±äº«ç­–ç•¥çš„æ”»å‡»ã€‚PropShareæ˜¯ä¸€ç§ä¸åŒçš„å¯¹ç­‰å¸¦å®½åˆ†é…ç­–ç•¥ï¼Œå®ƒèƒ½æ›´å¥½åœ°æŠµæŠ—åˆ©ç”¨ç­–ç•¥ï¼Œå¹¶æé«˜ç¾¤çš„æ€§èƒ½</li></ol><h3 id="Version-Control-Systems-Git"><a href="#Version-Control-Systems-Git" class="headerlink" title="Version Control Systems - Git"></a>Version Control Systems - Git</h3><p>ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿæä¾›äº†å¯¹éšæ—¶é—´å˜åŒ–çš„æ–‡ä»¶å»ºæ¨¡çš„å·¥å…·ï¼Œå¹¶æœ‰æ•ˆåœ°åˆ†å‘ä¸åŒçš„ç‰ˆæœ¬ã€‚æµè¡Œçš„ç‰ˆæœ¬æ§åˆ¶ç³»ç»ŸGitæä¾›äº†ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„Merkle dagå¯¹è±¡æ¨¡å‹ï¼Œå®ƒä»¥åˆ†å¸ƒå¼å‹å¥½çš„æ–¹å¼æ•è·å¯¹æ–‡ä»¶ç³»ç»Ÿæ ‘çš„æ›´æ”¹ã€‚</p><ol><li>ä¸å¯å˜å¯¹è±¡ä»£è¡¨Files (blob)ã€Directories (tree)å’ŒChanges (commit)</li><li>å¯¹è±¡æ˜¯å†…å®¹å¯»å€çš„ï¼Œé€šè¿‡å…¶å†…å®¹çš„åŠ å¯†æ•£åˆ—</li><li>ä¸å…¶ä»–ç‰©ä½“çš„é“¾æ¥è¢«åµŒå…¥ï¼Œå½¢æˆä¸€ä¸ªé»˜å…‹å°”DAGã€‚è¿™æä¾›äº†è®¸å¤šæœ‰ç”¨çš„å®Œæ•´æ€§å’Œå·¥ä½œæµå±æ€§</li><li>å¤§å¤šæ•°ç‰ˆæœ¬åŒ–å…ƒæ•°æ®(åˆ†æ”¯ã€æ ‡ç­¾ç­‰)éƒ½æ˜¯ç®€å•çš„æŒ‡é’ˆå¼•ç”¨ï¼Œå› æ­¤åˆ›å»ºå’Œæ›´æ–°çš„æˆæœ¬å¾ˆä½</li><li>ç‰ˆæœ¬æ›´æ”¹ä»…æ›´æ–°å¼•ç”¨æˆ–æ·»åŠ å¯¹è±¡</li><li>å°†ç‰ˆæœ¬æ›´æ”¹åˆ†å‘ç»™å…¶ä»–ç”¨æˆ·åªæ˜¯ç®€å•åœ°ä¼ è¾“å¯¹è±¡å’Œæ›´æ–°è¿œç¨‹å¼•ç”¨</li></ol><h3 id="Self-Certified-Filesystems-SFS"><a href="#Self-Certified-Filesystems-SFS" class="headerlink" title="Self-Certified Filesystems - SFS"></a>Self-Certified Filesystems - SFS</h3><p>SFS[12,11]æå‡ºäº†ä¸¤ç§å¼•äººæ³¨ç›®çš„å®ç°ï¼š</p><ul><li>åˆ†å¸ƒå¼ä¿¡ä»»é“¾</li><li>å¹³ç­‰å…±äº«çš„å…¨å±€å‘½åç©ºé—´</li></ul><p>SFSå¼•å…¥äº†ä¸€ç§ç”¨äºæ„å»ºè‡ªè®¤è¯æ–‡ä»¶ç³»ç»Ÿçš„æŠ€æœ¯:</p><p>ä½¿ç”¨ä»¥ä¸‹schemeï¼š</p><p><code>/sfs/&lt;Location&gt;:&lt;HostID&gt;</code></p><p>å…¶ä¸­Locationæ˜¯æœåŠ¡å™¨çš„ç½‘ç»œåœ°å€ï¼Œå¹¶ä¸”:HostID = hash(public_key || Location)</p><p>å› æ­¤SFSæ–‡ä»¶ç³»ç»Ÿçš„åç§°è¯æ˜äº†å®ƒçš„æœåŠ¡å™¨ã€‚ç”¨æˆ·å¯ä»¥éªŒè¯æœåŠ¡å™¨æä¾›çš„å…¬é’¥ï¼Œåå•†å…±äº«å¯†é’¥ï¼Œå¹¶ç¡®ä¿æ‰€æœ‰æµé‡çš„å®‰å…¨ã€‚æ‰€æœ‰SFSå®ä¾‹å…±äº«ä¸€ä¸ªå…¨å±€å‘½åç©ºé—´ï¼Œå…¶ä¸­çš„åç§°åˆ†é…æ˜¯åŠ å¯†çš„ï¼Œä¸å—ä»»ä½•é›†ä¸­ä¸»ä½“çš„é™åˆ¶ã€‚</p><h2 id="3-IPFS-DESIGN"><a href="#3-IPFS-DESIGN" class="headerlink" title="3. IPFS DESIGN"></a>3. IPFS DESIGN</h2><p>IPFSåè®®è¢«åˆ’åˆ†ä¸ºè´Ÿè´£ä¸åŒåŠŸèƒ½çš„å­åè®®å †æ ˆ</p><h3 id="3-1-èº«ä»½â€”â€”ç®¡ç†èŠ‚ç‚¹èº«ä»½çš„ç”Ÿæˆå’Œæ›´æ–°"><a href="#3-1-èº«ä»½â€”â€”ç®¡ç†èŠ‚ç‚¹èº«ä»½çš„ç”Ÿæˆå’Œæ›´æ–°" class="headerlink" title="3.1 èº«ä»½â€”â€”ç®¡ç†èŠ‚ç‚¹èº«ä»½çš„ç”Ÿæˆå’Œæ›´æ–°"></a>3.1 èº«ä»½â€”â€”ç®¡ç†èŠ‚ç‚¹èº«ä»½çš„ç”Ÿæˆå’Œæ›´æ–°</h3><p>èŠ‚ç‚¹ç”±ä¸€ä¸ªNodeIdæ ‡è¯†ï¼Œè¿™æ˜¯ä¸€ä¸ªå…¬é’¥çš„åŠ å¯†å“ˆå¸Œï¼Œæ˜¯ç”¨S/Kademliaçš„é™æ€åŠ å¯†è°œé¢˜åˆ›å»ºçš„ã€‚èŠ‚ç‚¹å­˜å‚¨å®ƒä»¬çš„å…¬é’¥å’Œç§é’¥(ä½¿ç”¨å¯†ç çŸ­è¯­åŠ å¯†)ã€‚ç”¨æˆ·å¯ä»¥åœ¨æ¯æ¬¡å¯åŠ¨æ—¶è‡ªç”±å®ä¾‹åŒ–ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹æ ‡è¯†ï¼Œå°½ç®¡è¿™æ ·ä¼šæŸå¤±å·²ç§¯ç´¯çš„ç½‘ç»œåˆ©ç›Šã€‚èŠ‚ç‚¹è¢«æ¿€åŠ±ä¿æŒä¸å˜</p><h3 id="3-2-ç½‘ç»œâ€”â€”ç®¡ç†ä¸å…¶ä»–å¯¹ç­‰ä½“çš„è¿æ¥ï¼Œä½¿ç”¨å„ç§åº•å±‚ç½‘ç»œåè®®ã€‚å¯é…ç½®çš„"><a href="#3-2-ç½‘ç»œâ€”â€”ç®¡ç†ä¸å…¶ä»–å¯¹ç­‰ä½“çš„è¿æ¥ï¼Œä½¿ç”¨å„ç§åº•å±‚ç½‘ç»œåè®®ã€‚å¯é…ç½®çš„" class="headerlink" title="3.2 ç½‘ç»œâ€”â€”ç®¡ç†ä¸å…¶ä»–å¯¹ç­‰ä½“çš„è¿æ¥ï¼Œä½¿ç”¨å„ç§åº•å±‚ç½‘ç»œåè®®ã€‚å¯é…ç½®çš„"></a>3.2 ç½‘ç»œâ€”â€”ç®¡ç†ä¸å…¶ä»–å¯¹ç­‰ä½“çš„è¿æ¥ï¼Œä½¿ç”¨å„ç§åº•å±‚ç½‘ç»œåè®®ã€‚å¯é…ç½®çš„</h3><p>IPFSç½‘ç»œæ ˆç‰¹æ€§:</p><ul><li>ä¼ è¾“:IPFSå¯ä»¥ä½¿ç”¨ä»»ä½•ä¼ è¾“åè®®ï¼Œæœ€é€‚åˆäºWebRTCæ•°æ®é€šé“(ç”¨äºæµè§ˆå™¨è¿æ¥)æˆ–uTP(LEDBAT)</li><li>å¯é æ€§:å¦‚æœåº•å±‚ç½‘ç»œä¸æä¾›ï¼ŒIPFSå¯ä»¥ä½¿ç”¨uTP (LEDBAT[14])æˆ–SCTP[15]æä¾›å¯é æ€§</li><li>è¿é€šæ€§:IPFSä¹Ÿä½¿ç”¨ICE NATç©¿è¶ŠæŠ€æœ¯</li><li>å®Œæ•´æ€§:å¯é€‰åœ°ä½¿ç”¨å“ˆå¸Œæ ¡éªŒå’Œæ£€æŸ¥æ¶ˆæ¯çš„å®Œæ•´æ€§</li><li>çœŸå®æ€§:å¯é€‰åœ°æ£€æŸ¥mes- sageçš„çœŸå®æ€§ï¼Œé€šè¿‡ä½¿ç”¨å‘é€æ–¹çš„ç‰¹æƒå¯†é’¥è¿›è¡Œæ•°å­—ç­¾åã€‚</li></ul><h3 id="3-3-è·¯ç”±â€”â€”ç»´æŠ¤å®šä½ç‰¹å®šå¯¹ç­‰ä½“å’Œå¯¹è±¡çš„ä¿¡æ¯ã€‚å“åº”æœ¬åœ°å’Œè¿œç¨‹æŸ¥è¯¢ã€‚é»˜è®¤ä¸ºDHTï¼Œä½†å¯åˆ‡æ¢"><a href="#3-3-è·¯ç”±â€”â€”ç»´æŠ¤å®šä½ç‰¹å®šå¯¹ç­‰ä½“å’Œå¯¹è±¡çš„ä¿¡æ¯ã€‚å“åº”æœ¬åœ°å’Œè¿œç¨‹æŸ¥è¯¢ã€‚é»˜è®¤ä¸ºDHTï¼Œä½†å¯åˆ‡æ¢" class="headerlink" title="3.3 è·¯ç”±â€”â€”ç»´æŠ¤å®šä½ç‰¹å®šå¯¹ç­‰ä½“å’Œå¯¹è±¡çš„ä¿¡æ¯ã€‚å“åº”æœ¬åœ°å’Œè¿œç¨‹æŸ¥è¯¢ã€‚é»˜è®¤ä¸ºDHTï¼Œä½†å¯åˆ‡æ¢"></a>3.3 è·¯ç”±â€”â€”ç»´æŠ¤å®šä½ç‰¹å®šå¯¹ç­‰ä½“å’Œå¯¹è±¡çš„ä¿¡æ¯ã€‚å“åº”æœ¬åœ°å’Œè¿œç¨‹æŸ¥è¯¢ã€‚é»˜è®¤ä¸ºDHTï¼Œä½†å¯åˆ‡æ¢</h3><p>IPFSèŠ‚ç‚¹éœ€è¦ä¸€ä¸ªè·¯ç”±ç³»ç»Ÿï¼Œå®ƒå¯ä»¥æ‰¾åˆ°å…¶ä»–èŠ‚ç‚¹çš„ç½‘ç»œåœ°å€ï¼Œä»¥åŠå¯ä»¥ä¸ºç‰¹å®šå¯¹è±¡æœåŠ¡çš„èŠ‚ç‚¹ã€‚IPFSä½¿ç”¨S/Kademliaå’ŒCoral DSHTå®ç°è¿™ä¸€ç‚¹ã€‚IPFSçš„å¯¹è±¡å¤§å°å’Œä½¿ç”¨æ¨¡å¼ç±»ä¼¼äºCoralå’ŒMainlineï¼Œå› æ­¤IPFS DHTæ ¹æ®å…¶å¤§å°å¯¹å­˜å‚¨çš„å€¼è¿›è¡ŒåŒºåˆ†ã€‚å°å€¼(ç­‰äºæˆ–å°äº1KB)ç›´æ¥å­˜å‚¨åœ¨DHTä¸Šã€‚å¯¹äºè¾ƒå¤§çš„å€¼ï¼ŒDHTå­˜å‚¨å¼•ç”¨ï¼Œè¿™äº›å¼•ç”¨æ˜¯å¯ä»¥ä¸ºå—æä¾›æœåŠ¡çš„èŠ‚ç‚¹çš„nodeid</p><h3 id="3-4-å—äº¤æ¢â€”â€”ä¸€ä¸ªæ–°çš„å—äº¤æ¢åè®®-BitSwap-ï¼Œå®ƒç®¡ç†æœ‰æ•ˆçš„å—åˆ†é…ã€‚ä»¥å¸‚åœºä¸ºæ¨¡å‹ï¼Œå¯¹æ•°æ®å¤åˆ¶çš„æ¿€åŠ±å¾ˆå¼±ã€‚å¯åˆ‡æ¢çš„è´¸æ˜“ç­–ç•¥"><a href="#3-4-å—äº¤æ¢â€”â€”ä¸€ä¸ªæ–°çš„å—äº¤æ¢åè®®-BitSwap-ï¼Œå®ƒç®¡ç†æœ‰æ•ˆçš„å—åˆ†é…ã€‚ä»¥å¸‚åœºä¸ºæ¨¡å‹ï¼Œå¯¹æ•°æ®å¤åˆ¶çš„æ¿€åŠ±å¾ˆå¼±ã€‚å¯åˆ‡æ¢çš„è´¸æ˜“ç­–ç•¥" class="headerlink" title="3.4 å—äº¤æ¢â€”â€”ä¸€ä¸ªæ–°çš„å—äº¤æ¢åè®®(BitSwap)ï¼Œå®ƒç®¡ç†æœ‰æ•ˆçš„å—åˆ†é…ã€‚ä»¥å¸‚åœºä¸ºæ¨¡å‹ï¼Œå¯¹æ•°æ®å¤åˆ¶çš„æ¿€åŠ±å¾ˆå¼±ã€‚å¯åˆ‡æ¢çš„è´¸æ˜“ç­–ç•¥"></a>3.4 å—äº¤æ¢â€”â€”ä¸€ä¸ªæ–°çš„å—äº¤æ¢åè®®(BitSwap)ï¼Œå®ƒç®¡ç†æœ‰æ•ˆçš„å—åˆ†é…ã€‚ä»¥å¸‚åœºä¸ºæ¨¡å‹ï¼Œå¯¹æ•°æ®å¤åˆ¶çš„æ¿€åŠ±å¾ˆå¼±ã€‚å¯åˆ‡æ¢çš„è´¸æ˜“ç­–ç•¥</h3><p>åœ¨IPFSä¸­ï¼Œæ•°æ®åˆ†å‘æ˜¯é€šè¿‡ä½¿ç”¨BitTorrentå¯å‘çš„åè®®BitSwapä¸å¯¹ç­‰ç‚¹äº¤æ¢å—æ¥å®ç°çš„ã€‚åƒBitTorrentä¸€æ ·ï¼ŒBitSwapå¯¹ç­‰ä½“æ­£åœ¨å¯»æ‰¾ä¸€ç»„å—(want_list)ï¼Œå¹¶æœ‰å¦ä¸€ç»„å—äº¤æ¢(have_list)ã€‚ä¸BitTorrentä¸åŒï¼ŒBitSwapå¹¶ä¸å±€é™äºä¸€ä¸ªtorrentä¸­çš„åŒºå—ã€‚BitSwapæ“ä½œæ˜¯ä¸€ä¸ªæŒä¹…çš„å¸‚åœºï¼ŒèŠ‚ç‚¹å¯ä»¥è·å–ä»–ä»¬éœ€è¦çš„å—ï¼Œè€Œä¸ç®¡è¿™äº›å—æ˜¯ä»€ä¹ˆæ–‡ä»¶çš„ä¸€éƒ¨åˆ†ã€‚è¿™äº›å—å¯ä»¥æ¥è‡ªæ–‡ä»¶ç³»ç»Ÿä¸­å®Œå…¨ä¸ç›¸å…³çš„æ–‡ä»¶ã€‚èŠ‚ç‚¹èšé›†åœ¨ä¸€èµ·è¿›è¡Œäº¤æ˜“ã€‚</p><h3 id="3-5-å¯¹è±¡â€”â€”ä¸€ä¸ªMerkle-DAGï¼Œç”±å…·æœ‰é“¾æ¥çš„å†…å®¹å®šä½çš„ä¸å¯å˜å¯¹è±¡ç»„æˆã€‚ç”¨äºè¡¨ç¤ºä»»æ„çš„æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚æ–‡ä»¶å±‚æ¬¡ç»“æ„å’Œé€šä¿¡ç³»ç»Ÿ"><a href="#3-5-å¯¹è±¡â€”â€”ä¸€ä¸ªMerkle-DAGï¼Œç”±å…·æœ‰é“¾æ¥çš„å†…å®¹å®šä½çš„ä¸å¯å˜å¯¹è±¡ç»„æˆã€‚ç”¨äºè¡¨ç¤ºä»»æ„çš„æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚æ–‡ä»¶å±‚æ¬¡ç»“æ„å’Œé€šä¿¡ç³»ç»Ÿ" class="headerlink" title="3.5 å¯¹è±¡â€”â€”ä¸€ä¸ªMerkle DAGï¼Œç”±å…·æœ‰é“¾æ¥çš„å†…å®¹å®šä½çš„ä¸å¯å˜å¯¹è±¡ç»„æˆã€‚ç”¨äºè¡¨ç¤ºä»»æ„çš„æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚æ–‡ä»¶å±‚æ¬¡ç»“æ„å’Œé€šä¿¡ç³»ç»Ÿ"></a>3.5 å¯¹è±¡â€”â€”ä¸€ä¸ªMerkle DAGï¼Œç”±å…·æœ‰é“¾æ¥çš„å†…å®¹å®šä½çš„ä¸å¯å˜å¯¹è±¡ç»„æˆã€‚ç”¨äºè¡¨ç¤ºä»»æ„çš„æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚æ–‡ä»¶å±‚æ¬¡ç»“æ„å’Œé€šä¿¡ç³»ç»Ÿ</h3><p>DHTå’ŒBitSwapå…è®¸IPFSå½¢æˆä¸€ä¸ªå¤§è§„æ¨¡çš„ç‚¹å¯¹ç‚¹ç³»ç»Ÿï¼Œç”¨äºå¿«é€Ÿã€å¯é åœ°å­˜å‚¨å’Œåˆ†å‘å—ã€‚åœ¨è¿™äº›ä¹‹ä¸Šï¼ŒIPFSæ„å»ºäº†ä¸€ä¸ªMerkle DAGï¼Œä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼Œå…¶ä¸­å¯¹è±¡ä¹‹é—´çš„é“¾æ¥æ˜¯åµŒå…¥æºä¸­çš„ç›®æ ‡çš„åŠ å¯†æ•£åˆ—ã€‚è¿™æ˜¯Gitæ•°æ®ç»“æ„çš„ä¸€èˆ¬åŒ–ã€‚</p><p>é»˜å…‹å°”DAGä¸ºIPFSæä¾›äº†è®¸å¤šæœ‰ç”¨çš„å±æ€§ï¼š</p><ol><li>å†…å®¹å¯»å€:æ‰€æœ‰å†…å®¹ç”±å…¶å¤šå“ˆå¸Œæ ¡éªŒå’Œå”¯ä¸€æ ‡è¯†ï¼ŒåŒ…æ‹¬é“¾æ¥</li><li>æŠ—ç¯¡æ”¹:æ‰€æœ‰å†…å®¹éƒ½é€šè¿‡æ ¡éªŒå’Œè¿›è¡ŒéªŒè¯ã€‚å¦‚æœæ•°æ®è¢«ç¯¡æ”¹æˆ–æŸåï¼ŒIPFSä¼šæ£€æµ‹åˆ°å®ƒ</li><li>é‡å¤æ•°æ®åˆ é™¤:æ‰€æœ‰åŒ…å«ç›¸åŒå†…å®¹çš„å¯¹è±¡éƒ½æ˜¯ç›¸åŒçš„ï¼Œä¸”åªå­˜å‚¨ä¸€æ¬¡ã€‚å¯¹äºç´¢å¼•å¯¹è±¡ï¼Œå¦‚gitæ ‘å’Œæäº¤ï¼Œæˆ–æ•°æ®çš„å…¬å…±éƒ¨åˆ†ï¼Œè¿™å°¤å…¶æœ‰ç”¨ã€‚</li></ol><h3 id="3-6-æ–‡ä»¶â€”â€”å—Gitå¯å‘çš„æ–‡ä»¶ç‰ˆæœ¬çš„æ–‡ä»¶ç³»ç»Ÿå±‚æ¬¡ç»“æ„"><a href="#3-6-æ–‡ä»¶â€”â€”å—Gitå¯å‘çš„æ–‡ä»¶ç‰ˆæœ¬çš„æ–‡ä»¶ç³»ç»Ÿå±‚æ¬¡ç»“æ„" class="headerlink" title="3.6 æ–‡ä»¶â€”â€”å—Gitå¯å‘çš„æ–‡ä»¶ç‰ˆæœ¬çš„æ–‡ä»¶ç³»ç»Ÿå±‚æ¬¡ç»“æ„"></a>3.6 æ–‡ä»¶â€”â€”å—Gitå¯å‘çš„æ–‡ä»¶ç‰ˆæœ¬çš„æ–‡ä»¶ç³»ç»Ÿå±‚æ¬¡ç»“æ„</h3><p>IPFSè¿˜å®šä¹‰äº†ä¸€ç»„å¯¹è±¡ï¼Œç”¨äºåœ¨Merkle DAGä¹‹ä¸Šå¯¹ç‰ˆæœ¬åŒ–çš„æ–‡ä»¶ç³»ç»Ÿå»ºæ¨¡ã€‚è¯¥å¯¹è±¡æ¨¡å‹ç±»ä¼¼äºGit s:</p><ol><li>å—:ä¸€ä¸ªå¯å˜å¤§å°çš„æ•°æ®å—</li><li>åˆ—è¡¨:å—æˆ–å…¶ä»–åˆ—è¡¨çš„é›†åˆ</li><li>æ ‘:å—ã€åˆ—è¡¨æˆ–å…¶ä»–æ ‘çš„é›†åˆ</li><li>æäº¤:æ ‘ç‰ˆæœ¬å†å²ä¸­çš„å¿«ç…§ã€‚</li></ol><h3 id="3-7-å‘½åâ€”â€”ä¸€ä¸ªè‡ªè®¤è¯çš„å¯å˜åç§°ç³»ç»Ÿ"><a href="#3-7-å‘½åâ€”â€”ä¸€ä¸ªè‡ªè®¤è¯çš„å¯å˜åç§°ç³»ç»Ÿ" class="headerlink" title="3.7 å‘½åâ€”â€”ä¸€ä¸ªè‡ªè®¤è¯çš„å¯å˜åç§°ç³»ç»Ÿ"></a>3.7 å‘½åâ€”â€”ä¸€ä¸ªè‡ªè®¤è¯çš„å¯å˜åç§°ç³»ç»Ÿ</h3><p>åˆ°ç›®å‰ä¸ºæ­¢ï¼ŒIPFSå †æ ˆå½¢æˆäº†ä¸€ä¸ªç‚¹å¯¹ç‚¹å—äº¤æ¢ï¼Œæ„é€ äº†ä¸€ä¸ªå¯¹è±¡çš„å†…å®¹å¯»å€DAGã€‚å®ƒç”¨äºå‘å¸ƒå’Œæ£€ç´¢ä¸å¯å˜å¯¹è±¡ã€‚å®ƒç”šè‡³å¯ä»¥è·Ÿè¸ªè¿™äº›å¯¹è±¡çš„ç‰ˆæœ¬å†å²ã€‚ä½†æ˜¯ï¼Œç¼ºå°‘ä¸€ä¸ªå…³é”®ç»„ä»¶:å¯å˜å‘½åã€‚æ²¡æœ‰å®ƒï¼Œæ‰€æœ‰æ–°å†…å®¹çš„é€šä¿¡éƒ½å¿…é¡»åœ¨å¸¦å¤–è¿›è¡Œï¼Œå‘é€IPFSé“¾æ¥ã€‚éœ€è¦çš„æ˜¯åœ¨åŒä¸€è·¯å¾„ä¸Šæ£€ç´¢å¯å˜çŠ¶æ€çš„æŸç§æ–¹æ³•ã€‚å€¼å¾—è¯´æ˜çš„æ˜¯ï¼Œå¦‚æœå¯å˜æ•°æ®æ˜¯å¿…è¦çš„ï¼Œæˆ‘ä»¬æœ€ç»ˆåŠªåŠ›å»ºç«‹ä¸€ä¸ªä¸å¯å˜çš„é»˜å…‹å°”DAGã€‚è€ƒè™‘ä¸€ä¸‹æ¥è‡ªMerkle DAGçš„IPFSå±æ€§:å¯¹è±¡å¯ä»¥(a)é€šè¿‡å…¶æ•£åˆ—æ£€ç´¢ï¼Œ(b)å®Œæ•´æ€§æ£€æŸ¥ï¼Œ(c)é“¾æ¥åˆ°å…¶ä»–å¯¹è±¡ï¼Œä»¥åŠ(d)æ— é™æœŸç¼“å­˜ã€‚åœ¨æŸç§æ„ä¹‰ä¸Š:å¯¹è±¡æ˜¯æ°¸ä¹…çš„ã€‚è¿™äº›æ˜¯é«˜æ€§èƒ½åˆ†å¸ƒå¼ç³»ç»Ÿçš„å…³é”®å±æ€§ï¼Œåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œæ•°æ®è·¨ç½‘ç»œé“¾è·¯ç§»åŠ¨çš„ä»£ä»·å¾ˆé«˜ã€‚å¯¹è±¡å†…å®¹å¯»å€æ„å»ºäº†ä¸€ä¸ªå…·æœ‰(a)æ˜¾è‘—å¸¦å®½ä¼˜åŒ–ã€(b)ä¸å¯ä¿¡å†…å®¹æœåŠ¡ã€(c)æ°¸ä¹…é“¾æ¥å’Œ(d)å¯¹ä»»ä½•å¯¹è±¡åŠå…¶å¼•ç”¨è¿›è¡Œå®Œå…¨æ°¸ä¹…å¤‡ä»½çš„èƒ½åŠ›çš„webã€‚Merkle DAG(ä¸å¯å˜çš„å†…å®¹å¯»å€å¯¹è±¡)å’Œå‘½å(æŒ‡å‘Merkle DAGçš„å¯å˜æŒ‡é’ˆ)ç¬æ—¶å‡ºç°åœ¨è®¸å¤šæˆåŠŸçš„åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ã€‚è¿™åŒ…æ‹¬Gitç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿï¼Œå®ƒæœ‰ä¸å¯å˜å¯¹è±¡å’Œå¯å˜å¼•ç”¨;å’ŒPlanï¼Œ UNIXçš„åˆ†å¸ƒå¼ç»§æ‰¿è€…ï¼ŒåŠå…¶å¯å˜çš„Fossilå’Œä¸å¯å˜çš„Ventiæ–‡ä»¶ç³»ç»Ÿã€‚LBFSä¹Ÿä½¿ç”¨å¯å˜ç´¢å¼•å’Œä¸å¯å˜å—ã€‚</p><h2 id="4-IPFSå…±è¯†"><a href="#4-IPFSå…±è¯†" class="headerlink" title="4. IPFSå…±è¯†"></a>4. IPFSå…±è¯†</h2><p>IPFSåˆ›æ–°çš„é‡‡ç”¨äº†ä¸€ç§æ··åˆå…±è¯†æœºåˆ¶â€”â€”å¤åˆ¶è¯æ˜ï¼ˆPoRepï¼‰+æ—¶ç©ºè¯æ˜ï¼ˆPoStï¼‰+ é¢„æœŸå…±è¯†(EC)</p><ol><li>å¤åˆ¶è¯æ˜ï¼šå…±è¯†æœºåˆ¶ä¸­çš„æ ¸å¿ƒå› ç´ ï¼Œå°½ç®¡IPFSçš„ç½‘ç»œåè®®ã€å…±è¯†ã€å…¶ä»–ç®—æ³•éƒ½åŸºæœ¬å®šå‹ï¼Œä½†æ˜¯å¤åˆ¶è¯æ˜ä»ç„¶å¤„äºä¸æ–­å®Œå–„çš„æ–¹æ¡ˆä¸­ã€‚</li><li>æ—¶ç©ºè¯æ˜:ï¼ˆPoSt)æå‡ºäº†è¯æ˜é“¾ï¼ˆproof-chainï¼‰çš„æ•°æ®ç»“æ„ï¼Œè¯æ˜é“¾æŠŠä¸€äº›çš„æŒ‘æˆ˜ï¼ˆchallengeï¼‰å’Œè¯æ˜ï¼ˆproofï¼‰é“¾æ¥èµ·æ¥å½¢æˆã€‚åœ¨è¯æ˜é“¾çš„åŸºç¡€ä¸Šæ·»åŠ ä¸Šæ—¶é—´æ®µï¼Œè¿™æ ·å°±å¾—åˆ°äº†ä¸€æ®µæ—¶é—´å†…çš„çŸ¿å·¥å­˜å‚¨æ•°æ®çš„è¯æ˜ï¼Œè¿™å°±æ˜¯æ—¶ç©ºè¯æ˜ï¼ˆProof of Spacetimeï¼ŒPoStï¼‰ã€‚PoStå¯ä»¥è¯æ˜åœ¨è¯¥æ®µæ—¶é—´å†…çŸ¿å·¥å­˜å‚¨äº†ç‰¹å®šçš„æ•°æ®ï¼Œå¹¶ä¸”åˆ©ç”¨æ—¶é—´æˆ³é”šå®šè¿™äº›è¯æ˜é“¾ï¼Œè¿™æ ·å³ä½¿éªŒè¯è€…ï¼ˆverifierï¼‰ä¸åœ¨çº¿ï¼Œä¹Ÿå¯ä»¥åœ¨æœªæ¥çš„æŸä¸ªæ—¶é—´å†…åˆ©ç”¨æ—¶ç©ºè¯æ˜å»éªŒè¯è¯¥çŸ¿å·¥ç”Ÿæˆäº†è¯æ˜é“¾ï¼ŒPoStä¼šè¢«æäº¤åˆ°é“¾ä¸Šç”¨æ¥äº§ç”Ÿæ–°çš„Blockã€‚</li><li>é¢„æœŸå…±è¯†:ï¼ˆExpected Consensusï¼ŒECï¼‰æ˜¯åœ¨æ¯ä¸€è½®é‡Œé¢é€‰ä¸¾å‡ºæ¥ä¸€åæˆ–è€…å¤šåçŸ¿å·¥æ¥åˆ›å»ºæ–°çš„åŒºå—ï¼ŒçŸ¿å·¥èµ¢å¾—é€‰ä¸¾çš„å¯èƒ½æ€§è·ŸçŸ¿å·¥å½“å‰çš„æœ‰æ•ˆå­˜å‚¨ï¼ˆç®—åŠ›ï¼‰æˆæ­£æ¯”ã€‚IPFSæŠŠçŸ¿å·¥åœ¨ç½‘ç»œä¸­çš„å½“å‰å­˜å‚¨æ•°æ®ç›¸å¯¹äºæ•´ä¸ªç½‘ç»œçš„å­˜å‚¨æ¯”ä¾‹è½¬åŒ–ä¸ºçŸ¿å·¥æŠ•ç¥¨æƒï¼ˆvoting power of the minerï¼‰ã€‚æ— è®ºåœ¨è¯¥å‘¨æœŸé‡Œï¼Œé€‰ä¸¾å‡ºæ¥çš„æ˜¯ä¸€åè¿˜æ˜¯å¤šåçŸ¿å·¥ï¼Œè¢«é€‰ä¸¾å‡ºæ¥çš„çŸ¿å·¥éƒ½éœ€è¦åˆ›å»ºæ–°çš„åŒºå—ï¼Œå¹¶æŠŠæ–°çš„åŒºå—å¯¹ç½‘ç»œè¿›è¡Œå¹¿æ’­ã€‚ å°½ç®¡é“¾ä¸­çš„åŒºå—æ˜¯çº¿æ€§çš„ï¼Œä½†æ˜¯IPFSçš„åŒºå—æ•°æ®ç»“æ„é‡‡ç”¨çš„DAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰ï¼Œå¯ä»¥åœ¨åŒä¸€æ—¶é—´äº§ç”Ÿå¤šä¸ªåŒºå—ï¼ˆæ‰€ä»¥Filecoinçš„äº¤æ˜“è¦æ¯”BTCçš„æœ‰æ•ˆçš„å¤šï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæŠŠFilecoinå«åšâ€œå¯èƒ½çš„blockchain 3.0â€çš„åŸå› ï¼‰ </li></ol><p>Filecoiné¦–åˆ›çš„æ··åˆå…±è¯†æœºåˆ¶ï¼Œä»æ ¹æœ¬ä¸Šå®šä¹‰äº†Filecoinæ˜¯ä¸€ä¸ªåˆç†é«˜æ•ˆã€å»ä¸­å¿ƒåŒ–çš„ç³»ç»Ÿï¼Œå¹¶ä½“ç°å‡ºFilecoinçš„å…¬å¹³æ€§ã€ä¿å¯†æ€§å’Œå…¬å¼€å¯éªŒè¯æ€§</p><h1 id="äºŒã€ä¸Šä¼ æ–‡ä»¶"><a href="#äºŒã€ä¸Šä¼ æ–‡ä»¶" class="headerlink" title="äºŒã€ä¸Šä¼ æ–‡ä»¶"></a>äºŒã€ä¸Šä¼ æ–‡ä»¶</h1><p><img src="/images/ipfs/upload_file.png" alt="img.png"></p><h2 id="1-ç”Ÿæˆé»˜å…‹å°”DAGçš„ç»“æ„"><a href="#1-ç”Ÿæˆé»˜å…‹å°”DAGçš„ç»“æ„" class="headerlink" title="1. ç”Ÿæˆé»˜å…‹å°”DAGçš„ç»“æ„"></a>1. ç”Ÿæˆé»˜å…‹å°”DAGçš„ç»“æ„</h2><p>ç”Ÿæˆçš„ç»“æ„æœ‰ä¸¤ç§Layoutï¼šbalancedå’Œtrickleçš„ã€‚è¿™é‡Œä»‹ç»é»˜è®¤çš„balancedç»“æ„ï¼Œé¦–å…ˆç”Ÿæˆrootä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œç„¶åå°†æ–‡ä»¶åˆ†å‰²ï¼Œé»˜è®¤æŒ‰ç…§256KBå¤§å°è¯»å–ä¸€ä¸ªchunkï¼Œç”Ÿæˆå¶å­èŠ‚ç‚¹ï¼Œä¾æ¬¡ç”Ÿæˆnode1ï¼Œnode2ï¼ŒrootèŠ‚ç‚¹ä¼šæœ‰LinkæŒ‡å‘æŒ‚åœ¨rootèŠ‚ç‚¹çš„å¶å­èŠ‚ç‚¹node1å’Œnode2ã€‚rootèŠ‚ç‚¹ä¸‹é¢èƒ½å¤ŸLinkçš„å¶å­èŠ‚ç‚¹æ•°é‡æ˜¯æœ‰é™çš„ï¼ŒIPFSä¸­é»˜è®¤è®¾ç½®çš„æ˜¯174ä¸ªï¼ˆå®šä¹‰çš„Linkçš„æ€»çš„å¤§å°æ˜¯8KBï¼Œæ¯ä¸ªLinkçš„å¤§å°æ˜¯34 + 8 + 5ã€sha256 multihash + size + no name + protobuf framingã€‘ï¼Œé»˜è®¤çš„Linkçš„ä¸ªæ•°ä¸º8192/47çº¦ç­‰äº174ï¼‰ã€‚</p><p><img src="/images/ipfs/image-1.png" alt="/images/ipfs/image-1.png"></p><p>å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œè¶…è¿‡174ä¸ªååˆ™ä¼šæ–°åˆ›å»ºä¸€ä¸ªnew rootèŠ‚ç‚¹ï¼Œå¹¶Linkåˆ°old rootï¼Œæ–°çš„chunkä½œä¸ºnode3ï¼ˆè¿™é‡Œç”¨node3ç®€çº¦äº†ï¼Œå®é™…ä¸Šæ˜¯ç¬¬175ä¸ªèŠ‚ç‚¹ï¼‰è¢«new rootç›´æ¥Linkã€‚</p><p><img src="/images/ipfs/image-4.png" alt="/images/ipfs/image-4.png"></p><p>å½“ç»§ç»­æœ‰æ–°çš„chunkæ·»åŠ æ—¶ï¼Œåˆ™ä¼šç”Ÿæˆnode34ä½œä¸ºnode3å’Œnode4çš„çˆ¶èŠ‚ç‚¹ï¼Œnode34å«æœ‰ä¸¤ä¸ªLinkåˆ†åˆ«é“¾æ¥åˆ°node3å’Œnode4ã€‚</p><p><img src="/images/ipfs/image-5.png" alt="/images/ipfs/image-5.png"></p><p>IPFSåœ¨initçš„æ—¶å€™ä¼šç”Ÿæˆ.ipfsç›®å½•ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œå…¶ä¸­blocksåˆ™ä¸ºæ–‡ä»¶å—å­˜å‚¨çš„ç›®å½•ï¼Œdatastoreä¸ºleveldbæ•°æ®åº“ï¼Œå…¶ä¸­å­˜å‚¨äº†æ–‡ä»¶ç³»ç»Ÿçš„æ ¹å“ˆå¸Œç­‰ï¼Œå­˜å‚¨ç›¸å…³çš„é…ç½®å…³è”åœ¨.ipfsç›®å½•ä¸‹é¢çš„configæ–‡ä»¶ã€‚</p><p><img src="/images/ipfs/image-6.png" alt="/images/ipfs/image-6.png"></p><h2 id="2-å¯¹å—è¿›è¡Œå­˜å‚¨"><a href="#2-å¯¹å—è¿›è¡Œå­˜å‚¨" class="headerlink" title="2. å¯¹å—è¿›è¡Œå­˜å‚¨"></a>2. å¯¹å—è¿›è¡Œå­˜å‚¨</h2><ul><li>å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œä¸€ä¸ªBlockå­˜å‚¨æ—¶ï¼Œé¦–å…ˆç”±dagServiceï¼ˆå®ç°äº†DAGServiceæ¥å£ï¼‰è°ƒç”¨Addè¿›è¡Œæ·»åŠ ï¼›</li><li>ä¹‹åç”±blockServiceï¼ˆå®ç°äº†BlockServiceæ¥å£ï¼‰è°ƒç”¨AddBlockæ·»åŠ è¯¥Blockï¼›</li><li>å†è°ƒç”¨arccacheçš„Putï¼Œarccacheæ˜¯å¯¹å­˜å‚¨çš„Blockåšarcç­–ç•¥çš„ç¼“å­˜ï¼›</li><li>å†ä¹‹åç”±VerifBSè°ƒç”¨Putè¿›è¡Œå­˜å‚¨ï¼ŒVerifyBSä¸»è¦å¯¹CIDçš„åˆæ³•æ€§è¿›è¡Œæ ¡éªŒï¼Œåˆæ³•åˆ™è¿›è¡ŒPutï¼›</li><li>æ¥ç€blockstoreï¼ˆå®ç°äº†Blockstoreæ¥å£ï¼‰è°ƒç”¨Putè¿›è¡Œå­˜å‚¨ï¼ŒPutå‡½æ•°ä¸­ä¼šå¯¹CIDè¿›è¡Œè½¬åŒ–ï¼Œè°ƒç”¨dshelpçš„CidToDsKeyæ–¹æ³•å°†CIDè½¬åŒ–æˆå­˜å‚¨çš„Keyï¼›</li><li>å†æ¥ç€è°ƒç”¨keytransform.Datastoreçš„Putï¼ŒPutå‡½æ•°ä¸­ä¼šå°†å‰ç¼€æ‹¼ä¸Šï¼Œè¿™æ—¶KeyåŠ ä¸Šäº†å‰ç¼€/blocksï¼›</li><li>ç„¶åè°ƒç”¨measureçš„Putå‡½æ•°ï¼Œmeasureæ˜¯å¯¹mountçš„å°è£…ï¼›</li><li>ä¹‹åè°ƒç”¨mountçš„Putå‡½æ•°ï¼Œmountå’ŒIPFSçš„configé…ç½®æ–‡ä»¶ä¸­ç»“æ„å¯¹åº”ï¼Œæ ¹æ®keyå»æŸ¥æ‰¾å¯¹åº”çš„datastoreï¼Œç”±äºå‰ç¼€æ˜¯/blocksåˆ™å¯ä»¥æ‰¾åˆ°å¯¹åº”çš„measureï¼›</li><li>è°ƒç”¨è¯¥measureçš„Putå‡½æ•°ï¼›</li><li>æœ€åè°ƒç”¨flatfsçš„Putå‡½æ•°ï¼Œç”±Putå‡½æ•°è°ƒç”¨doPutæœ€ç»ˆè°ƒç”¨encodeå‡½æ•°å°†å®Œæ•´çš„blockå†™å…¥çš„ç›®å½•æŒ‡å®šä¸º/home/test/.ipfs/blocks/WDï¼Œå…¶ä¸­WDæ¥è‡ªäºblocks/CIQFSQATUBIEIFDECKTNGHOKPOEE7WUPM5NNNSJCCDROMM6YHEKTWDYä¸­çš„å€’æ•°ç¬¬ä¸‰ç¬¬äºŒä¸ªå­—ç¬¦ã€‚è¿™æ ·è¯¥Blockåˆ™å†™å…¥äº†è¯¥ç›®å½•ä¸‹é¢çš„æ–‡ä»¶ä¸­ã€‚</li></ul><p><img src="/images/ipfs/image-7.png" alt="/images/ipfs/image-7.png"></p><p><img src="/images/ipfs/image-9.png" alt="/images/ipfs/image-9.png"></p><h1 id="ä¸‰ã€ä¸‹è½½æ–‡ä»¶"><a href="#ä¸‰ã€ä¸‹è½½æ–‡ä»¶" class="headerlink" title="ä¸‰ã€ä¸‹è½½æ–‡ä»¶"></a>ä¸‰ã€ä¸‹è½½æ–‡ä»¶</h1><p><img src="/images/ipfs/download_file.png" alt="img.png"></p><ol><li>æ£€æŸ¥æœ¬åœ°çš„blockstoreä¸­æ˜¯å¦å­˜åœ¨è¯·æ±‚çš„æ•°æ®ï¼Œå¦‚æœå­˜åœ¨åˆ™ç›´æ¥ä»æœ¬åœ°è¿”å›ï¼›å¦åˆ™ä¼šå‘å¯¹ç­‰èŠ‚ç‚¹å‘é€block hashåˆ—è¡¨ï¼›</li><li>å¯¹ç­‰èŠ‚ç‚¹é€šè¿‡DHTå’Œè·¯ç”±å±‚ç®—æ³•ï¼Œæ‰¾åˆ°æ¯ä¸ªblock hashæ‰€åœ¨çš„èŠ‚ç‚¹ï¼Œå°†æ–‡ä»¶è¿”å›æ¥ï¼›</li><li>æœ¬åœ°èŠ‚ç‚¹åœ¨æ¥æ”¶blockæ–‡ä»¶çš„åŒæ—¶ç¼“å­˜ä¸€ä»½åˆ°æœ¬åœ°çš„blockstoreä¸­</li><li>æ›´æ–°DHT</li><li>ç»„è£…blockæ–‡ä»¶ï¼Œè¿”å›è‡³ç”¨æˆ·ç«¯</li></ol><h1 id="é™„ï¼šèµ„æ–™"><a href="#é™„ï¼šèµ„æ–™" class="headerlink" title="é™„ï¼šèµ„æ–™"></a>é™„ï¼šèµ„æ–™</h1><ol><li>IPFSç™½çš®ä¹¦ï¼š<a href="https://github.com/ipfs/papers/raw/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf">https://github.com/ipfs/papers/raw/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf</a></li><li>ä¸Šä¼ /ä¸‹è½½æ–‡ä»¶è¿‡ç¨‹ï¼š<ul><li><a href="https://www.jianshu.com/p/9eb1e5f83e13">https://www.jianshu.com/p/9eb1e5f83e13</a></li><li><a href="https://www.chaindesk.cn/witbook/24/449">https://www.chaindesk.cn/witbook/24/449</a></li></ul></li><li><a href="https://www.jiabaotz.com/finance/79470.html">IPFS/Filecoinçš„å…±è¯†æœºåˆ¶æœ‰å“ªäº›ç‰¹ç‚¹ï¼Ÿ</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goè¯­è¨€æ ¸å¿ƒç¼–ç¨‹</title>
      <link href="/2022/01/17/go/Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/17/go/Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-Core-Programming"><a href="#Go-Core-Programming" class="headerlink" title="Go Core Programming"></a>Go Core Programming</h1><h1 id="ç¬¬-1-ç« -åŸºç¡€çŸ¥è¯†"><a href="#ç¬¬-1-ç« -åŸºç¡€çŸ¥è¯†" class="headerlink" title="ç¬¬ 1 ç«  åŸºç¡€çŸ¥è¯†"></a>ç¬¬ 1 ç«  åŸºç¡€çŸ¥è¯†</h1><h2 id="1-1-è¯­è¨€ç®€ä»‹"><a href="#1-1-è¯­è¨€ç®€ä»‹" class="headerlink" title="1.1 è¯­è¨€ç®€ä»‹"></a>1.1 è¯­è¨€ç®€ä»‹</h2><h3 id="1-1-1-Goè¯­è¨€çš„è¯ç”ŸèƒŒæ™¯"><a href="#1-1-1-Goè¯­è¨€çš„è¯ç”ŸèƒŒæ™¯" class="headerlink" title="1.1.1 Goè¯­è¨€çš„è¯ç”ŸèƒŒæ™¯"></a>1.1.1 Goè¯­è¨€çš„è¯ç”ŸèƒŒæ™¯</h3><ul><li><strong>å½“å‰ç¼–ç¨‹è¯­è¨€å¯¹å¹¶å‘çš„æ”¯æŒä¸æ˜¯å¾ˆå¥½</strong>ï¼Œä¸èƒ½å¾ˆå¥½åœ°å‘æŒ¥å¤šæ ¸CPUçš„å¨åŠ›</li><li>ç¨‹åºè§„æ¨¡è¶Šæ¥è¶Šå¤§ï¼Œ<strong>ç¼–è¯‘é€Ÿåº¦è¶Šæ¥è¶Šæ…¢</strong></li><li>ç°æœ‰çš„<strong>ç¼–ç¨‹è¯­è¨€è®¾è®¡è¶Šæ¥è¶Šå¤æ‚</strong>ï¼ŒæŸäº›ç‰¹æ€§çš„å®ç°ä¸æ€ä¹ˆä¼˜é›…</li></ul><h3 id="1-1-3-Goè¯­è¨€çš„ç‰¹æ€§"><a href="#1-1-3-Goè¯­è¨€çš„ç‰¹æ€§" class="headerlink" title="1.1.3 Goè¯­è¨€çš„ç‰¹æ€§"></a>1.1.3 Goè¯­è¨€çš„ç‰¹æ€§</h3><p><img src="/images/go_core_programming/Untitled.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%201.png" alt="Untitled"></p><h2 id="1-3-Goè¯æ³•å•å…ƒ"><a href="#1-3-Goè¯æ³•å•å…ƒ" class="headerlink" title="1.3 Goè¯æ³•å•å…ƒ"></a>1.3 Goè¯æ³•å•å…ƒ</h2><h3 id="1-3-1-token"><a href="#1-3-1-token" class="headerlink" title="1.3.1 token"></a>1.3.1 token</h3><p>tokenæ˜¯æ„æˆæºç¨‹åºçš„åŸºæœ¬ä¸å¯å†åˆ†å‰²çš„å•å…ƒã€‚</p><p>ç¼–è¯‘å™¨ç¼–è¯‘æºç¨‹åºçš„ç¬¬ä¸€æ­¥å°±æ˜¯å°†æºç¨‹åºåˆ†å‰²æˆä¸€ä¸ªä¸ªç‹¬ç«‹çš„tokenï¼Œè¿™ä¸ªè¿‡ç¨‹å°±æ˜¯è¯æ³•åˆ†æã€‚</p><p>Goè¯­è¨€çš„tokenå¯ä»¥åˆ†ä¸ºå…³é”®å­—ã€æ ‡è¯†ç¬¦ã€æ“ä½œç¬¦ã€åˆ†éš”ç¬¦å’Œå­—é¢å¸¸é‡</p><p><img src="/images/go_core_programming/Untitled%202.png" alt="Untitled"></p><h3 id="1-3-2-æ ‡è¯†ç¬¦"><a href="#1-3-2-æ ‡è¯†ç¬¦" class="headerlink" title="1.3.2 æ ‡è¯†ç¬¦"></a>1.3.2 æ ‡è¯†ç¬¦</h3><ol><li>æ ‡è¯†ç¬¦ç”¨æ¥æ ‡è¯†å˜é‡ã€ç±»å‹ã€å¸¸é‡ç­‰è¯­æ³•å¯¹è±¡çš„ç¬¦å·åç§°ï¼Œå…¶åœ¨è¯­æ³•åˆ†ææ—¶ä½œä¸ºä¸€ä¸ªtokenå­˜åœ¨ã€‚</li><li>æ ‡è¯†ç¬¦åˆ†ä¸ºä¸¤ç±»ï¼š<ul><li>è¯­è¨€è®¾è®¡è€…é¢„ç•™çš„æ ‡è¯†ç¬¦ï¼šè¯­è¨€è®¾è®¡è€…ç¡®å®šï¼ŒåŒ…æ‹¬è¯­è¨€çš„é¢„å£°æ˜æ ‡è¯†ç¬¦åŠä¿ç•™å­—</li><li>ç¼–ç¨‹è€…å¯ä»¥è‡ªå®šä¹‰çš„æ ‡è¯†ç¬¦ï¼šç”¨æˆ·å®šä¹‰çš„å˜é‡åã€å¸¸é‡åã€å‡½æ•°åç­‰</li></ul></li><li>æ ‡è¯†ç¬¦è§„åˆ™ï¼šå¼€å¤´ä¸€ä¸ªå­—ç¬¦å¿…é¡»æ˜¯å­—æ¯æˆ–ä¸‹åˆ’çº¿ï¼ŒåŒºåˆ†å¤§å°å†™</li><li><strong>å…³é”®å­—ï¼ˆkeywordsï¼Œ25ä¸ªï¼‰</strong></li></ol><p><img src="/images/go_core_programming/Untitled%203.png" alt="Untitled"></p><ol><li><strong>å†…ç½®æ•°æ®ç±»å‹æ ‡è¯†ç¬¦ï¼ˆ20ä¸ªï¼‰</strong></li></ol><p><img src="/images/go_core_programming/Untitled%204.png" alt="Untitled"></p><ol><li><strong>å†…ç½®å‡½æ•°ï¼ˆ15ä¸ªï¼‰</strong></li></ol><p><img src="/images/go_core_programming/Untitled%205.png" alt="Untitled"></p><ol><li><strong>å¸¸é‡å€¼æ ‡è¯†ç¬¦ï¼ˆ4ä¸ªï¼‰</strong></li></ol><p><img src="/images/go_core_programming/Untitled%206.png" alt="Untitled"></p><p>ç©ºç™½æ ‡è¯†ç¬¦ï¼š <code>_</code></p><h3 id="1-3-3-æ“ä½œç¬¦ï¼ˆoperatorsï¼‰å’Œåˆ†éš”ç¬¦ï¼ˆdelimitersï¼‰"><a href="#1-3-3-æ“ä½œç¬¦ï¼ˆoperatorsï¼‰å’Œåˆ†éš”ç¬¦ï¼ˆdelimitersï¼‰" class="headerlink" title="1.3.3 æ“ä½œç¬¦ï¼ˆoperatorsï¼‰å’Œåˆ†éš”ç¬¦ï¼ˆdelimitersï¼‰"></a>1.3.3 æ“ä½œç¬¦ï¼ˆoperatorsï¼‰å’Œåˆ†éš”ç¬¦ï¼ˆdelimitersï¼‰</h3><p>æ“ä½œç¬¦åŒ…æ‹¬è¿ç®—ç¬¦ã€ç°å¼çš„åˆ†éš”ç¬¦ã€å…¶ä»–è¯­æ³•è¾…åŠ©ç¬¦å·</p><h3 id="1-3-4-å­—é¢å¸¸é‡"><a href="#1-3-4-å­—é¢å¸¸é‡" class="headerlink" title="1.3.4 å­—é¢å¸¸é‡"></a>1.3.4 å­—é¢å¸¸é‡</h3><ol><li>Goçš„å­—é¢é‡å‡ºç°åœ¨ä¸¤ä¸ªåœ°æ–¹ï¼š<ul><li>ç”¨äºå¸¸é‡å’Œå˜é‡çš„åˆå§‹åŒ–</li><li>ç”¨åœ¨è¡¨è¾¾å¼é‡Œæˆ–å‡½æ•°è°ƒç”¨å®å‚</li></ul></li><li>å­—é¢é‡åˆ†ç±»ï¼š<ul><li>æ•´å‹å­—é¢é‡</li><li>æµ®ç‚¹å‹å­—é¢é‡</li><li>å¤æ•°ç±»å‹å­—é¢é‡</li><li>å­—ç¬¦å‹å­—é¢é‡</li><li>å­—ç¬¦ä¸²å­—é¢é‡</li></ul></li></ol><h2 id="1-4-å˜é‡å’Œå¸¸é‡"><a href="#1-4-å˜é‡å’Œå¸¸é‡" class="headerlink" title="1.4 å˜é‡å’Œå¸¸é‡"></a>1.4 å˜é‡å’Œå¸¸é‡</h2><h3 id="1-4-1-å˜é‡"><a href="#1-4-1-å˜é‡" class="headerlink" title="1.4.1 å˜é‡"></a>1.4.1 å˜é‡</h3><h3 id="1-4-2-å¸¸é‡"><a href="#1-4-2-å¸¸é‡" class="headerlink" title="1.4.2 å¸¸é‡"></a>1.4.2 å¸¸é‡</h3><h2 id="1-5-åŸºæœ¬æ•°æ®ç±»å‹"><a href="#1-5-åŸºæœ¬æ•°æ®ç±»å‹" class="headerlink" title="1.5 åŸºæœ¬æ•°æ®ç±»å‹"></a>1.5 åŸºæœ¬æ•°æ®ç±»å‹</h2><p>Goå†…ç½®ä¸ƒç±»åŸºæœ¬æ•°æ®ç±»å‹ï¼š</p><p><img src="/images/go_core_programming/Untitled%207.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%208.png" alt="Untitled"></p><h2 id="1-5-4-å¤æ•°ç±»å‹"><a href="#1-5-4-å¤æ•°ç±»å‹" class="headerlink" title="1.5.4 å¤æ•°ç±»å‹"></a>1.5.4 å¤æ•°ç±»å‹</h2><p>Goè¯­è¨€å†…ç½®çš„å¤æ•°ç±»å‹æœ‰ä¸¤ç§ï¼Œåˆ†åˆ«æ˜¯complex64å’Œcomplex128ã€‚å¤æ•°çš„å­—é¢é‡è¡¨ç¤ºå’Œæ•°å­¦è¡¨ç¤ºæ³•ä¸€æ ·ã€‚</p><p><img src="/images/go_core_programming/Untitled%209.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2010.png" alt="Untitled"></p><h3 id="1-5-6-runeç±»å‹"><a href="#1-5-6-runeç±»å‹" class="headerlink" title="1.5.6 runeç±»å‹"></a>1.5.6 runeç±»å‹</h3><p>Goå†…ç½®ä¸¤ç§å­—ç¬¦ç±»å‹ï¼š</p><ul><li>buteçš„å­—èŠ‚ç±»ç±»å‹ï¼ˆbyteæ˜¯uintçš„åˆ«åï¼‰</li><li>è¡¨ç¤ºUniocodeç¼–ç çš„å­—ç¬¦runeï¼ˆruneæ˜¯int32ç±»å‹çš„åˆ«åï¼‰</li></ul><h2 id="1-6-å¤åˆæ•°æ®ç±»å‹"><a href="#1-6-å¤åˆæ•°æ®ç±»å‹" class="headerlink" title="1.6 å¤åˆæ•°æ®ç±»å‹"></a>1.6 å¤åˆæ•°æ®ç±»å‹</h2><ol><li>å¤åˆæ•°æ®ç±»å‹å°±æ˜¯ç”±å…¶ä»–ç±»å‹ç»„åˆè€Œæˆçš„ç±»å‹ã€‚</li><li>GoåŸºæœ¬çš„å¤åˆæ•°æ®ç±»å‹æœ‰ï¼š<ul><li><p>æŒ‡é’ˆ</p></li><li><p>æ•°æ®</p></li><li><p>åˆ‡ç‰‡</p></li><li><p>å­—å…¸ï¼ˆmapï¼‰</p></li><li><p>é€šé“</p></li><li><p>ç»“æ„</p></li><li><p>æ¥å£</p><p><img src="/images/go_core_programming/Untitled%2011.png" alt="Untitled"></p></li></ul></li></ol><h3 id="1-6-1-æŒ‡é’ˆ"><a href="#1-6-1-æŒ‡é’ˆ" class="headerlink" title="1.6.1 æŒ‡é’ˆ"></a>1.6.1 æŒ‡é’ˆ</h3><ol><li>Goæ”¯æŒæŒ‡é’ˆï¼Œå£°æ˜ç±»å‹ä¸º <code>*T</code> ï¼ŒGoæ”¯æŒå¤šçº§æŒ‡é’ˆ <code>**T</code> ã€‚é€šè¿‡åœ¨å˜é‡åå‰åŠ  <code>&amp;</code> è·å–å˜é‡çš„åœ°å€ã€‚</li><li>æŒ‡é’ˆçš„ç‰¹ç‚¹ï¼š<ul><li>åœ¨èµ‹å€¼è¯­å¥ä¸­ï¼Œ<code>*T</code> å‡ºç°åœ¨ <code>=</code> å·¦è¾¹è¡¨ç¤ºæŒ‡é’ˆå£°æ˜ï¼Œ<code>*T</code> å‡ºç°åœ¨ <code>=</code> å³è¾¹è¡¨ç¤ºå–æŒ‡é’ˆæŒ‡å‘çš„å€¼ï¼ˆvarNameä¸ºå˜é‡åï¼‰ã€‚ç¤ºä¾‹ï¼š<pre><code class="go">var a = 11p := &amp;a // *på’Œaçš„å€¼éƒ½æ˜¯11</code></pre></li><li>ç»“æ„ä½“æŒ‡é’ˆè®¿é—®ç»“æ„ä½“å­—æ®µä»ç„¶ä½¿ç”¨ <code>.</code> ç‚¹æ“ä½œç¬¦ï¼ŒGoè¯­è¨€æ²¡æœ‰ <code>-&gt;</code> æ“ä½œç¬¦ï¼Œä¾‹å¦‚ï¼š<pre><code class="go">type User struct {    name string    age int}andes := User {    name: "andes",    age: 10,}p := &amp;andesfmt.Println(p.name) // p.nameé€šè¿‡"."æ“ä½œç¬¦è®¿é—®æˆå‘˜å˜é‡</code></pre></li><li>Goä¸æ”¯æŒæŒ‡é’ˆçš„è¿ç®—  Goç”±äºæ”¯æŒåƒåœ¾å›æ”¶ï¼Œå¦‚æœæ”¯æŒæŒ‡é’ˆè¿ç®—åˆ™ä¼šç»™åƒåœ¾å›æ”¶çš„å®ç°å¸¦æ¥å¾ˆå¤šä¸ä¾¿ã€‚ä¾‹å¦‚ï¼š  <img src="/images/go_core_programming/Untitled%2012.png" alt="Untitled"></li><li>å‡½æ•°ä¸­å…è®¸è¿”å›å±€éƒ¨å˜é‡çš„åœ°å€  Goç¼–è¯‘å™¨ä½¿ç”¨â€æ ˆé€ƒé€¸â€œæœºåˆ¶å°†è¿™ç§å±€éƒ¨å˜é‡çš„ç©ºé—´åˆ†é…åœ¨å †ä¸Šï¼Œä¾‹å¦‚ï¼š  <img src="/images/go_core_programming/Untitled%2013.png" alt="Untitled"></li></ul></li></ol><h3 id="1-6-2-æ•°ç»„"><a href="#1-6-2-æ•°ç»„" class="headerlink" title="1.6.2 æ•°ç»„"></a>1.6.2 æ•°ç»„</h3><ol><li>æ•°ç»„çš„ç±»å‹åæ˜¯<code>[n]elementType</code>ï¼Œnæ˜¯æ•°ç»„é•¿åº¦ï¼ŒelementTypeæ˜¯æ•°ç»„å…ƒç´ ç±»å‹ã€‚</li></ol><p><img src="/images/go_core_programming/Untitled%2014.png" alt="Untitled"></p><ol><li>æ•°ç»„çš„ç‰¹ç‚¹ï¼š<ul><li>æ•°ç»„åˆ›å»ºå®Œé•¿åº¦å°±å›ºå®šäº†ï¼Œä¸å¯ä»¥å†è¿½åŠ å…ƒç´ äº†</li><li>æ•°ç»„æ˜¯å€¼ç±»å‹çš„ï¼Œæ•°ç»„èµ‹å€¼æˆ–ä½œä¸ºå‡½æ•°å‚æ•°éƒ½æ˜¯å€¼æ‹·è´</li><li>æ•°ç»„é•¿åº¦æ˜¯æ•°ç»„ç±»å‹çš„ç»„æˆéƒ¨åˆ†ï¼Œ<code>[10]int</code>å’Œ<code>[20]int</code>æ˜¯ä¸åŒçš„ç±»å‹</li><li>å¯ä»¥æ ¹æ®æ•°ç»„åˆ›å»ºåˆ‡ç‰‡</li></ul></li><li>æ•°ç»„ç›¸å…³æ“ä½œï¼š<ul><li><p>æ•°ç»„å…ƒç´ è®¿é—®</p><p><img src="/images/go_core_programming/Untitled%2015.png" alt="Untitled"></p></li><li><p>æ•°ç»„é•¿åº¦</p><p><img src="/images/go_core_programming/Untitled%2016.png" alt="Untitled"></p></li></ul></li></ol><h3 id="1-6-3-åˆ‡ç‰‡"><a href="#1-6-3-åˆ‡ç‰‡" class="headerlink" title="1.6.3 åˆ‡ç‰‡"></a>1.6.3 åˆ‡ç‰‡</h3><p>Goè¯­è¨€çš„æ•°ç»„çš„å®šé•¿æ€§å’Œå€¼æ‹·è´é™åˆ¶äº†å…¶ä½¿ç”¨åœºæ™¯ï¼ŒGpæä¾›äº†å¦ä¸€ç§æ•°æ®ç±»å‹sliceï¼ˆåˆ‡ç‰‡ï¼‰ï¼Œè¿™æ˜¯ä¸€ç§å˜é•¿æ•°ç»„ï¼Œå…¶æ•°æ®ç»“æ„ä¸­æœ‰æŒ‡å‘æ•°ç»„çš„æŒ‡é’ˆï¼Œæ‰€ä»¥æ˜¯ä¸€ç§å¼•ç”¨ç±»å‹ã€‚</p><p>ä¾‹å¦‚ï¼š</p><pre><code class="go">type slice struct {    array unsafe.Pointer    len int    cap int}</code></pre><p>Goä¸ºåˆ‡ç‰‡ç»´æŠ¤ä¸‰ä¸ªå…ƒç´ ï¼š</p><ul><li>æŒ‡å‘åº•å±‚æ•°ç»„çš„æŒ‡é’ˆ</li><li>åˆ‡ç‰‡çš„å…ƒç´ æ•°é‡</li><li>åº•å±‚æ•°ç»„çš„å®¹é‡</li></ul><p><img src="/images/go_core_programming/Untitled%2017.png" alt="Untitled"></p><ol><li>åˆ‡ç‰‡çš„åˆ›å»º<ul><li>ç”±æ•°ç»„åˆ›å»ºï¼šåˆ›å»ºè¯­æ³•<code>array[b:e]</code> ï¼Œè¡¨ç¤ºåˆ›å»ºä¸€ä¸ªåŒ…å«e-bå„å…ƒç´ é¢çš„åˆ‡ç‰‡ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯<code>array[b]</code>ï¼Œæœ€åä¸€ä¸ªå…ƒç´ æ˜¯<code>array[e-1]</code> ã€‚ä¾‹å¦‚ï¼š  <img src="/images/go_core_programming/Untitled%2018.png" alt="Untitled"></li><li>é€šè¿‡å†…ç½®å‡½æ•°<code>make</code>åˆ›å»ºåˆ‡ç‰‡ã€‚<code>make</code>åˆ›å»ºçš„åˆ‡ç‰‡å„å…ƒç´ è¢«é»˜è®¤ä¸ºè¾“å‡ºåä¸ºåˆ‡ç‰‡å…ƒç´ ç±»å‹çš„é›¶å€¼ã€‚  <img src="/images/go_core_programming/Untitled%2019.png" alt="Untitled">  <img src="/images/go_core_programming/Untitled%2020.png" alt="Untitled"></li></ul><ol><li>åˆ‡ç‰‡æ”¯æŒçš„æ“ä½œ<ul><li>å†…ç½®å‡½æ•°<code>len()</code>è¿”å›åˆ‡ç‰‡é•¿åº¦</li><li>å†…ç½®å‡½æ•°<code>cap()</code>è¿”å›åˆ‡ç‰‡åº•å±‚æ•°ç»„å®¹é‡</li><li>å†…ç½®å‡½æ•°<code>append()</code>å¯¹åˆ‡ç‰‡è¿½åŠ å…ƒç´ </li><li>å†…ç½®å‡½æ•°<code>copy()</code>ç”¨äºå¤åˆ¶ä¸€ä¸ªåˆ‡ç‰‡</li></ul></li></ol></li></ol><h3 id="1-6-4-map"><a href="#1-6-4-map" class="headerlink" title="1.6.4 map"></a>1.6.4 map</h3><p>Goè¯­è¨€å†…ç½®çš„å­—å…¸ç±»å‹å«mapã€‚</p><p><code>map</code>ç±»å‹çš„æ ¼å¼æ˜¯ï¼š<code>map[K]T</code> ï¼Œå…¶ä¸­Kå¯ä»¥æ˜¯ä»»æ„å¯ä»¥è¿›è¡Œæ¯”è¾ƒçš„ç±»å‹ï¼ŒTæ˜¯å€¼ç±»å‹ã€‚</p><p><code>map</code>ä¹Ÿæ˜¯ä¸€ç§å¼•ç”¨ç±»å‹ã€‚</p><ol><li><code>map</code>çš„åˆ›å»º<ul><li>ä½¿ç”¨å­—é¢é‡åˆ›å»ºï¼Œä¾‹å¦‚ï¼š  <img src="/images/go_core_programming/Untitled%2021.png" alt="Untitled"></li><li>ä½¿ç”¨å†…ç½®çš„makeå‡½æ•°åˆ›å»ºï¼Œä¾‹å¦‚  <img src="/images/go_core_programming/Untitled%2022.png" alt="Untitled">  <img src="/images/go_core_programming/Untitled%2023.png" alt="Untitled"></li></ul></li><li><code>map</code>æ”¯æŒçš„æ“ä½œ<ul><li><p><code>map</code>çš„å•ä¸ªé”®å€¼è®¿é—®æ ¼å¼ä¸º<code>mapName[key]</code></p></li><li><p>å¯ä»¥ä½¿ç”¨<code>range</code>éå†ä¸€ä¸ª<code>map</code>ç±»å‹çš„å˜é‡ï¼Œä½†ä¸èƒ½ä¿è¯æ¯æ¬¡è¿­ä»£å…ƒç´ çš„é¡ºåº</p></li><li><p>åˆ é™¤<code>map</code>ä¸­çš„æŸä¸ªé”®å€¼ï¼Œ<code>delete(mapName,key)</code> ã€‚<code>delete</code>æ˜¯å†…ç½®å‡½æ•°ï¼Œç”¨æ¥åˆ é™¤<code>map</code>ä¸­çš„æŸä¸ªé”®å€¼å¯¹</p></li><li><p>å¯ä»¥ä½¿ç”¨å†…ç½®çš„<code>len()</code> å‡½æ•°è¿”å›<code>map</code>ä¸­çš„é”®å€¼å¯¹æ•°é‡</p><p>æ³¨æ„ï¼š</p></li><li><p>Goå†…ç½®çš„<code>map</code>ä¸æ˜¯å¹¶å‘å®‰å…¨çš„ï¼Œå¹¶å‘å®‰å…¨çš„<code>map</code>å¯ä»¥ä½¿ç”¨æ ‡å‡†åŒ…<code>sync</code>ä¸­çš„map</p></li><li><p>ä¸è¦ç›´æ¥ä¿®æ”¹<code>map value</code>å†…æŸä¸ªå…ƒç´ çš„å€¼ï¼Œå¦‚æœæƒ³ä¿®æ”¹<code>map</code>çš„æŸä¸ªé”®å€¼ï¼Œåˆ™å¿…é¡»æ•´ç†èµ‹å€¼</p></li></ul></li></ol><h3 id="1-6-5-struct"><a href="#1-6-5-struct" class="headerlink" title="1.6.5 struct"></a>1.6.5 struct</h3><p>Goä¸­çš„structç±»å‹å’ŒCç±»ä¼¼ï¼Œä¸­æ–‡ç¿»è¯‘ä¸ºç»“æ„ï¼Œç”±å¤šä¸ªä¸åŒç±»å‹å…ƒç´ ç»„åˆè€Œæˆã€‚</p><ul><li>structç»“æ„ä¸­çš„ç±»å‹å¯ä»¥æ˜¯ä»»æ„ç±»å‹</li><li>structçš„å­˜å‚¨ç©ºé—´æ˜¯è¿ç»­çš„ï¼Œå…¶å­—æ®µæŒ‰ç…§å£°æ˜æ—¶çš„é¡ºåºå­˜æ”¾ï¼ˆæ³¨æ„å­—æ®µå€¼ä¹‹é—´æœ‰å¯¹é½è¦æ±‚ï¼‰</li></ul><p>structæœ‰ä¸¤ç§å½¢å¼ï¼š</p><ul><li>structç±»å‹å­—é¢é‡</li><li>ä½¿ç”¨typeå£°æ˜çš„è‡ªå®šä¹‰structç±»å‹</li></ul><ol><li>strctç±»å‹å­—é¢é‡ structç±»å‹å­—é¢é‡çš„å£°æ˜æ ¼å¼å¦‚ä¸‹ï¼š <img src="/images/go_core_programming/Untitled%2024.png" alt="Untitled"></li><li>è‡ªå®šä¹‰structç±»å‹ è‡ªå®šä¹‰structç±»å‹å£°æ˜æ ¼å¼å¦‚ä¸‹ï¼š <img src="/images/go_core_programming/Untitled%2025.png" alt="Untitled"></li><li>structç±»å‹å˜é‡çš„åˆå§‹åŒ–ï¼Œç¤ºä¾‹ï¼š <img src="/images/go_core_programming/Untitled%2026.png" alt="Untitled"></li><li>å…¶ä»–å¤åˆç±»å‹<ul><li>æ¥å£ï¼ˆInterfaceï¼‰</li><li>é€šé“ï¼ˆchanï¼‰</li></ul></li></ol><h2 id="1-7-æ§åˆ¶ç»“æ„"><a href="#1-7-æ§åˆ¶ç»“æ„" class="headerlink" title="1.7 æ§åˆ¶ç»“æ„"></a>1.7 æ§åˆ¶ç»“æ„</h2><p>ç¨‹åºæ‰§è¡Œä»æœ¬è´¨ä¸Šæ¥è¯´å°±æ˜¯ä¸¤ç§æ¨¡å¼ï¼šé¡ºåºå’Œè·³è½¬</p><h3 id="1-7-1-if-è¯­å¥"><a href="#1-7-1-if-è¯­å¥" class="headerlink" title="1.7.1 if è¯­å¥"></a>1.7.1 if è¯­å¥</h3><h3 id="1-7-2-switch-è¯­å¥"><a href="#1-7-2-switch-è¯­å¥" class="headerlink" title="1.7.2 switch è¯­å¥"></a>1.7.2 switch è¯­å¥</h3><h3 id="1-7-3-for-è¯­å¥"><a href="#1-7-3-for-è¯­å¥" class="headerlink" title="1.7.3 for è¯­å¥"></a>1.7.3 for è¯­å¥</h3><h3 id="1-7-4-æ ‡ç­¾å’Œè·³è½¬"><a href="#1-7-4-æ ‡ç­¾å’Œè·³è½¬" class="headerlink" title="1.7.4 æ ‡ç­¾å’Œè·³è½¬"></a>1.7.4 æ ‡ç­¾å’Œè·³è½¬</h3><ol><li>æ ‡ç­¾ Goè¯­è¨€ä½¿ç”¨æ ‡ç­¾ï¼ˆLableï¼‰æ¥æ ‡è¯†ä¸€ä¸ªè¯­å¥çš„ä½ç½®ï¼Œç”¨äºgotoã€breakã€continueè¯­å¥çš„è·³è½¬ã€‚æ ‡ç­¾çš„è¯­æ³•æ˜¯ï¼š <img src="/images/go_core_programming/Untitled%2027.png" alt="Untitled"></li><li>goto gotoè¯­å¥ç”¨äºå‡½æ•°çš„å†…éƒ¨è·³è½¬ï¼Œéœ€è¦é…åˆæ ‡ç­¾ä¸€èµ·ä½¿ç”¨ï¼š <img src="/images/go_core_programming/Untitled%2028.png" alt="Untitled"> gotoç‰¹ç‚¹ï¼š<ul><li>gotoè¯­å¥åªèƒ½åœ¨å‡½æ•°å†…è·³è½¬</li><li>gotoè¯­å¥ä¸èƒ½è·³è¿‡å†…éƒ¨å˜é‡å£°æ˜è¯­å¥ï¼Œè¿™äº›å˜é‡åœ¨gotoè¯­å¥çš„æ ‡ç­¾è¯­å¥å¤„æœ‰äº‹å¯è§çš„</li><li>gotoè¯­å¥åªèƒ½è°ƒåˆ°åŒçº§ä½œç”¨åŸŸæˆ–è€…ä¸Šå±‚ä½œç”¨åŸŸï¼Œä¸èƒ½è·³åˆ°å†…éƒ¨ä½œç”¨åŸŸ</li></ul></li><li>break breakç”¨äºå‡½æ•°å†…è·³å‡ºforã€switchã€selectè¯­å¥çš„æ‰§è¡Œï¼Œæœ‰ä¸¤ç§ä½¿ç”¨æ ¼å¼ï¼š<ul><li>å•ç‹¬ä½¿ç”¨ï¼šç”¨äºè·³å‡ºbreakå½“å‰æ‰€åœ¨çš„forã€switchã€selectè¯­å¥çš„æ‰§è¡Œ</li><li>å’Œæ ‡ç­¾ä¸€èµ·ä½¿ç”¨ï¼šç”¨äºè·³å‡ºæ ‡ç­¾æ‰€æ ‡è¯†çš„forã€switchã€selectè¯­å¥çš„æ‰§è¡Œï¼Œå¯ç”¨äºè·³å‡ºå¤šé‡å¾ªç¯ï¼Œä½†æ ‡ç­¾å’Œbreakå¿…é¡»åœ¨åŒä¸€ä¸ªå‡½æ•°å†…ï¼Œä¾‹å¦‚ï¼š  <img src="/images/go_core_programming/Untitled%2029.png" alt="Untitled"></li></ul></li><li>continue continueç”¨äºè·³å‡ºforå¾ªç¯çš„æœ¬æ¬¡è¿­ä»£ï¼Œè·³åˆ°forå¾ªç¯çš„ä¸‹ä¸€æ¬¡è¿­ä»£çš„postè¯­å¥å¤„æ‰§è¡Œï¼Œæœ‰ä¸¤ç§ä½¿ç”¨æ ¼å¼ï¼š<ul><li><p>å•ç‹¬ä½¿ç”¨ï¼šè·³å‡ºcontinueå½“å‰æ‰€åœ¨çš„forå¾ªç¯çš„æœ¬æ¬¡è¿­ä»£</p></li><li><p>å’Œæ ‡ç­¾ä¸€èµ·ä½¿ç”¨ï¼šè·³å‡ºæ ‡ç­¾æ‰€æ ‡ç¤ºçš„forè¯­å¥çš„æœ¬æ¬¡è¿­ä»£ï¼Œä½†æ ‡ç­¾å’Œcontinueå¿…é¡»åœ¨åŒä¸€ä¸ªå‡½æ•°å†…ï¼Œä¾‹å¦‚ï¼š</p><p><img src="/images/go_core_programming/Untitled%2030.png" alt="Untitled"></p></li></ul></li><li>returnå’Œå‡½æ•°è°ƒç”¨ returnè¯­å¥ä¹Ÿèƒ½å¼•å‘æ§åˆ¶æµç¨‹çš„è·³è½¬ï¼Œç”¨äºå‡½æ•°å’Œæ–¹æ³•çš„é€€å‡ºã€‚</li></ol><h2 id="é—®é¢˜"><a href="#é—®é¢˜" class="headerlink" title="é—®é¢˜"></a>é—®é¢˜</h2><ol><li><p><code>slice</code> å’Œ <code>array</code> åŒºåˆ«</p><ul><li>åˆ›å»ºæ–¹å¼ä¸åŒï¼šæ•°ç»„<code>var identifier [len]type</code> ï¼›åˆ‡ç‰‡<code>var slice3 = []int{}</code></li><li><code>slice</code>çš„<code>array</code>å®é™…ä¸Šæ˜¯æ•°ç»„çš„æŒ‡é’ˆï¼Œæ‰€ä»¥ä½œä¸ºå‡½æ•°å‚æ•°ä¼ é€’æ—¶ä¸åŒï¼šæ•°ç»„ä¼ é€’çš„æ˜¯æ•°ç»„çš„å‰¯æœ¬ï¼›<code>slice</code>ä¼ é€’çš„æ˜¯æ•°ç»„çš„æŒ‡é’ˆ</li><li>é•¿åº¦æ˜¯å¦å›ºå®šï¼šæ•°ç»„é•¿åº¦å›ºå®šï¼›åˆ‡ç‰‡çš„é•¿åº¦æ˜¯ä¸å›ºå®šçš„ï¼Œå¯ä»¥è¿½åŠ å…ƒç´ ï¼Œåœ¨è¿½åŠ æ—¶å¯èƒ½ä½¿åˆ‡ç‰‡çš„å®¹é‡å¢å¤§</li></ul></li><li><p>structèƒ½ä¸èƒ½æ¯”è¾ƒï¼Ÿ<a href="https://juejin.cn/post/6881912621616857102">https://juejin.cn/post/6881912621616857102</a> </p></li><li><p>sliceï¼Œlenï¼Œcapï¼Œå…±äº«ï¼Œæ‰©å®¹</p></li><li><p>for å¾ªç¯éå† slice æœ‰ä»€ä¹ˆé—®é¢˜</p><ul><li>for rang Aï¼Œæ˜¯å¯¹Açš„å€¼æ‹·è´ï¼Œé—®é¢˜ä»£ç ï¼š<pre><code class="go">func TestName(t *testing.T) {    s :=[]int{1,2,3,4}    m :=make(map[int]*int)    for k,v:=range s{        m[k]= &amp;v    }    for key, value := range m {        fmt.Printf("map[%v]=%v\n", key, *value)    }    fmt.Println(m)}</code></pre>  æ”¹æ­£ï¼š<pre><code class="go">func TestName(t *testing.T) {    s := []int{1, 2, 3, 4}    m := make(map[int]*int)    for k, v := range s {        // è¿™é‡Œå˜åŠ¨        n := v        m[k] = &amp;n    }    for key, value := range m {        fmt.Printf("map[%v]=%v\n", key, *value)    }    fmt.Println(m)}</code></pre></li></ul></li><li><p>è¯·ä½ è¯´è¯´golangçš„CSPæ€æƒ³</p></li><li><p>è¿›ç¨‹ï¼Œåç¨‹ï¼Œçº¿ç¨‹å„è‡ªçš„ä¼˜ç¼ºç‚¹</p></li></ol><h1 id="ç¬¬-2-ç« -å‡½æ•°"><a href="#ç¬¬-2-ç« -å‡½æ•°" class="headerlink" title="ç¬¬ 2 ç«  å‡½æ•°"></a>ç¬¬ 2 ç«  å‡½æ•°</h1><p>Goä¸­çš„å‡½æ•°ï¼š</p><ul><li>å‡½æ•°æ˜¯ä¸€ç§ç±»å‹ï¼Œå‡½æ•°ç±»å‹å˜é‡å¯ä»¥å‘å…¶ä»–ç±»å‹å˜é‡ä¸€æ ·ä½¿ç”¨ï¼Œå¯ä»¥ä½œä¸ºå…¶å®ƒå‡½æ•°çš„å‚æ•°æˆ–è¿”å›å€¼ï¼Œä¹Ÿå¯ä»¥ç›´æ¥è°ƒç”¨æ‰§è¡Œ</li><li>å‡½æ•°æ”¯æŒå¤šå€¼è¿”å›</li><li>æ”¯æŒé—­åŒ…</li><li>å‡½æ•°æ”¯æŒå¯å˜å‚æ•°</li></ul><h2 id="2-1-åŸºæœ¬æ¦‚å¿µ"><a href="#2-1-åŸºæœ¬æ¦‚å¿µ" class="headerlink" title="2.1 åŸºæœ¬æ¦‚å¿µ"></a>2.1 åŸºæœ¬æ¦‚å¿µ</h2><h3 id="2-1-1-å‡½æ•°å®šä¹‰"><a href="#2-1-1-å‡½æ•°å®šä¹‰" class="headerlink" title="2.1.1 å‡½æ•°å®šä¹‰"></a>2.1.1 å‡½æ•°å®šä¹‰</h3><p>åŒ…æ‹¬å¦‚ä¸‹å‡ ä¸ªéƒ¨åˆ†ï¼š</p><ul><li>å‡½æ•°å£°æ˜å…³é”®å­—func</li><li>å‡½æ•°å</li><li>å‚æ•°åˆ—è¡¨</li><li>è¿”å›åˆ—è¡¨å’Œå‡½æ•°ä½“</li></ul><p>å‡½æ•°çš„ç‰¹ç‚¹ï¼š</p><ul><li>å‡½æ•°å¯ä»¥æ²¡æœ‰è¾“å…¥å‚æ•°ï¼Œä¹Ÿå¯ä»¥æ²¡æœ‰è¿”å›å€¼ï¼ˆé»˜è®¤è¿”å›0ï¼‰</li><li>å¤šä¸ªç›¸é‚»çš„ç›¸åŒç±»å‹çš„å‚æ•°å¯ä»¥ä½¿ç”¨ç®€å†™æ¨¡å¼</li><li>æ”¯æŒæœ‰åçš„è¿”å›å€¼ï¼Œå‚æ•°åå°±ç›¸å½“äºå‡½æ•°ä½“å†…æœ€å¤–å±‚çš„å±€éƒ¨å˜é‡ï¼Œå‘½åè¿”å›å€¼å˜é‡ä¼šè¢«åˆå§‹åŒ–æˆç±»å‹é›¶å€¼</li><li>ä¸æ”¯æŒé»˜è®¤å€¼å‚æ•°</li><li>ä¸æ”¯æŒå‡½æ•°é‡è½½</li><li>ä¸æ”¯æŒå‡½æ•°åµŒå¥—ï¼Œä¸¥æ ¼çš„è¯´æ˜¯ä¸æ”¯æŒå‘½åå‡½æ•°çš„åµŒå¥—å®šä¹‰ï¼Œä½†æ”¯æŒåµŒå¥—åŒ¿åå‡½æ•°</li></ul><h3 id="2-1-2-å¤šå€¼è¿”å›"><a href="#2-1-2-å¤šå€¼è¿”å›" class="headerlink" title="2.1.2 å¤šå€¼è¿”å›"></a>2.1.2 å¤šå€¼è¿”å›</h3><p>ä¹ æƒ¯ç”¨æ³•ï¼šå¦‚æœå¤šå€¼è¿”å›ä¹‹æœ‰é”™è¯¯ç±»å‹ï¼Œåˆ™ä¸€èˆ¬å°†é”™è¯¯ç±»å‹ä½œä¸ºæœ€åä¸€ä¸ªè¿”å›å€¼</p><h3 id="2-1-3-å®å‚åˆ°å½¢å‚çš„ä¼ é€’"><a href="#2-1-3-å®å‚åˆ°å½¢å‚çš„ä¼ é€’" class="headerlink" title="2.1.3 å®å‚åˆ°å½¢å‚çš„ä¼ é€’"></a>2.1.3 å®å‚åˆ°å½¢å‚çš„ä¼ é€’</h3><p>Goå‡½æ•°å®å‚åˆ°å½¢å‚çš„ä¼ é€’æ°¸è¿œæ˜¯å€¼æ‹·è´ã€‚æœ‰æ—¶å‡½æ•°è°ƒç”¨åå®å‚æŒ‡å‘çš„å€¼å‘ç”Ÿäº†å˜åŒ–ï¼Œé‚£æ˜¯å› ä¸ºå‚æ•°ä¼ é€’çš„æ˜¯æŒ‡é’ˆå€¼çš„æ‹·è´ï¼Œå®å‚æ˜¯ä¸€ä¸ªæŒ‡é’ˆå˜é‡ï¼Œä¼ é€’ç»™å½¢å‚çš„æ˜¯è¿™ä¸ªæŒ‡é’ˆå˜é‡çš„å‰¯æœ¬ï¼ŒäºŒè€…æŒ‡å‘åŒä¸€åœ°å€ã€‚</p><h3 id="2-1-4-ä¸å®šå‚æ•°"><a href="#2-1-4-ä¸å®šå‚æ•°" class="headerlink" title="2.1.4 ä¸å®šå‚æ•°"></a>2.1.4 ä¸å®šå‚æ•°</h3><p>Goæ”¯æŒä¸å®šæ•°æ®çš„å½¢å¼å‚æ•°ï¼Œå£°æ˜ä½¿ç”¨<code>param ...type</code> .</p><p>ä¸å®šå‚æ•°ç‰¹ç‚¹ï¼š</p><ul><li>æ‰€æœ‰çš„ä¸å®šå‚æ•°ç±»å‹å¿…é¡»æ˜¯ç›¸åŒçš„</li><li>ä¸å®šå‚æ•°å¿…é¡»æ˜¯å‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°</li><li>ä¸å®šå‚æ•°åœ¨å‡½æ•°ä½“å†…ç›¸å½“äºåˆ‡ç‰‡ï¼Œå¯¹åˆ‡ç‰‡çš„æ“ä½œåŒæ ·é€‚åˆå¯¹ä¸å®šå‚æ•°çš„æ“ä½œ</li><li>åˆ‡ç‰‡å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ç»™ä¸å®šå‚æ•°ï¼Œåˆ‡ç‰‡ååè¦åŠ ä¸Šâ€â€¦â€</li><li>å½¢å‚ä¸ºä¸å®šå‚æ•°çš„å‡½æ•°å’Œå½¢å‚ä¸ºåˆ‡ç‰‡çš„å‡½æ•°ç±»å‹ä¸ç›¸åŒ</li></ul><h2 id="2-2-å‡½æ•°ç­¾åå’ŒåŒ¿åå‡½æ•°"><a href="#2-2-å‡½æ•°ç­¾åå’ŒåŒ¿åå‡½æ•°" class="headerlink" title="2.2 å‡½æ•°ç­¾åå’ŒåŒ¿åå‡½æ•°"></a>2.2 å‡½æ•°ç­¾åå’ŒåŒ¿åå‡½æ•°</h2><h3 id="2-2-1-å‡½æ•°ç­¾å"><a href="#2-2-1-å‡½æ•°ç­¾å" class="headerlink" title="2.2.1 å‡½æ•°ç­¾å"></a>2.2.1 å‡½æ•°ç­¾å</h3><p>å‡½æ•°ç±»å‹åˆå«å‡½æ•°ç­¾åï¼Œå¯ä»¥ä½¿ç”¨fmt.Printfçš„%Tæ ¼å¼åŒ–å‚æ•°æ‰“å°å‡½æ•°çš„ç±»å‹</p><h3 id="2-2-2-åŒ¿åå‡½æ•°"><a href="#2-2-2-åŒ¿åå‡½æ•°" class="headerlink" title="2.2.2 åŒ¿åå‡½æ•°"></a>2.2.2 åŒ¿åå‡½æ•°</h3><p>Goæä¾›ä¸¤ç§å‡½æ•°ï¼šæœ‰åå‡½æ•°å’ŒåŒ¿åå‡½æ•°</p><p>åŒ¿åå‡½æ•°å¯ä»¥ç›´æ¥å¤åˆ¶ç»™å‡½æ•°å˜é‡ï¼Œå¯ä»¥å½“åšå®å‚ï¼Œä¹Ÿå¯ä»¥ä½œä¸ºè¿”å›å€¼ï¼Œè¿˜å¯ä»¥ç›´æ¥è¢«è°ƒç”¨ã€‚</p><h2 id="2-3-defer"><a href="#2-3-defer" class="headerlink" title="2.3 defer"></a>2.3 defer</h2><p>Goæä¾›äº†deferå…³é”®å­—ï¼Œå¯ä»¥æ³¨å†Œå¤šä¸ªå»¶è¿Ÿè°ƒç”¨ï¼Œè¿™äº›è°ƒç”¨ä»¥å…ˆè¿›åå‡ºçš„é¡ºåºåœ¨å‡½æ•°è¿”å›å‰è¢«æ‰§è¡Œã€‚è¿™æœ‰ç‚¹ç±»ä¼¼äºJavaè¯­è¨€ä¸­å¼‚å¸¸å¤„ç†çš„finalyè¯­å¥ã€‚</p><p>deferå¸¸ç”¨è¯­ä¿è¯ä¸€äº›èµ„æºæœ€ç»ˆä¸€å®šèƒ½å¤Ÿå¾—åˆ°å›æ”¶å’Œé‡Šæ”¾ã€‚</p><p>ç‰¹ç‚¹ï¼š</p><ul><li>deferåé¢å¿…é¡»æ˜¯å‡½æ•°æˆ–æ–¹æ³•çš„è°ƒç”¨ï¼Œä¸èƒ½æ˜¯è¯­å¥</li><li>deferå‡½æ•°çš„å®å‚åœ¨æ³¨å†Œæ—¶é€šè¿‡å€¼æ‹·è´ä¼ é€’è¿›å»</li><li>deferè¯­å¥å¿…é¡»å…ˆæ³¨å†Œåæ‰èƒ½æ‰§è¡Œ</li></ul><p>ä¼˜åŠ¿ï¼šå¯ä»¥åœ¨ä¸€å®šç¨‹åº¦ä¸Šé¿å…èµ„æºæ³„éœ²</p><p>ç¼ºç‚¹ï¼š</p><ul><li>deferä¼šæ¨è¿Ÿèµ„æºçš„é‡Šæ”¾</li><li>deferä¸è¦å†™åœ¨å¾ªç¯è¯­å¥é‡Œé¢</li><li>deferæœ€å¥½ä¸è¦å¯¹æœ‰åè¿”å›å€¼å‚æ•°è¿›è¡Œæ“ä½œ</li></ul><h2 id="2-4-é—­åŒ…"><a href="#2-4-é—­åŒ…" class="headerlink" title="2.4 é—­åŒ…"></a>2.4 é—­åŒ…</h2><p>é—­åŒ…æ˜¯ç”±å‡½æ•°åŠå…¶ç›¸å…³å¼•ç”¨ç¯å¢ƒç»„åˆè€Œæˆçš„å®ä½“ã€‚</p><p><code>é—­åŒ… = å‡½æ•° + å¼•ç”¨ç¯å¢ƒ</code></p><ol><li>é—­åŒ…å¯¹é—­åŒ…å¤–çš„ç¯å¢ƒå¼•å…¥æ˜¯ç›´æ¥å¼•ç”¨ï¼Œç¼–è¯‘å™¨æ£€æµ‹åˆ°é—­åŒ…ä¼šå°†é—­åŒ…å¼•ç”¨çš„å¤–éƒ¨å˜é‡åˆ†é…åˆ°å †ä¸Š</li><li>å¦‚æœå‡½æ•°è¿”å›çš„é—­åŒ…å¼•ç”¨äº†è¯¥å‡½æ•°çš„å±€éƒ¨å˜é‡ï¼ˆå‚æ•°æˆ–å‡½æ•°å†…éƒ¨å˜é‡ï¼‰<ol><li>å¤šæ¬¡è°ƒç”¨è¯¥å‡½æ•°è¿”å›çš„å¤šä¸ªé—­åŒ…æ‰€å¼•ç”¨çš„å¤–éƒ¨å˜é‡æ˜¯å¤šä¸ªå‰¯æœ¬ï¼ŒåŸå› æ˜¯æ¯æ¬¡è°ƒç”¨å‡½æ•°éƒ½ä¼šä¸ºå±€éƒ¨å˜é‡åˆ†é…å†…å­˜</li><li>ç”¨ä¸€ä¸ªé—­åŒ…å‡½æ•°å¤šæ¬¡ï¼Œå¦‚æœè¯¥é—­åŒ…ä¿®æ”¹äº†å…¶å¼•ç”¨çš„å¤–éƒ¨å˜é‡ï¼Œåˆ™æ¯ä¸€æ¬¡è°ƒç”¨è¯¥é—­åŒ…å¯¹è¯¥å¤–åŒ…å˜é‡éƒ½æœ‰å½±å“ï¼Œå› ä¸ºé—­åŒ…å‡½æ•°å…±äº«å¤–éƒ¨å¼•ç”¨</li></ol></li></ol><h3 id="2-4-2-é—­åŒ…çš„ä»·å€¼"><a href="#2-4-2-é—­åŒ…çš„ä»·å€¼" class="headerlink" title="2.4.2 é—­åŒ…çš„ä»·å€¼"></a>2.4.2 é—­åŒ…çš„ä»·å€¼</h3><p>å¯¹è±¡æ˜¯é™„æœ‰è¡Œä¸ºçš„æ•°æ®ï¼Œé—­åŒ…æ˜¯é™„æœ‰æ•°æ®çš„è¡Œä¸ºã€‚</p><h2 id="2-5-panicå’Œrecover"><a href="#2-5-panicå’Œrecover" class="headerlink" title="2.5 panicå’Œrecover"></a>2.5 panicå’Œrecover</h2><p>panicç”¨æ¥ä¸»åŠ¨æŠ›å‡ºé”™è¯¯</p><p>recoverç”¨æ¥æ•è·panicæŠ›å‡ºçš„é”™è¯¯</p><h3 id="2-5-1-åŸºæœ¬æ¦‚å¿µ"><a href="#2-5-1-åŸºæœ¬æ¦‚å¿µ" class="headerlink" title="2.5.1 åŸºæœ¬æ¦‚å¿µ"></a>2.5.1 åŸºæœ¬æ¦‚å¿µ</h3><p><img src="/images/go_core_programming/Untitled%2031.png" alt="Untitled"></p><p>å¼•å‘panicçš„æƒ…å†µï¼š</p><ul><li>ç¨‹åºä¸»åŠ¨è°ƒç”¨panicå‡½æ•°</li><li>ç¨‹åºäº§ç”Ÿè¿è¡Œæ—¶é”™è¯¯ï¼Œç”±è¿è¡Œæ—¶æ£€æµ‹å¹¶æŠ›å‡º</li></ul><p>recoverç”¨æ¥æ•è·panicï¼Œé˜»æ­¢panicç»§ç»­å‘ä¸Šä¼ é€’</p><h3 id="2-5-2-ä½¿ç”¨åœºæ™¯"><a href="#2-5-2-ä½¿ç”¨åœºæ™¯" class="headerlink" title="2.5.2 ä½¿ç”¨åœºæ™¯"></a>2.5.2 ä½¿ç”¨åœºæ™¯</h3><ul><li>ç¨‹åºé‡åˆ°äº†æ— æ³•æ­£å¸¸æ‰§è¡Œä¸‹å»çš„é”™è¯¯ï¼Œä¸»åŠ¨è°ƒç”¨panicå‡½æ•°ç»“æŸç¨‹åºè¿è¡Œ</li><li>åœ¨è°ƒè¯•ç¨‹åºæ—¶ï¼Œé€šè¿‡ä¸»åŠ¨è°ƒç”¨panicå®ç°å¿«é€Ÿé€€å‡ºï¼Œpanicæ‰“å°å‡ºçš„å †æ ˆèƒ½å¤Ÿæ›´å¿«çš„å®šä½é”™è¯¯</li></ul><h2 id="2-6-é”™è¯¯å¤„ç†"><a href="#2-6-é”™è¯¯å¤„ç†" class="headerlink" title="2.6 é”™è¯¯å¤„ç†"></a>2.6 é”™è¯¯å¤„ç†</h2><h3 id="2-6-1-error"><a href="#2-6-1-error" class="headerlink" title="2.6.1 error"></a>2.6.1 error</h3><p>Goè¯­è¨€å†…ç½®é”™è¯¯æ¥å£ç±»å‹error</p><p>é”™è¯¯å¤„ç†çš„æœ€ä½³å®è·µï¼š</p><ul><li>åœ¨å¤šä¸ªè¿”å›å€¼çš„å‡½æ•°ä¸­ï¼Œerroré€šå¸¸ä½œä¸ºå‡½æ•°æœ€åä¸€ä¸ªè¿”å›å€¼</li><li>å¦‚æœä¸€ä¸ªå‡½æ•°è¿”å›errorç±»å‹å˜é‡ï¼Œåˆ™å…ˆç”¨ifè¯­å¥å¤„ç†<code>error != nil</code> çš„å¼‚å¸¸åœºæ™¯ï¼Œæ­£å¸¸é€»è¾‘æ”¾åˆ°ifè¯­å¥å—åé¢ä¿æŒä»£ç å¹³å¦</li><li>deferè¯­å¥åº”è¯¥æ”¾åˆ°erråˆ¤æ–­çš„åé¢ï¼Œä¸ç„¶æœ‰å¯èƒ½äº§ç”Ÿpanic</li><li>åœ¨é”™è¯¯é€çº§å‘ä¸Šä¼ é€’çš„è¿‡ç¨‹ä¸­ï¼Œé”™è¯¯ä¿¡æ¯åº”è¯¥ä¸æ–­åœ°ä¸°å¯Œå’Œå®Œå–„ï¼Œè€Œä¸æ˜¯ç®€å•æŠ›å‡ºä¸‹å±‚è°ƒç”¨çš„é”™è¯¯</li></ul><pre><code class="go">func deferDemo() error {    err := createResource1()    if err != nil {        return ERR_CREATE_RESOURCE1_FAILED    }    defer func() {        if err != nil {            destroyResource1()        }    }()}</code></pre><h3 id="2-6-2-é”™è¯¯å’Œå¼‚å¸¸"><a href="#2-6-2-é”™è¯¯å’Œå¼‚å¸¸" class="headerlink" title="2.6.2 é”™è¯¯å’Œå¼‚å¸¸"></a>2.6.2 é”™è¯¯å’Œå¼‚å¸¸</h3><p>Goç¨‹åºéœ€è¦å¤„ç†çš„é”™è¯¯ç±»å‹ï¼š</p><ul><li>è¿è¡Œæ—¶é”™è¯¯ï¼šæ— æ³•é¿å…ï¼Œå¯ä»¥recoverè¿™äº›panic</li><li>ç¨‹åºé€»è¾‘é”™è¯¯</li></ul><p>errorå’Œpanicåº”è¯¥éµå¾ªå¦‚ä¸‹åŸåˆ™ï¼š</p><ul><li>ç¨‹åºå‘ç”Ÿçš„é”™è¯¯å¯¼è‡´ç¨‹åºä¸èƒ½å®¹é”™ç»§ç»­æ‰§è¡Œï¼Œæ­¤æ—¶ç¨‹åºåº”è¯¥ä¸»åŠ¨è°ƒç”¨panicæˆ–ç”±è¿è¡Œæ—¶æŠ›å‡ºpanic</li><li>ç¨‹åºè™½ç„¶å‘ç”Ÿé”™è¯¯ï¼Œä½†æ˜¯ç¨‹åºèƒ½å¤Ÿå®¹é”™ç»§ç»­æ‰§è¡Œï¼Œæ­¤æ—¶åº”è¯¥ä½¿ç”¨é”™è¯¯è¿”å›å€¼çš„æ–¹å¼å¤„ç†é”™è¯¯ï¼Œæˆ–è€…åœ¨å¯èƒ½å‘ç”Ÿè¿è¡Œæ—¶é”™è¯¯çš„éå…³é”®åˆ†æ”¯ä¸Šä½¿ç”¨recoveræ•è·panic</li></ul><pre><code class="go">func TestName(t *testing.T) {    height := []int{2,3,4,5,18,17,6}    defer func() {        if err := recover(); err != nil {            fmt.Println(err)        }    }()    print(height[10])}</code></pre><h2 id="2-7-åº•å±‚å®ç°"><a href="#2-7-åº•å±‚å®ç°" class="headerlink" title="2.7 åº•å±‚å®ç°"></a>2.7 åº•å±‚å®ç°</h2><h1 id="ç¬¬-3-ç« -ç±»å‹ç³»ç»Ÿ"><a href="#ç¬¬-3-ç« -ç±»å‹ç³»ç»Ÿ" class="headerlink" title="ç¬¬ 3 ç«  ç±»å‹ç³»ç»Ÿ"></a>ç¬¬ 3 ç«  ç±»å‹ç³»ç»Ÿ</h1><h2 id="3-1-ç±»å‹ç®€ä»‹"><a href="#3-1-ç±»å‹ç®€ä»‹" class="headerlink" title="3.1 ç±»å‹ç®€ä»‹"></a>3.1 ç±»å‹ç®€ä»‹</h2><h3 id="3-1-1-å‘½åç±»å‹å’Œæœªå‘½åç±»å‹"><a href="#3-1-1-å‘½åç±»å‹å’Œæœªå‘½åç±»å‹" class="headerlink" title="3.1.1 å‘½åç±»å‹å’Œæœªå‘½åç±»å‹"></a>3.1.1 å‘½åç±»å‹å’Œæœªå‘½åç±»å‹</h3><p>å‘½åç±»å‹ï¼šå¯ä»¥é€šè¿‡æ ‡è¯†ç¬¦æ¥è¡¨ç¤ºï¼ˆ3.2èŠ‚è¯¦ç»†ä»‹ç»ï¼‰</p><p>æœªå‘½åç±»å‹ï¼šä¸€ä¸ªç±»å‹ç”±é¢„å£°æ˜ç±»å‹ã€å…³é”®å­—å’Œæ“ä½œç¬¦ç»„åˆè€Œæˆï¼Œåˆç§°ä¸ºç±»å‹å­—é¢é‡ã€‚ä¾‹å¦‚ï¼šæ•°ç»„ï¼ˆarrayï¼‰ã€åˆ‡ç‰‡ï¼ˆsliceï¼‰ã€å­—å…¸ï¼ˆmapï¼‰ã€é€šé“ï¼ˆchannelï¼‰ã€æŒ‡é’ˆï¼ˆpointerï¼‰ã€å‡½æ•°å­—é¢é‡ï¼ˆfunctionï¼‰ã€ç»“æ„ï¼ˆstructï¼‰å’Œæ¥å£ï¼ˆinterfaceï¼‰éƒ½å±äºç±»å‹å­—é¢é‡</p><h3 id="3-1-2-åº•å±‚ç±»å‹"><a href="#3-1-2-åº•å±‚ç±»å‹" class="headerlink" title="3.1.2 åº•å±‚ç±»å‹"></a>3.1.2 åº•å±‚ç±»å‹</h3><p>æ‰€æœ‰â€œç±»å‹â€éƒ½æœ‰ä¸€ä¸ªunderlying typeï¼ˆåº•å±‚ç±»å‹ï¼‰ã€‚åº•å±‚ç±»å‹çš„è§„åˆ™å¦‚ä¸‹ï¼š</p><ul><li>é¢„å£°æ˜ç±»å‹ï¼ˆPre-declared typesï¼‰å’Œç±»å‹å­—é¢é‡ï¼ˆtype literalsï¼‰çš„åº•å±‚ç±»å‹æ˜¯ä»–ä»¬è‡ªèº«</li><li>è‡ªå®šä¹‰ç±»å‹type newtype oldtypeä¸­çš„newtypeçš„åº•å±‚æ˜¯é€å±‚é€’å½’å‘ä¸‹æŸ¥æ‰¾çš„ï¼ŒçŸ¥é“æŸ¥åˆ°çš„oldtypeæ˜¯é¢„å£°æ˜ç±»å‹ï¼ˆPre-declared typesï¼‰æˆ–ç±»å‹å­—é¢é‡ï¼ˆtype literalsï¼‰ä¸ºæ­¢ã€‚</li></ul><h3 id="3-1-3-ç±»å‹ç›¸åŒå’Œç±»å‹èµ‹å€¼"><a href="#3-1-3-ç±»å‹ç›¸åŒå’Œç±»å‹èµ‹å€¼" class="headerlink" title="3.1.3 ç±»å‹ç›¸åŒå’Œç±»å‹èµ‹å€¼"></a>3.1.3 ç±»å‹ç›¸åŒå’Œç±»å‹èµ‹å€¼</h3><p><strong>ç±»å‹ç›¸åŒ</strong></p><p>Goæ˜¯å¼ºç±»å‹çš„è¯­è¨€ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶ä¼šè¿›è¡Œä¸¥æ ¼çš„ç±»å‹æ ¡éªŒã€‚ä¸¤ä¸ªå‘½åç±»å‹æ˜¯å¦ç›¸åŒçš„åˆ¤æ–­ï¼š</p><ul><li>ä¸¤ä¸ªå‘½åç±»å‹ç›¸åŒçš„æ¡ä»¶æ˜¯ä¸¤ä¸ªç±»å‹å£°æ˜çš„è¯­å¥å®Œå…¨ç›¸åŒ</li><li>å‘½åç±»å‹å’Œæœªå‘½ä»¤ç±»å‹æ°¸è¿œä¸ç›¸åŒ</li><li>ä¸¤ä¸ªæœªå‘½åç±»å‹ç›¸åŒçš„æ¡ä»¶æ˜¯ä»–ä»¬çš„ç±»å‹å£°æ˜å­—é¢é‡çš„ç»“æ„ç›¸åŒï¼Œå¹¶ä¸”å†…éƒ¨å…ƒç´ çš„ç±»å‹ç›¸åŒ</li><li>é€šè¿‡ç±»å‹åˆ«åè¯­å¥å£°æ˜çš„ä¸¤ä¸ªç±»å‹ç›¸åŒ</li></ul><p><strong>ç±»å‹å¯ç›´æ¥èµ‹å€¼</strong></p><p>ç±»å‹ä¸ºT1çš„å˜é‡aå¯ä»¥èµ‹å€¼ç»™ç±»å‹ä¸ºT2çš„å˜é‡bï¼Œç§°ä¸ºç±»å‹T1å¯ä»¥èµ‹å€¼ç»™ç±»å‹T2ï¼Œä¼ªä»£ç ï¼š</p><pre><code class="go">var b T2 = a</code></pre><p>aå¯ä»¥èµ‹å€¼ç»™å˜é‡bå¿…é¡»è¦æ»¡è¶³å¦‚ä¸‹æ¡ä»¶ä¸­çš„ä¸€ä¸ªï¼š</p><ul><li>T1å’ŒT2çš„ç±»å‹ç›¸åŒ</li><li>T1å’ŒT2å…·æœ‰ç›¸åŒçš„åº•å±‚ç±»å‹ï¼Œå¹¶ä¸”T1å’ŒT2é‡Œé¢è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯æœªå‘½åç±»å‹</li><li>T2æ˜¯æ¥å£ç±»å‹ï¼ŒT1æ˜¯å…·ä½“ç±»å‹ï¼ŒT1çš„æ–¹æ³•é›†æ˜¯T2æ–¹æ³•é›†çš„è¶…çº§</li><li>T1å’ŒT2éƒ½æ˜¯é€šé“ç±»å‹ï¼Œä»–ä»¬æ‹¥æœ‰ç›¸åŒçš„å…ƒç´ ç±»å‹ï¼Œå¹¶ä¸”T1å’ŒT2è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯æœªå‘½åç±»å‹</li><li>aæ˜¯é¢„å£°æ˜æ ‡è¯†ç¬¦nilï¼ŒT2æ˜¯pointerã€functionã€sliceã€mapã€channelã€interfaceç±»å‹ä¸­çš„ä¸€ä¸ª</li><li>aæ˜¯ä¸€ä¸ªå­—é¢å¸¸é‡å€¼ï¼Œå¯ä»¥ç”¨æ¥è¡¨ç¤ºç±»å‹Tçš„å€¼</li></ul><h3 id="3-1-4-ç±»å‹å¼ºåˆ¶è½¬æ¢"><a href="#3-1-4-ç±»å‹å¼ºåˆ¶è½¬æ¢" class="headerlink" title="3.1.4 ç±»å‹å¼ºåˆ¶è½¬æ¢"></a>3.1.4 ç±»å‹å¼ºåˆ¶è½¬æ¢</h3><p>ç”±äºGoæ˜¯å¼ºç±»å‹çš„è¯­è¨€ï¼Œå¦‚æœä¸æ»¡è¶³è‡ªåŠ¨è½¬æ¢çš„æ¡ä»¶ï¼Œåˆ™å¿…é¡»è¿›è¡Œå¼ºåˆ¶ç±»å‹è½¬æ¢ã€‚</p><p>éå¸¸é‡ç±»å‹çš„å˜é‡xå¯ä»¥å¼ºåˆ¶è½¬åŒ–å¹¶ä¼ é€’ç»™ç±»å‹Tï¼Œéœ€è¦æ»¡è¶³å¦‚ä¸‹ä»»ä¸€æ¡ä»¶ï¼š</p><ul><li>xå¯ä»¥ç›´æ¥èµ‹å€¼ç»™Tç±»å‹å˜é‡</li><li>xç±»å‹å’ŒTå…·æœ‰ç›¸åŒçš„åº•å±‚ç±»å‹</li><li>xçš„ç±»å‹å’ŒTéƒ½æ˜¯æœªå‘½åçš„æŒ‡é’ˆç±»å‹ï¼Œå¹¶ä¸”æŒ‡é’ˆæŒ‡å‘çš„ç±»å‹å…·æœ‰ç›¸åŒçš„åº•å±‚ç±»å‹</li><li>xçš„ç±»å‹å’ŒTéƒ½æ˜¯æ•´å‹æˆ–è€…éƒ½æ˜¯æµ®ç‚¹å‹</li><li>xçš„ç±»å‹å’ŒTéƒ½æ˜¯å¤æ•°ç±»å‹</li><li>xæ˜¯æ•´æ•°å€¼æˆ–[]byteç±»å‹çš„å€¼ï¼ŒTæ˜¯stringç±»å‹</li><li>xæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ŒTæ˜¯[]byteæˆ–[]rune</li></ul><h2 id="3-2-ç±»å‹æ–¹æ³•"><a href="#3-2-ç±»å‹æ–¹æ³•" class="headerlink" title="3.2 ç±»å‹æ–¹æ³•"></a>3.2 ç±»å‹æ–¹æ³•</h2><h3 id="3-2-1-è‡ªå®šä¹‰ç±»å‹"><a href="#3-2-1-è‡ªå®šä¹‰ç±»å‹" class="headerlink" title="3.2.1 è‡ªå®šä¹‰ç±»å‹"></a>3.2.1 è‡ªå®šä¹‰ç±»å‹</h3><p>è‡ªå®šä¹‰ç±»å‹éƒ½æ˜¯å‘½åç±»å‹</p><p><img src="/images/go_core_programming/Untitled%2032.png" alt="Untitled"></p><p>è‡ªå®šä¹‰structç±»å‹</p><h3 id="3-2-2-æ–¹æ³•"><a href="#3-2-2-æ–¹æ³•" class="headerlink" title="3.2.2 æ–¹æ³•"></a>3.2.2 æ–¹æ³•</h3><p><img src="/images/go_core_programming/Untitled%2033.png" alt="Untitled"></p><p>ç±»å‹æ–¹æ³•æœ‰å¦‚ä¸‹ç‰¹ç‚¹ï¼š</p><ul><li>å¯ä»¥ä¸ºå‘½åç±»å‹å¢åŠ æ–¹æ³•ï¼ˆé™¤äº†æ¥å£ï¼‰ï¼Œéå‘½åç±»å‹ä¸èƒ½è‡ªå®šä¹‰æ–¹æ³•</li><li>ä¸ºç±»å‹å¢åŠ æ–¹æ³•æœ‰ä¸€ä¸ªé™åˆ¶ï¼Œå°±æ˜¯æ–¹æ³•çš„å®šä¹‰å¿…é¡»å’Œç±»å‹çš„å®šä¹‰åœ¨åŒä¸€ä¸ªåŒ…ä¸­</li><li>æ–¹æ³•çš„å‘½åç©ºé—´å¯è§æ€§å’Œå˜é‡ä¸€æ ·ï¼Œå¤§å†™å¼€å¤´çš„æ–¹æ³•å¯ä¹Ÿåœ¨åŒ…å¤–è¢«è®¿é—®ï¼Œå¦åˆ™åªèƒ½åœ¨åŒ…å†…å¯è§</li><li>ä½¿ç”¨typeå®šä¹‰çš„è‡ªå®šä¹‰ç±»å‹æ˜¯ä¸€ä¸ªæ–°ç±»å‹ï¼Œæ–°ç±»å‹ä¸èƒ½è°ƒç”¨åŸæœ‰ç±»å‹çš„æ–¹æ³•ï¼Œä½†æ˜¯åº•å±‚ç±»å‹æ”¯æŒçš„è¿ç®—å¯ä»¥è¢«æ–°ç±»å‹ç»§æ‰¿</li></ul><p><img src="/images/go_core_programming/Untitled%2034.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2035.png" alt="Untitled"></p><h2 id="3-3-æ–¹æ³•è°ƒç”¨"><a href="#3-3-æ–¹æ³•è°ƒç”¨" class="headerlink" title="3.3 æ–¹æ³•è°ƒç”¨"></a>3.3 æ–¹æ³•è°ƒç”¨</h2><h3 id="3-3-1-ä¸€èˆ¬è°ƒç”¨"><a href="#3-3-1-ä¸€èˆ¬è°ƒç”¨" class="headerlink" title="3.3.1 ä¸€èˆ¬è°ƒç”¨"></a>3.3.1 ä¸€èˆ¬è°ƒç”¨</h3><p><img src="/images/go_core_programming/Untitled%2036.png" alt="Untitled"></p><h3 id="3-3-2-æ–¹æ³•å€¼"><a href="#3-3-2-æ–¹æ³•å€¼" class="headerlink" title="3.3.2 æ–¹æ³•å€¼"></a>3.3.2 æ–¹æ³•å€¼</h3><p><img src="/images/go_core_programming/Untitled%2037.png" alt="Untitled"></p><h3 id="3-3-3-æ–¹æ³•è¡¨è¾¾å¼"><a href="#3-3-3-æ–¹æ³•è¡¨è¾¾å¼" class="headerlink" title="3.3.3 æ–¹æ³•è¡¨è¾¾å¼"></a>3.3.3 æ–¹æ³•è¡¨è¾¾å¼</h3><p>æ–¹æ³•è¡¨è¾¾å¼ç›¸å½“äºæä¾›ä¸€ç§è¯­æ³•å°†ç±»å‹æ–¹æ³•è°ƒç”¨æ˜¾ç¤ºç¬¬è½¬æ¢ä¸ºå‡½æ•°è°ƒç”¨ï¼Œæ¥å—è€…å¿…é¡»æ˜¾ç¤ºåœ°ä¼ é€’è¿›å»ã€‚</p><h3 id="3-3-4-æ–¹æ³•é›†"><a href="#3-3-4-æ–¹æ³•é›†" class="headerlink" title="3.3.4 æ–¹æ³•é›†"></a>3.3.4 æ–¹æ³•é›†</h3><p>å‘½åç±»å‹æ–¹æ³•æ¥å—è€…æœ‰ä¸¤ç§ç±»å‹ï¼Œä¸€ä¸ªæ˜¯å€¼ç±»å‹ï¼Œå¦ä¸€ä¸ªæ˜¯æŒ‡é’ˆç±»å‹ï¼Œè¿™ä¸ªå’Œå‡½æ•°æ˜¯ä¸€æ ·çš„ï¼Œå‰è€…çš„å½¢å‚æ˜¯å€¼ç±»å‹ï¼Œåè€…çš„å½¢å‚æ˜¯æŒ‡é’ˆç±»å‹ã€‚</p><p>æ— è®ºæ¥å—è€…æ˜¯ä»€ä¹ˆç±»å‹ï¼Œæ–¹æ³•å’Œå‡½æ•°çš„å®å‚ä¼ é€’éƒ½æ˜¯å€¼æ‹·è´ï¼Œå¦‚æœæ¥å—è€…æ˜¯å€¼ç±»å‹ï¼Œåˆ™ä¼ é€’çš„æ˜¯å€¼çš„å‰¯æœ¬ï¼›å¦‚æœæ¥å—è€…æ˜¯æŒ‡é’ˆç±»å‹ï¼Œåˆ™ä¼ é€’çš„æ˜¯æŒ‡é’ˆçš„å‰¯æœ¬</p><h3 id="3-3-5-å€¼è°ƒç”¨å’Œè¡¨è¾¾å¼è°ƒç”¨çš„æ–¹æ³•é›†"><a href="#3-3-5-å€¼è°ƒç”¨å’Œè¡¨è¾¾å¼è°ƒç”¨çš„æ–¹æ³•é›†" class="headerlink" title="3.3.5 å€¼è°ƒç”¨å’Œè¡¨è¾¾å¼è°ƒç”¨çš„æ–¹æ³•é›†"></a>3.3.5 å€¼è°ƒç”¨å’Œè¡¨è¾¾å¼è°ƒç”¨çš„æ–¹æ³•é›†</h3><h2 id="3-4-ç»„åˆå’Œæ–¹æ³•é›†"><a href="#3-4-ç»„åˆå’Œæ–¹æ³•é›†" class="headerlink" title="3.4 ç»„åˆå’Œæ–¹æ³•é›†"></a>3.4 ç»„åˆå’Œæ–¹æ³•é›†</h2><p>ç»“æ„ç±»å‹ä¸ºGoæä¾›äº†å¼ºå¤§çš„ç±»å‹æ‰©å±•ï¼Œä¸»è¦ä½“ç°åœ¨ä¸¤ä¸ªæ–¹é¢ï¼š</p><ul><li>structå¯ä»¥åµŒå…¥ä»»æ„å…¶ä»–ç±»å‹çš„å­—æ®µ</li><li>structå¯ä»¥åµŒå¥—è‡ªèº«çš„æŒ‡é’ˆç±»å‹çš„å­—æ®µ</li></ul><h3 id="3-4-1-ç»„åˆ"><a href="#3-4-1-ç»„åˆ" class="headerlink" title="3.4.1 ç»„åˆ"></a>3.4.1 ç»„åˆ</h3><p>å› ä¸ºGoæ²¡æœ‰ç»§æ‰¿çš„è¯­ä¹‰ï¼Œç»“æ„å’Œå­—æ®µä¹‹é—´æ˜¯â€œhas aâ€çš„å…³ç³»è€Œä¸æ˜¯â€œis aâ€çš„å…³ç³»ï¼Œæ²¡æœ‰çˆ¶å­æ¦‚å¿µï¼Œä»…ä»…æ˜¯æ•´ä½“å’Œå±€éƒ¨çš„æ¦‚å¿µï¼Œæ‰€ä»¥åç»­ç»Ÿç§°è¿™ç§åµŒå¥—çš„ç»“æ„å’Œå­—æ®µçš„å…³ç³»ä¸ºç»„åˆ</p><h3 id="3-4-2-ç»„åˆçš„æ–¹æ³•é›†"><a href="#3-4-2-ç»„åˆçš„æ–¹æ³•é›†" class="headerlink" title="3.4.2 ç»„åˆçš„æ–¹æ³•é›†"></a>3.4.2 ç»„åˆçš„æ–¹æ³•é›†</h3><h2 id="3-5-å‡½æ•°ç±»å‹"><a href="#3-5-å‡½æ•°ç±»å‹" class="headerlink" title="3.5 å‡½æ•°ç±»å‹"></a>3.5 å‡½æ•°ç±»å‹</h2><h1 id="ç¬¬-4-ç« -æ¥å£ï¼ˆæœªçœ‹ï¼‰"><a href="#ç¬¬-4-ç« -æ¥å£ï¼ˆæœªçœ‹ï¼‰" class="headerlink" title="ç¬¬ 4 ç«  æ¥å£ï¼ˆæœªçœ‹ï¼‰"></a>ç¬¬ 4 ç«  æ¥å£ï¼ˆæœªçœ‹ï¼‰</h1><h1 id="ç¬¬-5-ç« -å¹¶å‘"><a href="#ç¬¬-5-ç« -å¹¶å‘" class="headerlink" title="ç¬¬ 5 ç«  å¹¶å‘"></a>ç¬¬ 5 ç«  å¹¶å‘</h1><h2 id="5-1-å¹¶å‘åŸºç¡€"><a href="#5-1-å¹¶å‘åŸºç¡€" class="headerlink" title="5.1 å¹¶å‘åŸºç¡€"></a>5.1 å¹¶å‘åŸºç¡€</h2><h3 id="5-1-1-å¹¶å‘å’Œå¹¶è¡Œ"><a href="#5-1-1-å¹¶å‘å’Œå¹¶è¡Œ" class="headerlink" title="5.1.1 å¹¶å‘å’Œå¹¶è¡Œ"></a>5.1.1 å¹¶å‘å’Œå¹¶è¡Œ</h3><ol><li>å¹¶è¡Œå°±æ˜¯åœ¨ä»»ä¸€ç²’åº¦çš„æ—¶é—´å†…éƒ½å…·å¤‡åŒæ—¶æ‰§è¡Œçš„èƒ½åŠ›ï¼šä¾‹å¦‚å¤šæœº</li><li>å¹¶å‘æ˜¯åœ¨è§„å®šçš„æ—¶é—´å†…å¤šä¸ªè¯·æ±‚éƒ½å¾—åˆ°æ‰§è¡Œå’Œå¤„ç†ï¼Œå¼ºè°ƒçš„æ˜¯ç»™å¤–ç•Œçš„æ„Ÿå—ï¼Œå®é™…ä¸Šå†…éƒ¨å¯èƒ½æ˜¯åˆ†æ—¶æ“ä½œçš„</li></ol><h3 id="5-1-2-goroutine"><a href="#5-1-2-goroutine" class="headerlink" title="5.1.2 goroutine"></a>5.1.2 goroutine</h3><p>Goè¯­è¨€çš„å¹¶å‘æ‰§è¡Œä½“ç§°ä¸ºgoroutineï¼Œé€šè¿‡goå…³é”®å­—æ¥å¯åŠ¨ä¸€ä¸ªgoroutineã€‚</p><p>goroutineç‰¹æ€§ï¼š</p><ul><li>goçš„æ‰§è¡Œæ˜¯éé˜»å¡çš„ï¼Œä¸ä¼šç­‰å¾…</li><li>goåé¢çš„å‡½æ•°çš„è¿”å›å€¼ä¼šè¢«å¿½ç•¥</li><li>è°ƒåº¦å™¨ä¸èƒ½ä¿è¯å¤šä¸ªgoroutineçš„æ‰§è¡Œæ¬¡åº</li><li>æ²¡æœ‰çˆ¶å­goroutineçš„æ¦‚å¿µï¼Œæ‰€æœ‰goroutneæ˜¯å¹³ç­‰åœ°è¢«è°ƒç”¨å’Œæ‰§è¡Œçš„</li><li>Goç¨‹åºåœ¨æ‰§è¡Œæ—¶ä¼šå•ç‹¬ä¸ºmainå‡½æ•°åˆ›å»ºä¸€ä¸ªgoroutineï¼Œé‡åˆ°å…¶ä»–goå…³é”®å­—æ—¶å†å»åˆ›å»ºå…¶ä»–çš„goroutinue</li><li>Goæ²¡æœ‰æš´éœ²goroutine idç»™ç”¨æˆ·ï¼Œæ‰€ä»¥ä¸èƒ½åœ¨ä¸€ä¸ªgoroutineé‡Œé¢æ˜¾å¼åœ°æ“ä½œå¦ä¸€ä¸ªgoroutineï¼Œä¸è¿‡runtimeåŒ…æä¾›äº†ä¸€äº›å‡½æ•°è®¿é—®å’Œè®¾ç½®goroutineçš„ç›¸å…³ä¿¡æ¯</li></ul><ol><li>func GOMAXPROCS</li></ol><p>è®¾ç½®æˆ–æŸ¥è¯¢å¯ä»¥å¹¶å‘æ‰§è¡Œçš„goroutineæ•°ç›®</p><pre><code class="go">package goroutine_testimport (    "runtime"    "testing")func TestName(t *testing.T) {    // è·å–GOMAXPROCS    println("GOMAXPROCS=",runtime.GOMAXPROCS(0))    // è®¾ç½®GOMAXPROCS    runtime.GOMAXPROCS(2)    // è·å–GOMAXPROCS    println("GOMAXPROCS=",runtime.GOMAXPROCS(0))}</code></pre><ol><li>func Goexit</li></ol><p>ç»“æŸå½“å‰goroutinueçš„è¿è¡Œã€‚Goexitä¸ä¼šäº§ç”Ÿpanicã€‚</p><ol><li>fun Gosched</li></ol><p>æ”¾å¼ƒå½“å‰è°ƒåº¦æ‰§è¡Œæœºä¼šï¼Œå°†å½“å‰goroutinueæ”¾åˆ°é˜Ÿåˆ—ä¸­ç­‰å¾…ä¸‹æ¬¡è¢«è°ƒåº¦</p><h3 id="5-1-3-chan"><a href="#5-1-3-chan" class="headerlink" title="5.1.3 chan"></a>5.1.3 chan</h3><ol><li>chanæ˜¯Goè¯­è¨€é‡Œé¢çš„ä¸€ä¸ªå…³é”®å­—ï¼Œæ˜¯channelçš„ç®€å†™ï¼Œé€šé“ã€‚é€šé“æ˜¯Goé€šè¿‡é€šä¿¡æ¥å…±äº«å†…å®¹çš„è½½ä½“ã€‚</li><li>é€šé“ç±»å‹ï¼š<ul><li><p>æœ‰ç¼“å†²çš„é€šé“ï¼šä¸»è¦ç”¨äºé€šä¿¡</p></li><li><p>æ— ç¼“å†²çš„é€šé“ï¼šæ—¢å¯ä»¥ç”¨äºé€šä¿¡ï¼Œä¹Ÿå¯ä»¥ç”¨äºä¸¤ä¸ªgoroutinueçš„åŒæ­¥</p><p><img src="/images/go_core_programming/Untitled%2038.png" alt="Untitled"></p><pre><code class="go">func TestName(t *testing.T) {  println("NumGoroutinue=", runtime.NumGoroutine())  c := make(chan struct{})  ci := make(chan int, 100)  go func(i chan struct{}, j chan int) {      for i := 0; i &lt; 10; i++ {          ci &lt;- i      }      close(ci)      // å†™é€šé“      c &lt;- struct{}{}  }(c, ci)  // NumGoroutinueå¯ä»¥è¿”å›å½“å‰ç¨‹åºçš„goroutinueæ•°ç›®  println("NumGoroutinue=", runtime.NumGoroutine())  // è¯»é€šé“cï¼Œé€šè¿‡é€šé“è¿›è¡ŒåŒæ­¥ç­‰å¾…  &lt;-c  // æ­¤æ—¶cié€šé“å·²ç»å…³é—­ï¼ŒåŒ¿åå‡½æ•°å¯åŠ¨çš„goroutinueå·²ç»é€€å‡º  println("NumGoroutinue=", runtime.NumGoroutine())  for v := range ci {      println(v)  }}</code></pre></li></ul></li><li>æ“ä½œä¸åŒçŠ¶æ€çš„chanä¼šå¼•å‘ä¸‰ç§è¡Œä¸º<ul><li>panic<ul><li>å‘å·²ç»å…³é—­çš„é€šé“å†™æ•°æ®ä¼šå¯¼è‡´panicã€‚ç”±å†™å…¥è€…å…³é—­é€šé“èƒ½æœ€å¤§ç¨‹åº¦åœ°é¿å…å‘å·²ç»å…³é—­çš„é€šé“å†™æ•°æ®è€Œå¯¼è‡´panic</li><li>é‡å¤å…³é—­çš„é€šé“ä¼šå¯¼è‡´panic</li></ul></li><li>é˜»å¡<ul><li>å‘æœªåˆå§‹åŒ–çš„é€šé“å†™æ•°æ®æˆ–è¯»æ•°æ®éƒ½ä¼šå¯¼è‡´å½“å‰goroutineçš„æ°¸ä¹…é˜»å¡</li><li>å‘ç¼“å†²åŒºå·²æ»¡çš„é€šé“å†™å…¥æ•°æ®ä¼šå¯¼è‡´goroutinueé˜»å¡</li><li>é€šé“ä¸­æ²¡æœ‰æ•°æ®ï¼Œè¯»å–è¯¥é€šé“ä¼šå¯¼è‡´goroutinueé˜»å¡</li></ul></li><li>éé˜»å¡<ul><li>è¯»è€…å·²ç»å…³é—­çš„é€šé“ä¸ä¼šå¼•å‘é˜»å¡è€Œæ˜¯ç«‹å³è¿”å›é€šé“å…ƒç´ ç±»å‹çš„é›¶å€¼ï¼Œå¯ä»¥ä½¿ç”¨commaï¼Œokè¯­æ³•åˆ¤æ–­é€šé“æ˜¯å¦å·²ç»å…³é—­</li><li>å‘æœ‰ç¼“å†²ä¸”æ²¡æœ‰æ»¡çš„é€šé“è¯»/å†™ä¸ä¼šå¼•å‘é˜»å¡</li></ul></li></ul></li></ol><h3 id="5-1-4-WaitGroup"><a href="#5-1-4-WaitGroup" class="headerlink" title="5.1.4 WaitGroup"></a>5.1.4 WaitGroup</h3><p>syncåŒ…æä¾›äº†å¤šä¸ªgoroutineåŒæ­¥çš„æœºåˆ¶ï¼Œä¸»è¦æ˜¯é€šè¿‡WaitGroupå®ç°çš„ã€‚</p><h3 id="5-1-5-select"><a href="#5-1-5-select" class="headerlink" title="5.1.5 select"></a>5.1.5 select</h3><p>selectç”¨äºå¤šè·¯ç›‘å¬å¤šä¸ªé€šé“</p><ul><li>å½“ç›‘å¬çš„é€šé“æ²¡æœ‰çŠ¶æ€æ˜¯å¯è¯»æˆ–å¯å†™çš„ï¼Œselectæ˜¯é˜»å¡çš„</li><li>ç›‘å¬çš„é€šé“ä¸­æœ‰ä¸€ä¸ªçŠ¶æ€æ˜¯å¯è¯»æˆ–å¯å†™çš„ï¼Œåˆ™selectå°±ä¸ä¼šé˜»å¡ï¼Œè€Œæ˜¯è¿›å…¥å¤„ç†å°±ç»ªé€šé“çš„åˆ†æ”¯æµç¨‹</li><li>å¦‚æœç›‘å¬çš„é€šé“æœ‰å¤šä¸ªå¯è¯»æˆ–å¯å†™çš„çŠ¶æ€ï¼Œåˆ™selectéšæœºé€‰å–ä¸€ä¸ªå¤„ç†</li></ul><pre><code class="go">import "testing"func TestName(t *testing.T) {    ch := make(chan int, 2)    go func(chan int) {        for {            select {            case ch &lt;- 0:            case ch &lt;- 1:            }        }    }(ch)    for i := 0; i &lt; 10; i++ {        println(&lt;-ch)    }}</code></pre><h3 id="5-1-6-æ‰‡å…¥ï¼ˆFan-inï¼‰å’Œæ‰‡å‡ºï¼ˆFan-outï¼‰"><a href="#5-1-6-æ‰‡å…¥ï¼ˆFan-inï¼‰å’Œæ‰‡å‡ºï¼ˆFan-outï¼‰" class="headerlink" title="5.1.6 æ‰‡å…¥ï¼ˆFan inï¼‰å’Œæ‰‡å‡ºï¼ˆFan outï¼‰"></a>5.1.6 æ‰‡å…¥ï¼ˆFan inï¼‰å’Œæ‰‡å‡ºï¼ˆFan outï¼‰</h3><p>æ‰‡å…¥ï¼šå°†å¤šè·¯é€šé“èšåˆåˆ°ä¸€æ¡é€šé“ä¸­å¤„ç†ï¼ŒGoæœ€ç®€å•çš„æ‰‡å…¥å°±æ˜¯ä½¿ç”¨selectèšåˆå¤šæ¡é€šé“æœåŠ¡</p><p>æ‰‡å‡ºï¼šå°†ä¸€æ¡é€šé“å‘æ•£åˆ°å¤šæ¡é€šé“ä¸­å¤„ç†ï¼ŒGoè¯­è¨€é‡Œé¢å…·ä½“å®ç°å°±æ˜¯ä½¿ç”¨goå…³é”®å­—å¯åŠ¨å¤šä¸ªgoroutineå¹¶å‘å¤„ç† </p><pre><code class="go">import (    "fmt"    "sync"    "testing")var wg sync.WaitGroupfunc TestWaitGroup(t *testing.T) {    for i := 0; i &lt; 10; i++ {        wg.Add(1)        go func(i int) {            defer wg.Done()            fmt.Printf("go func: %d\n", i)        }(i)    }    wg.Wait()    println("success!")}</code></pre><h3 id="5-1-7-é€šçŸ¥é€€å‡ºæœºåˆ¶"><a href="#5-1-7-é€šçŸ¥é€€å‡ºæœºåˆ¶" class="headerlink" title="5.1.7 é€šçŸ¥é€€å‡ºæœºåˆ¶"></a>5.1.7 é€šçŸ¥é€€å‡ºæœºåˆ¶</h3><p>è¯»å–å·²ç»å…³é—­çš„é€šé“ä¸ä¼šå¼•èµ·é˜»å¡ï¼Œä¹Ÿä¸ä¼šå¯¼è‡´panicï¼Œè€Œæ˜¯ç«‹å³è¿”å›è¯¥é€šé“å­˜å‚¨ç±»å‹çš„é›¶å€¼ã€‚</p><p>å…³é—­selectç›‘å¬çš„æŸä¸ªé€šé“èƒ½ä½¿selectç«‹å³æ„ŸçŸ¥è¿™ç§é€šçŸ¥ï¼Œç„¶åè¿›è¡Œç›¸åº”çš„å¤„ç†ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„é€€å‡ºé€šçŸ¥æœºåˆ¶ã€‚</p><p>ä¸‹é¢é€šè¿‡ä¸€ä¸ªéšæœºæ•°ç”Ÿæˆå™¨çš„ç¤ºä¾‹æ©é¥°é€€å‡ºé€šçŸ¥æœºåˆ¶ï¼Œä¸‹æ¸¸çš„æ¶ˆè´¹è€…ä¸éœ€è¦éšæœºæ•°æ—¶æ˜¾å¼åœ°é€šçŸ¥ç”Ÿäº§è€…åœæ­¢ç”Ÿäº§ï¼š</p><pre><code class="go">import (    "fmt"    "math/rand"    "runtime"    "testing")func GenerateIntA(done chan struct{}) chan int {    ch := make(chan int)    go func() {    Lable:        for {            select {            case ch &lt;- rand.Int():            case &lt;-done:                break Lable            }        }        close(ch)    }()    return ch}func TestNotiExit(t *testing.T) {    println("NumGoroutine=", runtime.NumGoroutine())    done := make(chan struct{})    ch := GenerateIntA(done)    println("NumGoroutine=", runtime.NumGoroutine())    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    close(done)    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    println("NumGoroutine=", runtime.NumGoroutine())}</code></pre><h2 id="5-2-å¹¶å‘èŒƒå¼"><a href="#5-2-å¹¶å‘èŒƒå¼" class="headerlink" title="5.2 å¹¶å‘èŒƒå¼"></a>5.2 å¹¶å‘èŒƒå¼</h2><h3 id="5-2-1-ç”Ÿæˆå™¨"><a href="#5-2-1-ç”Ÿæˆå™¨" class="headerlink" title="5.2.1 ç”Ÿæˆå™¨"></a>5.2.1 ç”Ÿæˆå™¨</h3><ol><li>æœ€ç®€å•çš„å¸¦ç¼“å†²çš„ç”Ÿæˆå™¨</li></ol><pre><code class="go">import (    "fmt"    "math/rand"    "testing")func GenerateInt() chan int {    ch := make(chan int, 3)    go func() {        for {            ch &lt;- rand.Int()        }    }()    return ch}func TestGenerateInt(t *testing.T) {    ch := GenerateInt()    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)}</code></pre><ol><li>å¤šä¸ªgoroutinueå¢å¼ºå‹ç”Ÿæˆå™¨</li></ol><p><img src="/images/go_core_programming/Untitled%2039.png" alt="Untitled"></p><ol><li>æœ‰æ—¶å¸Œæœ›ç”Ÿæˆå™¨èƒ½å¤Ÿè‡ªåŠ¨é€€å‡ºï¼Œå¯ä»¥å€ŸåŠ©Goé€šé“çš„é€€å‡ºé€šçŸ¥æœºåˆ¶å®ç°ï¼Œä¾‹å¦‚ï¼š</li></ol><p><img src="/images/go_core_programming/Untitled%2040.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2041.png" alt="Untitled"></p><ol><li>èåˆå¹¶å‘ã€ç¼“å†²ã€é€€å‡ºé€šçŸ¥ç­‰å¤šé‡ç‰¹æ€§çš„ç”Ÿæˆå™¨</li></ol><pre><code class="go">package genericimport (    "fmt"    "math/rand"    "testing")func GenerateIntA(done chan struct{}) chan int {    fmt.Println("GenerateIntA")    ch := make(chan int, 5)    go func() {    Lable:        for {            select {            case ch &lt;- rand.Int():            case &lt;-done:                break Lable            }        }        close(ch)    }()    return ch}func GenerateIntB(done chan struct{}) chan int {    fmt.Println("GenerateIntB")    ch := make(chan int, 5)    go func() {    Lable:        for {            select {            case ch &lt;- rand.Int():            case &lt;-done:                break Lable            }        }        close(ch)    }()    return ch}func GenerateInt(done chan struct{}) chan int {    ch := make(chan int)    send := make(chan struct{})    go func() {    Lable:        for {            select {            case ch &lt;- &lt;-GenerateIntA(send):            case ch &lt;- &lt;-GenerateIntB(send):            case &lt;-done:                send &lt;- struct{}{}                send &lt;- struct{}{}                break Lable            }        }        close(ch)    }()    return ch}func Test(t *testing.T)  {    done := make(chan struct{})    ch := GenerateInt(done)    for i := 0; i &lt; 10; i++ {        fmt.Println(&lt;-ch)    }    done &lt;- struct{}{}    fmt.Println("stop generate")}</code></pre><h3 id="5-2-2-ç®¡é“"><a href="#5-2-2-ç®¡é“" class="headerlink" title="5.2.2 ç®¡é“"></a>5.2.2 ç®¡é“</h3><p>é€šé“å¯ä»¥åˆ†ä¸ºä¸¤ä¸ªæ–¹å‘ï¼Œä¸€ä¸ªæ˜¯è¯»å¦ä¸€ä¸ªæ˜¯å†™ï¼ŒåŠ å…¥ä¸€ä¸ªå‡½æ•°çš„è¾“å…¥å‚æ•°å’Œè¾“å‡ºå‚æ•°éƒ½æ˜¯ç›¸åŒçš„chanç±»å‹ï¼Œåˆ™è¯¥å‡½æ•°å¯ä»¥è°ƒç”¨è‡ªå·±ï¼Œæœ€ç»ˆå½¢æˆä¸€ä¸ªè°ƒç”¨é“¾ã€‚è¿™å¾ˆåƒUNIXç³»ç»Ÿçš„ç®¡é“ï¼Œæ˜¯ä¸€ä¸ªæœ‰ç±»å‹çš„ç®¡é“</p><h3 id="5-2-3-æ¯ä¸ªè¯·æ±‚ä¸€ä¸ªgoroutine"><a href="#5-2-3-æ¯ä¸ªè¯·æ±‚ä¸€ä¸ªgoroutine" class="headerlink" title="5.2.3 æ¯ä¸ªè¯·æ±‚ä¸€ä¸ªgoroutine"></a>5.2.3 æ¯ä¸ªè¯·æ±‚ä¸€ä¸ªgoroutine</h3><p>æ¥ä¸€ä¸ªè¯·æ±‚æˆ–ä»»åŠ¡å°±å¯åŠ¨ä¸€ä¸ªgoroutineå»å¤„ç†ï¼Œå…¸å‹çš„å°±æ˜¯Goä¸­çš„HTTP serveræœåŠ¡ã€‚</p><h3 id="5-2-4-å›ºå®šworkerå·¥ä½œæ± "><a href="#5-2-4-å›ºå®šworkerå·¥ä½œæ± " class="headerlink" title="5.2.4 å›ºå®šworkerå·¥ä½œæ± "></a>5.2.4 å›ºå®šworkerå·¥ä½œæ± </h3><p>ç¨‹åºä¸­é™¤äº†ä¸»è¦çš„main goroutineï¼Œè¿˜å¼€å¯äº†å¦‚ä¸‹å‡ ç±»goroutineï¼š</p><ul><li>åˆå§‹åŒ–ä»»åŠ¡çš„goroutine</li><li>åˆ†å‘ä»»åŠ¡çš„goroutine</li><li>ç­‰å¾…æ‰€æœ‰workerç»“æŸé€šçŸ¥ï¼Œç„¶åå…³é—­ç»“æœé€šé“çš„goroutine</li></ul><p>ç¨‹åºé‡‡ç”¨ä¸‰ä¸ªé€šé“ï¼Œåˆ†åˆ«æ˜¯ï¼š</p><ul><li>ä¼ é€’taskä»»åŠ¡çš„é€šé“</li><li>ä¼ é€’taskç»“æœçš„é€šé“</li><li>æ¥æ”¶workerå¤„ç†å®Œä»»åŠ¡åæ‰€å‘é€é€šçŸ¥çš„é€šé“</li></ul><p>è®¡ç®—å¤šä¸ªæ•´æ•°çš„å’Œæ ·ä¾‹ä»£ç ï¼š</p><pre><code class="go">package mainimport (    "fmt"    "math/rand"    "time")// å·¥ä½œæ± çš„goroutineæ•°ç›®const NUMBER = 10// å·¥ä½œä»»åŠ¡type task struct {    // å­˜æ”¾æ•°æ®    data int    // ä»»åŠ¡ç»“æœ    result chan&lt;- int}// ä»»åŠ¡å¤„ç†ï¼šè®¡ç®—beginå’Œendçš„å’Œ// æ‰§è¡Œç»“æœå†™å…¥ç»“æœchan resultfunc (t *task) do() {    // æ¨¡æ‹Ÿè®¡ç®—è€—æ—¶    r := rand.Intn(1000)    fmt.Println("Sleep:", r, "ms")    time.Sleep(time.Duration(r) * time.Millisecond)    // æ¨¡æ‹Ÿä»»åŠ¡ç»“æœå°±æ˜¯ä»»åŠ¡æ•°æ®    t.result &lt;- t.data}func main() {    workers := NUMBER    taskChan := make(chan task, 10)    resultChan := make(chan int, 10)    done := make(chan struct{}, 10)    // åˆå§‹åŒ–taskçš„goroutine    go InitTask(taskChan, resultChan, 100)    // åˆ†å‘ä»»åŠ¡åˆ°NUMBERä¸ªgoroutineæ±     DistributeTask(taskChan, workers, done)    // è·å–å„ä¸ªgoroutineå¤„ç†å®Œä»»åŠ¡çš„é€šçŸ¥å¹¶å…³é—­ç»“æœé€šé“    go CloseResult(done, resultChan, workers)    // é€šè¿‡ç»“æœé€šé“è·å–ç»“æœå¹¶æ±‡æ€»    sum := ProcessResult(resultChan)    fmt.Println("sum=", sum)}// åˆå§‹åŒ–å¾…å¤„ç†task chanfunc InitTask(taskChan chan&lt;- task, r chan int, p int) {    for i := 0; i &lt;= p; i++ {        taskChan &lt;- task{            data:   i,            result: r,        }    }    close(taskChan)}// è¯»å–task chanå¹¶åˆ†å‘åˆ°worker goroutineå¤„ç†ï¼Œæ€»çš„æ•°é‡æ˜¯workersfunc DistributeTask(taskChan &lt;-chan task, works int, done chan struct{}) {    for i := 0; i &lt; works; i++ {        go ProcessTask(taskChan, done)    }}// å·¥ä½œgoroutineå¤„ç†å…·ä½“å·¥ä½œï¼Œå¹¶å°†å¤„ç†ç»“æœå‘é€åˆ°ç»“æœchanfunc ProcessTask(taskChan &lt;-chan task, done chan struct{}) {    for t := range taskChan {        t.do()    }    done &lt;- struct{}{}}// é€šè¿‡done channelåŒæ­¥ç­‰å¾…æ‰€æœ‰å·¥ä½œgoroutineçš„ç»“æŸï¼Œç„¶åå…³é—­ç»“æœchanfunc CloseResult(done chan struct{}, resultChan chan int, workers int) {    for i := 0; i &lt; workers; i++ {        &lt;-done    }    close(done)    close(resultChan)}// è¯»å–ç»“æœé€šé“ï¼Œæ±‡æ€»ç»“æœfunc ProcessResult(resultChan chan int) int {    sum := 0    for r := range resultChan {        sum += r    }    return sum}</code></pre><p><img src="/images/go_core_programming/Untitled%2042.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2043.png" alt="Untitled"></p><h3 id="5-2-5-futureæ¨¡å¼"><a href="#5-2-5-futureæ¨¡å¼" class="headerlink" title="5.2.5 futureæ¨¡å¼"></a>5.2.5 futureæ¨¡å¼</h3><p>ç”¨å¤„ï¼šå­è°ƒç”¨ç›¸äº’ä¹‹é—´æ²¡æœ‰ä¾èµ–ï¼Œå¦‚æœä¸²è¡Œè°ƒç”¨åˆ™è€—æ—¶ä¼šå¾ˆé•¿ï¼Œæ­¤æ—¶å¯ä»¥ä½¿ç”¨Goå¹¶å‘ç¼–ç¨‹ä¸­çš„futureæ¨¡å¼</p><p>å·¥ä½œåŸç†ï¼š</p><ol><li>ä½¿ç”¨chanä½œä¸ºå‡½æ•°å‚æ•°</li><li>å¯åŠ¨goroutineè°ƒç”¨å®‰å¾½çœå†œæˆ·</li><li>é€šè¿‡chanä¼ é€’å¦‚å‚æ•°</li><li>åšå…¶ä»–å¯ä»¥å¹¶è¡Œå¤„ç†çš„äº‹æƒ…</li><li>é€šè¿‡chanå¼‚æ­¥è·å–ç»“æœ</li></ol><pre><code class="go">package mainimport (    "fmt"    "time")// ä¸€ä¸ªæŸ¥è¯¢ç»“æ„ä½“// è¿™é‡Œçš„sqlå’Œresultæ˜¯ä¸€ä¸ªç®€å•çš„æŠ½è±¡ï¼Œå…·ä½“çš„åº”ç”¨å¯èƒ½æ˜¯æ›´å¤æ‚çš„æ•°æ®ç±»å‹type query struct {    // å‚æ•°Channel    sql chan string    // ç»“æœChannel    result chan string}// æ‰§è¡ŒQueryfunc execQuery(q query) {    // å¯åŠ¨åç¨‹    go func() {        // è·å–è¾“å…¥        sql := &lt;-q.sql        // è®¿é—®æ•°æ®åº“        // è¾“å‡ºç»“æœé€šé“        q.result &lt;- "result from " + sql    }()}func main() {    // åˆå§‹åŒ–Query    q := query{make(chan string, 1), make(chan string, 1)}    // æ‰§è¡ŒQueryï¼Œæ³¨æ„æ‰§è¡Œçš„æ—¶å€™æ— éœ€å‡†å¤‡å‚æ•°    go execQuery(q)    // å‘é€å‚æ•°    q.sql &lt;- "select * from table"    // åšå…¶ä»–äº‹æƒ…    time.Sleep(1 * time.Second)    // è·å–ç»“æœ    fmt.Println(&lt;-q.result)}</code></pre><p><img src="/images/go_core_programming/Untitled%2044.png" alt="Untitled"></p><h2 id="5-3-contextæ ‡å‡†åº“"><a href="#5-3-contextæ ‡å‡†åº“" class="headerlink" title="5.3 contextæ ‡å‡†åº“"></a>5.3 contextæ ‡å‡†åº“</h2><p>Goä¸­çš„goroutineä¹‹é—´æ²¡æœ‰çˆ¶ä¸å­çš„å…³ç³»ï¼Œæ²¡æœ‰æ‰€è°“çš„å­è¿›ç¨‹é€€å‡ºåçš„é€šçŸ¥æœºåˆ¶ï¼Œgoroutineä¹‹é—´å¹³è¡Œåœ°è¢«è°ƒåº¦ï¼Œå¤šä¸ªgoroutineå¦‚ä½•åä½œå·¥ä½œè®¾è®¡é€šä¿¡ã€åŒæ­¥ã€é€šçŸ¥å’Œé€€å‡ºå››ä¸ªæ–¹é¢</p><ul><li>é€šä¿¡ï¼šchané€šé“æ˜¯goroutineä¹‹é—´é€šä¿¡çš„åŸºç¡€ï¼ˆé€šä¿¡æŒ‡ç¨‹åºçš„æ•°æ®é€šé“ï¼‰</li><li>åŒæ­¥ï¼šä¸å¸¦ç¼“å†²çš„chanæä¾›äº†ä¸€ä¸ªå¤©ç„¶çš„åŒæ­¥ç­‰å¾…æœºåˆ¶ï¼›sync.WaitGroupä¹Ÿä¸ºå¤šä¸ªgoroutineååŒå·¥ä½œæä¾›ä¸€ç§åŒæ­¥ç­‰å¾…æœºåˆ¶</li><li>é€šçŸ¥ï¼šè¿™ä¸ªé€šçŸ¥å’Œä¸Šé¢é€šä¿¡çš„æ•°æ®ä¸ä¸€æ ·ï¼Œé€šçŸ¥ä¸æ˜¯ä¸šåŠ¡æ•°æ®ï¼Œè€Œæ˜¯ç®¡ç†ã€æ§åˆ¶æµæ•°æ®ã€‚åœ¨è¾“å…¥ç«¯ç»‘å®šä¸¤ä¸ªchanï¼Œä¸€ä¸ªç”¨äºä¸šåŠ¡æµæ•°æ®ï¼Œå¦ä¸€ä¸ªç”¨äºå¼‚å¸¸é€šçŸ¥æ•°æ®ï¼Œç„¶åä½¿ç”¨selectæ”¶æ•›è¿›è¡Œå¤„ç†</li><li>é€€å‡ºï¼šå€ŸåŠ©é€šé“å’Œselectçš„å¹¿æ’­æœºåˆ¶å®ç°é€€å‡º</li></ul><h3 id="5-3-1-contextçš„è®¾è®¡ç›®çš„"><a href="#5-3-1-contextçš„è®¾è®¡ç›®çš„" class="headerlink" title="5.3.1 contextçš„è®¾è®¡ç›®çš„"></a>5.3.1 contextçš„è®¾è®¡ç›®çš„</h3><ul><li>é€€å‡ºé€šçŸ¥æœºåˆ¶ï¼šé€šçŸ¥å¯ä»¥ä¼ é€’ç»™æ•´ä¸ªgoroutineè°ƒç”¨æ ‘ä¸Šçš„æ¯ä¸€ä¸ªgoroutine</li><li>æ•°æ®ä¼ é€’ï¼šæ•°æ®å¯ä»¥ä¼ é€’ç»™æ•´ä¸ªgoroutineè°ƒç”¨æ ‘ä¸Šçš„æ¯ä¸€ä¸ªgoroutine</li></ul><h3 id="5-3-2-åŸºæœ¬æ•°æ®ç»“æ„"><a href="#5-3-2-åŸºæœ¬æ•°æ®ç»“æ„" class="headerlink" title="5.3.2 åŸºæœ¬æ•°æ®ç»“æ„"></a>5.3.2 åŸºæœ¬æ•°æ®ç»“æ„</h3><p>contextå·¥ä½œæœºåˆ¶ï¼šç¬¬ä¸€ä¸ªåˆ›å»º Context goroutineè¢«ç§°ä¸º root èŠ‚ç‚¹ã€‚ root èŠ‚ç‚¹è´Ÿè´£åˆ›å»ºä¸€ä¸ªå®ç°contextæ¥å£çš„å…·ä½“å¯¹è±¡ï¼Œå¹¶å°†è¯¥å¯¹è±¡ä½œä¸ºå‚æ•°ä¼ é€’åˆ°å…¶æ–°æ‹‰èµ·çš„goroutineï¼Œä¸‹æ¸¸çš„ goroutine ç»§ç»­å°è£…è¯¥å¯¹è±¡ï¼Œå†ä¼ é€’åˆ°æ›´ä¸‹æ¸¸çš„goroutineï¼ŒContext å¯¹è±¡åœ¨ä¼ é€’çš„è¿‡ç¨‹ä¸­æœ€ç»ˆå½¢æˆä¸€ä¸ªæ ‘çŠ¶çš„æ•°æ®ç»“æ„ï¼Œè¿™æ ·é€šè¿‡ä½äº root èŠ‚ç‚¹ï¼ˆæ ‘çš„æ ¹èŠ‚ç‚¹ï¼‰ Context å¯¹è±¡å°±èƒ½éå†æ•´ä¸ª Context å¯¹è±¡æ ‘ï¼Œé€šçŸ¥å’Œæ¶ˆæ¯å°±å¯ä»¥é€šè¿‡ root èŠ‚ç‚¹ä¼ é€’å‡ºå»ï¼Œå®ç°äº†ä¸Šæ¸¸ goroutine ä¸‹æ¸¸ goroutine çš„æ¶ˆæ¯ä¼ é€’ã€‚</p><p><strong>Contextæ¥å£</strong></p><p>Contextä½œä¸ºå‚æ•°ä¼ é€’</p><p><img src="/images/go_core_programming/Untitled%2045.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2046.png" alt="Untitled"></p><p><strong>canceleræ¥å£</strong></p><p>concelerè§„å®šäº†å–æ¶ˆé€šçŸ¥çš„Contextå…·ä½“ç±»å‹éœ€è¦å®ç°çš„æ¥å£</p><p><img src="/images/go_core_programming/Untitled%2047.png" alt="Untitled"></p><p><strong>empty Contextç»“æ„</strong></p><p>å®ç°äº†Contextæ¥å£ä½†ä¸å…·å¤‡ä»»ä½•åŠŸèƒ½ï¼Œå…¶å­˜åœ¨çš„ç›®çš„æ˜¯ä½œä¸ºContextå¯¹è±¡æ ‘çš„æ ¹ï¼ˆrootèŠ‚ç‚¹ï¼‰</p><p><strong>cancelCtx</strong></p><p>cancelCtxæ˜¯ä¸€ä¸ªå®ç°äº†Contextè€³æœºå£çš„å…·ä½“ç±»å‹ï¼ŒåŒæ—¶å®ç°äº†conceleræ¥å£</p><p><strong>timerCtx</strong></p><p>timerCtxæ˜¯ä¸€ä¸ªå®ç°äº†Contextæ¥å£çš„å…·ä½“ç±»å‹ï¼Œå†…éƒ¨å°è£…cancelCtxç±»å‹å®ä¾‹ï¼ŒåŒæ—¶æœ‰ä¸€ä¸ªdeadlinebianl,yonglaishixianå®šæ—¶é€€å‡ºé€šçŸ¥</p><p><strong>valueCtx</strong></p><p>valueCtxæ˜¯ä¸€ä¸ªå®ç°äº†Contextæ¥å£çš„å…·ä½“ç±»å‹ï¼Œå†…éƒ¨å°è£…äº†Contextæ¥å£ç±»å‹ï¼ŒåŒæ—¶å°è£…äº†ä¸€ä¸ªk/vçš„å­˜å‚¨éå†ï¼ŒvalueCtxå¯ä»¥ç”¨æ¥ä¼ é€’é€šçŸ¥ä¿¡æ¯</p><p><img src="/images/go_core_programming/Untitled%2048.png" alt="Untitled"></p><h3 id="5-3-3-APIå‡½æ•°"><a href="#5-3-3-APIå‡½æ•°" class="headerlink" title="5.3.3 APIå‡½æ•°"></a>5.3.3 APIå‡½æ•°</h3><p>ä»¥ä¸‹ä¸¤ä¸ªå‡½æ•°æ˜¯æ„é€ Contextå–æ¶ˆæ ‘çš„æ ¹èŠ‚ç‚¹å¯¹è±¡ï¼Œæ ¹èŠ‚ç‚¹å¯¹è±¡ç”¨ä½œåç»­WithåŒ…è£…å‡½æ•°çš„å®å‚ï¼š</p><ul><li>func Background() Context</li><li>func TODO() Context</li></ul><h3 id="5-3-6-ä½¿ç”¨Contextä¼ é€’æ•°æ®çš„äº‰è®®"><a href="#5-3-6-ä½¿ç”¨Contextä¼ é€’æ•°æ®çš„äº‰è®®" class="headerlink" title="5.3.6 ä½¿ç”¨Contextä¼ é€’æ•°æ®çš„äº‰è®®"></a>5.3.6 ä½¿ç”¨Contextä¼ é€’æ•°æ®çš„äº‰è®®</h3><p>ä½¿ç”¨contextä¼ é€’æ•°æ®çš„åå¤„ï¼š</p><ul><li>ä¼ é€’çš„éƒ½æ˜¯interface{}ç±»å‹çš„å€¼ï¼Œç¼–è¯‘å™¨ä¸èƒ½è¿›è¡Œä¸¥æ ¼çš„ç±»å‹æ ¡éªŒ</li><li>ä»interface{}åˆ°å…·ä½“ç±»å‹éœ€è¦ä½¿ç”¨ç±»å‹æ–­è¨€å’Œæ¥å£æŸ¥è¯¢ï¼Œæœ‰ä¸€å®šçš„è¿è¡ŒæœŸå¼€é”€å’Œæ€§èƒ½æŸå¤±</li><li>å€¼åœ¨ä¼ é€’è¿‡ç¨‹ä¸­æœ‰å¯èƒ½è¢«åç»­çš„æœåŠ¡è¦†ç›–ä¸”ä¸æ˜“è¢«å‘ç°</li><li>ä¼ é€’ä¿¡æ¯ä¸ç®€æ˜ã€‚è¾ƒæ™¦æ¶©ï¼›ä¸èƒ½é€šè¿‡ä»£ç æˆ–æ–‡æ¡£ä¸€çœ¼çœ‹åˆ°ä¼ é€’çš„æ˜¯ä»€ä¹ˆï¼Œä¸åˆ©äºåç»­ç»´æŠ¤</li></ul><p>contextåº”è¯¥ä¼ é€’ä»€ä¹ˆæ•°æ®ï¼š</p><ul><li>æ—¥å¿—ä¿¡æ¯</li><li>è°ƒä½æ˜¯ä¿¡æ¯</li><li>ä¸å½±å“ä¸šåŠ¡ä¸»é€»è¾‘çš„å¯é€‰æ•°æ®</li></ul><h2 id="5-4-å¹¶å‘æ¨¡å‹"><a href="#5-4-å¹¶å‘æ¨¡å‹" class="headerlink" title="5.4 å¹¶å‘æ¨¡å‹"></a>5.4 å¹¶å‘æ¨¡å‹</h2><h3 id="5-4-1-CSPç®€ä»‹"><a href="#5-4-1-CSPç®€ä»‹" class="headerlink" title="5.4.1 CSPç®€ä»‹"></a>5.4.1 CSPç®€ä»‹</h3><p>CSPåŸºæœ¬æ€æƒ³ï¼šå°†å¹¶å‘ç³»ç»ŸæŠ½è±¡ä¸ºChannelå’ŒProcessä¸¤éƒ¨åˆ†ï¼ŒChannelç”¨æ¥ä¼ é€’æ¶ˆæ¯ï¼ŒProcessç”¨äºæ‰§è¡Œï¼ŒChannelå’ŒProcessä¹‹é—´ç›¸äº’ç‹¬ç«‹ï¼Œæ²¡æœ‰ä»å±å…³ç³»ï¼Œæ¶ˆæ¯çš„å‘é€å’Œæ¥æ”¶æœ‰ä¸¥æ ¼çš„æ—¶åºé™åˆ¶ã€‚</p><p>Goä¸­Channelå°±æ˜¯é€šé“ï¼ŒProcesså°±æ˜¯goroutine</p><h3 id="5-4-2-è°ƒåº¦æ¨¡å‹"><a href="#5-4-2-è°ƒåº¦æ¨¡å‹" class="headerlink" title="5.4.2 è°ƒåº¦æ¨¡å‹"></a>5.4.2 è°ƒåº¦æ¨¡å‹</h3><p>åç¨‹æ˜¯ä¸€ç§ç”¨æˆ·æ€çš„è½»é‡çº§çº¿ç¨‹ï¼Œå†™æˆçš„è°ƒåº¦å®Œå…¨ç”±ç”¨æˆ·æ€ç¨‹åºæ§åˆ¶ï¼Œåç¨‹æ‹¥æœ‰è‡ªå·±çš„å¯„å­˜å™¨ä¸Šä¸‹æ–‡å’Œæ ˆã€‚</p><p>åç¨‹è°ƒåº¦åˆ‡æ¢æ—¶ï¼Œå°†å¯„å­˜å™¨ä¸Šä¸‹æ–‡å’Œæ ˆä¿å­˜åˆ°å…¶ä»–åœ°æ–¹ï¼Œåœ¨åˆ‡å›æ¥çš„æ—¶å€™æ¢å¤å…ˆå‰ä¿å­˜çš„å¯„å­˜å™¨ä¸Šä¸‹æ–‡å’Œæ ˆï¼Œæ¯ä¸ªå†…æ ¸çº¿ç¨‹å¯ä»¥å¯¹åº”å¤šä¸ªç”¨æˆ·åç¨‹ï¼Œå½“ä¸€ä¸ªåç¨‹æ‰§è¡Œä½“é˜»å¡äº†ï¼Œè°ƒåº¦å™¨ä¼šè°ƒåº¦å¦ä¸€ä¸ªæºç¨‹æ‰§è¡Œï¼Œæœ€å¤§æ•ˆç‡åœ°åˆ©ç”¨æ“ä½œç³»ç»Ÿåˆ†ç»™ç³»ç»Ÿçº¿ç¨‹çš„æ—¶é—´ç‰‡ã€‚</p><p>å¥½å¤„ï¼š</p><ul><li>æ§åˆ¶äº†ç³»ç»Ÿçº¿ç¨‹æ•°ï¼Œä¿è¯æ¯ä¸ªçº¿ç¨‹çš„è¿è¡Œæ—¶é—´ç‰‡å……è¶³</li><li>è°ƒåº¦å±‚èƒ½è¿›è¡Œç”¨æˆ·æ€çš„åˆ‡æ¢ï¼Œä¸ä¼šå¯¼è‡´å•ä¸ªåç¨‹é˜»å¡æ•´ä¸ªç¨‹åºçš„æƒ…å†µï¼Œå°½é‡å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œæå‡è¿è¡Œæ•ˆç‡</li></ul><p>ç”±æ­¤å¯è§ï¼Œåç¨‹æ˜¯ä¸€ç§éå¸¸é«˜æ•ˆã€ç†æƒ³çš„æ‰§è¡Œæ¨¡å‹ã€‚Goçš„å¹¶å‘æ‰§è¡Œæ¨¡å‹å°±æ˜¯ä¸€ç§å˜ç§çš„åç¨‹æ¨¡å‹ã€‚</p><h3 id="5-4-3-å¹¶å‘å’Œè°ƒåº¦"><a href="#5-4-3-å¹¶å‘å’Œè°ƒåº¦" class="headerlink" title="5.4.3 å¹¶å‘å’Œè°ƒåº¦"></a>5.4.3 å¹¶å‘å’Œè°ƒåº¦</h3><p>goroutineå¥½å¤„ï¼š</p><ul><li>goroutineå¯ä»¥åœ¨ç”¨æˆ·ç©ºé—´è°ƒåº¦ï¼Œé¿å…äº†å†…æ ¸æ€å’Œç”¨æˆ·æ€çš„åˆ‡æ¢å¯¼è‡´çš„æˆæœ¬</li><li>goroutineæ˜¯è¯­è¨€åŸç”Ÿæ”¯æŒçš„ï¼Œæä¾›äº†éå¸¸ç®€æ´çš„è¯­æ³•ï¼Œå±è”½äº†å¤§éƒ¨åˆ†å¤æ‚åº•å±‚å®ç°</li><li>goroutineæ›´å°çš„å ç©ºé—´å…è®¸ç”¨æˆ·åˆ›å»ºæˆåƒä¸Šä¸‡çš„å®ä¾‹</li></ul><p>goroutinueè°ƒåº¦æ¨¡å‹ï¼š</p><ol><li>å®ä½“Gï¼ˆGoroutineï¼‰</li></ol><p>Gæ˜¯Goè¿è¡Œæ—¶å¯¹goroutineçš„æŠ½è±¡æè¿°ï¼ŒGä¸­å­˜æ”¾å¹¶å‘æ‰§è¡Œçš„ä»£ç å…¥å£åœ°å€ã€ä¸Šä¸‹æ–‡ã€è¿è¡Œç¯å¢ƒï¼ˆå…³è”çš„På’ŒMï¼‰ã€è¿è¡Œæ ˆç­‰æ‰§è¡Œç›¸å…³çš„å…ƒä¿¡æ¯</p><ol><li>å®ä½“Mï¼ˆMachineï¼‰</li></ol><p>Mä»£è¡¨OSå†…æ ¸çº¿ç¨‹ï¼Œæ˜¯æ“ä½œç³»ç»Ÿå±‚é¢è°ƒåº¦å’Œæ‰§è¡Œçš„å®ä½“ã€‚Mä»…è´Ÿè´£æ‰§è¡Œï¼ŒMä¸åœåœ°è¢«å”¤é†’æˆ–åˆ›å»ºï¼Œç„¶åæ‰§è¡Œã€‚Må¯åŠ¨æ—¶è¿›å…¥çš„æ˜¯è¿è¡Œæ—¶çš„ç®¡ç†ä»£ç ï¼Œæœ‰è¿™æ®µä»£ç è·å–Gå’ŒPèµ„æºï¼Œç„¶åæ‰§è¡Œè°ƒåº¦ã€‚å¦å¤–Go</p><p>è¯­è¨€è¿è¡Œæ—¶ä¼šå•ç‹¬åˆ›å»ºä¸€ä¸ªç›‘æ§çº¿ç¨‹ï¼Œè´Ÿè´£å¯¹ç¨‹åºçš„å†…å­˜ã€è°ƒåº¦ç­‰ä¿¡æ¯è¿›è¡Œç›‘æ§å’Œæ§åˆ¶</p><ol><li>å®ä½“Pï¼ˆProcessorï¼‰</li></ol><p>Pä»£è¡¨Mè¿è¡ŒGæ‰€éœ€çš„èµ„æºï¼Œæ˜¯å¯¹èµ„æºçš„ä¸€ç§æŠ½è±¡å’Œç®¡ç†ï¼ŒPä¸æ˜¯ä¸€æ®µä»£ç å®ä½“ï¼Œè€Œæ˜¯ä¸€ä¸ªç®¡ç†çš„æ•°æ®ç»“æ„ï¼ŒPä¸»è¦æ˜¯é™ä½Mç®¡ç†è°ƒåº¦Gçš„å¤æ‚æ€§ï¼Œå¢åŠ ä¸€ä¸ªç®€æ´çš„æ§åˆ¶å±‚æ•°æ®ç»“æ„ã€‚</p><p><img src="/images/go_core_programming/Untitled%2049.png" alt="Untitled"></p><p><strong>m0å’Œg0</strong></p><p>m0å’Œg0æ˜¯å¯åŠ¨ç¨‹åºåçš„ä¸»çº¿ç¨‹ï¼Œè¿™ä¸ªmå¯¹åº”çš„ä¿¡æ¯ä¼šå­˜æ”¾åœ¨å…¨å±€å˜é‡m0ç§ï¼Œm0è´Ÿè´£æ‰§è¡Œåˆå§‹åŒ–æ“ä½œå’Œå¯åŠ¨ç¬¬ä¸€ä¸ªgï¼Œä¹‹åm0å°±å’Œå…¶ä»–mä¸€æ ·äº†ã€‚</p><p><img src="/images/go_core_programming/Untitled%2050.png" alt="Untitled"></p><h1 id="ç¬¬-7-ç« -è¯­è¨€é™·é˜±"><a href="#ç¬¬-7-ç« -è¯­è¨€é™·é˜±" class="headerlink" title="ç¬¬ 7 ç«  è¯­è¨€é™·é˜±"></a>ç¬¬ 7 ç«  è¯­è¨€é™·é˜±</h1><h2 id="7-1-å¤šå€¼èµ‹å€¼å’ŒçŸ­å˜é‡å£°æ˜"><a href="#7-1-å¤šå€¼èµ‹å€¼å’ŒçŸ­å˜é‡å£°æ˜" class="headerlink" title="7.1 å¤šå€¼èµ‹å€¼å’ŒçŸ­å˜é‡å£°æ˜"></a>7.1 å¤šå€¼èµ‹å€¼å’ŒçŸ­å˜é‡å£°æ˜</h2><h3 id="7-1-1-å¤šå€¼èµ‹å€¼"><a href="#7-1-1-å¤šå€¼èµ‹å€¼" class="headerlink" title="7.1.1 å¤šå€¼èµ‹å€¼"></a>7.1.1 å¤šå€¼èµ‹å€¼</h3><p>éæ³•ï¼š</p><p><img src="/images/go_core_programming/Untitled%2051.png" alt="Untitled"></p><p>å¤šå€¼èµ‹å€¼è¯­ä¹‰ï¼š</p><ul><li>å¯¹å·¦ä¾§æ“ä½œæ•°ä¸­çš„è¡¨è¾¾å¼ã€ç´¢å¼•å€¼è¿›è¡Œè®¡ç®—å’Œç¡®å®šï¼Œé¦–å…ˆç¡®å®šå·¦ä¾§çš„æ“ä½œæ•°çš„åœ°å€ï¼Œç„¶åå¯¹å³ä¾§çš„èµ‹å€¼è¡¨è¾¾å¼è¿›è¡Œè®¡ç®—ï¼Œå¦‚æœå‘ç°å³ä¾§çš„è¡¨è¾¾å¼è®¡ç®—å¼•ç”¨äº†å·¦ä¾§çš„å˜é‡ï¼Œåˆ™åˆ›å»ºä¸´æ—¶å˜é‡è¿›è¡Œå€¼æ‹·è´ï¼Œæœ€åå®Œæˆè®¡ç®—</li><li>ä»å·¦åˆ°å³çš„é¡ºåºä¾æ¬¡èµ‹å€¼</li></ul><p>ç¤ºä¾‹ï¼š</p><pre><code class="go">import (    "fmt"    "testing")func Test(t *testing.T) {    x := []int{1, 2, 3}    i := 0    i, x[i] = 1, 2    fmt.Println(i, x) // 1 [2 2 3]    x = []int{1, 2, 3}    i = 0    x[i], i = 2, 1    fmt.Println(i, x) // 1 [2 2 3]    x = []int{1, 2, 3}    i = 0    x[i], i = 2, x[i] // set tmp=x[0],x[0]=2,i=tmp ==&gt; i=1    fmt.Println(i, x) // 1 [2 2 3]    x[0], x[0] = 1, 2    fmt.Println(x[0]) // 2}</code></pre><h3 id="7-1-2-çŸ­å˜é‡çš„å£°æ˜å’Œèµ‹å€¼"><a href="#7-1-2-çŸ­å˜é‡çš„å£°æ˜å’Œèµ‹å€¼" class="headerlink" title="7.1.2 çŸ­å˜é‡çš„å£°æ˜å’Œèµ‹å€¼"></a>7.1.2 çŸ­å˜é‡çš„å£°æ˜å’Œèµ‹å€¼</h3><p>çº¦å®šï¼š</p><ul><li>ä½¿ç”¨â€œ:=â€æ“ä½œç¬¦ï¼Œå˜é‡çš„å®šä¹‰å’Œåˆå§‹åŒ–åŒæ—¶å®Œæˆ</li><li>å˜é‡ååä¸è¦è·Ÿä»»ä½•ç±»å‹åï¼ŒGoç¼–è¯‘å™¨å®Œå…¨é å³è¾¹çš„å€¼è¿›è¡Œæ¨å¯¼</li><li>æ”¯æŒå¤šå€¼çŸ­å˜é‡å£°æ˜èµ‹å€¼</li><li>åªèƒ½ç”¨åœ¨å‡½æ•°å’Œç±»å‹æ–¹æ³•çš„å†…éƒ¨</li></ul><p><img src="/images/go_core_programming/Untitled%2052.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2053.png" alt="Untitled"></p><h2 id="7-2-rangeå¤ç”¨ä¸´æ—¶å˜é‡"><a href="#7-2-rangeå¤ç”¨ä¸´æ—¶å˜é‡" class="headerlink" title="7.2 rangeå¤ç”¨ä¸´æ—¶å˜é‡"></a>7.2 rangeå¤ç”¨ä¸´æ—¶å˜é‡</h2><p><img src="/images/go_core_programming/Untitled%2054.png" alt="Untitled"></p><p>ç»“æœæ‰“å°çš„éƒ½æ˜¯9ï¼ŒåŸå› ï¼š</p><ul><li>for rangeä¸‹çš„è¿­ä»£å˜é‡içš„å€¼æ˜¯å…±ç”¨çš„</li><li>mainå‡½æ•°æ‰€åœ¨çš„goiroutinueå’Œåç»­å¯åŠ¨çš„goroutineså­˜åœ¨ç«äº‰å…³ç³»</li></ul><p>æ­£ç¡®å†™æ³•ï¼š</p><p><img src="/images/go_core_programming/Untitled%2055.png" alt="Untitled"></p><h2 id="7-3-deferé™·é˜±"><a href="#7-3-deferé™·é˜±" class="headerlink" title="7.3 deferé™·é˜±"></a>7.3 deferé™·é˜±</h2><p>å¯¹å¸¦deferçš„å‡½æ•°è¿”å›æ•´ä½“ä¸Šæœ‰ä¸‰ä¸ªæ­¥éª¤</p><ul><li>æ‰§è¡Œreturnçš„å€¼æ‹·è´ï¼Œå°†returnè¯­å¥è¿”å›çš„å€¼å¤åˆ¶åˆ°å‡½æ•°è¿”å›å€¼æ ˆåŒºï¼ˆå¦‚æœåªæœ‰ä¸€ä¸ªreturnï¼Œä¸å¸¦ä»»ä½•å˜é‡æˆ–å€¼ï¼Œåˆ™æ­¤æ­¥éª¤ä¸åšä»»ä½•åŠ¨ä½œï¼‰</li><li>æ‰§è¡Œdeferè¯­å¥ï¼Œå¤šä¸ªdeferæŒ‰ç…§FILOé¡ºåºæ‰§è¡Œ</li><li>æ‰§è¡Œè°ƒæ•´RETæŒ‡ä»¤</li></ul><h2 id="7-4-åˆ‡ç‰‡å›°æƒ‘"><a href="#7-4-åˆ‡ç‰‡å›°æƒ‘" class="headerlink" title="7.4 åˆ‡ç‰‡å›°æƒ‘"></a>7.4 åˆ‡ç‰‡å›°æƒ‘</h2><h3 id="7-4-1-æ•°ç»„"><a href="#7-4-1-æ•°ç»„" class="headerlink" title="7.4.1 æ•°ç»„"></a>7.4.1 æ•°ç»„</h3><p>Goçš„æ•°ç»„æ˜¯æœ‰å›ºå®šä¸ªç›¸åŒç±»å‹å…ƒç´ çš„æ•°æ®ç»“æ„ï¼Œåº•å±‚é‡‡ç”¨è¿ç»­çš„å†…å­˜ç©ºé—´å­˜æ”¾ï¼Œæ•°ç»„ä¸€æ—¦å£°æ˜åå¤§å°å°±ä¸å¯æ”¹å˜äº†ã€‚</p><p>Goä¸­çš„æ•°ç»„æ˜¯ä¸€ç§åŸºæœ¬ç±»å‹ã€‚æ•°ç»„çš„ç±»å‹ä¸ä»…åŒ…æ‹¬å…¶å…ƒç´ ç±»å‹ï¼Œä¹ŸåŒ…æ‹¬å…¶å¤§å°ï¼Œ[2]intå’Œ[5]intæ˜¯ä¸¤ä¸ªå®Œå…¨ä¸åŒçš„æ•°ç»„ç±»å‹</p><p><img src="/images/go_core_programming/Untitled%2056.png" alt="Untitled"></p><p>æ•°ç»„åæ— è®ºä½œä¸ºå‡½æ•°å®å‚è¿˜æ˜¯ä½œä¸ºstructåµŒå…¥å­—æ®µï¼Œæˆ–è€…æ•°ç»„ä¹‹é—´çš„ç›´æ¥èµ‹å€¼éƒ½æ˜¯å€¼æ‹·è´</p><h3 id="7-4-2-åˆ‡ç‰‡"><a href="#7-4-2-åˆ‡ç‰‡" class="headerlink" title="7.4.2 åˆ‡ç‰‡"></a>7.4.2 åˆ‡ç‰‡</h3><p><strong>åˆ‡ç‰‡åˆ›å»º</strong></p><ol><li>é€šè¿‡æ•°ç»„åˆ›å»º</li></ol><p>array[b:e]åˆ›å»ºä¸€ä¸ªåŒ…æ‹¬e-bä¸ªå…ƒç´ çš„åˆ‡ç‰‡ï¼ŒåŒ…å«bï¼Œä¸åŒ…å«e</p><ol><li>make</li></ol><p>make([]T, len, cap)ä¸­çš„Tæ˜¯åˆ‡ç‰‡å…ƒç´ ç±»å‹ï¼Œlenæ˜¯é•¿åº¦ï¼Œcapæ˜¯åº•å±‚æ•°ç»„çš„å®¹é‡ã€‚capæ˜¯å¯é€‰å‚æ•°</p><ol><li>ç›´æ¥å£°æ˜</li></ol><p><img src="/images/go_core_programming/Untitled%2057.png" alt="Untitled"></p><p>åˆ‡ç‰‡æ•°æ®ç»“æ„</p><p><img src="/images/go_core_programming/Untitled%2058.png" alt="Untitled"></p><p>å¤šä¸ªåˆ‡ç‰‡å…±äº«ä¸€ä¸ªåº•å±‚æ•°ç»„ï¼Œå…¶ä¸­ä¸€ä¸ªåˆ‡ç‰‡çš„appendæ“ä½œå¯èƒ½å¼•å‘å¦‚ä¸‹ä¸¤ç§æƒ…å†µï¼š</p><ul><li>appendè¿½åŠ çš„å…ƒç´ æ²¡æœ‰è¶…è¿‡åº•å±‚æ•°ç»„çš„å®¹é‡ï¼Œæ­¤ç§appendæ“ä½œä¼šç›´æ¥æ“ä½œå…±äº«çš„åº•å±‚æ•°ç»„ï¼Œå¦‚æœå…¶ä»–åˆ‡ç‰‡æœ‰å¼•ç”¨æ•°ç»„è¢«è¦†ç›–çš„åŸè‰²ï¼Œåˆ™ä¼šå¯¼è‡´å…¶ä»–åˆ‡ç‰‡çš„å€¼ä¹Ÿä¼šéšå¼åœ°å‘ç”Ÿå˜åŒ–</li><li>appendè¿½åŠ çš„å…ƒç´ åŠ ä¸ŠåŸæ¥çš„å…ƒç´ å¦‚æœè¶…å‡ºåº•å±‚æ•°ç»„çš„å®¹é‡ï¼Œåˆ™æ­¤ç§appendæ“ä½œä¼šé‡æ–°ç”³è¯·æ–°æ•°ç»„ï¼Œå¹¶å°†åŸæ¥æ•°ç»„çš„å€¼å¤åˆ¶åˆ°æ–°æ•°ç»„</li></ul><p>ç”±äºæœ‰è¿™ç§äºŒä¹‰æ€§ï¼Œæ‰€ä»¥åœ¨ä½¿ç”¨åˆ‡ç‰‡è¿‡ç¨‹ä¸­åº”è¯¥å°½é‡é¿å…å¤šä¸ªåˆ‡é¢å…±äº«åº•å±‚æ•°ç»„ï¼Œå¯ä»¥ä½¿ç”¨copyè¿›è¡Œæ˜¾å¼çš„å¤åˆ¶</p><h2 id="7-5-å€¼ã€æŒ‡é’ˆå’Œå¼•ç”¨"><a href="#7-5-å€¼ã€æŒ‡é’ˆå’Œå¼•ç”¨" class="headerlink" title="7.5 å€¼ã€æŒ‡é’ˆå’Œå¼•ç”¨"></a>7.5 å€¼ã€æŒ‡é’ˆå’Œå¼•ç”¨</h2><h3 id="7-5-1-ä¼ å€¼è¿˜æ˜¯ä¼ å¼•ç”¨"><a href="#7-5-1-ä¼ å€¼è¿˜æ˜¯ä¼ å¼•ç”¨" class="headerlink" title="7.5.1 ä¼ å€¼è¿˜æ˜¯ä¼ å¼•ç”¨"></a>7.5.1 ä¼ å€¼è¿˜æ˜¯ä¼ å¼•ç”¨</h3><p>Goåªæœ‰ä¸€ç§å‚æ•°ä¼ é€’è§„åˆ™ï¼šå€¼æ‹·è´ï¼Œå«ä¹‰ï¼š</p><ul><li>å‡½æ•°å‚æ•°ä¼ é€’æ—¶ä½¿ç”¨çš„æ˜¯å€¼æ‹·è´</li><li>å®ä¾‹èµ‹å€¼ç»™æ¥å£å˜é‡ï¼Œæ¥å£å¯¹å®ä¾‹çš„å¼•ç”¨æ˜¯å€¼æ‹·è´</li></ul><p>æœ‰æ—¶åœ¨æ˜æ˜æ˜¯å€¼æ‹·è´çš„åœ°æ–¹ç»“æœå´ä¿®æ”¹äº†å˜é‡çš„å†…å®¹ï¼Œæœ‰ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š</p><ul><li>ç›´æ¥ä¼ é€’çš„æ˜¯æŒ‡é’ˆï¼ŒæŒ‡é’ˆä¼ é€’åŒæ ·æ˜¯å€¼æ‹·è´ï¼Œä½†æŒ‡é’ˆå’ŒæŒ‡é’ˆå‰¯æœ¬çš„å€¼æŒ‡å‘çš„åœ°å€æ˜¯åŒä¸€åœ°æ–¹ï¼Œæ‰€ä»¥èƒ½ä¿®æ”¹å®å‚å€¼</li><li>å‚æ•°æ˜¯è´Ÿè·æ•°æ®ç±»å‹ï¼Œè¿™äº›å¤åˆæ•°æ®ç±»å‹å†…éƒ¨æœ‰æŒ‡é’ˆç±»å‹çš„å…ƒç´ ï¼Œæ­¤æ—¶å‚æ•°çš„å€¼biæ‹·è´å¹¶ä¸å½±å“æŒ‡é’ˆçš„æŒ‡å‘</li></ul><h3 id="7-5-2-å‡½æ•°åçš„æ„ä¹‰"><a href="#7-5-2-å‡½æ•°åçš„æ„ä¹‰" class="headerlink" title="7.5.2 å‡½æ•°åçš„æ„ä¹‰"></a>7.5.2 å‡½æ•°åçš„æ„ä¹‰</h3><ul><li>ç±»å‹ä¿¡æ¯</li><li>å‡½æ•°çš„æ‰§è¡Œä»£ç çš„èµ·å§‹ä½ç½®</li><li>å¯ä»¥é€šè¿‡å‡½æ•°åè¿›è¡Œå‡½æ•°è°ƒç”¨</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goé¢è¯•é¢˜æ‰‹å†™å†…å®¹</title>
      <link href="/2022/01/16/go/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%8B%E5%86%99/"/>
      <url>/2022/01/16/go/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%8B%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/go_interview/GO-r-01.jpg" alt="img"><br><img src="/images/go_interview/GO-r-02.jpg" alt="img"><br><img src="/images/go_interview/GO-r-03.jpg" alt="img"><br><img src="/images/go_interview/GO-r-04.jpg" alt="img"><br><img src="/images/go_interview/GO-r-05.jpg" alt="img"><br><img src="/images/go_interview/GO-r-06.jpg" alt="img"><br><img src="/images/go_interview/GO-r-07.jpg" alt="img"><br><img src="/images/go_interview/GO-r-08.jpg" alt="img"><br><img src="/images/go_interview/GO-r-09.jpg" alt="img"><br><img src="/images/go_interview/GO-r-10.jpg" alt="img"><br><img src="/images/go_interview/GO-r-11.jpg" alt="img"><br><img src="/images/go_interview/GO-r-12.jpg" alt="img"><br><img src="/images/go_interview/GO-r-13.jpg" alt="img"><br><img src="/images/go_interview/GO-r-14.jpg" alt="img"><br><img src="/images/go_interview/GO-r-15.jpg" alt="img"><br><img src="/images/go_interview/GO-r-16.jpg" alt="img"><br><img src="/images/go_interview/GO-r-17.jpg" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> é¢è¯•é¢˜ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goé¢è¯•é¢˜</title>
      <link href="/2022/01/16/go/Go%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/01/16/go/Go%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://geektutu.com/post/qa-golang.html">å‚è€ƒé“¾æ¥</a></p><h1 id="ä¸€ã€Go-è¯­è¨€ç¬”è¯•é¢è¯•é¢˜-åŸºç¡€è¯­æ³•"><a href="#ä¸€ã€Go-è¯­è¨€ç¬”è¯•é¢è¯•é¢˜-åŸºç¡€è¯­æ³•" class="headerlink" title="ä¸€ã€Go è¯­è¨€ç¬”è¯•é¢è¯•é¢˜(åŸºç¡€è¯­æ³•)"></a>ä¸€ã€Go è¯­è¨€ç¬”è¯•é¢è¯•é¢˜(åŸºç¡€è¯­æ³•)</h1><h2 id="1-å’Œ-çš„åŒºåˆ«ï¼Ÿ"><a href="#1-å’Œ-çš„åŒºåˆ«ï¼Ÿ" class="headerlink" title="1. = å’Œ := çš„åŒºåˆ«ï¼Ÿ"></a>1. = å’Œ := çš„åŒºåˆ«ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>:= å£°æ˜+èµ‹å€¼<br>= ä»…èµ‹å€¼</p><pre><code class="go">var foo intfoo = 10// ç­‰ä»·äºfoo := 10</code></pre><h2 id="2-æŒ‡é’ˆçš„ä½œç”¨ï¼Ÿ"><a href="#2-æŒ‡é’ˆçš„ä½œç”¨ï¼Ÿ" class="headerlink" title="2. æŒ‡é’ˆçš„ä½œç”¨ï¼Ÿ"></a>2. æŒ‡é’ˆçš„ä½œç”¨ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>æŒ‡é’ˆç”¨æ¥ä¿å­˜å˜é‡çš„åœ°å€ã€‚<br>ä¾‹å¦‚</p><pre><code class="go">var x =  5var p *int = &amp;xfmt.Printf("x = %d",  *p) // x å¯ä»¥ç”¨ *p è®¿é—®</code></pre><ul><li>è¿ç®—ç¬¦ï¼Œä¹Ÿç§°ä¸ºè§£å¼•ç”¨è¿ç®—ç¬¦ï¼Œç”¨äºè®¿é—®åœ°å€ä¸­çš„å€¼ã€‚<br>ï¼†è¿ç®—ç¬¦ï¼Œä¹Ÿç§°ä¸ºåœ°å€è¿ç®—ç¬¦ï¼Œç”¨äºè¿”å›å˜é‡çš„åœ°å€ã€‚<br>Q3 Go å…è®¸å¤šä¸ªè¿”å›å€¼å—ï¼Ÿ<br>ç­”æ¡ˆ<br>å…è®¸<pre><code>func swap(x, y string) (string, string) { return y, x}</code></pre></li></ul><p>func main() {<br>   a, b := swap(â€œAâ€, â€œBâ€)<br>   fmt.Println(a, b) // B A<br>}</p><pre><code>## 4. Go æœ‰å¼‚å¸¸ç±»å‹å—ï¼Ÿç­”æ¡ˆGo æ²¡æœ‰å¼‚å¸¸ç±»å‹ï¼Œåªæœ‰é”™è¯¯ç±»å‹ï¼ˆErrorï¼‰ï¼Œé€šå¸¸ä½¿ç”¨è¿”å›å€¼æ¥è¡¨ç¤ºå¼‚å¸¸çŠ¶æ€ã€‚```gof, err := os.Open("test.txt")if err != nil {    log.Fatal(err)}</code></pre><h2 id="5-ä»€ä¹ˆæ˜¯åç¨‹ï¼ˆGoroutineï¼‰"><a href="#5-ä»€ä¹ˆæ˜¯åç¨‹ï¼ˆGoroutineï¼‰" class="headerlink" title="5. ä»€ä¹ˆæ˜¯åç¨‹ï¼ˆGoroutineï¼‰"></a>5. ä»€ä¹ˆæ˜¯åç¨‹ï¼ˆGoroutineï¼‰</h2><p>ç­”æ¡ˆ<br>Goroutine æ˜¯ä¸å…¶ä»–å‡½æ•°æˆ–æ–¹æ³•åŒæ—¶è¿è¡Œçš„å‡½æ•°æˆ–æ–¹æ³•ã€‚ Goroutines å¯ä»¥è¢«è®¤ä¸ºæ˜¯è½»é‡çº§çš„çº¿ç¨‹ã€‚ ä¸çº¿ç¨‹ç›¸æ¯”ï¼Œåˆ›å»º Goroutine çš„å¼€é”€å¾ˆå°ã€‚ Goåº”ç”¨ç¨‹åºåŒæ—¶è¿è¡Œæ•°åƒä¸ª Goroutine æ˜¯éå¸¸å¸¸è§çš„åšæ³•ã€‚</p><h2 id="6-å¦‚ä½•é«˜æ•ˆåœ°æ‹¼æ¥å­—ç¬¦ä¸²"><a href="#6-å¦‚ä½•é«˜æ•ˆåœ°æ‹¼æ¥å­—ç¬¦ä¸²" class="headerlink" title="6. å¦‚ä½•é«˜æ•ˆåœ°æ‹¼æ¥å­—ç¬¦ä¸²"></a>6. å¦‚ä½•é«˜æ•ˆåœ°æ‹¼æ¥å­—ç¬¦ä¸²</h2><p>ç­”æ¡ˆ<br>Go è¯­è¨€ä¸­ï¼Œå­—ç¬¦ä¸²æ˜¯åªè¯»çš„ï¼Œä¹Ÿå°±æ„å‘³ç€æ¯æ¬¡ä¿®æ”¹æ“ä½œéƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ã€‚å¦‚æœéœ€è¦æ‹¼æ¥å¤šæ¬¡ï¼Œåº”ä½¿ç”¨ strings.Builderï¼Œæœ€å°åŒ–å†…å­˜æ‹·è´æ¬¡æ•°ã€‚</p><pre><code class="go">var str strings.Builderfor i := 0; i &lt; 1000; i++ {    str.WriteString("a")}fmt.Println(str.String())</code></pre><h2 id="7-ä»€ä¹ˆæ˜¯-rune-ç±»å‹"><a href="#7-ä»€ä¹ˆæ˜¯-rune-ç±»å‹" class="headerlink" title="7. ä»€ä¹ˆæ˜¯ rune ç±»å‹"></a>7. ä»€ä¹ˆæ˜¯ rune ç±»å‹</h2><p>ç­”æ¡ˆ<br>ASCII ç åªéœ€è¦ 7 bit å°±å¯ä»¥å®Œæ•´åœ°è¡¨ç¤ºï¼Œä½†åªèƒ½è¡¨ç¤ºè‹±æ–‡å­—æ¯åœ¨å†…çš„128ä¸ªå­—ç¬¦ï¼Œä¸ºäº†è¡¨ç¤ºä¸–ç•Œä¸Šå¤§éƒ¨åˆ†çš„æ–‡å­—ç³»ç»Ÿï¼Œå‘æ˜äº† Unicodeï¼Œ å®ƒæ˜¯ASCIIçš„è¶…é›†ï¼ŒåŒ…å«ä¸–ç•Œä¸Šä¹¦å†™ç³»ç»Ÿä¸­å­˜åœ¨çš„æ‰€æœ‰å­—ç¬¦ï¼Œå¹¶ä¸ºæ¯ä¸ªä»£ç åˆ†é…ä¸€ä¸ªæ ‡å‡†ç¼–å·ï¼ˆç§°ä¸ºUnicode CodePointï¼‰ï¼Œåœ¨ Go è¯­è¨€ä¸­ç§°ä¹‹ä¸º runeï¼Œæ˜¯ int32 ç±»å‹çš„åˆ«åã€‚<br>Go è¯­è¨€ä¸­ï¼Œå­—ç¬¦ä¸²çš„åº•å±‚è¡¨ç¤ºæ˜¯ byte (8 bit) åºåˆ—ï¼Œè€Œé rune (32 bit) åºåˆ—ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä¾‹å­ä¸­ è¯­ å’Œ è¨€ ä½¿ç”¨ UTF-8 ç¼–ç åå„å  3 ä¸ª byteï¼Œå› æ­¤ len(â€œGoè¯­è¨€â€) ç­‰äº 8ï¼Œå½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º rune åºåˆ—ã€‚</p><pre><code class="go">fmt.Println(len("Goè¯­è¨€")) // 8fmt.Println(len([]rune("Goè¯­è¨€"))) // 4</code></pre><h2 id="8-å¦‚ä½•åˆ¤æ–­-map-ä¸­æ˜¯å¦åŒ…å«æŸä¸ª-key-ï¼Ÿ"><a href="#8-å¦‚ä½•åˆ¤æ–­-map-ä¸­æ˜¯å¦åŒ…å«æŸä¸ª-key-ï¼Ÿ" class="headerlink" title="8. å¦‚ä½•åˆ¤æ–­ map ä¸­æ˜¯å¦åŒ…å«æŸä¸ª key ï¼Ÿ"></a>8. å¦‚ä½•åˆ¤æ–­ map ä¸­æ˜¯å¦åŒ…å«æŸä¸ª key ï¼Ÿ</h2><p>ç­”æ¡ˆ</p><pre><code class="go">if val, ok := dict["foo"]; ok {    //do something here}</code></pre><p>dict[â€œfooâ€] æœ‰ 2 ä¸ªè¿”å›å€¼ï¼Œval å’Œ okï¼Œå¦‚æœ ok ç­‰äº trueï¼Œåˆ™è¯´æ˜ dict åŒ…å« key â€œfooâ€ï¼Œval å°†è¢«èµ‹äºˆ â€œfooâ€ å¯¹åº”çš„å€¼ã€‚</p><h2 id="9-Go-æ”¯æŒé»˜è®¤å‚æ•°æˆ–å¯é€‰å‚æ•°å—ï¼Ÿ"><a href="#9-Go-æ”¯æŒé»˜è®¤å‚æ•°æˆ–å¯é€‰å‚æ•°å—ï¼Ÿ" class="headerlink" title="9. Go æ”¯æŒé»˜è®¤å‚æ•°æˆ–å¯é€‰å‚æ•°å—ï¼Ÿ"></a>9. Go æ”¯æŒé»˜è®¤å‚æ•°æˆ–å¯é€‰å‚æ•°å—ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>Go è¯­è¨€ä¸æ”¯æŒå¯é€‰å‚æ•°ï¼ˆpython æ”¯æŒï¼‰ï¼Œä¹Ÿä¸æ”¯æŒæ–¹æ³•é‡è½½ï¼ˆjavaæ”¯æŒï¼‰ã€‚</p><h2 id="10-defer-çš„æ‰§è¡Œé¡ºåº"><a href="#10-defer-çš„æ‰§è¡Œé¡ºåº" class="headerlink" title="10. defer çš„æ‰§è¡Œé¡ºåº"></a>10. defer çš„æ‰§è¡Œé¡ºåº</h2><p>ç­”æ¡ˆ<br>å¤šä¸ª defer è¯­å¥ï¼Œéµä»åè¿›å…ˆå‡º(Last In First Outï¼ŒLIFO)çš„åŸåˆ™ï¼Œæœ€åå£°æ˜çš„ defer è¯­å¥ï¼Œæœ€å…ˆå¾—åˆ°æ‰§è¡Œã€‚<br>defer åœ¨ return è¯­å¥ä¹‹åæ‰§è¡Œï¼Œä½†åœ¨å‡½æ•°é€€å‡ºä¹‹å‰ï¼Œdefer å¯ä»¥ä¿®æ”¹è¿”å›å€¼ã€‚<br>ä¾‹å¦‚ï¼š</p><pre><code class="go">func test() int {    i := 0    defer func() {        fmt.Println("defer1")    }()    defer func() {        i += 1        fmt.Println("defer2")    }()    return i}func main() {    fmt.Println("return", test())}// defer2// defer1// return 0</code></pre><p>è¿™ä¸ªä¾‹å­ä¸­ï¼Œå¯ä»¥çœ‹åˆ° defer çš„æ‰§è¡Œé¡ºåºï¼šåè¿›å…ˆå‡ºã€‚ä½†æ˜¯è¿”å›å€¼å¹¶æ²¡æœ‰è¢«ä¿®æ”¹ï¼Œè¿™æ˜¯ç”±äº Go çš„è¿”å›æœºåˆ¶å†³å®šçš„ï¼Œæ‰§è¡Œ return è¯­å¥åï¼ŒGo ä¼šåˆ›å»ºä¸€ä¸ªä¸´æ—¶å˜é‡ä¿å­˜è¿”å›å€¼ï¼Œå› æ­¤ï¼Œdefer è¯­å¥ä¿®æ”¹äº†å±€éƒ¨å˜é‡ iï¼Œå¹¶æ²¡æœ‰ä¿®æ”¹è¿”å›å€¼ã€‚é‚£å¦‚æœæ˜¯æœ‰åçš„è¿”å›å€¼å‘¢ï¼Ÿ</p><pre><code class="go">func test() (i int) {    i = 0    defer func() {        i += 1        fmt.Println("defer2")    }()    return i}func main() {    fmt.Println("return", test())}// defer2// return 1</code></pre><p>è¿™ä¸ªä¾‹å­ä¸­ï¼Œè¿”å›å€¼è¢«ä¿®æ”¹äº†ã€‚å¯¹äºæœ‰åè¿”å›å€¼çš„å‡½æ•°ï¼Œæ‰§è¡Œ return è¯­å¥æ—¶ï¼Œå¹¶ä¸ä¼šå†åˆ›å»ºä¸´æ—¶å˜é‡ä¿å­˜ï¼Œå› æ­¤ï¼Œdefer è¯­å¥ä¿®æ”¹äº† iï¼Œå³å¯¹è¿”å›å€¼äº§ç”Ÿäº†å½±å“ã€‚<br>Q11 å¦‚ä½•äº¤æ¢ 2 ä¸ªå˜é‡çš„å€¼ï¼Ÿ<br>ç­”æ¡ˆ</p><pre><code class="go">a, b := "A", "B"a, b = b, afmt.Println(a, b) // B A</code></pre><h2 id="12-Go-è¯­è¨€-tag-çš„ç”¨å¤„ï¼Ÿ"><a href="#12-Go-è¯­è¨€-tag-çš„ç”¨å¤„ï¼Ÿ" class="headerlink" title="12. Go è¯­è¨€ tag çš„ç”¨å¤„ï¼Ÿ"></a>12. Go è¯­è¨€ tag çš„ç”¨å¤„ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>tag å¯ä»¥ç†è§£ä¸º struct å­—æ®µçš„æ³¨è§£ï¼Œå¯ä»¥ç”¨æ¥å®šä¹‰å­—æ®µçš„ä¸€ä¸ªæˆ–å¤šä¸ªå±æ€§ã€‚æ¡†æ¶/å·¥å…·å¯ä»¥é€šè¿‡åå°„è·å–åˆ°æŸä¸ªå­—æ®µå®šä¹‰çš„å±æ€§ï¼Œé‡‡å–ç›¸åº”çš„å¤„ç†æ–¹å¼ã€‚tag ä¸°å¯Œäº†ä»£ç çš„è¯­ä¹‰ï¼Œå¢å¼ºäº†çµæ´»æ€§ã€‚<br>ä¾‹å¦‚ï¼š</p><pre><code class="go">package mainimport "fmt"import "encoding/json"type Stu struct {    Name string `json:"stu_name"`    ID   string `json:"stu_id"`    Age  int    `json:"-"`}func main() {    buf, _ := json.Marshal(Stu{"Tom", "t001", 18})    fmt.Printf("%s\n", buf)}</code></pre><p>è¿™ä¸ªä¾‹å­ä½¿ç”¨ tag å®šä¹‰äº†ç»“æ„ä½“å­—æ®µä¸ json å­—æ®µçš„è½¬æ¢å…³ç³»ï¼ŒName -&gt; stu_name, ID -&gt; stu_idï¼Œå¿½ç•¥ Age å­—æ®µã€‚å¾ˆæ–¹ä¾¿åœ°å®ç°äº† Go ç»“æ„ä½“ä¸ä¸åŒè§„èŒƒçš„ json æ–‡æœ¬ä¹‹é—´çš„è½¬æ¢ã€‚</p><h2 id="13-å¦‚ä½•åˆ¤æ–­-2-ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼ˆslice-æ˜¯ç›¸ç­‰çš„ï¼Ÿ"><a href="#13-å¦‚ä½•åˆ¤æ–­-2-ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼ˆslice-æ˜¯ç›¸ç­‰çš„ï¼Ÿ" class="headerlink" title="13. å¦‚ä½•åˆ¤æ–­ 2 ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼ˆslice) æ˜¯ç›¸ç­‰çš„ï¼Ÿ"></a>13. å¦‚ä½•åˆ¤æ–­ 2 ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼ˆslice) æ˜¯ç›¸ç­‰çš„ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>go è¯­è¨€ä¸­å¯ä»¥ä½¿ç”¨åå°„ reflect.DeepEqual(a, b) åˆ¤æ–­ aã€b ä¸¤ä¸ªåˆ‡ç‰‡æ˜¯å¦ç›¸ç­‰ï¼Œä½†æ˜¯é€šå¸¸ä¸æ¨èè¿™ä¹ˆåšï¼Œä½¿ç”¨åå°„éå¸¸å½±å“æ€§èƒ½ã€‚<br>é€šå¸¸é‡‡ç”¨çš„æ–¹å¼å¦‚ä¸‹ï¼Œéå†æ¯”è¾ƒåˆ‡ç‰‡ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼ˆæ³¨æ„å¤„ç†è¶Šç•Œçš„æƒ…å†µï¼‰ã€‚</p><pre><code class="go">func StringSliceEqualBCE(a, b []string) bool {    if len(a) != len(b) {        return false    }    if (a == nil) != (b == nil) {        return false    }    b = b[:len(a)]    for i, v := range a {        if v != b[i] {            return false        }    }    return true}</code></pre><h2 id="14-å­—ç¬¦ä¸²æ‰“å°æ—¶ï¼Œ-v-å’Œ-v-çš„åŒºåˆ«"><a href="#14-å­—ç¬¦ä¸²æ‰“å°æ—¶ï¼Œ-v-å’Œ-v-çš„åŒºåˆ«" class="headerlink" title="14. å­—ç¬¦ä¸²æ‰“å°æ—¶ï¼Œ%v å’Œ %+v çš„åŒºåˆ«"></a>14. å­—ç¬¦ä¸²æ‰“å°æ—¶ï¼Œ%v å’Œ %+v çš„åŒºåˆ«</h2><p>ç­”æ¡ˆ<br>%v å’Œ %+v éƒ½å¯ä»¥ç”¨æ¥æ‰“å° struct çš„å€¼ï¼ŒåŒºåˆ«åœ¨äº %v ä»…æ‰“å°å„ä¸ªå­—æ®µçš„å€¼ï¼Œ%+v è¿˜ä¼šæ‰“å°å„ä¸ªå­—æ®µçš„åç§°ã€‚</p><pre><code class="go">type Stu struct {    Name string}func main() {    fmt.Printf("%v\n", Stu{"Tom"}) // {Tom}    fmt.Printf("%+v\n", Stu{"Tom"}) // {Name:Tom}}</code></pre><p>ä½†å¦‚æœç»“æ„ä½“å®šä¹‰äº† String() æ–¹æ³•ï¼Œ%v å’Œ %+v éƒ½ä¼šè°ƒç”¨ String() è¦†ç›–é»˜è®¤å€¼ã€‚</p><h2 id="15-Go-è¯­è¨€ä¸­å¦‚ä½•è¡¨ç¤ºæšä¸¾å€¼-enums"><a href="#15-Go-è¯­è¨€ä¸­å¦‚ä½•è¡¨ç¤ºæšä¸¾å€¼-enums" class="headerlink" title="15. Go è¯­è¨€ä¸­å¦‚ä½•è¡¨ç¤ºæšä¸¾å€¼(enums)"></a>15. Go è¯­è¨€ä¸­å¦‚ä½•è¡¨ç¤ºæšä¸¾å€¼(enums)</h2><p>ç­”æ¡ˆ<br>é€šå¸¸ä½¿ç”¨å¸¸é‡(const) æ¥è¡¨ç¤ºæšä¸¾å€¼ã€‚</p><pre><code class="go">type StuType int32const (    Type1 StuType = iota    Type2    Type3    Type4)func main() {    fmt.Println(Type1, Type2, Type3, Type4) // 0, 1, 2, 3}</code></pre><p>å‚è€ƒ What is an idiomatic way of representing enums in Go? - StackOverflow</p><h2 id="16-ç©º-struct-çš„ç”¨é€”"><a href="#16-ç©º-struct-çš„ç”¨é€”" class="headerlink" title="16. ç©º struct{} çš„ç”¨é€”"></a>16. ç©º struct{} çš„ç”¨é€”</h2><p>ç­”æ¡ˆ<br>ä½¿ç”¨ç©ºç»“æ„ä½“ struct{} å¯ä»¥èŠ‚çœå†…å­˜ï¼Œä¸€èˆ¬ä½œä¸ºå ä½ç¬¦ä½¿ç”¨ï¼Œè¡¨æ˜è¿™é‡Œå¹¶ä¸éœ€è¦ä¸€ä¸ªå€¼ã€‚</p><pre><code class="go">fmt.Println(unsafe.Sizeof(struct{}{})) // 0</code></pre><p>æ¯”å¦‚ä½¿ç”¨ map è¡¨ç¤ºé›†åˆæ—¶ï¼Œåªå…³æ³¨ keyï¼Œvalue å¯ä»¥ä½¿ç”¨ struct{} ä½œä¸ºå ä½ç¬¦ã€‚å¦‚æœä½¿ç”¨å…¶ä»–ç±»å‹ä½œä¸ºå ä½ç¬¦ï¼Œä¾‹å¦‚ intï¼Œboolï¼Œä¸ä»…æµªè´¹äº†å†…å­˜ï¼Œè€Œä¸”å®¹æ˜“å¼•èµ·æ­§ä¹‰ã€‚</p><pre><code class="go">type Set map[string]struct{}func main() {    set := make(Set)    for _, item := range []string{"A", "A", "B", "C"} {        set[item] = struct{}{}    }    fmt.Println(len(set)) // 3    if _, ok := set["A"]; ok {        fmt.Println("A exists") // A exists    }}</code></pre><p>å†æ¯”å¦‚ï¼Œä½¿ç”¨ä¿¡é“(channel)æ§åˆ¶å¹¶å‘æ—¶ï¼Œæˆ‘ä»¬åªæ˜¯éœ€è¦ä¸€ä¸ªä¿¡å·ï¼Œä½†å¹¶ä¸éœ€è¦ä¼ é€’å€¼ï¼Œè¿™ä¸ªæ—¶å€™ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ struct{} ä»£æ›¿ã€‚</p><pre><code class="go">func main() {    ch := make(chan struct{}, 1)    go func() {        &lt;-ch        // do something    }()    ch &lt;- struct{}{}    // ...}</code></pre><p>å†æ¯”å¦‚ï¼Œå£°æ˜åªåŒ…å«æ–¹æ³•çš„ç»“æ„ä½“ã€‚</p><pre><code class="go">type Lamp struct{}func (l Lamp) On() {        println("On")}func (l Lamp) Off() {        println("Off")}</code></pre><h1 id="äºŒã€Go-è¯­è¨€ç¬”è¯•é¢è¯•é¢˜-å®ç°åŸç†"><a href="#äºŒã€Go-è¯­è¨€ç¬”è¯•é¢è¯•é¢˜-å®ç°åŸç†" class="headerlink" title="äºŒã€Go è¯­è¨€ç¬”è¯•é¢è¯•é¢˜(å®ç°åŸç†)"></a>äºŒã€Go è¯­è¨€ç¬”è¯•é¢è¯•é¢˜(å®ç°åŸç†)</h1><h2 id="1-init-å‡½æ•°æ˜¯ä»€ä¹ˆæ—¶å€™æ‰§è¡Œçš„ï¼Ÿ"><a href="#1-init-å‡½æ•°æ˜¯ä»€ä¹ˆæ—¶å€™æ‰§è¡Œçš„ï¼Ÿ" class="headerlink" title="1. init() å‡½æ•°æ˜¯ä»€ä¹ˆæ—¶å€™æ‰§è¡Œçš„ï¼Ÿ"></a>1. init() å‡½æ•°æ˜¯ä»€ä¹ˆæ—¶å€™æ‰§è¡Œçš„ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>init() å‡½æ•°æ˜¯ Go ç¨‹åºåˆå§‹åŒ–çš„ä¸€éƒ¨åˆ†ã€‚Go ç¨‹åºåˆå§‹åŒ–å…ˆäº main å‡½æ•°ï¼Œç”± runtime åˆå§‹åŒ–æ¯ä¸ªå¯¼å…¥çš„åŒ…ï¼Œåˆå§‹åŒ–é¡ºåºä¸æ˜¯æŒ‰ç…§ä»ä¸Šåˆ°ä¸‹çš„å¯¼å…¥é¡ºåºï¼Œè€Œæ˜¯æŒ‰ç…§è§£æçš„ä¾èµ–å…³ç³»ï¼Œæ²¡æœ‰ä¾èµ–çš„åŒ…æœ€å…ˆåˆå§‹åŒ–ã€‚<br>æ¯ä¸ªåŒ…é¦–å…ˆåˆå§‹åŒ–åŒ…ä½œç”¨åŸŸçš„å¸¸é‡å’Œå˜é‡ï¼ˆå¸¸é‡ä¼˜å…ˆäºå˜é‡ï¼‰ï¼Œç„¶åæ‰§è¡ŒåŒ…çš„ init() å‡½æ•°ã€‚åŒä¸€ä¸ªåŒ…ï¼Œç”šè‡³æ˜¯åŒä¸€ä¸ªæºæ–‡ä»¶å¯ä»¥æœ‰å¤šä¸ª init() å‡½æ•°ã€‚init() å‡½æ•°æ²¡æœ‰å…¥å‚å’Œè¿”å›å€¼ï¼Œä¸èƒ½è¢«å…¶ä»–å‡½æ•°è°ƒç”¨ï¼ŒåŒä¸€ä¸ªåŒ…å†…å¤šä¸ª init() å‡½æ•°çš„æ‰§è¡Œé¡ºåºä¸ä½œä¿è¯ã€‚<br>ä¸€å¥è¯æ€»ç»“ï¼š import â€“&gt; const â€“&gt; var â€“&gt; init() â€“&gt; main()<br>ç¤ºä¾‹ï¼š</p><pre><code class="go">package mainimport "fmt"func init()  {    fmt.Println("init1:", a)}func init()  {    fmt.Println("init2:", a)}var a = 10const b = 100func main() {    fmt.Println("main:", a)}// æ‰§è¡Œç»“æœ// init1: 10// init2: 10// main: 10</code></pre><h2 id="2-Go-è¯­è¨€çš„å±€éƒ¨å˜é‡åˆ†é…åœ¨æ ˆä¸Šè¿˜æ˜¯å †ä¸Šï¼Ÿ"><a href="#2-Go-è¯­è¨€çš„å±€éƒ¨å˜é‡åˆ†é…åœ¨æ ˆä¸Šè¿˜æ˜¯å †ä¸Šï¼Ÿ" class="headerlink" title="2. Go è¯­è¨€çš„å±€éƒ¨å˜é‡åˆ†é…åœ¨æ ˆä¸Šè¿˜æ˜¯å †ä¸Šï¼Ÿ"></a>2. Go è¯­è¨€çš„å±€éƒ¨å˜é‡åˆ†é…åœ¨æ ˆä¸Šè¿˜æ˜¯å †ä¸Šï¼Ÿ</h2><p>ç­”æ¡ˆ<br>ç”±ç¼–è¯‘å™¨å†³å®šã€‚Go è¯­è¨€ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å†³å®šæŠŠä¸€ä¸ªå˜é‡æ”¾åœ¨æ ˆè¿˜æ˜¯æ”¾åœ¨å †ï¼Œç¼–è¯‘å™¨ä¼šåšé€ƒé€¸åˆ†æ(escape analysis)ï¼Œå½“å‘ç°å˜é‡çš„ä½œç”¨åŸŸæ²¡æœ‰è¶…å‡ºå‡½æ•°èŒƒå›´ï¼Œå°±å¯ä»¥åœ¨æ ˆä¸Šï¼Œåä¹‹åˆ™å¿…é¡»åˆ†é…åœ¨å †ä¸Šã€‚</p><pre><code class="go">func foo() *int {    v := 11    return &amp;v}func main() {    m := foo()    println(*m) // 11}</code></pre><p>foo() å‡½æ•°ä¸­ï¼Œå¦‚æœ v åˆ†é…åœ¨æ ˆä¸Šï¼Œfoo å‡½æ•°è¿”å›æ—¶ï¼Œ&amp;v å°±ä¸å­˜åœ¨äº†ï¼Œä½†æ˜¯è¿™æ®µå‡½æ•°æ˜¯èƒ½å¤Ÿæ­£å¸¸è¿è¡Œçš„ã€‚Go ç¼–è¯‘å™¨å‘ç° v çš„å¼•ç”¨è„±ç¦»äº† foo çš„ä½œç”¨åŸŸï¼Œä¼šå°†å…¶åˆ†é…åœ¨å †ä¸Šã€‚å› æ­¤ï¼Œmain å‡½æ•°ä¸­ä»èƒ½å¤Ÿæ­£å¸¸è®¿é—®è¯¥å€¼ã€‚</p><h2 id="3-2-ä¸ª-interface-å¯ä»¥æ¯”è¾ƒå—ï¼Ÿ"><a href="#3-2-ä¸ª-interface-å¯ä»¥æ¯”è¾ƒå—ï¼Ÿ" class="headerlink" title="3. 2 ä¸ª interface å¯ä»¥æ¯”è¾ƒå—ï¼Ÿ"></a>3. 2 ä¸ª interface å¯ä»¥æ¯”è¾ƒå—ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>Go è¯­è¨€ä¸­ï¼Œinterface çš„å†…éƒ¨å®ç°åŒ…å«äº† 2 ä¸ªå­—æ®µï¼Œç±»å‹ T å’Œ å€¼ Vï¼Œinterface å¯ä»¥ä½¿ç”¨ == æˆ– != æ¯”è¾ƒã€‚2 ä¸ª interface ç›¸ç­‰æœ‰ä»¥ä¸‹ 2 ç§æƒ…å†µ<br>ä¸¤ä¸ª interface å‡ç­‰äº nilï¼ˆæ­¤æ—¶ V å’Œ T éƒ½å¤„äº unset çŠ¶æ€ï¼‰<br>ç±»å‹ T ç›¸åŒï¼Œä¸”å¯¹åº”çš„å€¼ V ç›¸ç­‰ã€‚<br>çœ‹ä¸‹é¢çš„ä¾‹å­ï¼š</p><pre><code class="go">type Stu struct {    Name string}type StuInt interface{}func main() {    var stu1, stu2 StuInt = &amp;Stu{"Tom"}, &amp;Stu{"Tom"}    var stu3, stu4 StuInt = Stu{"Tom"}, Stu{"Tom"}    fmt.Println(stu1 == stu2) // false    fmt.Println(stu3 == stu4) // true}</code></pre><p>stu1 å’Œ stu2 å¯¹åº”çš„ç±»å‹æ˜¯ *Stuï¼Œå€¼æ˜¯ Stu ç»“æ„ä½“çš„åœ°å€ï¼Œä¸¤ä¸ªåœ°å€ä¸åŒï¼Œå› æ­¤ç»“æœä¸º falseã€‚<br>stu3 å’Œ stu4 å¯¹åº”çš„ç±»å‹æ˜¯ Stuï¼Œå€¼æ˜¯ Stu ç»“æ„ä½“ï¼Œä¸”å„å­—æ®µç›¸ç­‰ï¼Œå› æ­¤ç»“æœä¸º trueã€‚</p><h2 id="4-ä¸¤ä¸ª-nil-å¯èƒ½ä¸ç›¸ç­‰å—ï¼Ÿ"><a href="#4-ä¸¤ä¸ª-nil-å¯èƒ½ä¸ç›¸ç­‰å—ï¼Ÿ" class="headerlink" title="4. ä¸¤ä¸ª nil å¯èƒ½ä¸ç›¸ç­‰å—ï¼Ÿ"></a>4. ä¸¤ä¸ª nil å¯èƒ½ä¸ç›¸ç­‰å—ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>å¯èƒ½ã€‚<br>æ¥å£(interface) æ˜¯å¯¹éæ¥å£å€¼(ä¾‹å¦‚æŒ‡é’ˆï¼Œstructç­‰)çš„å°è£…ï¼Œå†…éƒ¨å®ç°åŒ…å« 2 ä¸ªå­—æ®µï¼Œç±»å‹ T å’Œ å€¼ Vã€‚ä¸€ä¸ªæ¥å£ç­‰äº nilï¼Œå½“ä¸”ä»…å½“ T å’Œ V å¤„äº unset çŠ¶æ€ï¼ˆT=nilï¼ŒV is unsetï¼‰ã€‚<br>ä¸¤ä¸ªæ¥å£å€¼æ¯”è¾ƒæ—¶ï¼Œä¼šå…ˆæ¯”è¾ƒ Tï¼Œå†æ¯”è¾ƒ Vã€‚<br>æ¥å£å€¼ä¸éæ¥å£å€¼æ¯”è¾ƒæ—¶ï¼Œä¼šå…ˆå°†éæ¥å£å€¼å°è¯•è½¬æ¢ä¸ºæ¥å£å€¼ï¼Œå†æ¯”è¾ƒã€‚</p><pre><code class="go">func main() {    var p *int = nil    var i interface{} = p    fmt.Println(i == p) // true    fmt.Println(p == nil) // true    fmt.Println(i == nil) // false}</code></pre><p>ä¸Šé¢è¿™ä¸ªä¾‹å­ä¸­ï¼Œå°†ä¸€ä¸ª nil éæ¥å£å€¼ p èµ‹å€¼ç»™æ¥å£ iï¼Œæ­¤æ—¶ï¼Œi çš„å†…éƒ¨å­—æ®µä¸º(T=*int, V=nil)ï¼Œi ä¸ p ä½œæ¯”è¾ƒæ—¶ï¼Œå°† p è½¬æ¢ä¸ºæ¥å£åå†æ¯”è¾ƒï¼Œå› æ­¤ i == pï¼Œp ä¸ nil æ¯”è¾ƒï¼Œç›´æ¥æ¯”è¾ƒå€¼ï¼Œæ‰€ä»¥ p == nilã€‚<br>ä½†æ˜¯å½“ i ä¸ nil æ¯”è¾ƒæ—¶ï¼Œä¼šå°† nil è½¬æ¢ä¸ºæ¥å£ (T=nil, V=nil)ï¼Œä¸i (T=*int, V=nil) ä¸ç›¸ç­‰ï¼Œå› æ­¤ i != nilã€‚å› æ­¤ V ä¸º nil ï¼Œä½† T ä¸ä¸º nil çš„æ¥å£ä¸ç­‰äº nilã€‚</p><h2 id="5-ç®€è¿°-Go-è¯­è¨€GC-åƒåœ¾å›æ”¶-çš„å·¥ä½œåŸç†"><a href="#5-ç®€è¿°-Go-è¯­è¨€GC-åƒåœ¾å›æ”¶-çš„å·¥ä½œåŸç†" class="headerlink" title="5. ç®€è¿° Go è¯­è¨€GC(åƒåœ¾å›æ”¶)çš„å·¥ä½œåŸç†"></a>5. ç®€è¿° Go è¯­è¨€GC(åƒåœ¾å›æ”¶)çš„å·¥ä½œåŸç†</h2><p>ç­”æ¡ˆ<br>æœ€å¸¸è§çš„åƒåœ¾å›æ”¶ç®—æ³•æœ‰æ ‡è®°æ¸…é™¤(Mark-Sweep) å’Œå¼•ç”¨è®¡æ•°(Reference Count)ï¼ŒGo è¯­è¨€é‡‡ç”¨çš„æ˜¯æ ‡è®°æ¸…é™¤ç®—æ³•ã€‚å¹¶åœ¨æ­¤åŸºç¡€ä¸Šä½¿ç”¨äº†ä¸‰è‰²æ ‡è®°æ³•å’Œå†™å±éšœæŠ€æœ¯ï¼Œæé«˜äº†æ•ˆç‡ã€‚<br>æ ‡è®°æ¸…é™¤æ”¶é›†å™¨æ˜¯è·Ÿè¸ªå¼åƒåœ¾æ”¶é›†å™¨ï¼Œå…¶æ‰§è¡Œè¿‡ç¨‹å¯ä»¥åˆ†æˆæ ‡è®°ï¼ˆMarkï¼‰å’Œæ¸…é™¤ï¼ˆSweepï¼‰ä¸¤ä¸ªé˜¶æ®µï¼š<br>æ ‡è®°é˜¶æ®µ â€” ä»æ ¹å¯¹è±¡å‡ºå‘æŸ¥æ‰¾å¹¶æ ‡è®°å †ä¸­æ‰€æœ‰å­˜æ´»çš„å¯¹è±¡ï¼›<br>æ¸…é™¤é˜¶æ®µ â€” éå†å †ä¸­çš„å…¨éƒ¨å¯¹è±¡ï¼Œå›æ”¶æœªè¢«æ ‡è®°çš„åƒåœ¾å¯¹è±¡å¹¶å°†å›æ”¶çš„å†…å­˜åŠ å…¥ç©ºé—²é“¾è¡¨ã€‚<br>æ ‡è®°æ¸…é™¤ç®—æ³•çš„ä¸€å¤§é—®é¢˜æ˜¯åœ¨æ ‡è®°æœŸé—´ï¼Œéœ€è¦æš‚åœç¨‹åºï¼ˆStop the worldï¼ŒSTWï¼‰ï¼Œæ ‡è®°ç»“æŸä¹‹åï¼Œç”¨æˆ·ç¨‹åºæ‰å¯ä»¥ç»§ç»­æ‰§è¡Œã€‚ä¸ºäº†èƒ½å¤Ÿå¼‚æ­¥æ‰§è¡Œï¼Œå‡å°‘ STW çš„æ—¶é—´ï¼ŒGo è¯­è¨€é‡‡ç”¨äº†ä¸‰è‰²æ ‡è®°æ³•ã€‚<br>ä¸‰è‰²æ ‡è®°ç®—æ³•å°†ç¨‹åºä¸­çš„å¯¹è±¡åˆ†æˆç™½è‰²ã€é»‘è‰²å’Œç°è‰²ä¸‰ç±»ã€‚<br>ç™½è‰²ï¼šä¸ç¡®å®šå¯¹è±¡ã€‚<br>ç°è‰²ï¼šå­˜æ´»å¯¹è±¡ï¼Œå­å¯¹è±¡å¾…å¤„ç†ã€‚<br>é»‘è‰²ï¼šå­˜æ´»å¯¹è±¡ã€‚<br>æ ‡è®°å¼€å§‹æ—¶ï¼Œæ‰€æœ‰å¯¹è±¡åŠ å…¥ç™½è‰²é›†åˆï¼ˆè¿™ä¸€æ­¥éœ€ STW ï¼‰ã€‚é¦–å…ˆå°†æ ¹å¯¹è±¡æ ‡è®°ä¸ºç°è‰²ï¼ŒåŠ å…¥ç°è‰²é›†åˆï¼Œåƒåœ¾æœé›†å™¨å–å‡ºä¸€ä¸ªç°è‰²å¯¹è±¡ï¼Œå°†å…¶æ ‡è®°ä¸ºé»‘è‰²ï¼Œå¹¶å°†å…¶æŒ‡å‘çš„å¯¹è±¡æ ‡è®°ä¸ºç°è‰²ï¼ŒåŠ å…¥ç°è‰²é›†åˆã€‚é‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œç›´åˆ°ç°è‰²é›†åˆä¸ºç©ºä¸ºæ­¢ï¼Œæ ‡è®°é˜¶æ®µç»“æŸã€‚é‚£ä¹ˆç™½è‰²å¯¹è±¡å³å¯éœ€è¦æ¸…ç†çš„å¯¹è±¡ï¼Œè€Œé»‘è‰²å¯¹è±¡å‡ä¸ºæ ¹å¯è¾¾çš„å¯¹è±¡ï¼Œä¸èƒ½è¢«æ¸…ç†ã€‚<br>ä¸‰è‰²æ ‡è®°æ³•å› ä¸ºå¤šäº†ä¸€ä¸ªç™½è‰²çš„çŠ¶æ€æ¥å­˜æ”¾ä¸ç¡®å®šå¯¹è±¡ï¼Œæ‰€ä»¥åç»­çš„æ ‡è®°é˜¶æ®µå¯ä»¥å¹¶å‘åœ°æ‰§è¡Œã€‚å½“ç„¶å¹¶å‘æ‰§è¡Œçš„ä»£ä»·æ˜¯å¯èƒ½ä¼šé€ æˆä¸€äº›é—æ¼ï¼Œå› ä¸ºé‚£äº›æ—©å…ˆè¢«æ ‡è®°ä¸ºé»‘è‰²çš„å¯¹è±¡å¯èƒ½ç›®å‰å·²ç»æ˜¯ä¸å¯è¾¾çš„äº†ã€‚æ‰€ä»¥ä¸‰è‰²æ ‡è®°æ³•æ˜¯ä¸€ä¸ª false negativeï¼ˆå‡é˜´æ€§ï¼‰çš„ç®—æ³•ã€‚<br>ä¸‰è‰²æ ‡è®°æ³•å¹¶å‘æ‰§è¡Œä»å­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œå³åœ¨ GC è¿‡ç¨‹ä¸­ï¼Œå¯¹è±¡æŒ‡é’ˆå‘ç”Ÿäº†æ”¹å˜ã€‚æ¯”å¦‚ä¸‹é¢çš„ä¾‹å­ï¼š</p><pre><code>A (é»‘) -&gt; B (ç°) -&gt; C (ç™½) -&gt; D (ç™½)</code></pre><p>æ­£å¸¸æƒ…å†µä¸‹ï¼ŒD å¯¹è±¡æœ€ç»ˆä¼šè¢«æ ‡è®°ä¸ºé»‘è‰²ï¼Œä¸åº”è¢«å›æ”¶ã€‚ä½†åœ¨æ ‡è®°å’Œç”¨æˆ·ç¨‹åºå¹¶å‘æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œç”¨æˆ·ç¨‹åºåˆ é™¤äº† C å¯¹ D çš„å¼•ç”¨ï¼Œè€Œ A è·å¾—äº† D çš„å¼•ç”¨ã€‚æ ‡è®°ç»§ç»­è¿›è¡Œï¼ŒD å°±æ²¡æœ‰æœºä¼šè¢«æ ‡è®°ä¸ºé»‘è‰²äº†ï¼ˆA å·²ç»å¤„ç†è¿‡ï¼Œè¿™ä¸€è½®ä¸ä¼šå†è¢«å¤„ç†ï¼‰ã€‚</p><pre><code>A (é»‘) -&gt; B (ç°) -&gt; C (ç™½)   â†“ D (ç™½)</code></pre><p>ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒGo ä½¿ç”¨äº†å†…å­˜å±éšœæŠ€æœ¯ï¼Œå®ƒæ˜¯åœ¨ç”¨æˆ·ç¨‹åºè¯»å–å¯¹è±¡ã€åˆ›å»ºæ–°å¯¹è±¡ä»¥åŠæ›´æ–°å¯¹è±¡æŒ‡é’ˆæ—¶æ‰§è¡Œçš„ä¸€æ®µä»£ç ï¼Œç±»ä¼¼äºä¸€ä¸ªé’©å­ã€‚åƒåœ¾æ”¶é›†å™¨ä½¿ç”¨äº†å†™å±éšœï¼ˆWrite Barrierï¼‰æŠ€æœ¯ï¼Œå½“å¯¹è±¡æ–°å¢æˆ–æ›´æ–°æ—¶ï¼Œä¼šå°†å…¶ç€è‰²ä¸ºç°è‰²ã€‚è¿™æ ·å³ä½¿ä¸ç”¨æˆ·ç¨‹åºå¹¶å‘æ‰§è¡Œï¼Œå¯¹è±¡çš„å¼•ç”¨å‘ç”Ÿæ”¹å˜æ—¶ï¼Œåƒåœ¾æ”¶é›†å™¨ä¹Ÿèƒ½æ­£ç¡®å¤„ç†äº†ã€‚<br>ä¸€æ¬¡å®Œæ•´çš„ GC åˆ†ä¸ºå››ä¸ªé˜¶æ®µï¼š<br>1ï¼‰æ ‡è®°å‡†å¤‡(Mark Setupï¼Œéœ€ STW)ï¼Œæ‰“å¼€å†™å±éšœ(Write Barrier)<br>2ï¼‰ä½¿ç”¨ä¸‰è‰²æ ‡è®°æ³•æ ‡è®°ï¼ˆMarking, å¹¶å‘ï¼‰<br>3ï¼‰æ ‡è®°ç»“æŸ(Mark Terminationï¼Œéœ€ STW)ï¼Œå…³é—­å†™å±éšœã€‚<br>4ï¼‰æ¸…ç†(Sweeping, å¹¶å‘)<br>å‚è€ƒ fullstack</p><h2 id="6-å‡½æ•°è¿”å›å±€éƒ¨å˜é‡çš„æŒ‡é’ˆæ˜¯å¦å®‰å…¨ï¼Ÿ"><a href="#6-å‡½æ•°è¿”å›å±€éƒ¨å˜é‡çš„æŒ‡é’ˆæ˜¯å¦å®‰å…¨ï¼Ÿ" class="headerlink" title="6. å‡½æ•°è¿”å›å±€éƒ¨å˜é‡çš„æŒ‡é’ˆæ˜¯å¦å®‰å…¨ï¼Ÿ"></a>6. å‡½æ•°è¿”å›å±€éƒ¨å˜é‡çš„æŒ‡é’ˆæ˜¯å¦å®‰å…¨ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>è¿™åœ¨ Go ä¸­æ˜¯å®‰å…¨çš„ï¼ŒGo ç¼–è¯‘å™¨å°†ä¼šå¯¹æ¯ä¸ªå±€éƒ¨å˜é‡è¿›è¡Œé€ƒé€¸åˆ†æã€‚å¦‚æœå‘ç°å±€éƒ¨å˜é‡çš„ä½œç”¨åŸŸè¶…å‡ºè¯¥å‡½æ•°ï¼Œåˆ™ä¸ä¼šå°†å†…å­˜åˆ†é…åœ¨æ ˆä¸Šï¼Œè€Œæ˜¯åˆ†é…åœ¨å †ä¸Šã€‚</p><h2 id="7-éæ¥å£éæ¥å£çš„ä»»æ„ç±»å‹-T-éƒ½èƒ½å¤Ÿè°ƒç”¨-T-çš„æ–¹æ³•å—ï¼Ÿåè¿‡æ¥å‘¢ï¼Ÿ"><a href="#7-éæ¥å£éæ¥å£çš„ä»»æ„ç±»å‹-T-éƒ½èƒ½å¤Ÿè°ƒç”¨-T-çš„æ–¹æ³•å—ï¼Ÿåè¿‡æ¥å‘¢ï¼Ÿ" class="headerlink" title="7. éæ¥å£éæ¥å£çš„ä»»æ„ç±»å‹ T() éƒ½èƒ½å¤Ÿè°ƒç”¨ *T çš„æ–¹æ³•å—ï¼Ÿåè¿‡æ¥å‘¢ï¼Ÿ"></a>7. éæ¥å£éæ¥å£çš„ä»»æ„ç±»å‹ T() éƒ½èƒ½å¤Ÿè°ƒç”¨ *T çš„æ–¹æ³•å—ï¼Ÿåè¿‡æ¥å‘¢ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>ä¸€ä¸ªTç±»å‹çš„å€¼å¯ä»¥è°ƒç”¨ä¸º<em>Tç±»å‹å£°æ˜çš„æ–¹æ³•ï¼Œä½†æ˜¯ä»…å½“æ­¤Tçš„å€¼æ˜¯å¯å¯»å€(addressable) çš„æƒ…å†µä¸‹ã€‚ç¼–è¯‘å™¨åœ¨è°ƒç”¨æŒ‡é’ˆå±ä¸»æ–¹æ³•å‰ï¼Œä¼šè‡ªåŠ¨å–æ­¤Tå€¼çš„åœ°å€ã€‚å› ä¸ºä¸æ˜¯ä»»ä½•Tå€¼éƒ½æ˜¯å¯å¯»å€çš„ï¼Œæ‰€ä»¥å¹¶éä»»ä½•Tå€¼éƒ½èƒ½å¤Ÿè°ƒç”¨ä¸ºç±»å‹</em>Tå£°æ˜çš„æ–¹æ³•ã€‚<br>åè¿‡æ¥ï¼Œä¸€ä¸ª<em>Tç±»å‹çš„å€¼å¯ä»¥è°ƒç”¨ä¸ºç±»å‹Tå£°æ˜çš„æ–¹æ³•ï¼Œè¿™æ˜¯å› ä¸ºè§£å¼•ç”¨æŒ‡é’ˆæ€»æ˜¯åˆæ³•çš„ã€‚äº‹å®ä¸Šï¼Œä½ å¯ä»¥è®¤ä¸ºå¯¹äºæ¯ä¸€ä¸ªä¸ºç±»å‹ T å£°æ˜çš„æ–¹æ³•ï¼Œç¼–è¯‘å™¨éƒ½ä¼šä¸ºç±»å‹</em>Tè‡ªåŠ¨éšå¼å£°æ˜ä¸€ä¸ªåŒåå’ŒåŒç­¾åçš„æ–¹æ³•ã€‚<br>å“ªäº›å€¼æ˜¯ä¸å¯å¯»å€çš„å‘¢ï¼Ÿ<br>å­—ç¬¦ä¸²ä¸­çš„å­—èŠ‚ï¼›<br>map å¯¹è±¡ä¸­çš„å…ƒç´ ï¼ˆslice å¯¹è±¡ä¸­çš„å…ƒç´ æ˜¯å¯å¯»å€çš„ï¼Œsliceçš„åº•å±‚æ˜¯æ•°ç»„ï¼‰ï¼›<br>å¸¸é‡ï¼›<br>åŒ…çº§åˆ«çš„å‡½æ•°ç­‰ã€‚<br>ä¸¾ä¸€ä¸ªä¾‹å­ï¼Œå®šä¹‰ç±»å‹ Tï¼Œå¹¶ä¸ºç±»å‹ *T å£°æ˜ä¸€ä¸ªæ–¹æ³• hello()ï¼Œå˜é‡ t1 å¯ä»¥è°ƒç”¨è¯¥æ–¹æ³•ï¼Œä½†æ˜¯å¸¸é‡ t2 è°ƒç”¨è¯¥æ–¹æ³•æ—¶ï¼Œä¼šäº§ç”Ÿç¼–è¯‘é”™è¯¯ã€‚</p><pre><code class="go">type T stringfunc (t *T) hello() {    fmt.Println("hello")}func main() {    var t1 T = "ABC"    t1.hello() // hello    const t2 T = "ABC"    t2.hello() // error: cannot call pointer method on t}</code></pre><h1 id="ä¸‰ã€Go-è¯­è¨€ç¬”è¯•é¢è¯•é¢˜-å¹¶å‘ç¼–ç¨‹"><a href="#ä¸‰ã€Go-è¯­è¨€ç¬”è¯•é¢è¯•é¢˜-å¹¶å‘ç¼–ç¨‹" class="headerlink" title="ä¸‰ã€Go è¯­è¨€ç¬”è¯•é¢è¯•é¢˜(å¹¶å‘ç¼–ç¨‹)"></a>ä¸‰ã€Go è¯­è¨€ç¬”è¯•é¢è¯•é¢˜(å¹¶å‘ç¼–ç¨‹)</h1><h2 id="1-æ— ç¼“å†²çš„-channel-å’Œ-æœ‰ç¼“å†²çš„-channel-çš„åŒºåˆ«ï¼Ÿ"><a href="#1-æ— ç¼“å†²çš„-channel-å’Œ-æœ‰ç¼“å†²çš„-channel-çš„åŒºåˆ«ï¼Ÿ" class="headerlink" title="1. æ— ç¼“å†²çš„ channel å’Œ æœ‰ç¼“å†²çš„ channel çš„åŒºåˆ«ï¼Ÿ"></a>1. æ— ç¼“å†²çš„ channel å’Œ æœ‰ç¼“å†²çš„ channel çš„åŒºåˆ«ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>å¯¹äºæ— ç¼“å†²çš„ channelï¼Œå‘é€æ–¹å°†é˜»å¡è¯¥ä¿¡é“ï¼Œç›´åˆ°æ¥æ”¶æ–¹ä»è¯¥ä¿¡é“æ¥æ”¶åˆ°æ•°æ®ä¸ºæ­¢ï¼Œè€Œæ¥æ”¶æ–¹ä¹Ÿå°†é˜»å¡è¯¥ä¿¡é“ï¼Œç›´åˆ°å‘é€æ–¹å°†æ•°æ®å‘é€åˆ°è¯¥ä¿¡é“ä¸­ä¸ºæ­¢ã€‚<br>å¯¹äºæœ‰ç¼“å­˜çš„ channelï¼Œå‘é€æ–¹åœ¨æ²¡æœ‰ç©ºæ’æ§½ï¼ˆç¼“å†²åŒºä½¿ç”¨å®Œï¼‰çš„æƒ…å†µä¸‹é˜»å¡ï¼Œè€Œæ¥æ”¶æ–¹åœ¨ä¿¡é“ä¸ºç©ºçš„æƒ…å†µä¸‹é˜»å¡ã€‚<br>ä¾‹å¦‚:</p><pre><code class="go">func main() {    st := time.Now()    ch := make(chan bool)    go func ()  {        time.Sleep(time.Second * 2)        &lt;-ch    }()    ch &lt;- true  // æ— ç¼“å†²ï¼Œå‘é€æ–¹é˜»å¡ç›´åˆ°æ¥æ”¶æ–¹æ¥æ”¶åˆ°æ•°æ®ã€‚    fmt.Printf("cost %.1f s\n", time.Now().Sub(st).Seconds())    time.Sleep(time.Second * 5)}</code></pre><pre><code class="go">func main() {    st := time.Now()    ch := make(chan bool, 2)    go func ()  {        time.Sleep(time.Second * 2)        &lt;-ch    }()    ch &lt;- true    ch &lt;- true // ç¼“å†²åŒºä¸º 2ï¼Œå‘é€æ–¹ä¸é˜»å¡ï¼Œç»§ç»­å¾€ä¸‹æ‰§è¡Œ    fmt.Printf("cost %.1f s\n", time.Now().Sub(st).Seconds()) // cost 0.0 s    ch &lt;- true // ç¼“å†²åŒºä½¿ç”¨å®Œï¼Œå‘é€æ–¹é˜»å¡ï¼Œ2s åæ¥æ”¶æ–¹æ¥æ”¶åˆ°æ•°æ®ï¼Œé‡Šæ”¾ä¸€ä¸ªæ’æ§½ï¼Œç»§ç»­å¾€ä¸‹æ‰§è¡Œ    fmt.Printf("cost %.1f s\n", time.Now().Sub(st).Seconds()) // cost 2.0 s    time.Sleep(time.Second * 5)}</code></pre><h2 id="2-ä»€ä¹ˆæ˜¯åç¨‹æ³„éœ²-Goroutine-Leak-ï¼Ÿ"><a href="#2-ä»€ä¹ˆæ˜¯åç¨‹æ³„éœ²-Goroutine-Leak-ï¼Ÿ" class="headerlink" title="2. ä»€ä¹ˆæ˜¯åç¨‹æ³„éœ²(Goroutine Leak)ï¼Ÿ"></a>2. ä»€ä¹ˆæ˜¯åç¨‹æ³„éœ²(Goroutine Leak)ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>åç¨‹æ³„éœ²æ˜¯æŒ‡åç¨‹åˆ›å»ºåï¼Œé•¿æ—¶é—´å¾—ä¸åˆ°é‡Šæ”¾ï¼Œå¹¶ä¸”è¿˜åœ¨ä¸æ–­åœ°åˆ›å»ºæ–°çš„åç¨‹ï¼Œæœ€ç»ˆå¯¼è‡´å†…å­˜è€—å°½ï¼Œç¨‹åºå´©æºƒã€‚å¸¸è§çš„å¯¼è‡´åç¨‹æ³„éœ²çš„åœºæ™¯æœ‰ä»¥ä¸‹å‡ ç§ï¼š<br>ç¼ºå°‘æ¥æ”¶å™¨ï¼Œå¯¼è‡´å‘é€é˜»å¡<br>è¿™ä¸ªä¾‹å­ä¸­ï¼Œæ¯æ‰§è¡Œä¸€æ¬¡ queryï¼Œåˆ™å¯åŠ¨1000ä¸ªåç¨‹å‘ä¿¡é“ ch å‘é€æ•°å­— 0ï¼Œä½†åªæ¥æ”¶äº†ä¸€æ¬¡ï¼Œå¯¼è‡´ 999 ä¸ªåç¨‹è¢«é˜»å¡ï¼Œä¸èƒ½é€€å‡ºã€‚</p><pre><code class="go">func query() int {    ch := make(chan int)    for i := 0; i &lt; 1000; i++ {        go func() { ch &lt;- 0 }()    }    return &lt;-ch}func main() {    for i := 0; i &lt; 4; i++ {        query()        fmt.Printf("goroutines: %d\n", runtime.NumGoroutine())    }}// goroutines: 1001// goroutines: 2000// goroutines: 2999// goroutines: 3998</code></pre><p>ç¼ºå°‘å‘é€å™¨ï¼Œå¯¼è‡´æ¥æ”¶é˜»å¡<br>é‚£åŒæ ·çš„ï¼Œå¦‚æœå¯åŠ¨ 1000 ä¸ªåç¨‹æ¥æ”¶ä¿¡é“çš„ä¿¡æ¯ï¼Œä½†ä¿¡é“å¹¶ä¸ä¼šå‘é€é‚£ä¹ˆå¤šæ¬¡çš„ä¿¡æ¯ï¼Œä¹Ÿä¼šå¯¼è‡´æ¥æ”¶åç¨‹è¢«é˜»å¡ï¼Œä¸èƒ½é€€å‡ºã€‚<br>æ­»é”(dead lock)<br>ä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šçš„åç¨‹åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œç”±äºç«äº‰èµ„æºæˆ–è€…ç”±äºå½¼æ­¤é€šä¿¡è€Œé€ æˆé˜»å¡ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œä¹Ÿä¼šå¯¼è‡´åç¨‹è¢«é˜»å¡ï¼Œä¸èƒ½é€€å‡ºã€‚<br>æ— é™å¾ªç¯(infinite loops)<br>è¿™ä¸ªä¾‹å­ä¸­ï¼Œä¸ºäº†é¿å…ç½‘ç»œç­‰é—®é¢˜ï¼Œé‡‡ç”¨äº†æ— é™é‡è¯•çš„æ–¹å¼ï¼Œå‘é€ HTTP è¯·æ±‚ï¼Œç›´åˆ°è·å–åˆ°æ•°æ®ã€‚é‚£å¦‚æœ HTTP æœåŠ¡å®•æœºï¼Œæ°¸è¿œä¸å¯è¾¾ï¼Œå¯¼è‡´åç¨‹ä¸èƒ½é€€å‡ºï¼Œå‘ç”Ÿæ³„æ¼ã€‚</p><pre><code class="go">func request(url string, wg *sync.WaitGroup) {    i := 0    for {        if _, err := http.Get(url); err == nil {            // write to db            break        }        i++        if i &gt;= 3 {            break        }        time.Sleep(time.Second)    }    wg.Done()}func main() {    var wg sync.WaitGroup    for i := 0; i &lt; 1000; i++ {        wg.Add(1)        go request(fmt.Sprintf("https://127.0.0.1:8080/%d", i), &amp;wg)    }    wg.Wait()}</code></pre><h2 id="3-Go-å¯ä»¥é™åˆ¶è¿è¡Œæ—¶æ“ä½œç³»ç»Ÿçº¿ç¨‹çš„æ•°é‡å—ï¼Ÿ"><a href="#3-Go-å¯ä»¥é™åˆ¶è¿è¡Œæ—¶æ“ä½œç³»ç»Ÿçº¿ç¨‹çš„æ•°é‡å—ï¼Ÿ" class="headerlink" title="3. Go å¯ä»¥é™åˆ¶è¿è¡Œæ—¶æ“ä½œç³»ç»Ÿçº¿ç¨‹çš„æ•°é‡å—ï¼Ÿ"></a>3. Go å¯ä»¥é™åˆ¶è¿è¡Œæ—¶æ“ä½œç³»ç»Ÿçº¿ç¨‹çš„æ•°é‡å—ï¼Ÿ</h2><p>ç­”æ¡ˆ<br>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit.<br>å¯ä»¥ä½¿ç”¨ç¯å¢ƒå˜é‡ GOMAXPROCS æˆ– runtime.GOMAXPROCS(num int) è®¾ç½®ï¼Œä¾‹å¦‚ï¼š</p><pre><code class="go">runtime.GOMAXPROCS(1) // é™åˆ¶åŒæ—¶æ‰§è¡ŒGoä»£ç çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹æ•°ä¸º 1</code></pre><p>ä»å®˜æ–¹æ–‡æ¡£çš„è§£é‡Šå¯ä»¥çœ‹åˆ°ï¼ŒGOMAXPROCS é™åˆ¶çš„æ˜¯åŒæ—¶æ‰§è¡Œç”¨æˆ·æ€ Go ä»£ç çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹çš„æ•°é‡ï¼Œä½†æ˜¯å¯¹äºè¢«ç³»ç»Ÿè°ƒç”¨é˜»å¡çš„çº¿ç¨‹æ•°é‡æ˜¯æ²¡æœ‰é™åˆ¶çš„ã€‚GOMAXPROCS çš„é»˜è®¤å€¼ç­‰äº CPU çš„é€»è¾‘æ ¸æ•°ï¼ŒåŒä¸€æ—¶é—´ï¼Œä¸€ä¸ªæ ¸åªèƒ½ç»‘å®šä¸€ä¸ªçº¿ç¨‹ï¼Œç„¶åè¿è¡Œè¢«è°ƒåº¦çš„åç¨‹ã€‚å› æ­¤å¯¹äº CPU å¯†é›†å‹çš„ä»»åŠ¡ï¼Œè‹¥è¯¥å€¼è¿‡å¤§ï¼Œä¾‹å¦‚è®¾ç½®ä¸º CPU é€»è¾‘æ ¸æ•°çš„ 2 å€ï¼Œä¼šå¢åŠ çº¿ç¨‹åˆ‡æ¢çš„å¼€é”€ï¼Œé™ä½æ€§èƒ½ã€‚å¯¹äº I/O å¯†é›†å‹åº”ç”¨ï¼Œé€‚å½“åœ°è°ƒå¤§è¯¥å€¼ï¼Œå¯ä»¥æé«˜ I/O ååç‡ã€‚</p><h1 id="ä¸‰ã€Go-è¯­è¨€ç¬”è¯•é¢è¯•é¢˜-ä»£ç è¾“å‡º"><a href="#ä¸‰ã€Go-è¯­è¨€ç¬”è¯•é¢è¯•é¢˜-ä»£ç è¾“å‡º" class="headerlink" title="ä¸‰ã€Go è¯­è¨€ç¬”è¯•é¢è¯•é¢˜(ä»£ç è¾“å‡º)"></a>ä¸‰ã€Go è¯­è¨€ç¬”è¯•é¢è¯•é¢˜(ä»£ç è¾“å‡º)</h1><h2 id="1-å¸¸é‡ä¸å˜é‡"><a href="#1-å¸¸é‡ä¸å˜é‡" class="headerlink" title="1. å¸¸é‡ä¸å˜é‡"></a>1. å¸¸é‡ä¸å˜é‡</h2><h3 id="1-1-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"><a href="#1-1-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š" class="headerlink" title="1.1 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"></a>1.1 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š</h3><pre><code class="go">func main() {    const (        a, b = "golang", 100        d, e        f bool = true        g    )    fmt.Println(d, e, g)}</code></pre><p>ç­”æ¡ˆ<br>golang 100 true<br>åœ¨åŒä¸€ä¸ª const group ä¸­ï¼Œå¦‚æœå¸¸é‡å®šä¹‰ä¸å‰ä¸€è¡Œçš„å®šä¹‰ä¸€è‡´ï¼Œåˆ™å¯ä»¥çœç•¥ç±»å‹å’Œå€¼ã€‚ç¼–è¯‘æ—¶ï¼Œä¼šæŒ‰ç…§å‰ä¸€è¡Œçš„å®šä¹‰è‡ªåŠ¨è¡¥å…¨ã€‚å³ç­‰ä»·äº</p><pre><code class="go">func main() {    const (        a, b = "golang", 100        d, e = "golang", 100        f bool = true        g bool = true    )    fmt.Println(d, e, g)}</code></pre><h3 id="1-2-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"><a href="#1-2-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š" class="headerlink" title="1.2 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"></a>1.2 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š</h3><pre><code class="go">func main() {    const N = 100    var x int = N    const M int32 = 100    var y int = M    fmt.Println(x, y)}</code></pre><p>ç­”æ¡ˆ<br>ç¼–è¯‘å¤±è´¥ï¼šcannot use M (type int32) as type int in assignment<br>Go è¯­è¨€ä¸­ï¼Œå¸¸é‡åˆ†ä¸ºæ— ç±»å‹å¸¸é‡å’Œæœ‰ç±»å‹å¸¸é‡ä¸¤ç§ï¼Œconst N = 100ï¼Œå±äºæ— ç±»å‹å¸¸é‡ï¼Œèµ‹å€¼ç»™å…¶ä»–å˜é‡æ—¶ï¼Œå¦‚æœå­—é¢é‡èƒ½å¤Ÿè½¬æ¢ä¸ºå¯¹åº”ç±»å‹çš„å˜é‡ï¼Œåˆ™èµ‹å€¼æˆåŠŸï¼Œä¾‹å¦‚ï¼Œvar x int = Nã€‚ä½†æ˜¯å¯¹äºæœ‰ç±»å‹çš„å¸¸é‡ const M int32 = 100ï¼Œèµ‹å€¼ç»™å…¶ä»–å˜é‡æ—¶ï¼Œéœ€è¦ç±»å‹åŒ¹é…æ‰èƒ½æˆåŠŸï¼Œæ‰€ä»¥æ˜¾ç¤ºåœ°ç±»å‹è½¬æ¢ï¼š</p><pre><code class="go">var y int = int(M)</code></pre><h3 id="1-3-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"><a href="#1-3-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š" class="headerlink" title="1.3 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"></a>1.3 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š</h3><pre><code class="go">func main() {    var a int8 = -1    var b int8 = -128 / a    fmt.Println(b)}</code></pre><p>ç­”æ¡ˆ<br>-128<br>int8 èƒ½è¡¨ç¤ºçš„æ•°å­—çš„èŒƒå›´æ˜¯ [-2^7, 2^7-1]ï¼Œå³ [-128, 127]ã€‚-128 æ˜¯æ— ç±»å‹å¸¸é‡ï¼Œè½¬æ¢ä¸º int8ï¼Œå†é™¤ä»¥å˜é‡ -1ï¼Œç»“æœä¸º 128ï¼Œå¸¸é‡é™¤ä»¥å˜é‡ï¼Œç»“æœæ˜¯ä¸€ä¸ªå˜é‡ã€‚å˜é‡è½¬æ¢æ—¶å…è®¸æº¢å‡ºï¼Œç¬¦å·ä½å˜ä¸º1ï¼Œè½¬ä¸ºè¡¥ç åæ°å¥½ç­‰äº -128ã€‚<br>å¯¹äºæœ‰ç¬¦å·æ•´å‹ï¼Œæœ€é«˜ä½æ˜¯æ˜¯ç¬¦å·ä½ï¼Œè®¡ç®—æœºç”¨è¡¥ç è¡¨ç¤ºè´Ÿæ•°ã€‚è¡¥ç  = åŸç å–ååŠ ä¸€ã€‚<br>ä¾‹å¦‚ï¼š</p><pre><code>-1 :  1111111100000001(åŸç )    11111110(å–å)    11111111(åŠ ä¸€)-128ï¼š    10000000(åŸç )    01111111(å–å)    10000000(åŠ ä¸€)-1 + 1 = 011111111 + 00000001 = 00000000(æœ€é«˜ä½æº¢å‡ºçœç•¥)-128 + 127 = -110000000 + 01111111 = 11111111</code></pre><h3 id="1-4-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"><a href="#1-4-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š" class="headerlink" title="1.4 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"></a>1.4 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š</h3><pre><code class="go">func main() {    const a int8 = -1    var b int8 = -128 / a    fmt.Println(b)}</code></pre><p>ç­”æ¡ˆ<br>ç¼–è¯‘å¤±è´¥ï¼šconstant 128 overflows int8<br>-128 å’Œ a éƒ½æ˜¯å¸¸é‡ï¼Œåœ¨ç¼–è¯‘æ—¶æ±‚å€¼ï¼Œ-128 / a = 128ï¼Œä¸¤ä¸ªå¸¸é‡ç›¸é™¤ï¼Œç»“æœä¹Ÿæ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œå¸¸é‡ç±»å‹è½¬æ¢æ—¶ä¸å…è®¸æº¢å‡ºï¼Œå› è€Œç¼–è¯‘å¤±è´¥ã€‚</p><h2 id="2-ä½œç”¨åŸŸ"><a href="#2-ä½œç”¨åŸŸ" class="headerlink" title="2. ä½œç”¨åŸŸ"></a>2. ä½œç”¨åŸŸ</h2><h3 id="2-1-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"><a href="#2-1-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š" class="headerlink" title="2.1 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"></a>2.1 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š</h3><pre><code class="go">func main() {    var err error    if err == nil {        err := fmt.Errorf("err")        fmt.Println(1, err)    }    if err != nil {        fmt.Println(2, err)    }}</code></pre><p>ç­”æ¡ˆ<br>1 err<br>:= è¡¨ç¤ºå£°æ˜å¹¶èµ‹å€¼ï¼Œ= è¡¨ç¤ºä»…èµ‹å€¼ã€‚<br>å˜é‡çš„ä½œç”¨åŸŸæ˜¯å¤§æ‹¬å·ï¼Œå› æ­¤åœ¨ç¬¬ä¸€ä¸ª if è¯­å¥ if err == nil å†…éƒ¨é‡æ–°å£°æ˜ä¸”èµ‹å€¼äº†ä¸å¤–éƒ¨å˜é‡åŒåçš„å±€éƒ¨å˜é‡ errã€‚å¯¹è¯¥å±€éƒ¨å˜é‡çš„èµ‹å€¼ä¸ä¼šå½±å“åˆ°å¤–éƒ¨çš„ errã€‚å› æ­¤ç¬¬äºŒä¸ª if è¯­å¥ if err != nil ä¸æˆç«‹ã€‚æ‰€ä»¥åªæ‰“å°äº† 1 errã€‚</p><h2 id="3-defer-å»¶è¿Ÿè°ƒç”¨"><a href="#3-defer-å»¶è¿Ÿè°ƒç”¨" class="headerlink" title="3. defer å»¶è¿Ÿè°ƒç”¨"></a>3. defer å»¶è¿Ÿè°ƒç”¨</h2><h3 id="3-1-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"><a href="#3-1-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š" class="headerlink" title="3.1 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"></a>3.1 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š</h3><pre><code class="go">type T struct{}func (t T) f(n int) T {    fmt.Print(n)    return t}func main() {    var t T    defer t.f(1).f(2)    fmt.Print(3)}</code></pre><p>ç­”æ¡ˆ<br>132<br>defer å»¶è¿Ÿè°ƒç”¨æ—¶ï¼Œéœ€è¦ä¿å­˜å‡½æ•°æŒ‡é’ˆå’Œå‚æ•°ï¼Œå› æ­¤é“¾å¼è°ƒç”¨çš„æƒ…å†µä¸‹ï¼Œé™¤äº†æœ€åä¸€ä¸ªå‡½æ•°/æ–¹æ³•å¤–çš„å‡½æ•°/æ–¹æ³•éƒ½ä¼šåœ¨è°ƒç”¨æ—¶ç›´æ¥æ‰§è¡Œã€‚ä¹Ÿå°±æ˜¯è¯´ t.f(1) ç›´æ¥æ‰§è¡Œï¼Œç„¶åæ‰§è¡Œ fmt.Print(3)ï¼Œæœ€åå‡½æ•°è¿”å›æ—¶å†æ‰§è¡Œ .f(2)ï¼Œå› æ­¤è¾“å‡ºæ˜¯ 132ã€‚</p><h3 id="3-2-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"><a href="#3-2-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š" class="headerlink" title="3.2 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"></a>3.2 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š</h3><pre><code class="go">func f(n int) {    defer fmt.Println(n)    n += 100}func main() {    f(1)}</code></pre><p>ç­”æ¡ˆ<br>1<br>æ‰“å° 1 è€Œä¸æ˜¯ 101ã€‚defer è¯­å¥æ‰§è¡Œæ—¶ï¼Œä¼šå°†éœ€è¦å»¶è¿Ÿè°ƒç”¨çš„å‡½æ•°å’Œå‚æ•°ä¿å­˜èµ·æ¥ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰§è¡Œåˆ° defer æ—¶ï¼Œå‚æ•° n(æ­¤æ—¶ç­‰äº1) å·²ç»è¢«ä¿å­˜äº†ã€‚å› æ­¤åé¢å¯¹ n çš„æ”¹åŠ¨å¹¶ä¸ä¼šå½±å“å»¶è¿Ÿå‡½æ•°è°ƒç”¨çš„ç»“æœã€‚</p><h3 id="3-3-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"><a href="#3-3-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š" class="headerlink" title="3.3 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"></a>3.3 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š</h3><pre><code class="go">func main() {    n := 1    defer func() {        fmt.Println(n)    }()    n += 100}</code></pre><p>ç­”æ¡ˆ<br>101<br>åŒ¿åå‡½æ•°æ²¡æœ‰é€šè¿‡ä¼ å‚çš„æ–¹å¼å°† n ä¼ å…¥ï¼Œå› æ­¤åŒ¿åå‡½æ•°å†…çš„ n å’Œå‡½æ•°å¤–éƒ¨çš„ n æ˜¯åŒä¸€ä¸ªï¼Œå»¶è¿Ÿæ‰§è¡Œæ—¶ï¼Œå·²ç»è¢«æ”¹å˜ä¸º 101ã€‚</p><h3 id="3-4-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"><a href="#3-4-ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š" class="headerlink" title="3.4 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š"></a>3.4 ä¸‹åˆ—ä»£ç çš„è¾“å‡ºæ˜¯ï¼š</h3><pre><code class="go">func main() {    n := 1    if n == 1 {        defer fmt.Println(n)        n += 100    }    fmt.Println(n)}</code></pre><p>ç­”æ¡ˆ<br>1<br>2<br>101<br>1<br>å…ˆæ‰“å° 101ï¼Œå†æ‰“å° 1ã€‚defer çš„ä½œç”¨åŸŸæ˜¯å‡½æ•°ï¼Œè€Œä¸æ˜¯ä»£ç å—ï¼Œå› æ­¤ if è¯­å¥é€€å‡ºæ—¶ï¼Œdefer ä¸ä¼šæ‰§è¡Œï¼Œè€Œæ˜¯ç­‰ 101 æ‰“å°åï¼Œæ•´ä¸ªå‡½æ•°è¿”å›æ—¶ï¼Œæ‰ä¼šæ‰§è¡Œã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> é¢è¯•é¢˜ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>è®ºæ–‡ä¸‹è½½</title>
      <link href="/2022/01/12/other/%E8%AE%BA%E6%96%87%E4%B8%8B%E8%BD%BD/"/>
      <url>/2022/01/12/other/%E8%AE%BA%E6%96%87%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="https://www.scidown.cn/">scidown</a></li><li><a href="https://doi.qqsci.com/">ä¼é¹…è®ºæ–‡</a></li><li><a href="https://tool.yovisun.com/scihub/">sci-hub</a></li><li><a href="http://www.5638.org/">ç§‘ç ”å®åº“</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>è®ºæ–‡ç¿»è¯‘</title>
      <link href="/2022/01/12/other/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
      <url>/2022/01/12/other/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="https://www.onlinedoctranslator.com/">DocTranslator</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>å…±è¯†ç®—æ³•</title>
      <link href="/2022/01/08/blockchain/consensus/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/08/blockchain/consensus/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="ä¸»è¦å†…å®¹"><a href="#ä¸»è¦å†…å®¹" class="headerlink" title="ä¸»è¦å†…å®¹"></a>ä¸»è¦å†…å®¹</h1><ol><li>æ‹œå åº­å°†å†›é—®é¢˜æ¦‚è¿°</li><li>å…±è¯†ç®—æ³•å®šä¹‰(ä½œç”¨)</li><li>å…±è¯†ç®—æ³•ç§ç±»</li><li>å…±è¯†ç®—æ³•ä¼˜ç¼ºç‚¹å¯¹æ¯”ä»¥åŠåº”ç”¨</li></ol><h1 id="æ‹œå åº­å°†å†›é—®é¢˜"><a href="#æ‹œå åº­å°†å†›é—®é¢˜" class="headerlink" title="æ‹œå åº­å°†å†›é—®é¢˜"></a>æ‹œå åº­å°†å†›é—®é¢˜</h1><p>è±æ–¯åˆ©Â·å…°æ³¢ç‰¹åœ¨å…¶è®ºæ–‡ä¸­æè¿°äº†å¦‚ä¸‹é—®é¢˜ï¼š</p><blockquote><p>ä¸€ç»„æ‹œå åº­å°†å†›åˆ†åˆ«å„ç‡é¢†ä¸€æ”¯å†›é˜Ÿå…±åŒå›´å›°ä¸€åº§åŸå¸‚ã€‚ä¸ºäº†ç®€åŒ–é—®é¢˜ï¼Œå°†å„æ”¯å†›é˜Ÿçš„è¡ŒåŠ¨ç­–ç•¥é™å®šä¸ºè¿›æ”»æˆ–æ’¤ç¦»ä¸¤ç§ã€‚å› ä¸ºéƒ¨åˆ†å†›é˜Ÿè¿›æ”»éƒ¨åˆ†å†›é˜Ÿæ’¤ç¦»å¯èƒ½ä¼šé€ æˆç¾éš¾æ€§åæœï¼Œå› æ­¤å„ä½å°†å†›å¿…é¡»é€šè¿‡æŠ•ç¥¨æ¥è¾¾æˆä¸€è‡´ç­–ç•¥ï¼Œå³æ‰€æœ‰å†›é˜Ÿä¸€èµ·è¿›æ”»æˆ–æ‰€æœ‰å†›é˜Ÿä¸€èµ·æ’¤ç¦»ã€‚å› ä¸ºå„ä½å°†å†›åˆ†å¤„åŸå¸‚ä¸åŒæ–¹å‘ï¼Œä»–ä»¬åªèƒ½é€šè¿‡ä¿¡ä½¿äº’ç›¸è”ç³»ã€‚åœ¨æŠ•ç¥¨è¿‡ç¨‹ä¸­æ¯ä½å°†å†›éƒ½å°†è‡ªå·±æŠ•ç¥¨ç»™è¿›æ”»è¿˜æ˜¯æ’¤é€€çš„ä¿¡æ¯é€šè¿‡ä¿¡ä½¿åˆ†åˆ«é€šçŸ¥å…¶ä»–æ‰€æœ‰å°†å†›ï¼Œè¿™æ ·ä¸€æ¥æ¯ä½å°†å†›æ ¹æ®è‡ªå·±çš„æŠ•ç¥¨å’Œå…¶ä»–æ‰€æœ‰å°†å†›é€æ¥çš„ä¿¡æ¯å°±å¯ä»¥çŸ¥é“å…±åŒçš„æŠ•ç¥¨ç»“æœè€Œå†³å®šè¡ŒåŠ¨ç­–ç•¥ã€‚</p></blockquote><p>ç³»ç»Ÿçš„é—®é¢˜åœ¨äºï¼Œå¯èƒ½å°†å†›ä¸­å‡ºç°å›å¾’ï¼Œä»–ä»¬ä¸ä»…å¯èƒ½å‘è¾ƒä¸ºç³Ÿç³•çš„ç­–ç•¥æŠ•ç¥¨ï¼Œè¿˜å¯èƒ½é€‰æ‹©æ€§åœ°å‘é€æŠ•ç¥¨ä¿¡æ¯ã€‚</p><p>ä¸Šè¿°çš„æ•…äº‹æ˜ å°„åˆ°è®¡ç®—æœºç³»ç»Ÿé‡Œä¾¿æ˜¯ï¼š</p><p>åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­å­˜åœ¨æ¶æ„çš„è®¡ç®—æœºèŠ‚ç‚¹ï¼Œè¿™äº›èŠ‚ç‚¹ä¼šé€‰æ‹©æ€§å“åº”æŸäº›è¯·æ±‚æˆ–ç¯¡æ”¹ç³»ç»Ÿä¸­çš„æ•°æ®ã€‚ é‚£ä¹ˆ<font color="red">åœ¨ä¸Šè¿°ä¸å¯é çš„ä¿¡é“ä¸Šï¼Œç³»ç»Ÿä¸­æ‰€æœ‰éæ¶æ„èŠ‚ç‚¹å¦‚ä½•é€šè¿‡æ¶ˆæ¯ä¼ é€’è¾¾æˆå…±è¯†ï¼Ÿ</font></p><h1 id="å…±è¯†ç®—æ³•"><a href="#å…±è¯†ç®—æ³•" class="headerlink" title="å…±è¯†ç®—æ³•"></a>å…±è¯†ç®—æ³•</h1><h2 id="å®šä¹‰-ä½œç”¨"><a href="#å®šä¹‰-ä½œç”¨" class="headerlink" title="å®šä¹‰(ä½œç”¨)"></a>å®šä¹‰(ä½œç”¨)</h2><p>å…±è¯†ç®—æ³•<font color="red">ä½¿é«˜åº¦åˆ†æ•£ä¸”å½¼æ­¤ä¸ä¿¡ä»»çš„ç½‘ç»œç¯å¢ƒä¸­çš„èŠ‚ç‚¹å°±æŸä¸ªäº‹åŠ¡è¾¾æˆä¸€è‡´ä¸”ä¸åˆ†å‰</font></p><p>æŒ‰æ‹œå åº­å®¹é”™æ€§åˆ†ç±»ï¼š</p><ol><li><p>å®¹å¿éæ‹œå åº­é”™è¯¯ï¼ˆCTFï¼‰ï¼šå®¹å¿ç½‘ç»œç¯å¢ƒä¸­å­˜åœ¨æ•…éšœèŠ‚ç‚¹ä½†ä¸å­˜åœ¨æ¶æ„èŠ‚ç‚¹</p></li><li><p>å®¹å¿æ‹œå åº­é”™è¯¯ï¼ˆBFTï¼‰ï¼šå®¹å¿ç½‘ç»œç¯å¢ƒä¸­åŒæ—¶å­˜åœ¨æ•…éšœèŠ‚ç‚¹å’Œæ¶æ„èŠ‚ç‚¹</p></li></ol><h2 id="ç®—æ³•éœ€æ»¡è¶³çš„æ¡ä»¶"><a href="#ç®—æ³•éœ€æ»¡è¶³çš„æ¡ä»¶" class="headerlink" title="ç®—æ³•éœ€æ»¡è¶³çš„æ¡ä»¶"></a>ç®—æ³•éœ€æ»¡è¶³çš„æ¡ä»¶</h2><p>FLPä¸å¯èƒ½é—®é¢˜ï¼šåœ¨å¼‚æ­¥ç½‘ç»œä¸­ï¼Œå“ªæ€•åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹æ•…éšœä¹Ÿä¸å¯èƒ½å­˜åœ¨èƒ½å¤Ÿå®¹å¿èŠ‚ç‚¹æ•…éšœçš„ä¸€è‡´æ€§ç®—æ³•ã€‚</p><p>éœ€æ»¡è¶³çš„çº¦æŸæ¡ä»¶ï¼š</p><ol><li><strong>æ¶ˆæ¯å®‰å…¨</strong>ï¼šèŠ‚ç‚¹ä»¶å¿…é¡»é‡‡ç”¨éå¯¹ç§°åŠ å¯†å¯¹æ¶ˆæ¯è¿›è¡Œç­¾åä¿è¯æ¶ˆæ¯å¯ä¼ é€’ï¼ˆä¸å¯ç”¨å¯¹ç§°åŠ å¯†ï¼Œå› ä¸ºä¿¡é“ä¸å®‰å…¨ï¼‰</li><li><strong>å¤„ç†FLPä¸å¯èƒ½é—®é¢˜</strong>ï¼šè®¾ç½®æ¶ˆæ¯æœ€å¤§æ—¶å»¶</li><li><strong>å…±è¯†ç»“è®ºåˆæ³•</strong>ï¼šç»“è®ºå¿…é¡»æ˜¯ä¸€ä¸ªèŠ‚ç‚¹çš„ææ¡ˆ</li></ol><h2 id="ç®—æ³•è¯¦æƒ…"><a href="#ç®—æ³•è¯¦æƒ…" class="headerlink" title="ç®—æ³•è¯¦æƒ…"></a>ç®—æ³•è¯¦æƒ…</h2><h3 id="Paxosï¼ˆCTFï¼‰"><a href="#Paxosï¼ˆCTFï¼‰" class="headerlink" title="Paxosï¼ˆCTFï¼‰"></a>Paxosï¼ˆCTFï¼‰</h3><ol><li><p>æ¦‚å¿µ</p><p>PaxosåŸç†åŸºäº<font color="red">â€œä¸¤é˜¶æ®µæäº¤â€</font>ç®—æ³•å¹¶è¿›è¡Œæ³›åŒ–å’Œæ‰©å±•ï¼Œé€šè¿‡æ¶ˆæ¯ä¼ é€’æ¥é€æ­¥æ¶ˆé™¤ç³»ç»Ÿä¸­çš„ä¸ç¡®å®šçŠ¶æ€ï¼Œæ˜¯Raftã€ZABè®¾è®¡çš„åŸºç¡€</p><p>Paxosè§’è‰²ï¼š</p><ul><li><strong>ææ¡ˆè€…ï¼ˆProposerï¼‰</strong>ï¼šæå‡ºä¸€ä¸ªææ¡ˆç­‰å¾…å¤§å®¶æ‰¹å‡†ä¸ºç»“æ¡ˆï¼ˆvalueï¼‰</li><li><strong>æ¥å—è€…ï¼ˆAcceptorï¼‰</strong>ï¼šå¯¹ææ¡ˆè¿›è¡ŒæŠ•ç¥¨ï¼Œæ¥å—ææ¡ˆ</li><li><strong>å­¦ä¹ è€…ï¼ˆLearnerï¼‰</strong>ï¼šè·å–æ‰¹å‡†ç»“æœï¼Œä¸å‚ä¸æŠ•ç¥¨</li></ul></li><li><p>å…±è¯†è¿‡ç¨‹</p><p><img src="/images/consensus/paxos_flow_chart.png" alt="img.png"><br>pokï¼šæ”¶åˆ°æè®®è¯·æ±‚ï¼› aokï¼šæ”¶åˆ°æäº¤è¯·æ±‚ï¼›æœ€å¤§ææ¡ˆç¼–å·ï¼šMaxNï¼›AcceptNï¼šæ¥æ”¶åˆ°çš„ææ¡ˆç¼–å·ï¼› AcceptVï¼šæ¥æ”¶åˆ°çš„ææ¡ˆå€¼ï¼›</p></li><li><p>ä¸¾ä¾‹è¯´æ˜ å‡è®¾é›†ç¾¤ä¸­æœ‰2ä¸ªProposerã€3ä¸ªAcceptorã€1ä¸ªLearner</p><ul><li>æœ‰ä¸¤ä¸ªProposerï¼Œä¸¤ä¸ªéƒ½æå‡º prepare requestã€‚æ¥è‡ª Proposer Açš„ request å…ˆäºProposer B çš„ request åˆ°è¾¾ Acceptor Xå’Œ Acceptor Yï¼Œ ä½†æ¥è‡ªProposer Bçš„ request é¦–å…ˆåˆ°è¾¾ Proposer Z.<br><img src="/images/consensus/paxos_prepare1.png" alt="img.png"></li><li>å¦‚æœæ¥æ”¶ï¼ˆacceptï¼‰prepare request çš„ Acceptor ä¹‹å‰æ²¡æœ‰çœ‹åˆ°å…¶ä»–çš„æè®®ï¼Œåˆ™ Acceptor ä»¥ prepare response ä½œå‡ºå“åº”ï¼Œ è¯¥ prepare responseæ‰¿è¯ºæ°¸è¿œä¸æ¥å—å…·æœ‰è¾ƒä½æè®®ç¼–å·çš„å¦ä¸€æè®®ã€‚<br><img src="/images/consensus/paxos_prepare2.png" alt="img.png"></li><li>Acceptor Zæ”¶åˆ°äº† Proposer A çš„ request ï¼ŒAcceptor Xå’Œ Acceptor Yæ”¶åˆ°äº† Proposer Bçš„ request ã€‚ å¦‚æœ Proposer ä¹‹å‰å·²ç»çœ‹åˆ°å…·æœ‰æ›´é«˜æè®®å·çš„request ï¼Œåˆ™å¿½ç•¥æ™šåˆ°çš„ requestï¼Œå¦‚Acceptor Zå°†å¿½ç•¥ Proposer Açš„ requestï¼ˆå› ä¸º2&lt;4ï¼‰ã€‚ å¦‚æœ Proposer ä¹‹å‰æ²¡æœ‰çœ‹åˆ°æ›´é«˜ç¼–å·çš„ requestï¼Œå®ƒå†æ¬¡æ‰¿è¯ºå¿½ç•¥å…·æœ‰è¾ƒä½æè®®ç¼–å·çš„ä»»ä½•è¯·æ±‚ï¼Œå¹¶å‘å›å…¶å·²æ¥å—çš„ç¼–å·æœ€é«˜çš„æè®®ä»¥åŠè¯¥æè®®çš„å€¼ã€‚ å¦‚ Acceptor Xå’ŒY å¯¹Proposer Bçš„ request çš„åšæ³•ã€‚<br><img src="/images/consensus/paxos_prepare3.png" alt="img.png"></li><li>ä¸€æ—¦ Proposer æ”¶åˆ°å¤§å¤šæ•° Acceptor çš„å‡†å¤‡å“åº”ï¼Œå®ƒå°±å¯ä»¥å‘å‡ºæ¥å—è¯·æ±‚<ul><li>å¯¹äºProposer Aï¼šç”±äº Proposer Aä»…æ”¶åˆ°è¡¨æ˜æ²¡æœ‰å…ˆå‰ææ¡ˆçš„ç­”å¤ï¼Œ å› æ­¤å®ƒå‘æ¯ä¸ªå…·æœ‰ä¸å…¶åˆå§‹ææ¡ˆç›¸åŒçš„æè®®ç¼–å·å’Œå€¼çš„ Acceptor å‘é€ accept requestï¼ˆn = 2ï¼Œv = 8ï¼‰ã€‚ç„¶è€Œï¼Œè¿™äº› request éƒ½å°†è¢«å¿½ç•¥ï¼Œå› ä¸ºç›®æ ‡ Acceptor éƒ½æ‰¿è¯ºä¸æ¥å—çš„æè®®ç¼–å·ä½äº4 çš„ requestï¼ˆè¿™æ˜¯å¯¹ Proposer B çš„æ‰¿è¯ºï¼‰</li><li>å¯¹äºProposer Bï¼šProposer B å‘æ¯ä¸ª Acceptor å‘é€ accept request ï¼Œ è¯¥ request åŒ…å«å…ˆå‰ä½¿ç”¨çš„æè®®å·ï¼ˆn = 4ï¼‰ä»¥åŠä¸å…¶æ¥æ”¶çš„å‡†å¤‡å“åº”æ¶ˆæ¯ä¸­çš„æœ€é«˜æè®®å·ç›¸å…³è”çš„å€¼ï¼ˆv = 8ï¼‰ã€‚ è¯·æ³¨æ„ï¼Œè¿™ä¸æ˜¯ Proposer B æœ€åˆæå‡ºçš„å€¼ï¼Œè€Œæ˜¯å®ƒçœ‹åˆ°çš„ prepare response æ¶ˆæ¯ä¸­çš„æœ€é«˜å€¼ã€‚<br><img src="/images/consensus/paxos_accept1.png" alt="img.png"></li></ul></li><li>å¦‚æœ Acceptor accept çš„ accept request çš„ ç¼–å· æ¯”å…¶å·²ç»çœ‹åˆ°çš„æ›´é«˜æˆ–ç›¸ç­‰ï¼Œåˆ™å®ƒä¼š accept å¹¶å‘æ¯ä¸ª Learner èŠ‚ç‚¹å‘é€é€šçŸ¥ã€‚ å½“ Learner å‘ç°å¤§å¤šæ•° Acceptorå·²æ¥å—æŸä¸ªå€¼æ—¶ï¼ŒPaxosç®—æ³•ä¼šé€‰æ‹©è¯¥å€¼<br><img src="/images/consensus/paxos_sync1.png" alt="img.png"></li><li>ä¸€æ—¦Paxosé€‰æ‹©äº†ä¸€ä¸ªå€¼ï¼Œä¸å…¶ä»– Proposer çš„è¿›ä¸€æ­¥æ²Ÿé€šå°±æ— æ³•æ”¹å˜è¿™ä¸ªå€¼ã€‚ å¦‚æœå¦ä¸€ä¸ª Proposerï¼ˆå¦‚ Proposer Cï¼‰å‘é€çš„ request çš„ ææ¡ˆå·æ¯”ä¹‹å‰çœ‹åˆ°çš„ææ¡ˆå·æ›´é«˜ï¼Œå¹¶ä¸”å…·æœ‰ä¸åŒçš„å€¼ï¼ˆä¾‹å¦‚ï¼Œn= 6ï¼Œv = 7ï¼‰ï¼Œ åˆ™æ¯ä¸ªæ¥å—è€…éƒ½ä¼šä½¿ç”¨ä¹‹å‰çš„æœ€é«˜ææ¡ˆè¿›è¡Œå“åº”ï¼ˆn = 4ï¼Œv = 8ï¼‰ã€‚è¿™è¦æ±‚æè®®è€…Cå‘é€åŒ…å«[n = 6ï¼Œv = 8] çš„æ¥å—è¯·æ±‚ï¼Œè¯¥è¯·æ±‚ä»…ç¡®è®¤å·²ç»é€‰æ‹©çš„å€¼ã€‚æ­¤å¤–ï¼Œå¦‚æœä¸€äº›å°‘æ•°æ¥å—è€…è¿˜æ²¡æœ‰é€‰æ‹©ä¸€ä¸ªä»·å€¼ï¼Œè¿™ä¸ªè¿‡ç¨‹å¯ä»¥ç¡®ä¿ä»–ä»¬æœ€ç»ˆå°±åŒä¸€ä»·å€¼è¾¾æˆå…±è¯†ã€‚ ï¼ˆæ‰¹æ³¨ï¼Œè¿™ä¸ªè¿‡ç¨‹æ€»æ˜¯æˆç«‹çš„ï¼Œå…·ä½“è®ºè¯è¿‡ç¨‹è§ä¸Šï¼‰</li></ul></li></ol><h3 id="Raftï¼ˆCTFï¼‰"><a href="#Raftï¼ˆCTFï¼‰" class="headerlink" title="Raftï¼ˆCTFï¼‰"></a>Raftï¼ˆCTFï¼‰</h3><ol><li><p>æ¦‚å¿µ</p><p>Raftç›¸æ¯”Paxosæ˜¯ä¸€ç§æ—¨åœ¨<font color="red">æ˜“äºç†è§£</font>çš„å…±è¯†ç®—æ³•ã€‚</p><p>Raftè§’è‰²ï¼š</p><ul><li><strong>é¢†å¯¼è€…ï¼ˆLeaderï¼‰</strong></li><li><strong>å€™é€‰é¢†å¯¼è€…ï¼ˆCandidateï¼‰</strong></li><li><strong>è·Ÿéšè€…ï¼ˆFollowerï¼‰</strong></li></ul></li><li><p>å…±è¯†è¿‡ç¨‹</p><p><a href="http://www.kailing.pub/raft/index.html">Raftæ¼”ç¤ºåœ°å€</a></p><p>ä¸»è¦é˜¶æ®µï¼š</p><ul><li><strong>Leaderé€‰ä¸¾</strong></li><li><strong>åŒæ­¥æ—¥å¿—</strong></li></ul></li></ol><h3 id="PoWï¼ˆBFTï¼‰"><a href="#PoWï¼ˆBFTï¼‰" class="headerlink" title="PoWï¼ˆBFTï¼‰"></a>PoWï¼ˆBFTï¼‰</h3><ol><li><p>æ¦‚å¿µ</p><p>POW <font color="red">å·¥ä½œé‡è¯æ˜å…±è¯†æœºåˆ¶</font>ï¼Œç³»ç»Ÿé€šè¿‡è®©æ‰€æœ‰èŠ‚ç‚¹å…¬å¹³åœ°å»è®¡ç®—ä¸€ä¸ªéšæœºæ•°ï¼Œæœ€å…ˆå¯»æ‰¾åˆ°éšæœºæ•°çš„èŠ‚ç‚¹å³æ‹¥æœ‰è®°è´¦æƒ</p></li><li><p>æ¯”ç‰¹å¸å…±è¯†è¿‡ç¨‹</p><ul><li>å®¢æˆ·ç«¯å‘èµ·äº¤æ˜“å¹¿æ’­åˆ°ç½‘ç»œä¸­ç­‰å¾…ç¡®è®¤</li><li>ç½‘ç»œä¸­çš„ç”¨æˆ·å°†æ‰€æœ‰ç­‰å¾…ç¡®è®¤çš„äº¤æ˜“æ‰“åŒ…åˆ°ä¸€ä¸ªåŒºå—é“¾ä¸­</li><li><strong>ä¸æ–­ä¿®æ”¹åŒºå—å¤´ä¸­çš„Nonceå€¼ä»¥ä½¿è¯¥åŒºå—å¤´çš„hashå€¼å°äºä¸€ä¸ªç‰¹å®šçš„ç›®æ ‡å€¼</strong></li><li>è®¡ç®—å‡ºNonceåå‘å…¨ç½‘å¹¿æ’­</li><li>ç½‘ç»œä¸­æ”¶åˆ°ææ¡ˆåŒºå—çš„èŠ‚ç‚¹å¯¹Nonceè¿›è¡ŒéªŒè¯ï¼ŒéªŒè¯åˆæ³•äº¤æ˜“è¢«ç¡®è®¤ï¼Œè¯¥å—åŠ å…¥é“¾</li></ul></li></ol><h3 id="PoSï¼ˆBFTï¼‰"><a href="#PoSï¼ˆBFTï¼‰" class="headerlink" title="PoSï¼ˆBFTï¼‰"></a>PoSï¼ˆBFTï¼‰</h3><p>æƒç›Šè¯æ˜æœºåˆ¶ï¼Œæ˜¯ä¸ºè§£å†³PoWç®—æ³•å¤§é‡æµªè´¹èµ„æºé—®é¢˜è€Œæå‡ºçš„ä¸€ç§æ›¿ä»£ç®—æ³•ï¼Œè¯¥ç®—æ³•ä¸­åŒºå—çš„è®°è´¦æƒ<font color="red">ç”±æƒç›Šæœ€é«˜çš„èŠ‚ç‚¹è·å¾—</font></p><h3 id="DPoSï¼ˆBFTï¼‰"><a href="#DPoSï¼ˆBFTï¼‰" class="headerlink" title="DPoSï¼ˆBFTï¼‰"></a>DPoSï¼ˆBFTï¼‰</h3><ol><li><p>æ¦‚å¿µ</p><p>è‚¡ä»½æˆæƒè¯æ˜æœºåˆ¶ï¼Œæ˜¯PoSçš„ä¸€ç§è¡ç”Ÿç®—æ³•ï¼Œç®—æ³•çš„æ€æƒ³æ˜¯<font color="red">ç³»ç»Ÿä¸­æŒæœ‰æƒç›Šçš„èŠ‚ç‚¹æŠ•ç¥¨é€‰ä¸¾å‡ºä¸€éƒ¨åˆ†ä»£è¡¨ï¼Œå†ç”±è¿™äº›ä»£è¡¨è½®æµè·å–åŒºå—é“¾è®°è´¦æƒ</font>ï¼Œç±»ä¼¼äºè‚¡ä»½åˆ¶å…¬å¸çš„â€œè‘£äº‹ä¼šâ€</p></li><li><p>å…±è¯†è¿‡ç¨‹</p><ul><li>æ¯ä¸ªèŠ‚ç‚¹å°†è‡ªå·±æŒæœ‰çš„æƒç›Šè½¬æ¢ä¸ºé€‰ç¥¨æŠ•ç»™è‡ªå·±ä¿¡ä»»çš„èŠ‚ç‚¹</li><li>é€‰ç¥¨æœ€å¤šçš„Nä¸ªèŠ‚ç‚¹å½“é€‰ä¸ºè§è¯äººï¼ˆWitnessï¼‰ï¼Œå³ä»£è¡¨</li><li>è§è¯äººåœ¨ä¸€ä¸ªè§„å®šæ—¶é—´å†…éšæœºæ’åˆ—å¹¶è½®æµå¯¹äº¤æ˜“æ‰“åŒ…ï¼Œç”Ÿæˆæ–°åŒºå—è¿æ¥åˆ°æœ€é•¿é“¾ï¼Œè§è¯äººæ”¶è·mï¼…çš„äº¤æ˜“æ‰‹ç»­è´¹</li></ul></li></ol><h3 id="PBFTï¼ˆBFTï¼‰"><a href="#PBFTï¼ˆBFTï¼‰" class="headerlink" title="PBFTï¼ˆBFTï¼‰"></a>PBFTï¼ˆBFTï¼‰</h3><ol><li><p>æ¦‚å¿µ</p><p><font color="red">PBFTåœ¨ä¿è¯å¯ç”¨æ€§å’Œå®‰å…¨æ€§çš„å‰æä¸‹ï¼Œæä¾›äº†(n-1)/3çš„å®¹é”™æ€§</font>ï¼Œæ„æ€å°±æ˜¯å¦‚æœç³»ç»Ÿå†…æœ‰nä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆç³»ç»Ÿæœ€å¤šèƒ½å®¹å¿çš„ä½œæ¶/æ•…éšœèŠ‚ç‚¹ä¸º(n-1)/3ä¸ªã€‚ï¼ˆä½œæ¶èŠ‚ç‚¹å¯ä»¥ä¸å“åº”æˆ–è€…å›åº”é”™è¯¯çš„ä¿¡æ¯ï¼‰</p></li><li><p>å…±è¯†è¿‡ç¨‹</p><p>â€‹    <img src="/images/consensus/pbft_flow_chart.png" alt="å…±è¯†ç®—æ³•ç³»åˆ—ï¼šPBFTç®—æ³•å…³é”®ç‚¹ç»¼è¿°ã€ä¼˜ç¼ºç‚¹æ€»ç»“"></p><p>å®šä¹‰ï¼š</p><ul><li><p>fï¼šæ¶æ„èŠ‚ç‚¹</p></li><li><p>Digest(m)ï¼šæ¶ˆæ¯æ‘˜è¦</p></li></ul><p>è¿‡ç¨‹ï¼š</p><ul><li><strong>é¢„å‡†å¤‡é˜¶æ®µ</strong>ï¼šå‘é€åŸæœ¬çš„æ¶ˆæ¯mï¼Œè®©æ¯ä¸ªèŠ‚ç‚¹éƒ½è·å–åŸå§‹æ¶ˆæ¯</li><li><strong>å‡†å¤‡é˜¶æ®µ</strong>ï¼šç”¨Digest(m)å»å‘é€ï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹æ”¶åˆ°<strong>2f+1</strong>ä¸ªprepareæ¶ˆæ¯ï¼Œå°±è®¤ä¸ºå‡†å¤‡é˜¶æ®µç»“æŸï¼Œè¯´æ˜å·²ç»æœ‰å¤§éƒ¨åˆ†èŠ‚ç‚¹è®¤åŒäº†è¿™ä¸ªm</li><li><strong>æäº¤é˜¶æ®µ</strong>ï¼šç”¨Digest(m)å»å‘é€ï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹æ”¶åˆ°<strong>2f+1</strong>ä¸ªcommitï¼Œé‚£ä¹ˆå°±å¯ä»¥è®¤ä¸ºï¼Œå°±è¯´æ˜å·²ç»æœ‰å¤§å¤šæ•°èŠ‚ç‚¹â€œæ‰§è¡Œâ€äº†è¿™äº›mï¼Œè¿™ä¸ªé˜¶æ®µä¸»è¦æ˜¯ä¸ºäº†View ChangeæœåŠ¡</li><li><strong>å›æ‰§é˜¶æ®µ</strong>ï¼šæäº¤ç»“æŸåå°†ç»“æœè¿”å›ç»™å®¢æˆ·ç«¯ï¼Œå®¢æˆ·ç«¯æ”¶åˆ°è‡³å°‘<strong>f+1</strong>ä¸ªæ¶ˆæ¯å³å¯ç¡®è®¤</li></ul></li></ol><h3 id="DBFTï¼ˆBFTï¼‰"><a href="#DBFTï¼ˆBFTï¼‰" class="headerlink" title="DBFTï¼ˆBFTï¼‰"></a>DBFTï¼ˆBFTï¼‰</h3><ol><li><p>æ¦‚å¿µ</p><p>æˆæƒæ‹œå åº­å®¹é”™ï¼Œç³»ç»Ÿä¸­çš„ä»£å¸æŒæœ‰è€…<font color="red">é€šè¿‡æŠ•ç¥¨é€‰ä¸¾å‡ºè‡ªå·±æ‰€æ”¯æŒçš„å…±è¯†èŠ‚ç‚¹ï¼Œè¿™äº›é€‰å‡ºæ¥çš„å…±è¯†èŠ‚ç‚¹å†é€šè¿‡BFTæ¥è¾¾æˆå…±è¯†å¹¶ç”ŸæˆåŒºå—</font></p></li><li><p>å…±è¯†è¿‡ç¨‹</p><p><img src="/images/consensus/dbft_flow_chart.png" alt="image-20220108234438067"></p><p>è¿‡ç¨‹ï¼š</p><ul><li>èŠ‚ç‚¹<strong>æŠ•ç¥¨</strong>é€‰å‡ºä¸€å®šæ•°é‡çš„å…±è¯†èŠ‚ç‚¹</li><li>è®®é•¿è®¾ç½®è§†å›¾å¹¶å¹¿æ’­ææ¡ˆ<code>&lt;PrepareRequest&gt;</code>æ¶ˆæ¯</li><li>è®®å‘˜æ”¶åˆ°ææ¡ˆå¯¹å…¶éªŒè¯ï¼ŒéªŒè¯é€šè¿‡åè®®å‘˜å‘å…¨ç½‘å‘é€<code>&lt;PrepareResponse&gt;</code>æ¶ˆæ¯</li><li>å½“æ”¶åˆ°n-fæ¡<code>&lt;PrepareResponse&gt;</code>æ¶ˆæ¯æ—¶ï¼Œè®®å‘˜ä»¬å‘å¸ƒä¸€ä¸ªæ–°çš„åŒºå—ï¼Œå¯¹åŒºå—ç­¾åï¼Œå‘é€ç»™å…¶ä»–èŠ‚ç‚¹è¿›è¡ŒåŒæ­¥<code>&lt;Synchronization&gt;</code></li><li>å…¶ä»–èŠ‚ç‚¹æ”¶åˆ°å®Œæ•´åŒºå—åè¾¾åˆ°ç›¸åŒçš„åŒºå—é«˜åº¦ï¼Œæ¸…é™¤æœ¬åœ°å†…å­˜ä¸­æ‰€å­˜å‚¨çš„å½“å‰è§†å›¾äº¤æ˜“æ•°æ®ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡å…±è¯†</li></ul></li></ol><h2 id="ç®—æ³•ä¼˜ç¼ºç‚¹ä¸åº”ç”¨"><a href="#ç®—æ³•ä¼˜ç¼ºç‚¹ä¸åº”ç”¨" class="headerlink" title="ç®—æ³•ä¼˜ç¼ºç‚¹ä¸åº”ç”¨"></a>ç®—æ³•ä¼˜ç¼ºç‚¹ä¸åº”ç”¨</h2><table><thead><tr><th>ç®—æ³•</th><th>ä¼˜ç‚¹</th><th>ç¼ºç‚¹</th><th>åº”ç”¨</th></tr></thead><tbody><tr><td>Paxos</td><td>- å®¹å¿éæ‹œå åº­é”™è¯¯èŠ‚ç‚¹èƒ½åŠ›é«˜<br>- æ€§èƒ½é«˜</td><td>- ç®—æ³•éš¾ä»¥ç†è§£<br>- ä¸èƒ½å®¹å¿æ‹œå åº­é”™è¯¯èŠ‚ç‚¹</td><td>ZooKeeperã€GoogleChubby</td></tr><tr><td>Raft</td><td>- ç®—æ³•å®¹å¿éæ‹œå åº­é”™è¯¯èŠ‚ç‚¹èƒ½åŠ›é«˜<br>- æ€§èƒ½é«˜<br>- æ˜“äºç†è§£å’Œå®ç°</td><td>- ä¸èƒ½å®¹å¿æ‹œå åº­é”™è¯¯èŠ‚ç‚¹</td><td>IPFS Private Clusterã€R3 CodaQuorum</td></tr><tr><td>Pow</td><td>- ç®—æ³•é€»è¾‘ç®€å•<br>- å®‰å…¨æ€§é«˜<br>- å®¹é”™æ€§é«˜</td><td>- èµ„æºæ¶ˆè€—è¿‡é«˜<br>- ç³»ç»Ÿååé‡ä½</td><td>Bitcoinã€Ethereumã€Dogcoinã€Litecoinã€Zcash</td></tr><tr><td>PoS</td><td>- ç¼“è§£PoWèµ„æºæµªè´¹é—®é¢˜<br>- ç›¸å¯¹PoWæé«˜äº†å‡ºå—é€Ÿåº¦</td><td>- æ˜“å‡ºç°æŒå¸äººå±¯å¸ç°è±¡ï¼Œé€ æˆå¯¡å¤´ä¼˜åŠ¿</td><td>Blackcoinã€ADAã€Peercoinã€Casperã€Nxt</td></tr><tr><td>DPoS</td><td>- è§£å†³äº†PoWèµ„æºæµªè´¹é—®é¢˜<br>- æ€§èƒ½è¾ƒé«˜<br>- å‡ºå—é€Ÿåº¦è¾ƒå¿«</td><td>- ç›¸æ¯”å…¶ä»–ç®—æ³•è¯¥ç®—æ³•è¶‹äºä¸­å¿ƒåŒ–<br>- æŠ•ç¥¨æ— é—¨æ§›ï¼Œæƒç›Šä½™é¢å¤§ç¥¨æ•°è¶Šå¤§ï¼Œæ˜“é€ æˆè”åˆé€‰ä¸¾è¡Œä¸º</td><td>EOSã€Bitsharesã€Steemitã€Liskã€Arkã€GXChainã€ASCH</td></tr><tr><td>PBFT</td><td>- æ— ä»£å¸<br>- æ€§èƒ½æ•ˆç‡é«˜<br>- å®‰å…¨æ€§é«˜</td><td>- ç¡®è®¤æµç¨‹è¿‡å¤šï¼Œé€šä¿¡å¼€é”€å¤§<br>- æ— æ³•é¿å…æ¶æ„èŠ‚ç‚¹æ‹…ä»»ä¸»èŠ‚ç‚¹<br>- èŠ‚ç‚¹ä¸å¯è¿›è¡ŒåŠ¨æ€å¢åˆ <br>- æ— æ³•æ‰¿å—å¤§è§„æ¨¡èŠ‚ç‚¹</td><td>Fabric</td></tr><tr><td>DBFT</td><td>- å€Ÿé‰´DPoSï¼Œå‚ä¸å…±è¯†èŠ‚ç‚¹æ•°é‡è¾ƒå°‘ï¼Œå› æ­¤æé«˜äº†æ€§èƒ½</td><td>- ç›¸æ¯”å…¶ä»–ç®—æ³•è¯¥ç®—æ³•è¶‹äºä¸­å¿ƒåŒ–</td><td>NEO</td></tr></tbody></table><h1 id="å¼•å‘æ€è€ƒ"><a href="#å¼•å‘æ€è€ƒ" class="headerlink" title="å¼•å‘æ€è€ƒ"></a>å¼•å‘æ€è€ƒ</h1><ol><li><p>PBFTåœ¨èŠ‚ç‚¹æ•°è¶…è¿‡100åæ€§èƒ½ç»§ç»­ä¸‹é™ï¼Œå¦‚ä½•ç¼“è§£ï¼Ÿ</p><ul><li><p>æ–¹æ³•ä¸€ï¼šå¸¦å®½ä¼˜åŒ–ï¼š</p><ul><li>å®¢æˆ·ç«¯å°†è¯·æ±‚å‘ç»™ä»»æ„èŠ‚ç‚¹ï¼Œè€Œä¸æ˜¯åªå‘ç»™ä¸»èŠ‚ç‚¹ï¼Œç„¶åèŠ‚ç‚¹ç›´æ¥å°†è¯·æ±‚å¹¿æ’­ç»™æ‰€æœ‰èŠ‚ç‚¹</li><li>è®¾è®¡å…±äº«äº¤æ˜“æ± ï¼Œé¢„å…ˆè¿›è¡Œäº¤æ˜“çš„å¹¿æ’­ï¼Œä»…å…±è¯†äº¤æ˜“å“ˆå¸Œå€¼ä¸»èŠ‚ç‚¹æ‰“åŒ…äº¤æ˜“hashï¼Œå¹¿æ’­åŒ…å«hashçš„ææ¡ˆæ¶ˆæ¯ï¼Œè€Œä¸æ˜¯å¹¿æ’­äº¤æ˜“æ•°æ®</li><li>ä»èŠ‚ç‚¹åœ¨æäº¤ä¹‹å‰ä¸»åŠ¨å‘ä¸»èŠ‚ç‚¹è·å–å¯èƒ½ç¼ºå¤±çš„äº¤æ˜“ï¼Œæœ€ç»ˆæäº¤ä¹‹å‰ç¡®è®¤äº¤æ˜“åˆæ³•æ€§</li></ul><p><img src="/images/consensus/pbft_bandwidth_optimization.png" alt="image-20220109102820146"></p></li><li><p>æ–¹æ³•äºŒï¼šBFTé—®é¢˜è½¬æ¢æˆCFTé—®é¢˜ï¼Œå³è§„é¿æ‹œå åº­è¡Œä¸º</p><p><img src="/images/consensus/fast_bft_flow_chart.png" alt="image-20220109104150146"></p></li><li><p>æ–¹æ³•ä¸‰ï¼šç‚¹å¯¹ç‚¹ç½‘ç»œè½¬æ¢ä¸ºæ˜Ÿå‹ç½‘ç»œ</p><p><img src="/images/consensus/hot_stuff_flow_chart.png" alt="image-20220109104400275"></p></li></ul></li><li><p>PBFTæ— æ³•åŠ¨æ€å¢åˆ èŠ‚ç‚¹ï¼Œå¦‚ä½•è§£å†³ï¼Ÿ</p><p>å…ˆè¯·æ±‚åˆ†å¸ƒå¼CAï¼Œå†é€šè¿‡é…ç½®äº¤æ˜“çš„æ–¹å¼ï¼Œå‡†å…¥ä¸åˆ é™¤å…±è¯†èŠ‚ç‚¹</p><p><img src="/images/consensus/pbft_add_delete_node.png" alt="image-20220109103818671"></p></li><li><p>PBFTä¸­prepareå’Œcommité˜¶æ®µä¸ºä½•éƒ½è¦2f+1ä¸ªèŠ‚ç‚¹åé¦ˆç¡®è®¤?ï¼ˆè¿™2f+1èŠ‚ç‚¹åé¦ˆçš„ç»“æœå¹¶ä¸ä¸€å®šæ˜¯ç›¸åŒçš„ï¼‰</p><p>å¯¹äºprepareå’Œcommitæ¥è¯´ï¼ŒèŠ‚ç‚¹éœ€è¦åœ¨2f+1ä¸ªçŠ¶æ€å¤åˆ¶æœºçš„æ²Ÿé€šå†…å°±è¦åšå‡ºå†³å®šï¼Œè¿™æ˜¯åˆšå¥½å¯ä»¥ä¿è¯ä¸€è‡´æ€§çš„ï¼Œè€ƒè™‘æœ€åçš„æƒ…å†µï¼šæˆ‘ä»¬å‡è®¾æ”¶åˆ°çš„æœ‰fä¸ªæ˜¯æ­£å¸¸èŠ‚ç‚¹å‘è¿‡æ¥çš„ï¼Œä¹Ÿæœ‰fä¸ªæ˜¯æ¶æ„èŠ‚ç‚¹å‘è¿‡æ¥çš„ï¼Œé‚£ä¹ˆï¼Œç¬¬2f+1ä¸ªåªå¯èƒ½æ˜¯æ­£å¸¸èŠ‚ç‚¹å‘è¿‡æ¥çš„ã€‚ï¼ˆå› ä¸ºæˆ‘ä»¬é™åˆ¶äº†æœ€å¤šåªæœ‰fä¸ªæ¶æ„èŠ‚ç‚¹ï¼‰ç”±æ­¤å¯çŸ¥ï¼Œâ€œå¤§å¤šæ•°â€æ­£å¸¸çš„èŠ‚ç‚¹è¿˜æ˜¯å¯ä»¥è®©ç³»ç»Ÿå·¥ä½œä¸‹å»çš„ã€‚æ‰€ä»¥2f+1è¿™ä¸ªå‚æ•°å’Œn&gt;3f+1çš„è¦æ±‚æ˜¯é€»è¾‘è‡ªæ´½çš„ã€‚</p></li><li><p>PBFTä¸­clientä¸ºä½•åªéœ€è¦f+1ä¸ªç›¸åŒçš„å›å¤å°±å¯ç¡®è®¤ï¼Ÿ</p><p>ä¹‹å‰æˆ‘ä»¬è¯´ï¼Œprepareå’Œcommité˜¶æ®µä¸ºä½•éƒ½è¦2f+1ä¸ªèŠ‚ç‚¹åé¦ˆï¼Œæ‰èƒ½ç¡®è®¤ã€‚clientåªéœ€è¦f+1ä¸ªç›¸åŒçš„replyå°±å¯ä»¥äº†å‘¢ï¼Ÿæˆ‘ä»¬è¿˜æ˜¯æ¥è€ƒè™‘æœ€åçš„æƒ…å†µï¼Œæˆ‘ä»¬å‡è®¾è¿™f+1ä¸ªç›¸åŒçš„replyä¸­ï¼Œæœ‰fä¸ªéƒ½æ˜¯æ¶æ„èŠ‚ç‚¹ã€‚</p><p>æ‰€ä»¥è‡³å°‘æœ‰ä¸€ä¸ªrelyæ˜¯æ­£å¸¸èŠ‚ç‚¹å‘å‡ºæ¥çš„ï¼Œå› ä¸ºåœ¨prepareé˜¶æ®µï¼Œè¿™ä¸ªæ­£å¸¸çš„èŠ‚ç‚¹å·²ç»å¯ä»¥ä¿è¯prepared(m,v,n,i)ä¸ºçœŸï¼Œæ‰€ä»¥å·²ç»èƒ½ä»£è¡¨å¤§å¤šæ•°çš„æ„è§ï¼Œæ‰€ä»¥ï¼Œclientåªéœ€è¦f+1ä¸ªç›¸åŒçš„replyå°±èƒ½ä¿è¯ä»–æ‹¿åˆ°çš„æ˜¯æ•´ä¸ªç³»ç»Ÿå†…â€œå¤§å¤šæ•°æ­£å¸¸èŠ‚ç‚¹â€œçš„æ„è§ï¼Œä»è€Œè¾¾åˆ°ä¸€è‡´æ€§ã€‚</p></li><li><p>PBFTä¸­å¦‚æœprimaryæ˜¯æ¶æ„èŠ‚ç‚¹å‘¢ï¼Ÿ</p><p>å¯¹äºä¸€è‡´æ€§ï¼Œæˆ‘ä»¬å¯ä»¥è¿™ä¹ˆçœ‹ï¼šå¦‚æœprepared(mï¼Œvï¼Œnï¼Œi)ä¸ºçœŸï¼Œé‚£ä¹ˆprepared(mâ€™ï¼Œvï¼Œnï¼Œj)ä¸€å®šæ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºå¯¹äºåŒä¸€ä¸ªææ¡ˆæˆ‘ä»¬ä¸å¯èƒ½æœ‰ä¸¤ç§ç»“æœï¼Œä»è€Œä¿è¯æ•´ä¸ªç³»ç»Ÿçš„ä¸€è‡´æ€§ã€‚</p><p>å‡è®¾primaryèŠ‚ç‚¹æ˜¯æ¶æ„çš„ï¼Œé‚£ä¹ˆæ„å‘³ç€åœ¨replicasèŠ‚ç‚¹ä¸­â¾„å¤šæœ‰f-1ä¸ªæ¶æ„çš„èŠ‚ç‚¹ï¼Œprepared(mï¼Œvï¼Œnï¼Œi)ä¸ºçœŸï¼Œåˆ™è¯æ˜æœ‰f+1ä¸ªå–„æ„èŠ‚ç‚¹è¾¾æˆäº†ï¦ºâ¼€è‡´ï¼Œprepared(mâ€™ï¼Œvï¼Œnï¼Œj)ä¸ºçœŸï¼Œæ„å‘³ç€å¦å¤–f+1ä¸ªå–„æ„èŠ‚ç‚¹è¾¾æˆï¦ºä¸€è‡´ï¼Œå› ä¸ºç³»ç»Ÿä¸­åªæœ‰2f+1ä¸ªå–„æ„èŠ‚ç‚¹ï¼Œå› æ­¤æœ€å°‘æœ‰â¼€ä¸ªå–„æ„èŠ‚ç‚¹å‘é€ï¦ºä¸¤ä¸ªå†²çªçš„prepareæ¶ˆæ¯ï¼Œè¿™æ˜¯ï¥§å¯èƒ½çš„ã€‚æ‰€ä»¥prepared(mï¼Œvï¼Œnï¼Œi)ä¸ºçœŸï¼Œé‚£ä¹ˆprepared(mâ€™ï¼Œvï¼Œnï¼Œj)æ˜¯é”™è¯¯çš„ã€‚</p></li></ol><h1 id="å‚è€ƒèµ„æ–™"><a href="#å‚è€ƒèµ„æ–™" class="headerlink" title="å‚è€ƒèµ„æ–™"></a>å‚è€ƒèµ„æ–™</h1><ol><li><a href="https://b23.tv/c2IGPiA">ææ°¸ä¹è€å¸ˆè®²è§£æ‹œå åº­å°†å†›é—®é¢˜</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">ç»´åŸºç™¾ç§‘å¯¹æ‹œå åº­å°†å†›é—®é¢˜çš„è§£é‡Š</a></li><li><a href="https://blog.csdn.net/alinyua/article/details/86153013">Paxoså­¦ä¹ ç¬”è®°åŠå›¾è§£</a></li><li><a href="https://pmg.csail.mit.edu/papers/osdi99.pdf">PBFTæå‡ºè€…è®ºæ–‡ã€ŠPractical Byzantine Fault Toleranceã€‹</a></li><li><a href="https://zhuanlan.zhihu.com/p/53897982">å…±è¯†ç®—æ³•ç³»åˆ—ï¼šPBFTç®—æ³•å…³é”®ç‚¹ç»¼è¿°ã€ä¼˜ç¼ºç‚¹æ€»ç»“</a></li><li><a href="http://www.jsjkx.com/CN/article/openArticlePDF.jsp?id=19169">åŒºå—é“¾å…±è¯†ç®—æ³•å¯¹æ¯”ç ”ç©¶</a></li><li><a href="https://www.modb.pro/doc/42136">è”ç›ŸåŒºå—é“¾å…±è¯†ç®—æ³•çš„å®è·µä¸æŒ‘æˆ˜ - ç«¯è±ª æ­å·è¶£é“¾ç§‘æŠ€æ¶æ„å¸ˆ</a></li><li><a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf">Paxosè®ºæ–‡</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> å…±è¯†ç®—æ³• </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FabricåŒºå—é“¾åº”ç”¨å¼€å‘</title>
      <link href="/2021/10/26/blockchain/fabric/%E7%AC%AC13%E7%AB%A0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2021/10/26/blockchain/fabric/%E7%AC%AC13%E7%AB%A0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="FabricåŒºå—é“¾åº”ç”¨å¼€å‘"><a href="#FabricåŒºå—é“¾åº”ç”¨å¼€å‘" class="headerlink" title="FabricåŒºå—é“¾åº”ç”¨å¼€å‘"></a>FabricåŒºå—é“¾åº”ç”¨å¼€å‘</h1><h2 id="13-1-ç®€ä»‹"><a href="#13-1-ç®€ä»‹" class="headerlink" title="13.1 ç®€ä»‹"></a>13.1 ç®€ä»‹</h2><p>æ™ºèƒ½åˆçº¦æ˜¯æ— çŠ¶æ€çš„ã€äº‹ä»¶é©±åŠ¨çš„ä»£ç </p><h3 id="1-æ™ºèƒ½åˆçº¦å¼€å‘"><a href="#1-æ™ºèƒ½åˆçº¦å¼€å‘" class="headerlink" title="1. æ™ºèƒ½åˆçº¦å¼€å‘"></a>1. æ™ºèƒ½åˆçº¦å¼€å‘</h3><p>æ™ºèƒ½åˆçº¦ä»£ç æœ¬è´¨ä¸Šæ˜¯ä¸ºäº†å¯¹ä¸Šå±‚ä¸šåŠ¡é€»è¾‘è¿›è¡Œæ”¯æŒ</p><p>éœ€è¦å¼€å‘è€…å…·å¤‡çš„èƒ½åŠ›ï¼š</p><ul><li>äº†è§£æ‰€é€‰ç”¨åŒºå—é“¾å¹³å°çš„æ™ºèƒ½åˆçº¦ç»“æ„ã€è¯­è¨€ç‰¹æ€§ã€çŠ¶æ€å­˜å‚¨æ–¹å¼ç­‰çŸ¥è¯†</li><li>å¯¹æ™ºèƒ½åˆçº¦çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†è¿›è¡Œè€ƒè™‘ï¼ŒåŒ…æ‹¬ä»£ç ç¼–å†™ã€ç‰ˆæœ¬ç®¡ç†ã€æäº¤éªŒè¯ä»¥åŠå‡çº§ç‰ˆæœ¬</li></ul><h3 id="2-åº”ç”¨ç¨‹åºå¼€å‘"><a href="#2-åº”ç”¨ç¨‹åºå¼€å‘" class="headerlink" title="2. åº”ç”¨ç¨‹åºå¼€å‘"></a>2. åº”ç”¨ç¨‹åºå¼€å‘</h3><p>åº”ç”¨ç¨‹åºé€šè¿‡è°ƒç”¨æ™ºèƒ½åˆçº¦æä¾›çš„æ–¹æ³•æ¥å£æ¥å®ç°ä¸šåŠ¡é€»è¾‘ã€‚å¯ä»¥è¿è¡Œåœ¨åŒºå—é“¾çš„ç½‘ç»œèŠ‚ç‚¹ä¸Šï¼Œä¹Ÿå¯ä»¥è¿è¡Œåœ¨ä¸­å¿ƒåŒ–çš„æœåŠ¡å™¨ä¸Šã€‚</p><p>éœ€è¦å¼€å‘è€…å…·å¤‡çš„èƒ½åŠ›ï¼š</p><ul><li>æŒæ¡è‡³å°‘ä¸€ç§åº”ç”¨ç¨‹åºå¼€å‘è¯­è¨€</li><li>ç†Ÿç»ƒä½¿ç”¨æ™ºèƒ½åˆçº¦SDK</li></ul><h2 id="13-2-é“¾ç çš„åŸç†ã€æ¥å£ä¸ç»“æ„"><a href="#13-2-é“¾ç çš„åŸç†ã€æ¥å£ä¸ç»“æ„" class="headerlink" title="13.2 é“¾ç çš„åŸç†ã€æ¥å£ä¸ç»“æ„"></a>13.2 é“¾ç çš„åŸç†ã€æ¥å£ä¸ç»“æ„</h2><p>é“¾ç èŒè´£ï¼š</p><ul><li>å¯¹Fabricåº”ç”¨ç¨‹åºå‘é€çš„äº¤æ˜“åšå‡ºå“åº”ï¼Œæ‰§è¡Œä»£ç é€»è¾‘ï¼Œä¸è´¦æœ¬è¿›è¡Œäº¤äº’</li><li>åˆ›å»ºä¸€äº›çŠ¶æ€ï¼ˆstateï¼‰å¹¶å†™å…¥è´¦æœ¬</li></ul><p>é“¾ç ä¸èŠ‚ç‚¹çš„äº¤äº’ä½¿ç”¨gRPCåè®®</p><h3 id="13-2-1-Chaincodeæ¥å£"><a href="#13-2-1-Chaincodeæ¥å£" class="headerlink" title="13.2.1 Chaincodeæ¥å£"></a>13.2.1 Chaincodeæ¥å£</h3><pre><code class="go">// Chaincode interface must be implemented by all chaincodes. The fabric runs// the transactions by calling these functions as specified.type Chaincode interface {    // Init is called during Instantiate transaction after the chaincode container    // has been established for the first time, allowing the chaincode to    // initialize its internal data    // å½“é“¾ç æ”¶åˆ°å®ä¾‹åŒ–çš„äº¤æ˜“æ—¶ï¼ŒInitæ–¹æ³•ä¼šè¢«è°ƒç”¨ï¼ˆFabric1.4ç‰ˆæœ¬ï¼‰    Init(stub ChaincodeStubInterface) pb.Response    // Invoke is called to update or query the ledger in a proposal transaction.    // Updated state variables are not committed to the ledger until the    // transaction is committed.    // å½“é“¾ç æ”¶åˆ°å‡çº§æˆ–æŸ¥è¯¢ç±»å‹çš„äº¤æ˜“æ—¶ï¼ŒInvokeæ–¹æ³•ä¼šè¢«è°ƒç”¨ï¼ˆFabric1.4ç‰ˆæœ¬ï¼‰    Invoke(stub ChaincodeStubInterface) pb.Response}</code></pre><h3 id="13-2-2-é“¾ç ç»“æ„"><a href="#13-2-2-é“¾ç ç»“æ„" class="headerlink" title="13.2.2 é“¾ç ç»“æ„"></a>13.2.2 é“¾ç ç»“æ„</h3><pre><code class="go">package main// å¼•å…¥å¿…è¦çš„åŒ…import (    "fmt"    // shimåŒ…æä¾›äº†é“¾ç ä¸è´¦æœ¬äº¤äº’çš„ä¸­é—´å±‚ã€‚é“¾ç é€šè¿‡shim.ChaincodeStubInterfaceæä¾›çš„æ–¹æ³•æ¥è¯»å–å’Œä¿®æ”¹è´¦æœ¬çŠ¶æ€    "github.com/hyperledger/fabric/core/chaincode/shim"    // Initå’ŒInvokeæ–¹æ³•éœ€è¦è¿”å›pb.Responseç±»å‹    pb "github.com/hyperledger/fabric/protos/peer")// å£°æ˜ä¸€ä¸ªç»“æ„ä½“type SimpleChaincode struct {}// ä¸ºç»“æ„ä½“æ·»åŠ Initæ–¹æ³•func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {    // è¯¥æ–¹æ³•ç”¨æ¥å®Œæˆä¸€äº›åˆå§‹åŒ–çš„å·¥ä½œ    return shim.Success(nil)}// ä¸ºç»“æ„ä½“æ·»åŠ Invokeæ–¹æ³•func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {    // å“åº”è°ƒç”¨æˆ–æŸ¥è¯¢çš„ä¸šåŠ¡é€»è¾‘åœ¨è¯¥æ–¹æ³•ä¸­å®ç°    return shim.Success(nil)}// ä¸»å‡½æ•°ï¼Œéœ€è¦è°ƒç”¨shim.Start()æ–¹æ³•func main() {    err := shim.Start(new(SimpleChaincode))    if err != nil {        fmt.Printf("Error starting Simple chaincode: %s", err)    }}</code></pre><h3 id="13-2-3-é“¾ç åŸºæœ¬å·¥ä½œåŸç†"><a href="#13-2-3-é“¾ç åŸºæœ¬å·¥ä½œåŸç†" class="headerlink" title="13.2.3 é“¾ç åŸºæœ¬å·¥ä½œåŸç†"></a>13.2.3 é“¾ç åŸºæœ¬å·¥ä½œåŸç†</h3><p><img src="https://img-blog.csdnimg.cn/2e6b5bf1c26e4f8396154f82fcbe29fe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>æ­¥éª¤ï¼š</p><ul><li>ç”¨æˆ·é€šè¿‡å®¢æˆ·ç«¯ï¼ˆSDKæˆ–CLIï¼‰å‘Fabricçš„èƒŒä¹¦èŠ‚ç‚¹ï¼ˆendorserï¼‰å‘å‡ºè°ƒç”¨é“¾ç çš„äº¤æ˜“ææ¡ˆï¼ˆproposalï¼‰ã€‚èŠ‚ç‚¹å¯¹ææ¡ˆè¿›è¡ŒåŒ…æ‹¬ACLæƒé™æ£€æŸ¥åœ¨å†…çš„å„ç§æ£€éªŒï¼Œé€šè¿‡ååˆ™åˆ›å»ºæ¨¡æ‹Ÿæ‰§è¡Œè¿™ä¸€äº¤æ˜“çš„ç¯å¢ƒ</li><li>èŠ‚ç‚¹å’Œé“¾ç å®¹å™¨ä¹‹é—´é€šè¿‡gRPCæ¶ˆæ¯æ¥äº¤äº’ï¼Œæ¨¡æ‹Ÿæ‰§è¡Œäº¤æ˜“å¹¶ç»™å‡ºèƒŒä¹¦ç»“è®º</li></ul><h2 id="13-3-é“¾ç å¼€å‘API"><a href="#13-3-é“¾ç å¼€å‘API" class="headerlink" title="13.3 é“¾ç å¼€å‘API"></a>13.3 é“¾ç å¼€å‘API</h2><h3 id="13-3-1-è´¦æœ¬çŠ¶æ€äº¤äº’API"><a href="#13-3-1-è´¦æœ¬çŠ¶æ€äº¤äº’API" class="headerlink" title="13.3.1 è´¦æœ¬çŠ¶æ€äº¤äº’API"></a>13.3.1 è´¦æœ¬çŠ¶æ€äº¤äº’API</h3><p><img src="https://img-blog.csdnimg.cn/edd578638df647ce87034b4e1ae34133.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h3 id="13-3-2-äº¤æ˜“ä¿¡æ¯ç›¸å…³API"><a href="#13-3-2-äº¤æ˜“ä¿¡æ¯ç›¸å…³API" class="headerlink" title="13.3.2 äº¤æ˜“ä¿¡æ¯ç›¸å…³API"></a>13.3.2 äº¤æ˜“ä¿¡æ¯ç›¸å…³API</h3><p><img src="https://img-blog.csdnimg.cn/53fea4951f7f457d8f9175cc3935a3cc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h3 id="13-3-3-å‚æ•°è¯»å–API"><a href="#13-3-3-å‚æ•°è¯»å–API" class="headerlink" title="13.3.3 å‚æ•°è¯»å–API"></a>13.3.3 å‚æ•°è¯»å–API</h3><p><img src="https://img-blog.csdnimg.cn/e8c5d6e04792454dbeec1f4c3039cac7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h3 id="13-3-4-å…¶ä»–API"><a href="#13-3-4-å…¶ä»–API" class="headerlink" title="13.3.4 å…¶ä»–API"></a>13.3.4 å…¶ä»–API</h3><p><img src="https://img-blog.csdnimg.cn/dde665b33019483ba78615f5f0ec9b37.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h2 id="13-4-åº”ç”¨å¼€å‘æ¡ˆä¾‹ä¸€ï¼šè½¬è´¦"><a href="#13-4-åº”ç”¨å¼€å‘æ¡ˆä¾‹ä¸€ï¼šè½¬è´¦" class="headerlink" title="13.4 åº”ç”¨å¼€å‘æ¡ˆä¾‹ä¸€ï¼šè½¬è´¦"></a>13.4 åº”ç”¨å¼€å‘æ¡ˆä¾‹ä¸€ï¼šè½¬è´¦</h2><p>ç›®æ ‡ï¼š</p><ul><li>æŒæ¡æ™ºèƒ½åˆçº¦çš„åŸºæœ¬ç»“æ„</li><li>æŒæ¡æŸ¥è¯¢è´¦æœ¬ã€ä¿®æ”¹è´¦æœ¬ã€åˆ é™¤è´¦æœ¬çš„æ–¹æ³•</li></ul><p><a href="https://gitee.com/hbuzzs/fabric-chaincode-example/blob/master/chaincode/src/github.com/1.chaincode_example02/chaincode_example02.go">æŸ¥çœ‹ä»£ç </a></p><h2 id="13-5-åº”ç”¨å¼€å‘æ¡ˆä¾‹äºŒï¼šèµ„äº§æƒå±ç®¡ç†"><a href="#13-5-åº”ç”¨å¼€å‘æ¡ˆä¾‹äºŒï¼šèµ„äº§æƒå±ç®¡ç†" class="headerlink" title="13.5 åº”ç”¨å¼€å‘æ¡ˆä¾‹äºŒï¼šèµ„äº§æƒå±ç®¡ç†"></a>13.5 åº”ç”¨å¼€å‘æ¡ˆä¾‹äºŒï¼šèµ„äº§æƒå±ç®¡ç†</h2><p>ç›®æ ‡ï¼š</p><ul><li>æŒæ¡èµ„äº§çš„åˆ›å»ºã€æŸ¥è¯¢ã€è½¬ç§»æ‰€æœ‰æƒç­‰æ“ä½œ</li></ul><p><a href="https://gitee.com/hbuzzs/fabric-chaincode-example/blob/master/chaincode/src/github.com/2.marbles02/marbles_chaincode.go">æŸ¥çœ‹ä»£ç </a></p><h2 id="13-6-åº”ç”¨å¼€å‘æ¡ˆä¾‹ä¸‰ï¼šè°ƒç”¨å…¶ä»–é“¾ç "><a href="#13-6-åº”ç”¨å¼€å‘æ¡ˆä¾‹ä¸‰ï¼šè°ƒç”¨å…¶ä»–é“¾ç " class="headerlink" title="13.6 åº”ç”¨å¼€å‘æ¡ˆä¾‹ä¸‰ï¼šè°ƒç”¨å…¶ä»–é“¾ç "></a>13.6 åº”ç”¨å¼€å‘æ¡ˆä¾‹ä¸‰ï¼šè°ƒç”¨å…¶ä»–é“¾ç </h2><p>ç›®æ ‡ï¼š</p><ul><li>æŒæ¡å¦‚ä½•è°ƒç”¨å…¶ä»–é“¾ç <br><a href="https://gitee.com/hbuzzs/fabric-chaincode-example/blob/master/chaincode/src/github.com/3.passthru/passthru.go">æŸ¥çœ‹ä»£ç </a></li></ul><h2 id="13-7-åº”ç”¨å¼€å‘æ¡ˆä¾‹å››ï¼šå‘é€äº‹ä»¶"><a href="#13-7-åº”ç”¨å¼€å‘æ¡ˆä¾‹å››ï¼šå‘é€äº‹ä»¶" class="headerlink" title="13.7 åº”ç”¨å¼€å‘æ¡ˆä¾‹å››ï¼šå‘é€äº‹ä»¶"></a>13.7 åº”ç”¨å¼€å‘æ¡ˆä¾‹å››ï¼šå‘é€äº‹ä»¶</h2><p>ç›®æ ‡ï¼š</p><ul><li>æŒæ¡å¦‚ä½•å‘é€äº‹ä»¶</li></ul><p><a href="https://gitee.com/hbuzzs/fabric-chaincode-example/blob/master/chaincode/src/github.com/4.eventsender/eventsender.go">æŸ¥çœ‹ä»£ç </a></p><h2 id="13-8-å¼€å‘æœ€ä½³å®è·µå°ç»“"><a href="#13-8-å¼€å‘æœ€ä½³å®è·µå°ç»“" class="headerlink" title="13.8 å¼€å‘æœ€ä½³å®è·µå°ç»“"></a>13.8 å¼€å‘æœ€ä½³å®è·µå°ç»“</h2><ol><li>é‡è§†èµ„æºé™åˆ¶</li><li>æ— çŠ¶æ€è®¾è®¡</li><li>é¿å…éç¡®å®šæ€§é€»è¾‘</li><li>é“¾ç ç»“æ„è®¾è®¡</li><li>é“¾ç ç”Ÿå‘½å‘¨æœŸçš„ç®¡ç†</li></ol><h1 id="å‚è€ƒ"><a href="#å‚è€ƒ" class="headerlink" title="å‚è€ƒ"></a>å‚è€ƒ</h1><ul><li>ã€ŠåŒºå—é“¾åŸç†ã€è®¾è®¡ä¸åº”ç”¨-æ¨ä¿åã€é™ˆæ˜Œã€‹</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric CAåº”ç”¨ä¸é…ç½®</title>
      <link href="/2021/10/18/blockchain/fabric/%E7%AC%AC11%E7%AB%A0-Fabric-CA%E5%BA%94%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/10/18/blockchain/fabric/%E7%AC%AC11%E7%AB%A0-Fabric-CA%E5%BA%94%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Fabric-CAåº”ç”¨ä¸é…ç½®"><a href="#Fabric-CAåº”ç”¨ä¸é…ç½®" class="headerlink" title="Fabric CAåº”ç”¨ä¸é…ç½®"></a>Fabric CAåº”ç”¨ä¸é…ç½®</h1><h2 id="11-1-ç®€ä»‹"><a href="#11-1-ç®€ä»‹" class="headerlink" title="11.1 ç®€ä»‹"></a>11.1 ç®€ä»‹</h2><ol><li>Fabric CAé¡¹ç›®ä¸»è¦åŠŸèƒ½ï¼š</li></ol><ul><li>è´Ÿè´£Fabricç½‘ç»œå†…æ‰€æœ‰å®ä½“çš„èº«ä»½ç®¡ç†ï¼ŒåŒ…æ‹¬èº«ä»½çš„æ³¨å†Œã€æ³¨é”€ç­‰</li><li>è´Ÿè´£è¯ä¹¦ç®¡ç†ï¼ŒåŒ…æ‹¬ECertsï¼ˆèº«ä»½è¯ä¹¦ï¼‰ã€TCertsï¼ˆäº¤æ˜“è¯ä¹¦ï¼‰ç­‰çš„å‘æ”¾å’Œæ³¨é”€</li><li>æœåŠ¡ç«¯æ”¯æŒåŸºäºå®¢æˆ·ç«¯å‘½ä»¤è¡Œå’ŒRESTful APIçš„äº¤äº’æ–¹å¼</li></ul><ol start="2"><li>åŸºæœ¬ç»„ä»¶<br>é‡‡ç”¨å…¸å‹çš„CSæ¶æ„ï¼Œç›®å‰åŒ…å«ä¸¤ä¸ªåŸºæœ¬ç»„ä»¶ï¼š</li></ol><ul><li>æœåŠ¡ç«¯ï¼šfabric-ca-serverå®ç°æ ¸å¿ƒçš„PKIæœåŠ¡åŠŸèƒ½ï¼Œæ”¯æŒå¤šç§æ•°æ®åº“åå°ï¼ˆåŒ…æ‹¬MySQLã€PostgreSQLç­‰ï¼‰ï¼Œå¹¶æ”¯æŒé›†æˆLDAPä½œä¸ºç”¨æˆ·æ³¨å†Œç®¡ç†åŠŸèƒ½</li><li>å®¢æˆ·ç«¯ï¼ˆClientï¼‰ï¼šfabric-ca-clientå°è£…äº†æœåŠ¡ç«¯çš„RESTful APIï¼Œæä¾›è®¿é—®æœåŠ¡ç«¯çš„å‘½ä»¤ï¼Œä¾›ç”¨æˆ·ä¸æœåŠ¡ç«¯è¿›è¡Œäº¤äº’</li></ul><h2 id="11-2-å®‰è£…æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯"><a href="#11-2-å®‰è£…æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯" class="headerlink" title="11.2 å®‰è£…æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯"></a>11.2 å®‰è£…æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯</h2><h3 id="11-2-1-æœ¬åœ°ç¼–è¯‘"><a href="#11-2-1-æœ¬åœ°ç¼–è¯‘" class="headerlink" title="11.2.1 æœ¬åœ°ç¼–è¯‘"></a>11.2.1 æœ¬åœ°ç¼–è¯‘</h3><ol><li>é…ç½®ç¼–è¯‘ç¯å¢ƒ<br>åŸºæœ¬ä¾èµ–ï¼š</li></ol><ul><li>Golang 1.7+ï¼Œå¹¶é…ç½®GOPATHç¯å¢ƒå˜é‡</li><li>libtoolå’Œlibltdl-devä¾èµ–åº“</li></ul><ol start="2"><li>ç¼–è¯‘äºŒè¿›åˆ¶æ–‡ä»¶</li></ol><h3 id="11-2-2-è·å–å’Œä½¿ç”¨Dockeré•œåƒï¼ˆæ¨èï¼‰"><a href="#11-2-2-è·å–å’Œä½¿ç”¨Dockeré•œåƒï¼ˆæ¨èï¼‰" class="headerlink" title="11.2.2 è·å–å’Œä½¿ç”¨Dockeré•œåƒï¼ˆæ¨èï¼‰"></a>11.2.2 è·å–å’Œä½¿ç”¨Dockeré•œåƒï¼ˆæ¨èï¼‰</h3><pre><code class="shell">docker pull hyperledger/fabric-caï¼š1.4.0</code></pre><p>å¿«é€Ÿè¿›å…¥å®¹å™¨ï¼Œé‡‡ç”¨é»˜è®¤é…ç½®å¿«é€Ÿåˆå§‹åŒ–å¹¶å¯åŠ¨æœåŠ¡ï¼š</p><pre><code class="shell">docker run -it hyperledger/fabric-cafabric-ca-server init -b admin:adminpw</code></pre><ol><li>æŒ‚è½½æœ¬åœ°é…ç½®æ–‡ä»¶<pre><code class="shell">docker run -it -v LOCAL_PATH:/etc/hyperledger/fabric-ca-server hyperledger/fabric-ca bash</code></pre></li><li>æš´éœ²RESTfulæœåŠ¡<br>ä¸ºäº†è®©å…¶ä»–ç‰©ç†æœºèƒ½è®¿é—®åˆ°å®¹å™¨å†…çš„æœåŠ¡ï¼Œå¯ä»¥å°†è¯¥ç«¯å£æ˜ å°„åˆ°æœ¬åœ°å®¿ä¸»æœº<br>ä¾‹å¦‚ä¸‹é¢å‘½ä»¤å°†æœ¬åœ°çš„7054ç«¯å£ä¸å®¹å™¨ç«¯å£æ˜ å°„å…³è”ï¼Œä¹‹åå…¶ä»–ç‰©ç†æœºå¯ä»¥é€šè¿‡è®¿é—®æœ¬åœ°å®¿ä¸»æœºçš„7054ç«¯å£æ¥è®¿é—®å®¹å™¨å†…æœåŠ¡ï¼š<pre><code class="shell">docker run -it -v LOCAL_PATH:/etc/hyperledger/fabric-ca-server -p 7054:7054 hyperledger/fabric-ca bash</code></pre></li></ol><h2 id="11-3-å¯åŠ¨CAæœåŠ¡"><a href="#11-3-å¯åŠ¨CAæœåŠ¡" class="headerlink" title="11.3 å¯åŠ¨CAæœåŠ¡"></a>11.3 å¯åŠ¨CAæœåŠ¡</h2><ol><li>é…ç½®è¯»å–<br>fabric-ca-serveræœåŠ¡æ‰€éœ€è¦çš„ç›¸å…³é…ç½®é¡¹ä¼šä¾æ¬¡å°è¯•ä»å‘½ä»¤è¡Œå‚æ•°ã€ç¯å¢ƒå˜é‡ï¼ˆå‘½åéœ€è¦å¸¦æœ‰<code>FABIRIC_CA_SERVER</code>å‰ç¼€ï¼‰æˆ–ä¸»é…ç½®ç›®å½•ï¼ˆæœªæŒ‡å®šé…ç½®æ–‡ä»¶è·¯å¾„æ—¶ï¼‰ä¸‹æœ¬åœ°é…ç½®æ–‡ä»¶æ¥è¯»å–ã€‚<br>ä¾‹å¦‚æŒ‡å®šå¯ç”¨TLSå¯ä»¥é€šè¿‡å¦‚ä¸‹ä¸‰ç§æ–¹å¼æ¥è¿›è¡Œé…ç½®ï¼Œä¼˜å…ˆçº§ç”±é«˜åˆ°ä½ï¼š</li></ol><ul><li>å‘½ä»¤è¡Œå‚æ•°ï¼š<code>--tls-enabled=true</code></li><li>ç¯å¢ƒå˜é‡ï¼š<code>FABRIC_CA_SERVER_TLS_ENABLED=true</code></li><li>é…ç½®æ–‡ä»¶ï¼š<code>tls.enabled=true</code><br>å¦‚æœéƒ½æœªå‘ç°ï¼Œåˆ™é‡‡ç”¨å†…ç½®çš„é»˜è®¤å€¼ï¼ˆfalseï¼‰</li></ul><ol start="2"><li>ä¸»é…ç½®ç›®å½•<br>æœ¬åœ°é…ç½®æ–‡ä»¶é»˜è®¤éƒ½æ˜¯ä»æ‰€è°“ä¸»é…ç½®ç›®å½•ï¼ˆHome Dirï¼‰ä¸‹è¿›è¡ŒæŸ¥æ‰¾ï¼Œè¿˜å¯ä»¥é¢„ç½®è¯ä¹¦å’Œå¯†é’¥æ–‡ä»¶<br>ä¸»é…ç½®ç›®å½•çš„å…·ä½“è·¯å¾„è·å–è§„åˆ™ï¼šä¾æ­¤ä»ç¯å¢ƒå˜é‡<code>FABRIC_CA_SERVER_HOME</code>ã€<code>FABRIC_CA_HOME</code>ã€<code>CA_CFG_PATH</code>ç­‰ä¸­è¯»å–ã€‚ä¸€èˆ¬æ¨èä½¿ç”¨é»˜è®¤çš„<code>/etc/hyperledger/fabric-ca-server</code>è·¯å¾„ä½œä¸ºä¸»é…ç½®ç›®å½•ç¯å¢ƒå˜é‡çš„æŒ‡å‘è·¯å¾„ï¼Œç”¨æˆ·ä¹Ÿå¯ä»¥æ ¹æ®éœ€æ±‚è‡ªè¡Œè®¾å®šã€‚</li><li>åˆå§‹åŒ–fabric-ca-server<br>é¦–æ¬¡ä½¿ç”¨fabric-ca-serveræœåŠ¡çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨initå‘½ä»¤æ¥å®Œæˆåˆå§‹åŒ–<pre><code class="shell">fabric-ca-server init -b admin:adminpw</code></pre></li><li>å¯åŠ¨fabric-ca-server<pre><code class="shell">fabric-ca-server start -b admin:adminpw</code></pre></li><li>RESTful API<br>é»˜è®¤çš„RESTfulæœåŠ¡ç›‘å¬åœ¨7054åœ°å€ï¼ŒæœåŠ¡å‰ç¼€ä¸º/api/v1<br>å‚è€ƒ<a href="https://github.com/hyperledger/fabric-ca/blob/release-1.4/swagger/swagger-fabric-ca.json">swagger</a>ï¼Œä¸»è¦æ¥å£ï¼š</li></ol><ul><li>POST /cainfoï¼šè·å–æŸä¸ªCAæœåŠ¡çš„åŸºæœ¬ä¿¡æ¯ï¼Œbodyä¸­å¯å¸¦æœ‰cnameä¿¡æ¯</li><li>POST /enrollï¼šä½¿ç”¨ç”¨æˆ·ç™»è®°åŠŸèƒ½ï¼Œbodyä¸­å¯å¸¦æœ‰hostã€requestã€profileã€labelã€canameç­‰ä¿¡æ¯</li><li>POST /reenrollï¼šä½¿ç”¨ç”¨æˆ·é‡æ–°ç™»è®°åŠŸèƒ½ï¼Œbodyä¸­å¯å¸¦æœ‰hostã€requestã€profileã€labelã€canameä¿¡æ¯</li><li>POST /registerï¼šä½¿ç”¨ç”¨æˆ·æ³¨å†ŒåŠŸèƒ½ï¼Œbodyä¸­å¯å¸¦æœ‰idã€typeã€secretã€max_enrollmentsã€affiliation_pathã€attiresã€canameç­‰ä¿¡æ¯</li><li>POST /revokeï¼šæ’¤é”€æŸä¸ªè¯ä¹¦ï¼Œbodyä¸­å¯å¸¦æœ‰idã€akiã€serialã€resonã€canameç­‰ä¿¡æ¯</li><li>POST /tcertï¼šç”³è¯·è·å–ä¸€æ‰¹äº¤æ˜“è¯ä¹¦ï¼Œbodyå¯ä»¥å¸¦æœ‰countã€arr_namesã€encrypy_attrsã€validity_periodã€canameç­‰ä¿¡æ¯</li></ul><h2 id="11-4-æœåŠ¡ç«¯å‘½ä»¤å‰–æ"><a href="#11-4-æœåŠ¡ç«¯å‘½ä»¤å‰–æ" class="headerlink" title="11.4 æœåŠ¡ç«¯å‘½ä»¤å‰–æ"></a>11.4 æœåŠ¡ç«¯å‘½ä»¤å‰–æ</h2><h3 id="11-4-1-å…¨å±€å‘½ä»¤å‚æ•°"><a href="#11-4-1-å…¨å±€å‘½ä»¤å‚æ•°" class="headerlink" title="11.4.1 å…¨å±€å‘½ä»¤å‚æ•°"></a>11.4.1 å…¨å±€å‘½ä»¤å‚æ•°</h3><ol><li><p>é€šç”¨å‚æ•°<br><img src="https://img-blog.csdnimg.cn/d38a58e238c74b05bffda95b4f82ca17.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"><br><img src="https://img-blog.csdnimg.cn/a80a90a362f248bb85d771717a33edda.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>è¯ä¹¦ç­¾åè¯·æ±‚å‚æ•°<br><img src="https://img-blog.csdnimg.cn/3028936c69b346e2a6a019110b707b06.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>æ•°æ®åº“ç›¸å…³å‚æ•°<br><img src="https://img-blog.csdnimg.cn/e92be96027a641b494192a6422585b4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>TLSç›¸å…³å‚æ•°<br><img src="https://img-blog.csdnimg.cn/762ade5b32084acdbf63dca432a04017.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>LDAPå‚æ•°</p></li></ol><p><img src="https://img-blog.csdnimg.cn/85444b1b43624510a4cb2d2cb309f1de.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h3 id="11-4-2-initå‘½ä»¤"><a href="#11-4-2-initå‘½ä»¤" class="headerlink" title="11.4.2 initå‘½ä»¤"></a>11.4.2 initå‘½ä»¤</h3><p>fabric-ca-server init [flags]<br>åˆå§‹åŒ–ä¸€ä¸ªfabric-ca-serveræœåŠ¡ï¼Œä¸»è¦ç”¨äºç”Ÿæˆå¯†é’¥ç›¸å…³çš„è¯ä¹¦æ–‡ä»¶ä»¥åŠé…ç½®æ–‡ä»¶ç­‰</p><h3 id="11-4-3-startå‘½ä»¤"><a href="#11-4-3-startå‘½ä»¤" class="headerlink" title="11.4.3 startå‘½ä»¤"></a>11.4.3 startå‘½ä»¤</h3><p>fabric-ca-server start [flags]<br>å¯åŠ¨ä¸€ä¸ªfabric-ca-serveræœåŠ¡</p><h2 id="11-5-æœåŠ¡ç«¯é…ç½®æ–‡ä»¶è§£æ"><a href="#11-5-æœåŠ¡ç«¯é…ç½®æ–‡ä»¶è§£æ" class="headerlink" title="11.5 æœåŠ¡ç«¯é…ç½®æ–‡ä»¶è§£æ"></a>11.5 æœåŠ¡ç«¯é…ç½®æ–‡ä»¶è§£æ</h2><p>æœåŠ¡ç«¯é…ç½®æ–‡ä»¶æœ€å¸¸è§çš„è·¯å¾„åœ¨<code>/etc/hyperledger/fabric-ca-server/fabric-ca-server-config.yaml</code>ï¼ŒåŒ…æ‹¬é€šç”¨é…ç½®ã€TLSé…ç½®ã€CAé…ç½®ã€æ³¨å†Œç®¡ç†é…ç½®ã€æ•°æ®åº“é…ç½®ã€LDAPé…ç½®ã€ç»„ç»‡ç»“æ„é…ç½®ã€ç­¾åã€è¯ä¹¦ç”³è¯·ç­‰å‡ ä¸ªéƒ¨åˆ†</p><ol><li>é€šç”¨é…ç½®<br>åŒ…æ‹¬æœåŠ¡ç›‘å¬çš„ç«¯å£å·ï¼Œæ˜¯å¦è¾“å‡ºæ›´å¤šçš„DEBUGæ—¥å¿—ç­‰ï¼š</li></ol><ul><li>portï¼š7054:æŒ‡å®šæœåŠ¡çš„ç›‘å¬ç«¯å£ï¼›</li><li>debugï¼šfalseï¼šæ˜¯å¦å¯ç”¨DEBUGæ¨¡å¼ï¼Œè¾“å‡ºæ›´å¤šçš„è°ƒè¯•ä¿¡æ¯</li></ul><ol start="2"><li>TLSé…ç½®<br>æ˜¯å¦åœ¨æœåŠ¡ç«¯å¯ç”¨TLSï¼Œèº«ä»½éªŒè¯çš„è¯ä¹¦å’Œç­¾åçš„ç§é’¥ã€‚<br>å®¢æˆ·ç«¯è¿›è¡ŒTLSè®¤è¯çš„æ¨¡å¼ï¼š</li></ol><ul><li>NoClientCertï¼šä¸å¯ç”¨ï¼Œé»˜è®¤å€¼</li><li>RequestClientCertï¼šè¯·æ±‚å®¢æˆ·ç«¯æä¾›è¯ä¹¦</li><li>RequireAnyClientCertï¼šè¦æ±‚å®¢æˆ·ç«¯æä¾›åˆæ³•æ ¼å¼çš„è¯ä¹¦</li><li>VerifyClientCertIfGivenï¼šå¦‚æœå®¢æˆ·ç«¯æä¾›è¯ä¹¦åˆ™è¿›è¡ŒéªŒè¯</li><li>RequireAndVerfyClientCertï¼šè¦æ±‚å¹¶ä¸”è¦éªŒè¯å®¢æˆ·ç«¯çš„è¯ä¹¦<br><img src="https://img-blog.csdnimg.cn/1f825f49e6ce4934950b5f592f2d2a4c.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></li></ul><ol start="3"><li>CAé…ç½®<br>åŒ…æ‹¬å®ä¾‹çš„åç§°ã€ç­¾åç§é’¥æ–‡ä»¶ã€èº«ä»½éªŒè¯è¯ä¹¦å’Œè¯ä¹¦é“¾æ–‡ä»¶ç­‰ã€‚è¿™äº›ç§é’¥å’Œè¯ä¹¦æ–‡ä»¶ä¼šç”¨æ¥ä½œä¸ºç”ŸæˆECertã€TCertçš„è·Ÿè¯ä¹¦</li></ol><p><img src="https://img-blog.csdnimg.cn/e589721894da46f98846a55600162d17.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_12,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"><br>4. æ³¨å†Œç®¡ç†é…ç½®<br>   å½“fabric-ca-serverè‡ªèº«æä¾›ç”¨æˆ·çš„æ³¨å†Œç®¡ç†æ—¶ä½¿ç”¨ï¼Œè¿™ç§æƒ…å†µä¸‹éœ€è¦ç¦ç”¨LDAPåŠŸèƒ½ï¼Œå¦åˆ™fabric-ca-serverå°†ä¼šæŠŠæ³¨å†Œç®¡ç†æ•°æ®è½¬å‘åˆ°LDAPè¿›è¡ŒæŸ¥è¯¢<br>   é…ç½®å†…å®¹ï¼š</p><ul><li>å¯¹enrollmentè¿‡ç¨‹çš„ç”¨æˆ·åå’Œå¯†ç è¿›è¡ŒéªŒè¯</li><li>è·å–æŸä¸ªè®¤è¯å®ä½“çš„ç”¨æˆ·å±æ€§ä¿¡æ¯<br><img src="https://img-blog.csdnimg.cn/1fae1c7aac014e7883509aa6f1ca1fe6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></li></ul><ol start="5"><li>æ•°æ®åº“é…ç½®</li></ol><p>æ•°æ®åº“æ”¯æŒSQlite3ã€Postgresã€MySQLï¼Œå¯ä»¥åœ¨æœ¬æ®µä¸­è¿›è¡Œé…ç½®ï¼Œé»˜è®¤ä¸ºSQlite3ç±»å‹çš„æœ¬åœ°æ•°æ®åº“ã€‚<br><img src="https://img-blog.csdnimg.cn/02546b184e374c5ebccdf1f4745f9e92.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"><br><img src="https://img-blog.csdnimg.cn/77cad42365984779910a8bacc78a8e10.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><ol start="6"><li>LDAPé…ç½®<br>é…ç½®ä½¿ç”¨è¿œç«¯çš„LDAPæ¥è¿›è¡Œæ³¨å†Œç®¡ç†ï¼Œè®¤è¯enrollmentçš„ç”¨æˆ·åå’Œå¯†ç ï¼Œå¹¶è·å–ç”¨æˆ·å±æ€§ä¿¡æ¯ã€‚</li></ol><p><img src="https://img-blog.csdnimg.cn/6bd9a1e5382c47ec90ad5dd4a4de068e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"><br>7. ç»„ç»‡ç»“æ„é…ç½®<br>   æ¯ä¸ªç»„ç»‡è‹¥å¹²éƒ¨é—¨<br>   <img src="https://img-blog.csdnimg.cn/1a00ad4dabeb487b99c4c8708f385f7f.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><ol start="8"><li><p>ç­¾å‘è¯ä¹¦ç›¸å…³é…ç½®<br>ç­¾å‘è¯ä¹¦ç›¸å…³çš„é…ç½®åŒ…æ‹¬ç­¾åæ–¹æ³•ã€è¯ä¹¦è¶…æ—¶æ—¶é—´ç­‰<br>fabric-ca-serverå¯ä»¥ä½œä¸ºç”¨æˆ·è¯ä¹¦çš„ç­¾å‘CAï¼Œè¿˜å¯ä»¥ä½œä¸ºæ ¹CAæ¥è¿›ä¸€æ­¥æ”¯æŒå…¶ä»–ä¸­é—´CA<br><img src="https://img-blog.csdnimg.cn/d160955a705a46c5bbe7b8f04afc8b7f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_13,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>è¯ä¹¦ç”³è¯·è¯·æ±‚é…ç½®<br>CAè‡ªèº«è¯ä¹¦çš„ç”³è¯·è¯·æ±‚é…ç½®ã€‚<br>å½“CAä½œä¸ºæ ¹è¯ä¹¦æœåŠ¡æ—¶ï¼Œå°†ç»™äºˆè¯·æ±‚ç”Ÿæˆä¸€ä¸ªè‡ªç­¾åçš„è¯ä¹¦ï¼›å½“CAä½œä¸ºä¸­é—´è¯ä¹¦æœåŠ¡æ—¶ï¼Œå°†è¯·æ±‚å‘ç»™ä¸Šå±‚çš„æ ¹è¯ä¹¦è¿›è¡Œç­¾ç½²ã€‚<br><img src="https://img-blog.csdnimg.cn/1daf145fbb9c45aaac6fc7839950e659.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_14,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>BCCSPé…ç½®<br>é…ç½®æ‰€é€‰æ‹©çš„åŠ å¯†åº“<br><img src="https://img-blog.csdnimg.cn/7a71d04006b04ee2abfccc343c1f1146.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>å¤šCAæ”¯æŒé…ç½®<br>é€šè¿‡cacountï¼šè‡ªåŠ¨åˆ›å»ºé™¤äº†é»˜è®¤CAå¤–çš„å¤šä¸ªCAå®ä¾‹ï¼Œå¦‚ca1ã€ca2ç­‰<br>é€šè¿‡cafilesï¼šå¯ä»¥æŒ‡å®šå¤šä¸ªCAé…ç½®æ–‡ä»¶è·¯å¾„ï¼Œæ¯ä¸ªé…ç½®æ–‡ä»¶ä¼šå¯åŠ¨ä¸€ä¸ªCAæœåŠ¡ï¼Œæ³¨æ„ä¸åŒé…ç½®æ–‡ä»¶ä¹‹é—´éœ€è¦é¿å…å†²çª</p></li><li><p>ä¸­é—´å±‚CAé…ç½®<br>å½“CAä½œä¸ºä¸­é—´å±‚CAæœåŠ¡æ—¶çš„ç›¸å…³é…ç½®ï¼ŒåŒ…æ‹¬çˆ¶CAçš„åœ°å€å’Œåç§°ã€ç™»è®°ä¿¡æ¯ã€TLSé…ç½®ç­‰ã€‚æ³¨æ„å½“intermediate.parentserver.urléç©ºæ—¶ï¼Œæ„å‘³ç€æœ¬CAæ˜¯ä¸­é—´å±‚CAæœåŠ¡ï¼Œå¦åˆ™ä¸ºæ ¹CAæœåŠ¡ã€‚</p></li></ol><p><img src="https://img-blog.csdnimg.cn/66edf93596874e29bf47f8d179bf25d8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_8,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h2 id="11-6-ä¸æœåŠ¡ç«¯è¿›è¡Œäº¤äº’"><a href="#11-6-ä¸æœåŠ¡ç«¯è¿›è¡Œäº¤äº’" class="headerlink" title="11.6 ä¸æœåŠ¡ç«¯è¿›è¡Œäº¤äº’"></a>11.6 ä¸æœåŠ¡ç«¯è¿›è¡Œäº¤äº’</h2><h3 id="1-é…ç½®è¯»å–"><a href="#1-é…ç½®è¯»å–" class="headerlink" title="1. é…ç½®è¯»å–"></a>1. é…ç½®è¯»å–</h3><p>ä¸»é…ç½®ç›®å½•å›ä¸€æ¬¡å°è¯•ä»ç¯å¢ƒå˜é‡FABRIC_CA_CLIENT_HOMEã€FABRIC_CA_HOMEã€CA_CFG_PATHä¸­è¯»å–ã€‚ä¸€èˆ¬æ¨èä½¿ç”¨$HOME/.fabric-ca-clientä½œä¸ºä¸»ç›®å½•ç¯å¢ƒå˜é‡çš„æŒ‡å‘è·¯å¾„ã€‚ç”¨æˆ·ä¹Ÿå¯ä»¥æ ¹æ®éœ€æ±‚è‡ªè¡Œè®¾å®š</p><h3 id="2-ç™»è®°ç”¨æˆ·"><a href="#2-ç™»è®°ç”¨æˆ·" class="headerlink" title="2. ç™»è®°ç”¨æˆ·"></a>2. ç™»è®°ç”¨æˆ·</h3><p>é€šè¿‡enrollå‘½ä»¤å¯ä»¥å¯¹æ³¨å†Œåˆ°fabric-ca-serverä¸­çš„å°¸ä½“è¿›è¡Œç™»è®°ï¼Œè·å–å…¶è¯ä¹¦ä¿¡æ¯</p><h3 id="3-æ³¨å†Œç”¨æˆ·"><a href="#3-æ³¨å†Œç”¨æˆ·" class="headerlink" title="3. æ³¨å†Œç”¨æˆ·"></a>3. æ³¨å†Œç”¨æˆ·</h3><p>ç™»è®°åçš„ç”¨æˆ·èº«ä»½å¯ä»¥é‡‡ç”¨å¦‚ä¸‹å‘½ä»¤æ¥æ³¨å†Œæ–°ç”¨æˆ·ï¼š<br><img src="https://img-blog.csdnimg.cn/7671d461d79d489dbfc385099893eda4.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h3 id="4-ç™»è®°èŠ‚ç‚¹"><a href="#4-ç™»è®°èŠ‚ç‚¹" class="headerlink" title="4. ç™»è®°èŠ‚ç‚¹"></a>4. ç™»è®°èŠ‚ç‚¹</h3><p>ç™»è®°Peeræˆ–OrdererèŠ‚ç‚¹çš„æ“ä½œä¸ç™»è®°ç”¨æˆ·èº«ä»½ç±»ä¼¼ã€‚é€šè¿‡-Må¯ä»¥åˆ¶å®šæœ¬åœ°MSPçš„è·Ÿè·¯å¾„æ¥åœ¨å…¶ä¸‹å­˜æ”¾è¯ä¹¦æ–‡ä»¶ï¼š<br><img src="https://img-blog.csdnimg.cn/50e9a165e55a486ca563c02f331353cd.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h2 id="11-7-å®¢æˆ·ç«¯å‘½ä»¤å‰–æ"><a href="#11-7-å®¢æˆ·ç«¯å‘½ä»¤å‰–æ" class="headerlink" title="11.7 å®¢æˆ·ç«¯å‘½ä»¤å‰–æ"></a>11.7 å®¢æˆ·ç«¯å‘½ä»¤å‰–æ</h2><p>fabric-ca-clientå‘½ä»¤å¯ä»¥è·ŸæœåŠ¡ç«¯è¿›è¡Œäº¤äº’ï¼Œä¸»è¦åŠŸèƒ½å¦‚ä¸‹ï¼š</p><ul><li>enrollï¼šç™»é™†è·å–ECert</li><li>getcacertï¼šè·å–CAæœåŠ¡çš„è¯ä¹¦é“¾</li><li>reenrollï¼šå†æ¬¡ç™»é™†</li><li>registerï¼šæ³¨å†Œç”¨æˆ·å®ä½“</li><li>revokeï¼šåŠé”€ç­¾å‘çš„å®ä½“è¯ä¹¦</li></ul><h3 id="11-7-1-å…¨å±€å‘½ä»¤å‚æ•°"><a href="#11-7-1-å…¨å±€å‘½ä»¤å‚æ•°" class="headerlink" title="11.7.1 å…¨å±€å‘½ä»¤å‚æ•°"></a>11.7.1 å…¨å±€å‘½ä»¤å‚æ•°</h3><ol><li><p>é€šç”¨å‚æ•°<br><img src="https://img-blog.csdnimg.cn/4eee18cbd50240e1a6470fc39b32116c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>è¯ä¹¦ç­¾åè¯·æ±‚å‚æ•°</p></li></ol><p><img src="https://img-blog.csdnimg.cn/ab42cc36468241dba8d999a52c41c210.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><ol start="3"><li>ç™»è®°ç›¸å…³å‚æ•°<br><img src="https://img-blog.csdnimg.cn/b99ecbab7c174619a1f3d74bb51515be.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></li><li>èº«ä»½å®ä½“ç›¸å…³å‚æ•°<br><img src="https://img-blog.csdnimg.cn/8aace32f85084e83a30989546a0d80c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></li><li>åŠé”€è¯ä¹¦ç›¸å…³å‚æ•°<br><img src="https://img-blog.csdnimg.cn/c200513ee89d42948556a5c8fc5e7a0c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></li><li>TLSç›¸å…³å‚æ•°<br><img src="https://img-blog.csdnimg.cn/0ccc5b4916714fb99d4f084a20eda7bf.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"><h3 id="11-7-2-enrollå‘½ä»¤"><a href="#11-7-2-enrollå‘½ä»¤" class="headerlink" title="11.7.2 enrollå‘½ä»¤"></a>11.7.2 enrollå‘½ä»¤</h3></li></ol><p>å‘½ä»¤æ ¼å¼ä¸ºï¼š<code>fabric-ca-client enrool -u http://user:userpw@serverAddr.serverPort</code>ã€‚è¯¥å‘½ä»¤ä¼šå‘æœåŠ¡å™¨ç”³è¯·ç­¾å‘ECertè¯ä¹¦ã€‚</p><h3 id="11-7-3-getcacertå‘½ä»¤"><a href="#11-7-3-getcacertå‘½ä»¤" class="headerlink" title="11.7.3 getcacertå‘½ä»¤"></a>11.7.3 getcacertå‘½ä»¤</h3><p>æƒ³æœåŠ¡ç«¯ç”³è¯·æ ¹è¯ä¹¦ä¿¡æ¯</p><h3 id="11-7-4-reenrollå‘½ä»¤"><a href="#11-7-4-reenrollå‘½ä»¤" class="headerlink" title="11.7.4 reenrollå‘½ä»¤"></a>11.7.4 reenrollå‘½ä»¤</h3><p>ç”Ÿæˆæ–°çš„ç­¾åè¯ä¹¦ææ–™</p><h3 id="11-7-5-registerå‘½ä»¤"><a href="#11-7-5-registerå‘½ä»¤" class="headerlink" title="11.7.5 registerå‘½ä»¤"></a>11.7.5 registerå‘½ä»¤</h3><p>æ³¨å†Œæ–°çš„ç”¨æˆ·å®ä½“èº«ä»½</p><h3 id="11-7-6-revokeå‘½ä»¤"><a href="#11-7-6-revokeå‘½ä»¤" class="headerlink" title="11.7.6 revokeå‘½ä»¤"></a>11.7.6 revokeå‘½ä»¤</h3><p>åŠé”€æŒ‡å®šçš„è¯ä¹¦æˆ–è€…æŒ‡å®šå®ä½“ç›¸å…³çš„æ‰€æœ‰çš„è¯ä¹¦</p><h2 id="11-8-å®¢æˆ·ç«¯é…ç½®æ–‡ä»¶è§£æ"><a href="#11-8-å®¢æˆ·ç«¯é…ç½®æ–‡ä»¶è§£æ" class="headerlink" title="11.8 å®¢æˆ·ç«¯é…ç½®æ–‡ä»¶è§£æ"></a>11.8 å®¢æˆ·ç«¯é…ç½®æ–‡ä»¶è§£æ</h2><ol><li><p>é€šç”¨é…ç½®<br><img src="https://img-blog.csdnimg.cn/6f2976a99c6d4e4797fe4d8dbee5491a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>TLSé…ç½®<br><img src="https://img-blog.csdnimg.cn/21baf3eab22447cca6581cbba1be4d8b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>è¯ä¹¦ç­¾åç”³è¯·é…ç½®<br>å®¢æˆ·ç«¯æƒ³è¦ç”³è¯·ä¸€ä¸ªECertæ—¶ï¼Œéœ€è¦æä¾›è¯ä¹¦ç­¾åç”³è¯·æ–‡ä»¶ï¼ˆCSRï¼‰ç›¸å…³çš„ä¿¡æ¯<br><img src="https://img-blog.csdnimg.cn/633022e95b7140f1aeacb90a901ee7af.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>æ³¨å†Œç®¡ç†é…ç½®<br><img src="https://img-blog.csdnimg.cn/3c19735238e74a97855c28e462437994.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>ç™»è®°é…ç½®<br><img src="https://img-blog.csdnimg.cn/d8e0eda7b98d41bdac2fc78ac2423c13.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>BCCSPé…ç½®<br><img src="https://img-blog.csdnimg.cn/f1aed0c548c444899afef3cc821a28c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_17,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h2 id="11-9-ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²"><a href="#11-9-ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²" class="headerlink" title="11.9 ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²"></a>11.9 ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²</h2></li><li><p>æ ¹è¯ä¹¦çš„ç”Ÿæˆ<br><img src="https://img-blog.csdnimg.cn/a450542e7d5140ebb99e551c3bcacf58.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>åˆ†å±‚éƒ¨ç½²ç»“æ„<br>PKIæ¨èé‡‡ç”¨åˆ†å±‚çš„ç»“æ„ï¼Œå³ä¸ç”±æ ¹CAæ¥ç›´æ¥ç­¾å‘è¯ä¹¦ï¼Œè€Œæ˜¯é€šè¿‡ç”±æ ¹CAç­¾å‘çš„ä¸­é—´CAç”šè‡³æ›´ä¸‹å±‚CAæ¥å®ç°å¯¹æœåŠ¡å™¨å®ä½“å’Œç”¨æˆ·è¯ä¹¦çš„ç®¡ç†ã€‚<br><img src="https://img-blog.csdnimg.cn/e8990f51f1e34fc49822fd36bf77c765.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>TLSæœºåˆ¶<br><img src="https://img-blog.csdnimg.cn/1953c78b88f640e2a2980dae3612bfaa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li><li><p>è´Ÿè½½å‡è¡¡å’Œé«˜å¯ç”¨<br><img src="https://img-blog.csdnimg.cn/ed38164183bf471090acd45d1a50199b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"><br><img src="https://img-blog.csdnimg.cn/94883dcb5f964e2e90bfd221c812791e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p></li></ol><h1 id="å‚è€ƒï¼š"><a href="#å‚è€ƒï¼š" class="headerlink" title="å‚è€ƒï¼š"></a>å‚è€ƒï¼š</h1><ul><li><a href="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/identity/identity.html">Fabric CAå®˜æ–¹ä»‹ç»</a></li><li>ã€ŠåŒºå—é“¾åŸç†ã€è®¾è®¡ä¸åº”ç”¨-æ¨ä¿åã€é™ˆæ˜Œã€‹</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric1.0æ¶æ„ä¸è®¾è®¡</title>
      <link href="/2021/09/24/blockchain/fabric/%E7%AC%AC12%E7%AB%A0-Fabric1-0%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/24/blockchain/fabric/%E7%AC%AC12%E7%AB%A0-Fabric1-0%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Fabric1-0æ¶æ„ä¸è®¾è®¡"><a href="#Fabric1-0æ¶æ„ä¸è®¾è®¡" class="headerlink" title="Fabric1.0æ¶æ„ä¸è®¾è®¡"></a>Fabric1.0æ¶æ„ä¸è®¾è®¡</h1><h2 id="12-1-æ•´ç†æ¶æ„æ¦‚è§ˆ"><a href="#12-1-æ•´ç†æ¶æ„æ¦‚è§ˆ" class="headerlink" title="12.1 æ•´ç†æ¶æ„æ¦‚è§ˆ"></a>12.1 æ•´ç†æ¶æ„æ¦‚è§ˆ</h2><h3 id="12-1-1-æ ¸å¿ƒç‰¹æ€§"><a href="#12-1-1-æ ¸å¿ƒç‰¹æ€§" class="headerlink" title="12.1.1 æ ¸å¿ƒç‰¹æ€§"></a>12.1.1 æ ¸å¿ƒç‰¹æ€§</h3><ul><li>æ¶ˆé™¤ç½‘ç»œå¤„ç†ç“¶é¢ˆï¼Œæé«˜å¯æ‰©å±•æ€§ï¼šè§£è€¦äº†åŸå­æ’åºç¯èŠ‚ä¸å…¶ä»–å¤æ‚å¤„ç†ç¯èŠ‚</li><li>æ ¹æ®è´Ÿè½½è¿›è¡Œçµæ´»éƒ¨ç½²ï¼šè§£è—•äº¤æ˜“å¤„ç†èŠ‚ç‚¹çš„é€»è¾‘è§’è‰²ä¸ºèƒŒä¹¦èŠ‚ç‚¹ï¼ˆEndorserï¼‰ã€ç¡®è®¤èŠ‚ç‚¹ï¼ˆCommotterï¼‰</li><li>æä¾›æ›´å¤šåŠŸèƒ½ï¼šåŠ å¼ºäº†èº«ä»½è¯ä¹¦ç®¡ç†æœåŠ¡ï¼Œä½œä¸ºå•ç‹¬çš„Fabric CAé¡¹ç›®</li><li>æäº¤éš”ç¦»å®‰å…¨æ€§ï¼šæ”¯æŒå¤šé€šé“ç‰¹æ€§ï¼Œä¸åŒé€šé“ä¹‹é—´çš„æ•°æ®å½¼æ­¤éš”ç¦»</li><li>æ”¯æŒå¯æ’æ‹”çš„æ¶æ„ï¼ŒåŒ…æ‹¬å…±è¯†ã€æƒé™ç®¡ç†ã€åŠ è§£å¯†ã€è´¦æœ¬æœºåˆ¶ç­‰æ¨¡å—ï¼Œæ”¯æŒå¤šç§ç±»å‹</li><li>æ”¯æŒå¯ç¼–ç¨‹å’Œç¬¬ä¸‰æ–¹å®ç°ï¼šå¼•å…¥ç³»ç»Ÿé“¾ç æ¥å®ç°åŒºå—é“¾ç³»ç»Ÿçš„å¤„ç†</li></ul><h3 id="12-1-2-æ•´ä½“æ¶æ„"><a href="#12-1-2-æ•´ä½“æ¶æ„" class="headerlink" title="12.1.2 æ•´ä½“æ¶æ„"></a>12.1.2 æ•´ä½“æ¶æ„</h3><p><img src="https://img-blog.csdnimg.cn/b05b1fe7b97344f8b0d5ee3edab23675.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_10,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="12-1-3-å…¸å‹å·¥ä½œæµç¨‹"><a href="#12-1-3-å…¸å‹å·¥ä½œæµç¨‹" class="headerlink" title="12.1.3 å…¸å‹å·¥ä½œæµç¨‹"></a>12.1.3 å…¸å‹å·¥ä½œæµç¨‹</h3><p>äº¤æ˜“å¤„ç†è¿‡ç¨‹ï¼š</p><p><img src="/images/fabric/image-20220307194816235.png" alt="image-20220307194816235"></p><p>å„ä¸ªç»„ä»¶åŠŸèƒ½ï¼š</p><ol><li>å®¢æˆ·ç«¯ï¼ˆAPPï¼‰</li></ol><p>å®¢æˆ·ç«¯ä½¿ç”¨SDKä¸Fabricç½‘ç»œäº¤äº’ã€‚</p><p>æ­¥éª¤ï¼š</p><ul><li>å®¢æˆ·ç«¯ä»CAè·å–åˆæ³•çš„èº«ä»½è¯ä¹¦æ¥åŠ å…¥ç½‘ç»œå†…çš„åº”ç”¨é€šé“</li><li>æ„é€ äº¤æ˜“ææ¡ˆï¼ˆProposalï¼‰æäº¤ç»™Endorserè¿›è¡ŒèƒŒä¹¦</li><li>å®¢æˆ·ç«¯æ”¶åˆ°è¶³å¤Ÿï¼ˆèƒŒä¹¦ç­–ç•¥å†³å®šï¼‰çš„èƒŒä¹¦æ”¯æŒåå¯ä»¥åˆ©ç”¨èƒŒä¹¦æ„é€ ä¸€ä¸ªåˆæ³•çš„äº¤æ˜“è¯·æ±‚</li><li>å‘ç»™Ordererè¿›è¡Œæ’åºå¤„ç†</li></ul><ol start="2"><li>EndorserèŠ‚ç‚¹</li></ol><p>ä¸»è¦æä¾›ProcessProposalæ–¹æ³•ä¾›å®¢æˆ·ç«¯è°ƒç”¨ï¼Œå®Œæˆå¯¹ç„¦ä¸€å¤©çš„èƒŒä¹¦ï¼ˆç›®å‰ä¸»è¦æ˜¯ç­¾åï¼‰å¤„ç†ï¼Œåªæœ‰éƒ¨åˆ†èŠ‚ç‚¹æ‹…ä»»Endorserè§’è‰²</p><p>æ­¥éª¤ï¼š</p><ul><li>æ”¶åˆ°å®¢æˆ·ç«¯çš„äº¤æ˜“ææ¡ˆ</li><li>è¿›è¡Œåˆæ³•æ€§å’ŒACLæƒé™æ£€æŸ¥</li><li>æ¨¡æ‹Ÿè¿è¡Œäº¤æ˜“ï¼Œå¯¹äº¤æ˜“å¯¼è‡´çš„çŠ¶æ€å˜åŒ–è¿›è¡ŒèƒŒä¹¦å¹¶è¿”å›ç»“æœç»™å®¢æˆ·ç«¯</li></ul><ol start="3"><li>CommitterèŠ‚ç‚¹</li></ol><p>è´Ÿè´£ç»´æŠ¤åŒºå—é“¾å’Œè´¦æœ¬ç»“æ„ï¼ˆåŒ…æ‹¬DBã€å†å²DBã€ç´¢å¼•DBç­‰ï¼‰ï¼ŒåŒä¸€ç‰©ç†èŠ‚ç‚¹å¯ä»¥ä»…ä½œä¸ºCommitterè§’è‰²è¿è¡Œä¹Ÿå¯ä»¥åŒæ—¶æ‹…ä»»Endorserå’ŒCommitterè¿™ä¸¤ç§è§’è‰²</p><p>æ­¥éª¤ï¼š</p><ul><li>å®šæœŸä»Ordererè·å–æ’åºåçš„æ‰¹é‡äº¤æ˜“åŒºå—ç»“æ„ï¼Œå¯¹è¿™äº›äº¤æ˜“è¿›è¡Œè½ç›˜å‰çš„æœ€ç»ˆæ£€æŸ¥ï¼ˆåŒ…æ‹¬äº¤æ˜“æ¶ˆæ¯ç»“æ„ã€ç­¾åå®Œæ•´æ€§ã€æ˜¯å¦é‡å¤ã€è¯»å†™é›†åˆç‰ˆæœ¬æ˜¯å¦åŒ¹é…ç­‰ï¼‰</li><li>å°†ç»“æœå†™å…¥è´¦æœ¬ï¼ŒåŒæ—¶æ„é€ æ–°çš„åŒºå—ã€æ›´æ–°åŒºå—ä¸­BlockMetadata[2]è®°å½•äº¤æ˜“æ˜¯å¦åˆæ³•ç­‰ä¿¡æ¯</li></ul><ol start="4"><li>Orderer</li></ol><p>ä»…è´Ÿè´£æ’åºã€‚ä¸ºç½‘ç»œä¸­æ‰€æœ‰åˆæ³•äº¤æ˜“è¿›è¡Œå…¨å±€æ’åºï¼Œå¹¶å°†ä¸€æ‰¹æ’åºåçš„äº¤æ˜“ç»„åˆæˆåŒºå—ç»“æ„</p><ol start="5"><li>CA</li></ol><p>è´Ÿè´£ç½‘ç»œä¸­æ‰€æœ‰è¯ä¹¦çš„ç®¡ç†ï¼ˆåˆ†å‘ã€æ’¤é”€ç­‰ï¼‰ï¼Œå®ç°æ ‡å‡†çš„PKIæ¶æ„</p><h2 id="12-2-æ ¸å¿ƒæ¦‚å¿µä¸ç»„ä»¶"><a href="#12-2-æ ¸å¿ƒæ¦‚å¿µä¸ç»„ä»¶" class="headerlink" title="12.2 æ ¸å¿ƒæ¦‚å¿µä¸ç»„ä»¶"></a>12.2 æ ¸å¿ƒæ¦‚å¿µä¸ç»„ä»¶</h2><p><img src="https://img-blog.csdnimg.cn/069a68e6f29a42f48f64ce967a44c933.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_13,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><ol><li>ç½‘ç»œå±‚</li></ol><ul><li>é¢å‘ï¼šç³»ç»Ÿç®¡ç†äººå‘˜</li><li>åŠŸèƒ½ï¼šå®ç°P2Pç½‘ç»œï¼Œæä¾›åº•å±‚æ„å»ºåŒºå—é“¾ç½‘ç»œçš„åŸºæœ¬èƒ½åŠ›ï¼ŒåŒ…æ‹¬ä»£è¡¨ä¸åŒè§’è‰²çš„èŠ‚ç‚¹å’ŒæœåŠ¡</li></ul><ol start="2"><li>å…±è¯†æœºåˆ¶å’Œæƒé™ç®¡ç†</li></ol><ul><li>é¢å‘ï¼šè”ç›Ÿå’Œç»„ç»‡çš„ç®¡ç†äººå‘˜</li><li>åŠŸèƒ½ï¼šåŸºäºç½‘ç»œå±‚çš„è¿é€šï¼Œå®ç°å…±è¯†æœºåˆ¶å’Œæƒé™ç®¡ç†ï¼Œæä¾›åˆ†å¸ƒå¼è´¦æœ¬çš„åŸºç¡€</li></ul><ol start="3"><li>ä¸šåŠ¡å±‚</li></ol><ul><li>é¢å‘ï¼šä¸šåŠ¡åº”ç”¨å¼€å‘äººå‘˜</li><li>åŠŸèƒ½ï¼šåŸºäºåˆ†å¸ƒå¼è´¦æœ¬ï¼Œæ”¯æŒé“¾ç ã€äº¤æ˜“ç­‰è·Ÿä¸šåŠ¡ç›¸å…³çš„åŠŸèƒ½æ¨¡å—ï¼Œæä¾›æ›´é«˜ä¸€å±‚çš„åº”ç”¨å¼€å‘æ”¯æŒ</li></ul><h3 id="12-2-1-ç½‘ç»œå±‚ç›¸å…³ç»„ä»¶"><a href="#12-2-1-ç½‘ç»œå±‚ç›¸å…³ç»„ä»¶" class="headerlink" title="12.2.1 ç½‘ç»œå±‚ç›¸å…³ç»„ä»¶"></a>12.2.1 ç½‘ç»œå±‚ç›¸å…³ç»„ä»¶</h3><ol><li>èŠ‚ç‚¹</li></ol><ul><li>Endorserï¼ˆèƒŒä¹¦èŠ‚ç‚¹ï¼‰ï¼šè´Ÿè´£å¯¹æ¥è‡ªå®¢æˆ·ç«¯çš„äº¤æ˜“è¿›è¡Œæ£€æŸ¥å’ŒèƒŒä¹¦</li><li>Committerï¼ˆç¡®è®¤èŠ‚ç‚¹ï¼‰ï¼šè´Ÿè´£æ£€æŸ¥äº¤æ˜“è¯·æ±‚ï¼Œæ‰§è¡Œäº¤æ˜“å¹¶ç»´æŠ¤åŒºå—é“¾å’Œè´¦æœ¬ç»“æ„</li><li>Submitterï¼ˆæäº¤èŠ‚ç‚¹ï¼‰ï¼šè´Ÿè´£æ¥æ”¶äº¤æ˜“ï¼Œè½¬å‘ç»™æ’åºè€…</li></ul><ol start="2"><li>æ’åºè€…</li></ol><p>æ’åºè€…ï¼ˆOrdererï¼‰ä¹Ÿç§°ä¸ºæ’åºèŠ‚ç‚¹ï¼Œè´Ÿè´£å¯¹æ‰€æ”¶åˆ°çš„äº¤æ˜“åœ¨ç½‘ç»œä¸­è¿›è¡Œå…¨å±€æ’åº</p><ol start="3"><li>å®¢æˆ·ç«¯</li></ol><p>å®¢æˆ·ç«¯æ˜¯ç”¨æˆ·å’Œåº”ç”¨è·ŸåŒºå—é“¾ç½‘ç»œæ‰“äº¤é“çš„æ¡¥æ¢</p><p>åŠŸèƒ½ï¼š</p><ul><li>æ“ä½œFabricç½‘ç»œ</li><li>æ“ä½œè¿è¡Œåœ¨ç½‘ç»œä¸­çš„é“¾ç </li></ul><ol start="4"><li>æˆå‘˜èº«ä»½ç®¡ç†</li></ol><p>CAèŠ‚ç‚¹ï¼ˆFabric-CAï¼‰è´Ÿè´£å¯¹Fabricç½‘ç»œä¸­çš„æˆå‘˜èº«ä»½è¿›è¡Œç®¡ç†</p><p>Fabricç½‘ç»œç›®å‰é‡‡ç”¨æ•°å­—è¯ä¹¦æœºåˆ¶æ¥å®ç°å¯¹èº«ä»½çš„é‰´åˆ«å’Œæƒé™æ§åˆ¶ï¼ŒCAèŠ‚ç‚¹åˆ™å®ç°äº†PKIæœåŠ¡ï¼Œä¸»è¦è´Ÿè´£å¯¹èº«ä»½è¯ä¹¦è¿›è¡Œç®¡ç†ï¼ŒåŒ…æ‹¬ç”Ÿæˆã€æ’¤é”€ç­‰</p><ol start="5"><li>Gossipåè®®</li></ol><p>Fabricç½‘ç»œä¸­çš„èŠ‚ç‚¹ä¹‹é—´é€šè¿‡Gossipåè®®æ¥è¿›è¡ŒçŠ¶æ€åŒæ­¥å’Œæ•°æ®åˆ†å‘</p><p>åŸºæœ¬æ€æƒ³ï¼šæ•°æ®å‘é€æ–¹ä»ç½‘ç»œä¸­éšæœºé€‰å–è‹¥å¹²èŠ‚ç‚¹ï¼Œå°†æ•°æ®å‘é€è¿‡å»ï¼›æ¥å—æ–¹é‡å¤è¿™ä¸€è¿‡ç¨‹ï¼ˆå¾€å¾€åªé€‰æ‹©å‘é€æ–¹ä¹‹å¤–çš„èŠ‚ç‚¹è¿›è¡Œä¼ æ’­ï¼‰ã€‚æ•°æ®ä¼ è¾“æ–¹å‘å¯ä»¥æ˜¯å‘é€æ–¹å‘é€æˆ–è·å–æ–¹æ‹‰å–</p><h3 id="12-2-2-å…±è¯†ç›¸å…³ç»„ä»¶"><a href="#12-2-2-å…±è¯†ç›¸å…³ç»„ä»¶" class="headerlink" title="12.2.2 å…±è¯†ç›¸å…³ç»„ä»¶"></a>12.2.2 å…±è¯†ç›¸å…³ç»„ä»¶</h3><ol><li>èƒŒä¹¦è¿‡ç¨‹</li></ol><p>èƒŒä¹¦ï¼šèƒŒä¹¦èŠ‚ç‚¹å¯¹æ”¶åˆ°çš„æ¥è‡ªå®¢æˆ·ç«¯çš„è¯·æ±‚ï¼ˆäº¤æ˜“ææ¡ˆï¼‰æŒ‰ç…§è‡ªèº«åˆ†é€»è¾‘è¿›è¡Œé‡‘å‰ï¼Œä¸€å†³ç­–æ˜¯å¦ç»™äºˆæ”¯æŒçš„è¿‡ç¨‹</p><ol start="2"><li>æ’åºæœåŠ¡</li></ol><p>æ’åºæœåŠ¡é€šå¸¸æ˜¯ç”±æ’åºèŠ‚ç‚¹ç»„æˆçš„é›†ç¾¤æ¥æä¾›</p><p>æ’åºåŠŸèƒ½ï¼šå¯¹ä¸€æ®µæ—¶é—´å†…çš„ä¸€æ‰¹äº¤æ˜“è¾¾æˆä¸€ä¸ªç½‘ç»œå†…å…¨å±€ä¸€è‡´çš„é¡ºåº</p><ol start="3"><li>éªŒè¯è¿‡ç¨‹</li></ol><p>éªŒè¯æ˜¯å¯¹æ’åºåçš„ä¸€æ‰¹äº¤æ˜“è¿›è¡Œæäº¤åˆ°è´¦æœ¬ä¹‹å‰æœ€ç»ˆæ£€æŸ¥çš„è¿‡ç¨‹</p><p>éªŒè¯å†…å®¹ï¼š</p><ul><li>æ£€æŸ¥äº¤æ˜“ç»“æ„è‡ªèº«å®Œæ•´æ€§</li><li>æ£€æŸ¥äº¤æ˜“æ‰€å¸¦èƒŒä¹¦ç­¾åæ˜¯å¦æ»¡è¶³é¢„è®¾çš„èƒŒä¹¦ç­–ç•¥</li><li>äº¤æ˜“çš„è¯»å†™é›†æ˜¯å¦æ»¡è¶³å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶çš„ç›¸å…³è¦æ±‚</li><li>ç­‰</li></ul><h3 id="12-2-3-æƒé™ç®¡ç†ç›¸å…³ç»„ä»¶"><a href="#12-2-3-æƒé™ç®¡ç†ç›¸å…³ç»„ä»¶" class="headerlink" title="12.2.3 æƒé™ç®¡ç†ç›¸å…³ç»„ä»¶"></a>12.2.3 æƒé™ç®¡ç†ç›¸å…³ç»„ä»¶</h3><ol><li>æˆå‘˜æœåŠ¡æä¾›è€…ï¼ˆMembership Service Providerï¼ŒMSPï¼‰</li></ol><p>MSPï¼šæŠ½è±¡ä»£è¡¨äº†ä¸€ä¸ªèº«ä»½éªŒè¯çš„å®ä½“ï¼Œä»£è¡¨ç”¨äºå¯¹æŸä¸ªèµ„æºï¼ˆæˆå‘˜/èŠ‚ç‚¹/ç»„ç»‡ç­‰ï¼‰è¿›è¡Œèº«ä»½éªŒè¯çš„ä¸€ç»„æœºåˆ¶ï¼Œæ˜¯å®ç°æƒé™ç®¡ç†çš„åŸºç¡€</p><p>åŸºäºMSPå¯ä»¥å®ç°å¯¹ä¸åŒèµ„æºè¿›è¡ŒåŸºäºèº«ä»½è¯ä¹¦çš„æƒé™éªŒè¯ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œä¸€ä¸ªç»„ç»‡æˆ–è”ç›Ÿå¯ä»¥å¯¹åº”åˆ°ä¸€ä¸ªå±‚çº§åŒ–çš„MSP</p><ol start="2"><li>ç»„ç»‡</li></ol><p>ç»„ç»‡ä»£è¡¨ä¸€ç»„æ‹¥æœ‰å…±åŒä¿¡ä»»çš„æ ¹è¯ä¹¦ï¼ˆå¯ä»¥ä¸ºæ ¹CAè¯ä¹¦æˆ–ä¸­é—´CAè¯ä¹¦ï¼‰çš„æˆå‘˜</p><p>ç»„ç»‡ä¹‹é—´å¯ä»¥ç›¸äº’äº¤æ¢æ¯”è¾ƒæ•æ„Ÿçš„å†…å®¹</p><p>åŒä¸€ä¸ªç»„ç»‡çš„æˆå‘˜èŠ‚ç‚¹åœ¨ç½‘ç»œä¸­å¯ä»¥è¢«è®¤ä¸ºæ˜¯åŒä¸€ä¸ªèº«ä»½ï¼Œä»£è¡¨ç»„ç»‡è¿›è¡Œç­¾å</p><p>ç»„ç»‡ä¸­çš„æˆå‘˜å¯ä»¥ä¸ºæ™®é€šæˆå‘˜è§’è‰²æˆ–è€…ç®¡ç†å‘˜è§’è‰²ï¼Œåè€…æ‹¥æœ‰æ›´å¥½çš„æƒé™ï¼Œå¯ä»¥å¯¹ç»„ç»‡é…ç½®è¿›è¡Œä¿®æ”¹</p><p>ç»„ç»‡ä¸­</p><ol start="3"><li>è”ç›Ÿ</li></ol><p>è”ç›Ÿç”±è‹¥å¹²ç»„ç»‡æ„æˆçš„é›†åˆï¼Œæ˜¯è”ç›Ÿè”åœºæ™¯æ‰€ç‹¬æœ‰çš„ç»“æ„å½¢å¼</p><p>è”ç›Ÿä¸€èˆ¬ç”¨äºå¤šä¸ªç»„ç»‡ç›¸äº’åˆä½œçš„åœºæ™¯ï¼Œä¾‹å¦‚æŸè”ç›Ÿä¸­æŒ‡å®šéœ€è¦æ‰€æœ‰å‚ä¸æ–¹åŒæ—¶å¯¹äº¤æ˜“èƒŒä¹¦ï¼Œæ‰å…è®¸åœ¨ç½‘ç»œä¸­æ‰§è¡Œæ‰§è¡Œ</p><ol start="4"><li>èº«ä»½è¯ä¹¦</li></ol><p>èº«ä»½è¯ä¹¦æ˜¯Fabricä¸­æƒé™ç®¡ç†çš„åŸºç¡€ï¼Œé‡‡ç”¨åŸºäºECDSAç®—æ³•çš„éå¯¹ç§°åŠ å¯†ç®—æ³•ç”Ÿæˆå…¬é’¥å’Œç§é’¥ï¼Œè¯ä¹¦æ ¼å¼åˆ™é‡‡ç”¨äº†X.509æ ‡å‡†è§„èŒƒ</p><h3 id="12-2-4-ä¸šåŠ¡å±‚ç›¸å…³ç»„ä»¶"><a href="#12-2-4-ä¸šåŠ¡å±‚ç›¸å…³ç»„ä»¶" class="headerlink" title="12.2.4 ä¸šåŠ¡å±‚ç›¸å…³ç»„ä»¶"></a>12.2.4 ä¸šåŠ¡å±‚ç›¸å…³ç»„ä»¶</h3><ol><li>äº¤æ˜“</li></ol><p>äº¤æ˜“æ„å‘³ç€é€šè¿‡è°ƒç”¨é“¾ç å®ç°å¯¹è´¦æœ¬çŠ¶æ€è¿›è¡Œä¸€æ¬¡æ”¹å˜</p><ol start="2"><li>åŒºå—</li></ol><p>åŒºå—æ„å‘³ç€ä¸€ç»„è¿›è¡Œæ’åºåçš„äº¤æ˜“çš„é›†åˆ</p><p>åŒºå—ç»“æ„åŒ…æ‹¬ï¼š</p><ul><li>åŒºå—å¤´ï¼šæ„å»ºåŒºå—ç»“æ„ï¼ŒåŒ…å«Numberï¼ˆåŒºå—åºå·ï¼‰ã€PreviousHashï¼ˆå‰ä¸€åŒºå—å¤´éƒ¨Hashï¼‰ã€DataHashï¼ˆæœ¬åŒºå—DataåŸŸå†…å®¹çš„Hashå€¼ï¼‰</li><li>æ•°æ®ï¼šä»¥Envelopeç»“æ„è®°å½•åŒºå—å†…çš„å¤šä¸ªäº¤æ˜“ä¿¡æ¯ï¼Œä½¿ç”¨Merkleæ ‘ç»“æ„</li><li>å…ƒæ•°æ®ï¼šè®°å½•è¾…åŠ©ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼šç­¾åä¿¡æ¯ã€é€šé“çš„æœ€æ–°é…ç½®åŒºå—çš„ç´¢å¼•ã€äº¤æ˜“æ˜¯å¦åˆæ³•æ ‡è®°ã€é€šé“çš„æ’åºæœåŠ¡ä¿¡æ¯</li></ul><ol start="3"><li>é“¾ç <br>é“¾ç æºè‡ªæ™ºèƒ½åˆçº¦çš„æ€æƒ³</li></ol><p>ç§ç±»ï¼š</p><ul><li>ç”¨æˆ·é“¾ç </li><li>ç³»ç»Ÿé“¾ç </li></ul><ol start="4"><li>é€šé“</li></ol><p>é€šé“ï¼Œç‹­ä¹‰åœ°è®²ï¼Œæ˜¯æ’åºæœåŠ¡ä¸Šåˆ’åˆ†çš„å½¼æ­¤éš”ç¦»çš„åŸå­å¹¿æ’­æ¸ é“ï¼Œç”±æ’åºæœåŠ¡è¿›è¡Œç®¡ç†</p><ol start="5"><li>é“¾ç»“æ„</li></ol><p>é“¾ç»“æ„å†…å®¹ï¼š</p><ul><li>æ‰€ç»‘å®šçš„é€šé“å†…çš„æ‰€æœ‰çš„äº¤æ˜“ä¿¡æ¯ï¼Œè¿™äº›äº¤æ˜“ä»¥åŒºå—å½¢å¼è¿›è¡Œå­˜æ”¾</li><li>é€šé“å†…æ‰€å®‰è£…å’Œå®ä¾‹åŒ–çš„é“¾ç çš„ç›¸å…³ä¿¡æ¯</li><li>å¯¹é“¾è¿›è¡Œæ“ä½œçš„æƒé™ç®¡ç†ï¼Œä»¥åŠå‚ä¸åˆ°é“¾ä¸Šçš„ç»„ç»‡æˆå‘˜</li></ul><ol start="6"><li>è´¦æœ¬</li></ol><p>è´¦æœ¬ä¸»è¦è´Ÿè´£è®°å½•å‘ç”Ÿåœ¨ç½‘ç»œä¸­çš„äº¤æ˜“ä¿¡æ¯ï¼Œè´¦æœ¬åŒ…æ‹¬åŒºå—é“¾ç»“æ„å’Œå¤šä¸ªæ•°æ®åº“ç»“æ„</p><p><img src="https://img-blog.csdnimg.cn/7046bcd0555f4b1c8b906124c1583c11.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><ul><li>State Databaseï¼šçŠ¶æ€æ•°æ®åº“ï¼Œç”±åŒºå—é“¾ç»“æ„ä¸­äº¤æ˜“æ‰§è¡Œæ¨æ¼”è€Œæˆï¼Œè®°å½•æœ€æ–°çš„ä¸–ç•ŒçŠ¶æ€</li><li>History Databaseï¼šå†å²æ•°æ®åº“ï¼Œå­˜æ”¾å„ä¸ªçŠ¶æ€çš„å†å²å˜åŒ–è®°å½•</li><li>Index Databaseï¼šç´¢å¼•æ•°æ®åº“ï¼Œå­˜æ”¾ç´¢å¼•ä¿¡æ¯</li></ul><h2 id="12-3-gRPCæ¶ˆæ¯åè®®ã€å¾…è¡¥å……ã€‘"><a href="#12-3-gRPCæ¶ˆæ¯åè®®ã€å¾…è¡¥å……ã€‘" class="headerlink" title="12.3 gRPCæ¶ˆæ¯åè®®ã€å¾…è¡¥å……ã€‘"></a>12.3 gRPCæ¶ˆæ¯åè®®ã€å¾…è¡¥å……ã€‘</h2><h2 id="12-4-æƒé™ç®¡ç†å’Œç­–ç•¥"><a href="#12-4-æƒé™ç®¡ç†å’Œç­–ç•¥" class="headerlink" title="12.4 æƒé™ç®¡ç†å’Œç­–ç•¥"></a>12.4 æƒé™ç®¡ç†å’Œç­–ç•¥</h2><h3 id="12-4-1-ç­–ç•¥åº”ç”¨åœºæ™¯"><a href="#12-4-1-ç­–ç•¥åº”ç”¨åœºæ™¯" class="headerlink" title="12.4.1 ç­–ç•¥åº”ç”¨åœºæ™¯"></a>12.4.1 ç­–ç•¥åº”ç”¨åœºæ™¯</h3><p><img src="https://img-blog.csdnimg.cn/d7491f1b67b64f7ca0061c1db13bc2fb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h3 id="12-4-2-èº«ä»½è¯ä¹¦"><a href="#12-4-2-èº«ä»½è¯ä¹¦" class="headerlink" title="12.4.2 èº«ä»½è¯ä¹¦"></a>12.4.2 èº«ä»½è¯ä¹¦</h3><ul><li>ç™»è®°è¯ä¹¦ï¼ˆECertï¼‰ï¼šé¢å‘ç»™æä¾›äº†æ³¨å†Œå‡­è¯çš„ç”¨æˆ·æˆ–èŠ‚ç‚¹ç­‰å®ä½“ï¼Œä¸€èˆ¬é•¿æœŸæœ‰æ•ˆ</li><li>äº¤æ˜“è¯ä¹¦ï¼ˆTCertï¼‰ï¼šåŠæ³•ç»™ç”¨æˆ·ï¼Œæ§åˆ¶æ¯ä¸ªäº¤æ˜“çš„æƒé™ï¼Œä¸€èˆ¬é’ˆå¯¹æŸä¸ªäº¤æ˜“ï¼ŒçŸ­æœŸæœ‰æ•ˆï¼›</li><li>é€šä¿¡è¯ä¹¦ï¼ˆTLSCertï¼‰ï¼šæ§åˆ¶å¯¹ç½‘ç»œå±‚çš„æ¥å…¥è®¿é—®ï¼Œå¯ä»¥å¯¹è¿œç«¯å®ä½“èº«ä»½è¿›è¡Œæ ¡éªŒï¼Œé˜²æ­¢çªƒå¬</li></ul><h3 id="12-4-3-æƒé™ç­–ç•¥çš„å®ç°"><a href="#12-4-3-æƒé™ç­–ç•¥çš„å®ç°" class="headerlink" title="12.4.3 æƒé™ç­–ç•¥çš„å®ç°"></a>12.4.3 æƒé™ç­–ç•¥çš„å®ç°</h3><p>åŠŸèƒ½ï¼šå¯¹é€šé“å†…æ•°æ®çš„å„ç§æ“ä½œæƒè¿›è¡Œç®¡ç†ã€‚åŒ…æ‹¬å¯¹è¯»èº«ä»½ï¼ˆä¾‹å¦‚è·å–é€šé“çš„äº¤æ˜“ã€åŒºå—ç­‰æ•°æ®ï¼‰ã€å†™èº«ä»½ï¼ˆä¾‹å¦‚å‘é€šé“å‘èµ·äº¤æ˜“ï¼‰ã€ç®¡ç†å‘˜èº«ä»½ï¼ˆä¾‹å¦‚åŠ å…¥é€šé“ã€ä¿®æ”¹é€šé“çš„é…ç½®ä¿¡æ¯ï¼‰ç­‰æƒé™è¿›è¡Œé™åˆ¶</p><ol><li>æ•°æ®ç»“æ„</li></ol><p>å®ç°ä¸Šï¼Œæ¯ç§ç­–ç•¥ç»“æ„éƒ½è¦å®ç°Evaluateæ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸­ä¼šå¯¹äºç»™å®šçš„ä¸€ç»„ç­¾åæ•°æ®æŒ‰ç…§ä¸€å®šè§„åˆ™å¯¹å®ƒä»¬è¿›è¡Œæ ¡éªŒï¼Œçœ‹æ˜¯å¦ç¬¦åˆçº¦å®šçš„æ¡ä»¶ï¼Œç¬¦åˆåˆ™è¯´æ˜æ»¡è¶³äº†è¯¥ç­–ç•¥</p><ol start="2"><li>SIGNATUREç­–ç•¥</li></ol><p>é€šè¿‡ç­¾åæ¥å¯¹æ•°æ®è¿›è¡Œè®¤è¯ï¼Œä¾‹å¦‚æ•°æ®å¿…é¡»æ»¡è¶³ä¸€å®šçš„ç­¾åèº«ä»½ç»„åˆ</p><p>SignaturePolicyç»“æ„ä½“ä»£è¡¨äº†ä¸€ä¸ªç­–ç•¥çš„å…·ä½“å†…å®¹ã€‚æ”¯æŒæŒ‡å®šæŸä¸ªç‰¹æ€§ç­¾åæˆ–è€…æ»¡è¶³ç»™å®šç­–ç•¥é›†åˆä¸­çš„è‹¥å¹²ä¸ªï¼ˆNOutOfï¼‰å³å¯ã€‚</p><p>SignaturePolicyEnvelopeç»“æ„ä½“ä»£è¡¨äº†ä¸€ä¸ªå®Œæ•´çš„ç­–ç•¥ï¼ŒåŒ…æ‹¬ç‰ˆæœ¬å·ã€ç­–ç•¥è§„åˆ™å’Œç­–ç•¥å…³è”çš„å®ä½“é›†åˆã€‚</p><ol start="3"><li>IMPLICIT_METAç­–ç•¥</li></ol><p>è¯¥ç­–ç•¥ä¸ç›´æ¥è¿›è¡Œç­¾åæ£€æŸ¥ï¼Œè€Œæ˜¯é€šè¿‡å¼•ç”¨å…¶å­å…ƒç´ çš„ç­–ç•¥ï¼ˆæœ€ç»ˆè¿˜æ˜¯é€šè¿‡SIGNATUREç­–ç•¥ï¼‰æ¥è¿›è¡Œæ£€æŸ¥ã€‚æ£€æŸ¥ç»“æœé€šè¿‡Ruleæ¥è¿›è¡Œé™åˆ¶ã€‚</p><h3 id="12-4-4-é€šé“ç­–ç•¥"><a href="#12-4-4-é€šé“ç­–ç•¥" class="headerlink" title="12.4.4 é€šé“ç­–ç•¥"></a>12.4.4 é€šé“ç­–ç•¥</h3><p>é€šé“ç­–ç•¥æ˜¯å±‚çº§åŒ–ç»“æ„ï¼Œæœ€ä¸Šå±‚ä¸º/Channelã€‚åœ¨æ¯ä¸€çº§åˆ«éƒ½å¯ä»¥æŒ‡å®šç­–ç•¥ï¼Œä½œä¸ºæœ¬å±‚çº§çš„é»˜è®¤ç­–ç•¥ã€‚</p><p><img src="https://img-blog.csdnimg.cn/fb8f53d53d93442bb99be2c966e8c128.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>æœªç»ä¿®æ”¹çš„æƒ…å†µä¸‹ï¼Œä¼šä¸ºé€šé“å†…å…ƒç´ é¢„å…ˆå®šä¹‰ä¸€äº›é»˜è®¤çš„ç­–ç•¥ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p><p><img src="https://img-blog.csdnimg.cn/ab4a0a6391d5405ea7eeecc9cc4f73c1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h3 id="12-4-5-èƒŒä¹¦ç­–ç•¥"><a href="#12-4-5-èƒŒä¹¦ç­–ç•¥" class="headerlink" title="12.4.5 èƒŒä¹¦ç­–ç•¥"></a>12.4.5 èƒŒä¹¦ç­–ç•¥</h3><p>ç”¨æˆ·åœ¨å®ä¾‹åŒ–é“¾ç ä½¿ï¼Œå¯ä»¥æŒ‡å®šèƒŒä¹¦ç­–ç•¥</p><p>èƒŒä¹¦ç­–ç•¥é‡‡ç”¨SignaturePolicyç»“æ„è¿›è¡ŒæŒ‡å®šï¼ŒåŒæ ·å¯ä»¥åŸºäºMSPPrincipalç»“æ„æ„å»ºä»»æ„å¤æ‚çš„ç­¾åæ ¡éªŒç»„åˆ</p><p>ä¸‹é¢çš„å‘½ä»¤æŒ‡å®šè¦ä¹ˆOrg1çš„ç®¡ç†å‘˜è¿›è¡ŒèƒŒä¹¦ï¼Œæˆ–è€…Org2å’ŒOrg3çš„æˆå‘˜åŒæ—¶è¿›è¡ŒèƒŒä¹¦æ‰æ»¡è¶³èƒŒä¹¦ç­–ç•¥ï¼š<br><img src="https://img-blog.csdnimg.cn/54576b21b6bd4f499ae6ca0f358ea0c4.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h3 id="12-4-6-å®ä¾‹åŒ–ç­–ç•¥"><a href="#12-4-6-å®ä¾‹åŒ–ç­–ç•¥" class="headerlink" title="12.4.6 å®ä¾‹åŒ–ç­–ç•¥"></a>12.4.6 å®ä¾‹åŒ–ç­–ç•¥</h3><p>å®ä¾‹åŒ–ç­–ç•¥ä¸€èˆ¬ç”¨äºæœ€ç»ˆç¡®è®¤é˜¶æ®µï¼ŒCommitteråˆ©ç”¨VSCCå¯¹ç½‘ç»œä¸­è¿›è¡Œé“¾ç éƒ¨ç½²çš„cao zuoæ“ä½œè¿›è¡Œæƒé™æ£€æŸ¥</p><p>å®ä¾‹åŒ–ç­–ç•¥é‡‡ç”¨SignaturePolicyç»“æ„è¿›è¡ŒæŒ‡å®šï¼Œå¯ä»¥ç»™äºˆMSTPPrincipalç»“æ„æ„å»ºä»»æ„å¤æ‚çš„ç­¾åæ ¡éªŒç»„åˆ</p><p>é»˜è®¤æƒ…å†µä¸‹ï¼Œä¼šä»¥å½“å‰MSPçš„ç®¡ç†å‘˜èº«ä»½ä½œä¸ºé»˜è®¤çš„ç­–ç•¥ï¼Œè¿™å¯ä»¥é¿å…è„¸å—è¢«é€šé“ä¸­å…¶ä»–ç»„ç»‡æˆå‘˜ç§è‡ªåœ¨å…¶ä»–é€šé“å†…è¿›è¡Œå®ä¾‹åŒ–</p><h2 id="12-5-ç”¨æˆ·é“¾ç "><a href="#12-5-ç”¨æˆ·é“¾ç " class="headerlink" title="12.5 ç”¨æˆ·é“¾ç "></a>12.5 ç”¨æˆ·é“¾ç </h2><h3 id="12-5-1-åŸºæœ¬ç»“æ„"><a href="#12-5-1-åŸºæœ¬ç»“æ„" class="headerlink" title="12.5.1 åŸºæœ¬ç»“æ„"></a>12.5.1 åŸºæœ¬ç»“æ„</h3><p>é“¾ç çš„å…¸å‹ç»“æ„ï¼š</p><p><img src="https://img-blog.csdnimg.cn/1312f1b5804645f2a4534ffa4eafdca7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>ç”¨æˆ·åªéœ€è¦å…³æ³¨åˆ°Init()å’ŒInvoke()å‡½æ•°çš„è§†çº¿ï¼Œå…¶ä¸­åˆ©ç”¨shim.ChaincodeStubInterfaceç»“æ„å®ç°è·Ÿè´¦æœ¬çš„äº¤äº’é€»è¾‘</p><p>ç”¨æˆ·é“¾ç æ”¯æŒinstallã€instantiateã€invokeã€queryã€upgradeã€packageã€signpackageç­‰æ“ä½œï¼Œå…¶ç”Ÿå‘½å‘¨æœŸè¢«ç”Ÿå‘½å‘¨æœŸç®¡ç†ç³»ç»Ÿé“¾ç ï¼ˆLSCCï¼‰è¿›è¡Œç®¡ç†</p><h3 id="12-5-2-é“¾ç ä¸Peerçš„äº¤äº’è¿‡ç¨‹"><a href="#12-5-2-é“¾ç ä¸Peerçš„äº¤äº’è¿‡ç¨‹" class="headerlink" title="12.5.2 é“¾ç ä¸Peerçš„äº¤äº’è¿‡ç¨‹"></a>12.5.2 é“¾ç ä¸Peerçš„äº¤äº’è¿‡ç¨‹</h3><p><img src="https://img-blog.csdnimg.cn/5859c9af4dac47d29d0fb51746ee4742.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><ul><li>Typeï¼šæ¶ˆæ¯çš„ç±»å‹</li><li>TxIdï¼šå…³è”çš„äº¤æ˜“ID</li><li>Payloadï¼šå­˜å‚¨æ¶ˆæ¯å†…å®¹</li></ul><p>äº¤äº’è¿‡ç¨‹ï¼š<br><img src="https://img-blog.csdnimg.cn/a9909a44a56e4a9cba4fa7890df883fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><ul><li>ç”¨æˆ·é“¾ç è°ƒç”¨shim.Start()æ–¹æ³•åï¼Œé¦–å…ˆå‘Peerå‘é€<code>ChaincodeMessage_REGISTER</code>æ¶ˆæ¯å°è¯•è¿›è¡Œæ³¨å†Œã€‚ä¹‹åå¼€å§‹ç­‰å¾…æ¥æ”¶æ¥è‡ªPeerçš„æ¶ˆæ¯ã€‚æ­¤æ—¶çŠ¶æ€ä¸ºå‡ºäº‹çš„created</li><li>Peeræ”¶åˆ°æ¥è‡ªé“¾ç å®¹å™¨çš„<code>ChaincodeMessage_REGISTER</code>æ¶ˆæ¯ï¼Œæ³¨å†Œåˆ°æœ¬åœ°çš„ä¸€ä¸ªhandlerç»“æ„ï¼Œè¿”å›<code>ChaincodeMessage_REGISTERED</code>æ¶ˆæ¯ç»™é“¾ç å®¹å™¨ï¼Œæ›´æ–°çŠ¶æ€ä¸ºestablishedï¼Œä¹‹åè‡ªåŠ¨å‘å‡º<code>ChaincodeMessage_READY</code>æ¶ˆæ¯ç»™é“¾ç å®¹å™¨ï¼Œæ›´æ–°çŠ¶æ€ä¸ºready</li><li>é“¾ç ä¾§æ”¶åˆ°<code>ChaincodeMessage_REGISTERED</code>æ¶ˆæ¯åï¼Œä¸è¿›è¡Œä»»ä½•æ“ä½œï¼Œæ³¨å†ŒæˆåŠŸã€‚æ›´æ–°çŠ¶æ€ä¸ºestabliedã€‚æ”¶åˆ°<code>ChaincodeMessage_READY</code>æ¶ˆæ¯åæ›´æ–°çŠ¶æ€ä¸ºready</li><li>Peerä¾§å‘å‡º<code>ChaincodeMessage_INIT</code>æ¶ˆæ¯ç»™é“¾ç å®¹å™¨ï¼Œå¯¹é“¾ç è¿›è¡Œåˆå§‹åŒ–</li><li>é“¾ç å®¹å™¨æ”¶åˆ°<code>ChaincodeMessage_INIT</code>æ¶ˆæ¯ï¼Œè°ƒç”¨ç”¨æˆ·é“¾ç ä»£ç Init()æ–¹æ³•è¿›è¡Œåˆå§‹åŒ–ï¼ŒæˆåŠŸåè¿”å›<code>ChaincodeMessage_COMPLETED</code>æ¶ˆæ¯ï¼Œæ­¤æ—¶é“¾ç å®¹å™¨å¯ä»¥è¢«è°ƒç”¨äº†</li><li>é“¾ç è¢«è°ƒç”¨æ—¶ï¼ŒPeerå‘å‡º<code>ChaincodeMessage_TRANSACTION</code>æ¶ˆæ¯ç»™é“¾ç </li><li>é“¾ç æ”¶åˆ°<code>ChaincodeMessage_TRANSACTION</code>æ¶ˆæ¯ï¼Œä¼šè°ƒç”¨Invoke()æ–¹æ³•ã€‚æ ¹æ®Invoke()æ–¹æ³•ä¸­ç”¨æˆ·å®ç°çš„é€»è¾‘å‘é€æ¶ˆæ¯ã€‚Peerä¾§æ”¶åˆ°è¿™äº›æ¶ˆæ¯ï¼Œè¿›è¡Œç›¸åº”å¤„ç†ï¼Œå¹¶å›å¤<code>ChaincodeMessage_RESPONSE</code>æ¶ˆæ¯ï¼Œæœ€åé“¾ç ä¾§ä¼šå›å¤è°ƒç”¨å®Œæˆçš„æ¶ˆæ¯<code>ChaincodeMessage_COMPLETE</code>ç»™Peerä¾§</li></ul><p>ä¸Šè¿°è¿‡ç¨‹ä¸­ï¼ŒPeerå’Œé“¾ç ä¾§ä¼šå®šæœŸçš„å‘é€<code>ChaincodeMessage_KEEPALIVE</code>æ¶ˆæ¯ç»™å¯¹æ–¹ï¼Œä»¥ç¡®ä¿å½¼æ­¤åœ¨çº¿</p><h3 id="12-5-3-é“¾ç å¤„ç†çŠ¶æ€æœº"><a href="#12-5-3-é“¾ç å¤„ç†çŠ¶æ€æœº" class="headerlink" title="12.5.3 é“¾ç å¤„ç†çŠ¶æ€æœº"></a>12.5.3 é“¾ç å¤„ç†çŠ¶æ€æœº</h3><p><img src="https://img-blog.csdnimg.cn/93a115e4e5c84464b0dbca6c18a5ecbe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_18,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h3 id="12-6-ç³»ç»Ÿé“¾ç "><a href="#12-6-ç³»ç»Ÿé“¾ç " class="headerlink" title="12.6 ç³»ç»Ÿé“¾ç "></a>12.6 ç³»ç»Ÿé“¾ç </h3><p>ç³»ç»Ÿé“¾ç è´Ÿè´£FabricèŠ‚ç‚¹è‡ªèº«çš„å¤„ç†é€»è¾‘ï¼ŒåŒ…æ‹¬ç³»ç»Ÿé…ç½®ã€èƒŒä¹¦ã€æ ¡éªŒç­‰å·¥ä½œ</p><p>ç±»å‹ï¼š</p><p><img src="https://img-blog.csdnimg.cn/ed6c8e03be1142d5bd37d2a2da50f85c.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"><br><img src="https://img-blog.csdnimg.cn/67644becc0894c9e9322b56981a2b27b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h4 id="1-é…ç½®ç³»ç»Ÿé“¾ç "><a href="#1-é…ç½®ç³»ç»Ÿé“¾ç " class="headerlink" title="1. é…ç½®ç³»ç»Ÿé“¾ç "></a>1. é…ç½®ç³»ç»Ÿé“¾ç </h4><p>Configuration System Chaincodeå³é…ç½®ç³»ç»Ÿé“¾ç ï¼Œæ˜¯è´Ÿè´£é…ç½®ç®¡ç†çš„ç³»ç»Ÿé“¾ç ï¼Œæ”¯æŒè¢«ä»é“¾å¤–è¿›è¡Œè°ƒç”¨ã€‚</p><p>CSCCæ”¯æŒå¦‚ä¸‹ç±»å‹Invokeæ–¹æ³•ï¼š</p><ul><li>JoinChainï¼šå½“æŸä¸ªèŠ‚ç‚¹ç”³è¯·åŠ å…¥æŸæ¡é€šé“æ—¶è¢«è°ƒç”¨ã€‚è´Ÿè´£è·Ÿæ ¹æ®ä¼ å…¥çš„åˆå§‹åŒºå—å‚æ•°ç”Ÿæˆæ‰€åŠ å…¥é€šé“çš„åˆ›ä¸–åŒºå—ï¼Œå¹¶å®Œæˆè´¦æœ¬ã€é€šé“ç›¸å…³æ•°æ®ç»“æ„çš„åˆå§‹åŒ–å·¥ä½œã€‚è°ƒç”¨åèŠ‚ç‚¹æœ¬åœ°å°†ç»´æŠ¤æ‰€åŠ å…¥é€šé“çš„æ•°æ®ç»“æ„ï¼Œå¹¶åˆ›å»ºåˆå§‹åŒºå—ã€‚</li><li>GetConfigBlockï¼šå½“éœ€è¦è·å–èŠ‚ç‚¹åœ¨æŸä¸ªé€šé“ä¸Šé…ç½®æ—¶å€™è¢«è°ƒç”¨ã€‚è¯¥æ–¹æ³•è·å–æŒ‡å®šé€šé“çš„é…ç½®åŒºå—ï¼ˆæœªæ›´æ–°æ—¶ç­‰ä»·äºåˆå§‹åŒºå—ï¼‰çš„å†…å®¹</li><li>UpdateConfigBlockï¼šå½“éœ€è¦æ›´æ–°èŠ‚ç‚¹åœ¨æŸä¸ªé€šé“ä¸Šçš„é…ç½®æ—¶è¢«è°ƒç”¨ã€‚æ ¹æ®ä¼ å…¥çš„åŒºå—æ•°æ®ç”ŸæˆåŒºå—ç»“æ„ï¼Œæ›¿æ¢æ‰ç°æœ‰çš„é…ç½®åŒºå—ç»“æ„ã€‚æ›¿æ¢åé…ç½®åŒºå—æ•°æ®å°†è·Ÿè¯¥é€šé“å†…çš„åˆå§‹åŒºå—ä¸å†ä¸€è‡´</li><li>GetChannelsï¼šéœ€è¦è·å–åˆ°èŠ‚ç‚¹æ‰€åŠ å…¥æ‰€æœ‰é€šé“åˆ—è¡¨æ—¶è¢«è°ƒç”¨ã€‚è¯¥æ–¹æ³•è·å–è¯¥èŠ‚ç‚¹å·²ç»åŠ å…¥çš„æ‰€æœ‰é€šé“çš„ä¿¡æ¯</li></ul><h4 id="2-èƒŒä¹¦ç®¡ç†ç³»ç»Ÿé“¾ç "><a href="#2-èƒŒä¹¦ç®¡ç†ç³»ç»Ÿé“¾ç " class="headerlink" title="2. èƒŒä¹¦ç®¡ç†ç³»ç»Ÿé“¾ç "></a>2. èƒŒä¹¦ç®¡ç†ç³»ç»Ÿé“¾ç </h4><p>Endorsement Sysment Chaincodeå³èƒŒä¹¦ç®¡ç†ç³»ç»Ÿé“¾ç ã€‚è´Ÿè´£èƒŒä¹¦ï¼ˆç­¾åï¼‰è¿‡ç¨‹ï¼Œå¹¶å¯ä»¥æ”¯æŒå¯¹è¢«ä¹¦ç­–ç•¥è¿›è¡Œç®¡ç†ï¼Œä»…æ”¯æŒé“¾å†…ç³»ç»Ÿè°ƒç”¨ã€‚</p><h4 id="3-ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿé“¾ç "><a href="#3-ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿé“¾ç " class="headerlink" title="3. ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿé“¾ç "></a>3. ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿé“¾ç </h4><p>Liftcycle System Chaincodeå³ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿé“¾ç ï¼Œè´Ÿè´£å¯¹ç”¨æˆ·é“¾ç çš„ç”Ÿå‘½å‘¨æœŸè¿›è¡Œç®¡ç†ï¼Œæ”¯æŒè¢«ä»é“¾å¤–è¿›è¡Œè°ƒç”¨</p><p>é“¾ç ç”Ÿå‘½å‘¨æœŸåŒ…æ‹¬å®‰è£…ã€éƒ¨ç½²ã€å‡çº§ã€æƒé™ç®¡ç†ã€è·å–ä¿¡æ¯ç­‰ç¯èŠ‚ã€‚è¿™äº›æ“ä½œéƒ½å¯ä»¥é€šè¿‡å¯¹LSCCè¿›è¡ŒInvokeæ¥å®ç°ï¼š</p><ul><li>INSTALLï¼šå®‰è£…æ„å‘³ç€å°†ç”¨æˆ·é“¾ç ç›¸å…³æ–‡ä»¶æ‰“åŒ…ï¼Œæ”¾ç½®åˆ°èŠ‚ç‚¹çš„æ–‡ä»¶ç³»ç»Ÿï¼Œé»˜è®¤åœ¨/var/hyperledger/production/chaincodes/è·¯å¾„ä¸‹</li><li>DEPLOYï¼šæ„å‘³ç€é“¾ç è¢«éƒ¨ç½²å’Œå®ä¾‹åŒ–ï¼Œç”Ÿæˆé“¾ç å®¹å™¨ã€‚æ­¤è¿‡ç¨‹ä¸­ä¼šæ£€æŸ¥é€šé“çš„ACLï¼Œä»æœ¬åœ°æ‹¿åˆ°é“¾ç æ•°æ®ï¼Œæ£€æŸ¥Instantiation Policy</li><li>UPGRADEï¼šå‡çº§é“¾ç æ—¶è¢«è°ƒç”¨ã€‚æ£€æŸ¥Instantiation Policyï¼Œé€šè¿‡åˆ™å¯¹æœ¬åœ°æ–‡ä»¶è¿›è¡Œæ›¿æ¢ï¼Œå¹¶ç”Ÿæˆæ–°çš„é“¾ç å®¹å™¨</li><li>GETCCINFOï¼šè·å–é“¾ç ä¿¡æ¯æ—¶è¢«è°ƒç”¨ã€‚æ£€æŸ¥èŠ‚ç‚¹å¯¹é’™é€šé“æ˜¯å¦æœ‰è¯»æƒé™ï¼Œé€šè¿‡åˆ™è¿”å›æŒ‡å®šé“¾ç çš„ä¿¡æ¯</li><li>GETCCDATAï¼šè·å–é“¾ç æ•°æ®æ—¶è¢«è°ƒç”¨ã€‚æ£€æŸ¥èŠ‚ç‚¹å¯¹è¯¥é€šé“æ˜¯å¦æœ‰è¯»æƒé™ï¼Œé€šè¿‡åˆ™è¿”å›æŒ‡å®šé“¾ç çš„å®Œæ•´æ•°æ®</li><li>GETCHAINCODESï¼šè·å–èŠ‚ç‚¹åœ¨é€šé“ä¸Šçš„è¿ç ä¿¡æ¯ï¼Œæ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å…·æœ‰ç®¡ç†å‘˜æƒé™ï¼Œé€šè¿‡åˆ™è¿”å›åœ¨é€šé“ä¸Šçš„æ‰€æœ‰é“¾ç ä¿¡æ¯ï¼ŒåŒ…æ‹¬å·²å®‰è£…å’Œå·²å®ä¾‹åŒ–çš„</li></ul><h4 id="4-æŸ¥è¯¢ç³»ç»Ÿé“¾ç "><a href="#4-æŸ¥è¯¢ç³»ç»Ÿé“¾ç " class="headerlink" title="4. æŸ¥è¯¢ç³»ç»Ÿé“¾ç "></a>4. æŸ¥è¯¢ç³»ç»Ÿé“¾ç </h4><p>Query System Chaincodeï¼ŒæŸ¥è¯¢ç³»ç»Ÿé“¾ç ï¼Œè´Ÿè´£æä¾›ä¸€äº›è´¦æœ¬å’Œé“¾ä¿¡æ¯çš„æŸ¥è¯¢æ–¹æ³•ï¼š</p><ul><li>GetChainInfoï¼šè·å–åŒºå—é“¾çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬é«˜åº¦å€¼ã€å½“å‰åŒºå—Hashå€¼ã€ä¸Šä¸€ä¸ªåŒºå—Hashå€¼ç­‰</li><li>GetBlockByNumberï¼šæ ¹æ®ç»™å®šé«˜åº¦ï¼Œè¿”å›å¯¹åº”åŒºå—çš„æ•°æ®</li><li>GetBlockByHashï¼šæ ¹æ®ç»™å®šçš„åŒºå—å¤´Hashå€¼ï¼Œè¿”å›å¯¹åº”åŒºå—çš„æ•°æ®</li><li>GetTransactionByIDï¼šæ ¹æ®ç»™å®šçš„TxIDï¼Œè¿”å›å¯¹åº”äº¤æ˜“çš„æ•°æ®</li><li>GetBlockByTxIDï¼šæ ¹æ®ç»™å®šçš„TxIDï¼Œè¿”å›åŒ…å«è¯¥äº¤æ˜“çš„åŒºå—çš„æ•°æ®</li></ul><h4 id="5-éªŒè¯ç³»ç»Ÿé“¾ç "><a href="#5-éªŒè¯ç³»ç»Ÿé“¾ç " class="headerlink" title="5. éªŒè¯ç³»ç»Ÿé“¾ç "></a>5. éªŒè¯ç³»ç»Ÿé“¾ç </h4><p>Verification System ChaincodeéªŒè¯ç³»ç»Ÿé“¾ç ï¼Œè´Ÿè´£æ‹…ä»»Committerè§’è‰²çš„èŠ‚ç‚¹å¯¹ä»Ordereræ”¶åˆ°çš„ä¸€æ‰¹äº¤æ˜“è¿›è¡Œå†™å…¥å‰çš„å†æ¬¡éªŒè¯ï¼Œä»…æ”¯æŒé“¾å†…ç³»ç»Ÿè°ƒç”¨ã€‚</p><p>VSCCä¸»è¦è¿‡ç¨‹ï¼š</p><ul><li>é¦–å…ˆè§£æå‡ºäº¤æ˜“ç»“æ„ï¼Œå¹¶å¯¹äº¤æ˜“ç»“æ„æ ¼å¼è¿›è¡Œæ ¡éªŒ</li><li>æ£€æŸ¥äº¤æ˜“çš„è¯»é›†åˆä¸­å…ƒç´ ç‰ˆæœ¬è·Ÿæœ¬åœ°è´¦æœ¬ä¸­ç‰ˆæœ¬ä¸€è‡´</li><li>æ£€æŸ¥å¸¦æœ‰åˆæ³•çš„èƒŒä¹¦ä¿¡æ¯ï¼ˆç›®å‰ä¸»è¦æ˜¯æ£€æŸ¥ç­¾åä¿¡æ¯ï¼‰</li><li>é€šè¿‡åˆ™è¿”å›æ­£ç¡®ï¼Œå¦åˆ™è¿”å›é”™è¯¯ä¿¡æ¯</li></ul><h3 id="12-7-æ’åºæœåŠ¡"><a href="#12-7-æ’åºæœåŠ¡" class="headerlink" title="12.7 æ’åºæœåŠ¡"></a>12.7 æ’åºæœåŠ¡</h3><p>æ’åºæœåŠ¡åœ¨è¶…çº§è´¦æœ¬Fabricç½‘ç»œä¸­èµ·åˆ°ååˆ†æ ¸å¿ƒçš„ä½œç”¨ã€‚æ‰€æœ‰äº¤æ˜“åœ¨å‘é€åˆ°ç½‘ç»œä¸­äº¤ç”±Committerè¿›è¡ŒéªŒè¯æ¥å—ä¹‹å‰ï¼Œéœ€è¦å…ˆç»è¿‡æ’åºæœåŠ¡è¿›è¡Œå…¨å±€æ’åºã€‚æ’åºæœåŠ¡æä¾›äº†åŸå­å¹¿æ’­æ’åºåŠŸèƒ½ã€‚</p><p>æ’åºæœåŠ¡ä¸‰éƒ¨åˆ†ï¼š</p><ul><li>gRPCåè®®å¯¹å¤–æä¾›æœåŠ¡æ¥å£</li><li>è´¦æœ¬ç»„ä»¶ç½‘ç»œä¸­æ¯ä¸ªåº”ç”¨é€šé“ç»´æŠ¤åŒºå—é“¾ç»“æ„</li><li>æ’åºæ’ä»¶è·Ÿä¸åŒç±»å‹çš„æ’åºåç«¯æ‰“äº¤é“</li></ul><p><img src="/images/fabric/image-20220306155841781.png" alt="image-20220306155841781"></p><h4 id="12-7-1-gRPCæœåŠ¡æ¥å£"><a href="#12-7-1-gRPCæœåŠ¡æ¥å£" class="headerlink" title="12.7.1 gRPCæœåŠ¡æ¥å£"></a>12.7.1 gRPCæœåŠ¡æ¥å£</h4><p>Ordereré€šè¿‡gRPCæ¥å£æä¾›äº†å¯¹å¤–çš„è°ƒç”¨æœåŠ¡ï¼Œä¸»è¦åŒ…æ‹¬ï¼š</p><ul><li>Broadcastï¼šæ„å‘³ç€å®¢æˆ·ç«¯å‘é€äº¤æ˜“è¯·æ±‚åˆ°æ’åºæœåŠ¡è¿›è¡Œæ’åºå¤„ç†</li><li>Deliverï¼šæ„å‘³ç€å®¢æˆ·ç«¯æˆ–Peerä»æ’åºæœåŠ¡è·å–æ’åºåçš„åŒºå—ï¼ˆæ‰¹é‡äº¤æ˜“ï¼‰</li></ul><h4 id="12-7-2-é“¾å’Œè´¦æœ¬ç®¡ç†"><a href="#12-7-2-é“¾å’Œè´¦æœ¬ç®¡ç†" class="headerlink" title="12.7.2 é“¾å’Œè´¦æœ¬ç®¡ç†"></a>12.7.2 é“¾å’Œè´¦æœ¬ç®¡ç†</h4><p>OrdererèŠ‚ç‚¹æœ¬åœ°éœ€è¦ç»´æŠ¤ç½‘ç»œä¸­çš„è´¦æœ¬ç»“æ„ã€‚å…¶ä¸­è´¦æœ¬ç»“æ„æ”¯æŒä¸‰ç§å®ç°ç±»å‹ï¼š</p><ul><li>ramï¼šå­˜æ”¾è¿‘æœŸè‹¥å¹²åŒºå—åˆ°å†…å­˜ä¸­</li><li>fileï¼šå­˜æ”¾åŒºå—è®°å½•åˆ°æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿ</li><li>jsonï¼šå­˜æ”¾åŒºå—è®°å½•åˆ°æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿï¼ˆå­˜å‚¨æ ¼å¼ä¸ºjsonï¼‰</li></ul><h4 id="12-7-3-é€šé“é…ç½®æ›´æ–°"><a href="#12-7-3-é€šé“é…ç½®æ›´æ–°" class="headerlink" title="12.7.3 é€šé“é…ç½®æ›´æ–°"></a>12.7.3 é€šé“é…ç½®æ›´æ–°</h4><p>å¯¹é€šé“é…ç½®çš„æ›´æ–°ä¸»è¦é€šè¿‡Processorç»“æ„æ¥å®Œæˆï¼Œè¯¥ç»“æ„ä¸»è¦æä¾›äº†Processæ–¹æ³•ã€‚è¯¥æ–¹æ³•æ¥æ”¶ä¸€ä¸ªCONFIG_UPDATEç±»å‹çš„Envelopeç»“æ„æ¶ˆæ¯ï¼Œæ ¹æ®è¯·æ±‚ç±»å‹ï¼ˆæ–°å»ºé€šé“æˆ–æ›´æ–°é…ç½®ï¼‰ï¼Œå°†å…¶è½¬æ¢ä¸ºæ–°å»ºåº”ç”¨é€šé“çš„è¯·æ±‚ï¼Œæˆ–è€…è½¬æ¢ä¸ºå¯¹é€šé“è¿›è¡Œé…ç½®æ›´æ”¹çš„è¯·æ±‚ã€‚</p><p>ä¸»è¦æ­¥éª¤ï¼š</p><ul><li>ä»è¯·æ±‚ä¸­æå–channelIDï¼Œæ£€æŸ¥æœ¬åœ°æ˜¯å¦å­˜åœ¨å¯¹åº”çš„é“¾ç»“æ„</li><li>å¦‚æœchannelIDå¯¹åº”çš„é“¾åœ¨æœ¬åœ°å­˜åœ¨ï¼Œåˆ™æ„å‘³ç€è¿™æ˜¯ä¸€ä¸ªå¯¹å·²æœ‰é€šé“è¿›è¡Œé…ç½®æ›´æ–°çš„è¯·æ±‚</li><li>å¦‚æœchannelIDå¯¹åº”çš„é“¾åœ¨æœ¬åœ°ä¸å­˜åœ¨ï¼Œåˆ™æ„å‘³ç€è¿™æ˜¯ä¸€ä¸ªæ–°é€šé“çš„è¯·æ±‚</li></ul><h4 id="12-7-4-å…±è¯†æ’ä»¶"><a href="#12-7-4-å…±è¯†æ’ä»¶" class="headerlink" title="12.7.4 å…±è¯†æ’ä»¶"></a>12.7.4 å…±è¯†æ’ä»¶</h4><p>Ordereræ¨¡å—ä¸­åŒ…å«ä¸‰ç§å…±è¯†æ’ä»¶ï¼š</p><ul><li>Soloï¼šå•èŠ‚ç‚¹çš„æ’åºåŠŸèƒ½ï¼Œè¯•éªŒæ€§è´¨ï¼Œä¸å…·å¤‡å¯æ‰©å±•æ€§å’Œå®¹é”™ï¼Œä¸èƒ½åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨</li><li>Kafkaï¼šåŸºäºKafkaé›†ç¾¤çš„æ’åºå®ç°ã€‚æ”¯æŒCFTå®¹é”™ï¼Œæ”¯æŒå¯æŒä¹…åŒ–å’Œæ‰©å±•æ€§ï¼Œå¯åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨</li><li>SBFTï¼šæ”¯æŒBFTå®¹é”™çš„æ’åºå®ç°ï¼Œ1.0å°šæœªå®ç°</li></ul><h1 id="å‚è€ƒ"><a href="#å‚è€ƒ" class="headerlink" title="å‚è€ƒ"></a>å‚è€ƒ</h1><ul><li>ã€ŠåŒºå—é“¾åŸç†ã€è®¾è®¡ä¸åº”ç”¨-æ¨ä¿åã€é™ˆæ˜Œã€‹</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-æ¶‰åŠåˆ°çš„æ•°æ®ç»“æ„ä¸ç®—æ³•</title>
      <link href="/2021/07/08/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2021/07/08/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="ç‰ˆæœ¬è¯´æ˜"><a href="#ç‰ˆæœ¬è¯´æ˜" class="headerlink" title="ç‰ˆæœ¬è¯´æ˜"></a>ç‰ˆæœ¬è¯´æ˜</h1><p>æºç åˆ†æä½¿ç”¨çš„ç‰ˆæœ¬ä¸ºï¼š<a href="https://github.com/ethereum/go-ethereum/tree/v1.10.3">v1.10.3</a></p><h1 id="ä¸€ã€æ•°æ®ç»“æ„"><a href="#ä¸€ã€æ•°æ®ç»“æ„" class="headerlink" title="ä¸€ã€æ•°æ®ç»“æ„"></a>ä¸€ã€æ•°æ®ç»“æ„</h1><h2 id="1-MPT"><a href="#1-MPT" class="headerlink" title="1. MPT"></a>1. MPT</h2><p>ä»¥å¤ªåŠæºç ä¸­çš„trieåŒ…å®ç°äº†Merkle Patricia Triesï¼ˆMPTï¼‰ï¼Œè¿™ç§æ•°æ®ç»“æ„å®é™…ä¸Šæ˜¯ä¸€ç§Trieæ ‘å˜ç§ã€‚<br>MPTæ˜¯ä»¥å¤ªåŠä¸­ä¸€ç§éå¸¸é‡è¦çš„æ•°æ®ç»“æ„ï¼Œç”¨æ¥å­˜å‚¨ç”¨æˆ·è´¦æˆ·çš„çŠ¶æ€åŠå…¶å˜æ›´ã€äº¤æ˜“ä¿¡æ¯ã€äº¤æ˜“çš„æ”¶æ®ä¿¡æ¯ã€‚<br>MPTå®é™…ä¸Šæ˜¯ä¸‰ç§æ•°æ®ç»“æ„çš„ç»„åˆï¼Œåˆ†åˆ«æ˜¯Merkleæ ‘ã€Patricia Trieå’ŒTrieæ ‘ã€‚</p><p>ğŸ”è¯¦æƒ…ï¼š</p><ul><li><a href="https://blog.csdn.net/qq_36254699/article/details/117325437">MPT(Merkleæ ‘ã€Patricia Triesã€Trieæ ‘)</a></li></ul><h2 id="2-LevelDB"><a href="#2-LevelDB" class="headerlink" title="2. LevelDB"></a>2. LevelDB</h2><p>go-ethereumæ‰€æœ‰çš„æ•°æ®å­˜å‚¨åœ¨levelDBè¿™ä¸ªGoogleå¼€æºçš„KeyValueæ–‡ä»¶æ•°æ®åº“ä¸­ï¼Œæ•´ä¸ªåŒºå—é“¾çš„æ‰€æœ‰æ•°æ®éƒ½å­˜å‚¨åœ¨ä¸€ä¸ªlevelDBçš„æ•°æ®åº“ä¸­ï¼ŒlevelDBæ”¯æŒæŒ‰ç…§æ–‡ä»¶å¤§å°åˆ‡åˆ†æ–‡ä»¶çš„åŠŸèƒ½ï¼Œæ‰€ä»¥æˆ‘ä»¬çœ‹åˆ°çš„åŒºå—é“¾çš„æ•°æ®éƒ½æ˜¯ä¸€ä¸ªä¸€ä¸ªå°æ–‡ä»¶ï¼Œå…¶å®è¿™äº›å°æ–‡ä»¶éƒ½æ˜¯åŒä¸€ä¸ªlevelDBå®ä¾‹ã€‚<br>levelDBå®˜æ–¹ç½‘ç«™ä»‹ç»ç‰¹ç‚¹ï¼š</p><ul><li>keyå’Œvalueéƒ½æ˜¯ä»»æ„é•¿åº¦çš„å­—èŠ‚æ•°ç»„ï¼›</li><li>entryï¼ˆå³ä¸€æ¡K-Vè®°å½•ï¼‰é»˜è®¤æ˜¯æŒ‰ç…§keyçš„å­—å…¸é¡ºåºå­˜å‚¨çš„ï¼Œå½“ç„¶å¼€å‘è€…ä¹Ÿå¯ä»¥é‡è½½è¿™ä¸ªæ’åºå‡½æ•°ï¼›</li><li>æä¾›çš„åŸºæœ¬æ“ä½œæ¥å£ï¼šPut()ã€Delete()ã€Get()ã€Batch()ï¼›</li><li>æ”¯æŒæ‰¹é‡æ“ä½œä»¥åŸå­æ“ä½œè¿›è¡Œï¼›</li><li>å¯ä»¥åˆ›å»ºæ•°æ®å…¨æ™¯çš„snapshot(å¿«ç…§)ï¼Œå¹¶å…è®¸åœ¨å¿«ç…§ä¸­æŸ¥æ‰¾æ•°æ®ï¼›</li><li>å¯ä»¥é€šè¿‡å‰å‘ï¼ˆæˆ–åå‘ï¼‰è¿­ä»£å™¨éå†æ•°æ®ï¼ˆè¿­ä»£å™¨ä¼šéšå«çš„åˆ›å»ºä¸€ä¸ªsnapshotï¼‰ï¼›</li><li>è‡ªåŠ¨ä½¿ç”¨Snappyå‹ç¼©æ•°æ®ï¼›</li><li>å¯ç§»æ¤æ€§ï¼›</li></ul><p>é™åˆ¶ï¼š</p><ul><li> éå…³ç³»å‹æ•°æ®æ¨¡å‹ï¼ˆNoSQLï¼‰ï¼Œä¸æ”¯æŒsqlè¯­å¥ï¼Œä¹Ÿä¸æ”¯æŒç´¢å¼•ï¼›</li><li> ä¸€æ¬¡åªå…è®¸ä¸€ä¸ªè¿›ç¨‹è®¿é—®ä¸€ä¸ªç‰¹å®šçš„æ•°æ®åº“ï¼›</li><li> æ²¡æœ‰å†…ç½®çš„C/Sæ¶æ„ï¼Œä½†å¼€å‘è€…å¯ä»¥ä½¿ç”¨LevelDBåº“è‡ªå·±å°è£…ä¸€ä¸ªserverï¼›</li></ul><p>ğŸ”è¯¦æƒ…ï¼š</p><ul><li><a href="https://blog.csdn.net/qq_36254699/article/details/117906308?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_36254699/article/details/117906308?spm=1001.2014.3001.5501</a></li><li><a href="https://github.com/google/leveldb">https://github.com/google/leveldb</a></li></ul><h1 id="äºŒã€ç®—æ³•"><a href="#äºŒã€ç®—æ³•" class="headerlink" title="äºŒã€ç®—æ³•"></a>äºŒã€ç®—æ³•</h1><h2 id="1-è¿ªè²-èµ«å°”æ›¼å¯†é’¥äº¤æ¢"><a href="#1-è¿ªè²-èµ«å°”æ›¼å¯†é’¥äº¤æ¢" class="headerlink" title="1. è¿ªè²-èµ«å°”æ›¼å¯†é’¥äº¤æ¢"></a>1. è¿ªè²-èµ«å°”æ›¼å¯†é’¥äº¤æ¢</h2><p>è¿ªè²ï¼èµ«å°”æ›¼é€šè¿‡å…¬å…±ä¿¡é“äº¤æ¢ä¸€ä¸ªä¿¡æ¯ï¼Œå°±å¯ä»¥åˆ›å»ºä¸€ä¸ªå¯ä»¥ç”¨äºåœ¨å…¬å…±ä¿¡é“ä¸Šå®‰å…¨é€šä¿¡çš„å…±äº«ç§˜å¯†ï¼ˆshared secretï¼‰ã€‚</p><p>ğŸ”è¯¦æƒ…ï¼š</p><ul><li><a href="https://gitee.com/hbuzzs/go-ethereum-code-analysis/blob/analysis-zzs/p2p-rlpx%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8A%A0%E5%AF%86%E9%93%BE%E8%B7%AF.md#%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E5%B0%94%E6%9B%BC%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2">è¿ªè²-èµ«å°”æ›¼å¯†é’¥äº¤æ¢</a></li></ul><h2 id="2-ä»¥å¤ªåŠå¿«é€ŸåŒæ­¥ç®—æ³•"><a href="#2-ä»¥å¤ªåŠå¿«é€ŸåŒæ­¥ç®—æ³•" class="headerlink" title="2. ä»¥å¤ªåŠå¿«é€ŸåŒæ­¥ç®—æ³•"></a>2. ä»¥å¤ªåŠå¿«é€ŸåŒæ­¥ç®—æ³•</h2><p>åŒºå—é“¾æœ€å¼€å§‹çš„åŒæ­¥å·¥ä½œï¼Œå½“å‰çš„åŒæ­¥æœ‰ä¸¤ç§æ¨¡å¼ï¼š<br>ä¸€ç§æ˜¯ä¼ ç»Ÿçš„fullmode,è¿™ç§æ¨¡å¼é€šè¿‡ä¸‹è½½åŒºå—å¤´ï¼Œå’ŒåŒºå—ä½“æ¥æ„å»ºåŒºå—é“¾ï¼ŒåŒæ­¥çš„è¿‡ç¨‹å°±å’Œæ™®é€šçš„åŒºå—æ’å…¥çš„è¿‡ç¨‹ä¸€æ ·ï¼ŒåŒ…æ‹¬åŒºå—å¤´çš„éªŒè¯ï¼Œäº¤æ˜“çš„éªŒè¯ï¼Œäº¤æ˜“æ‰§è¡Œï¼Œè´¦æˆ·çŠ¶æ€çš„æ”¹å˜ç­‰æ“ä½œï¼Œè¿™å…¶å®æ˜¯ä¸€ä¸ªæ¯”è¾ƒæ¶ˆè€—CPUå’Œç£ç›˜çš„ä¸€ä¸ªè¿‡ç¨‹ã€‚<br>å¦ä¸€ç§æ¨¡å¼å°±æ˜¯å¿«é€ŸåŒæ­¥çš„fast syncæ¨¡å¼ã€‚ç®€å•çš„è¯´ fast syncçš„æ¨¡å¼ä¼šä¸‹è½½åŒºå—å¤´ï¼ŒåŒºå—ä½“å’Œæ”¶æ®ï¼Œ æ’å…¥çš„è¿‡ç¨‹ä¸ä¼šæ‰§è¡Œäº¤æ˜“ï¼Œç„¶ååœ¨ä¸€ä¸ªåŒºå—é«˜åº¦(æœ€é«˜çš„åŒºå—é«˜åº¦ - 1024)çš„æ—¶å€™åŒæ­¥æ‰€æœ‰çš„è´¦æˆ·çŠ¶æ€ï¼Œåé¢çš„1024ä¸ªåŒºå—ä¼šé‡‡ç”¨fullmodeçš„æ–¹å¼æ¥æ„å»ºã€‚ è¿™ç§æ¨¡å¼ä¼šåŠ å¿«åŒºå—çš„æ’å…¥æ—¶é—´ï¼ŒåŒæ—¶ä¸ä¼šäº§ç”Ÿå¤§é‡çš„å†å²çš„è´¦æˆ·ä¿¡æ¯ï¼Œä¼šç›¸å¯¹èŠ‚çº¦ç£ç›˜ï¼Œ ä½†æ˜¯å¯¹äºç½‘ç»œçš„æ¶ˆè€—ä¼šæ›´é«˜ã€‚ å› ä¸ºéœ€è¦ä¸‹è½½æ”¶æ®å’ŒçŠ¶æ€ã€‚<br>å³å¿«é€ŸåŒæ­¥ç®—æ³•çš„ç›®æ ‡æ˜¯ç”¨å¸¦å®½æ¢è®¡ç®—ã€‚ å¿«é€ŸåŒæ­¥ä¸æ˜¯é€šè¿‡ä¸€ä¸ªé“¾æ¥å¤„ç†æ•´ä¸ªåŒºå—é“¾ï¼Œè€Œæ˜¯é‡æ”¾å†å²ä¸Šå‘ç”Ÿçš„æ‰€æœ‰äº‹åŠ¡ï¼Œå¿«é€ŸåŒæ­¥ä¼šæ²¿ç€è¿™äº›å—ä¸‹è½½äº‹åŠ¡å¤„ç†å•æ®ï¼Œç„¶åæ‹‰å–æ•´ä¸ªæœ€è¿‘çš„çŠ¶æ€æ•°æ®åº“ã€‚ è¿™å…è®¸å¿«é€ŸåŒæ­¥çš„èŠ‚ç‚¹ä»ç„¶ä¿æŒå…¶åŒ…å«ç”¨äºç”¨æˆ·æŸ¥è¯¢çš„æ‰€æœ‰å†å²æ•°æ®çš„å­˜æ¡£èŠ‚ç‚¹çš„çŠ¶æ€ï¼ˆå¹¶ä¸”å› æ­¤ä¸ä¼šä¸€èˆ¬åœ°å½±å“ç½‘ç»œçš„å¥åº·çŠ¶å†µï¼‰ï¼Œå¯¹äºæœ€æ–°çš„åŒºå—çŠ¶æ€æ›´æ”¹ï¼Œä¼šä½¿ç”¨å…¨é‡çš„åŒºå—å¤„ç†æ–¹å¼ã€‚</p><p>å¿«é€ŸåŒæ­¥ç®—æ³•çš„æ¦‚è¦ï¼š</p><ul><li>ä¸åŸæœ‰çš„åŒæ­¥ç±»ä¼¼ï¼Œä¸‹è½½ç»„æˆåŒºå—é“¾çš„åŒºå—å¤´å’ŒåŒºå—body</li><li>ç±»ä¼¼äºåŸæœ‰çš„åŒæ­¥ï¼ŒéªŒè¯åŒºå—å¤´çš„ä¸€è‡´æ€§ï¼ˆPOWï¼Œæ€»éš¾åº¦ç­‰ï¼‰</li><li>ä¸‹è½½ç”±åŒºå—å¤´å®šä¹‰çš„äº¤æ˜“æ”¶æ®,è€Œä¸æ˜¯å¤„ç†åŒºå—ã€‚</li><li>å­˜å‚¨ä¸‹è½½çš„åŒºå—é“¾å’Œæ”¶æ®é“¾ï¼Œå¯ç”¨æ‰€æœ‰å†å²æŸ¥è¯¢</li><li>å½“é“¾æ¡è¾¾åˆ°æœ€è¿‘çš„çŠ¶æ€ï¼ˆå¤´éƒ¨ - 1024ä¸ªå—ï¼‰æ—¶ï¼Œæš‚åœçŠ¶æ€åŒæ­¥ï¼š<ul><li>è·å–ç”± pivot pointå®šä¹‰çš„åŒºå—çš„å®Œæ•´çš„Merkel Patricia TrieçŠ¶æ€</li><li>å¯¹äºMerkel Patricia Trieé‡Œé¢çš„æ¯ä¸ªè´¦æˆ·ï¼Œè·å–ä»–çš„åˆçº¦ä»£ç å’Œä¸­é—´å­˜å‚¨çš„Trie</li></ul></li><li>å½“Merkel Patricia Trieä¸‹è½½æˆåŠŸåï¼Œå°†pivot pointå®šä¹‰çš„åŒºå—ä½œä¸ºå½“å‰çš„åŒºå—å¤´</li><li>é€šè¿‡åƒåŸæœ‰çš„åŒæ­¥ä¸€æ ·å¯¹å…¶è¿›è¡Œå®Œå…¨å¤„ç†ï¼Œå¯¼å…¥æ‰€æœ‰å‰©ä½™çš„å—ï¼ˆ1024ï¼‰</li></ul><p>ğŸ”è¯¦æƒ…ï¼š</p><ul><li><a href="https://github.com/ethereum/go-ethereum/pull/1889">ä»¥å¤ªåŠå¿«é€ŸåŒæ­¥ç®—æ³•-åŸæ–‡</a></li><li><a href="https://gitee.com/hbuzzs/go-ethereum-code-analysis/blob/analysis-zzs/%E4%BB%A5%E5%A4%AA%E5%9D%8Afast%20sync%E7%AE%97%E6%B3%95.md">ä»¥å¤ªåŠå¿«é€ŸåŒæ­¥ç®—æ³•-è¯‘æ–‡</a></li></ul><h2 id="3-ä»¥å¤ªåŠçš„å¸ƒéš†è¿‡æ»¤å™¨"><a href="#3-ä»¥å¤ªåŠçš„å¸ƒéš†è¿‡æ»¤å™¨" class="headerlink" title="3. ä»¥å¤ªåŠçš„å¸ƒéš†è¿‡æ»¤å™¨"></a>3. ä»¥å¤ªåŠçš„å¸ƒéš†è¿‡æ»¤å™¨</h2><p>ä»¥å¤ªåŠçš„åŒºå—å¤´ä¸­åŒ…å«äº†ä¸€ä¸ªå«åšlogsBloomçš„åŒºåŸŸã€‚ è¿™ä¸ªåŒºåŸŸå­˜å‚¨äº†å½“å‰åŒºå—ä¸­æ‰€æœ‰çš„æ”¶æ®çš„æ—¥å¿—çš„å¸ƒéš†è¿‡æ»¤å™¨ï¼Œä¸€å…±æ˜¯2048ä¸ªbitã€‚ä¹Ÿå°±æ˜¯256ä¸ªå­—èŠ‚ã€‚è€Œæˆ‘ä»¬çš„ä¸€ä¸ªäº¤æ˜“çš„æ”¶æ®åŒ…å«äº†å¾ˆå¤šçš„æ—¥å¿—è®°å½•ã€‚ æ¯ä¸ªæ—¥å¿—è®°å½•åŒ…å«äº† åˆçº¦çš„åœ°å€ï¼Œ å¤šä¸ªTopicã€‚ è€Œåœ¨æˆ‘ä»¬çš„æ”¶æ®ä¸­ä¹Ÿå­˜åœ¨ä¸€ä¸ªå¸ƒéš†è¿‡æ»¤å™¨ï¼Œè¿™ä¸ªå¸ƒéš†è¿‡æ»¤å™¨è®°å½•äº†æ‰€æœ‰çš„æ—¥å¿—è®°å½•çš„ä¿¡æ¯ã€‚</p><p>ğŸ”è¯¦æƒ…ï¼š</p><ul><li><a href="https://zhuanlan.zhihu.com/p/43263751">å¸ƒéš†è¿‡æ»¤å™¨ç®€ä»‹</a></li><li><a href="https://gitee.com/hbuzzs/go-ethereum-code-analysis/blob/analysis-zzs/eth-bloombits%E5%92%8Cfilter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">ä»¥å¤ªåŠçš„å¸ƒéš†è¿‡æ»¤å™¨</a></li></ul><h2 id="4-POWä¸€è‡´æ€§ç®—æ³•"><a href="#4-POWä¸€è‡´æ€§ç®—æ³•" class="headerlink" title="4. POWä¸€è‡´æ€§ç®—æ³•"></a>4. POWä¸€è‡´æ€§ç®—æ³•</h2><p>åœ¨CPUæŒ–çŸ¿éƒ¨åˆ†ï¼ŒCpuAgentçš„mineå‡½æ•°ï¼Œæ‰§è¡ŒæŒ–çŸ¿æ“ä½œçš„æ—¶å€™è°ƒç”¨äº†self.engine.Sealå‡½æ•°ã€‚è¿™é‡Œçš„engineæ˜¯å°±æ˜¯å…±è¯†å¼•æ“ã€‚Sealä¸ºå…¶ä¸­å¾ˆé‡è¦çš„ä¸€ä¸ªæ¥å£ã€‚å®ƒå®ç°äº†nonceå€¼çš„å¯»æ‰¾å’Œhashçš„è®¡ç®—ã€‚å¹¶ä¸”è¯¥å‡½æ•°æ˜¯ä¿è¯å…±è¯†å¹¶ä¸”ä¸èƒ½ä¼ªé€ çš„ä¸€ä¸ªé‡è¦çš„å‡½æ•°ã€‚ å†PoWå…±è¯†ç®—æ³•ä¸­ï¼ŒSealå‡½æ•°å®ç°äº†å·¥ä½œè¯æ˜ã€‚è¯¥éƒ¨åˆ†æºç åœ¨consensus/ethhashä¸‹ã€‚</p><ul><li><a href="https://gitee.com/hbuzzs/go-ethereum-code-analysis/blob/analysis-zzs/pow%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.md">POWä¸€è‡´æ€§ç®—æ³•</a></li></ul><h1 id="ä¸‰ã€åè®®"><a href="#ä¸‰ã€åè®®" class="headerlink" title="ä¸‰ã€åè®®"></a>ä¸‰ã€åè®®</h1><h2 id="1-RPCåè®®"><a href="#1-RPCåè®®" class="headerlink" title="1. RPCåè®®"></a>1. RPCåè®®</h2><p>rpcåŒ…æä¾›è¿™æ ·ä¸€ç§èƒ½åŠ›ï¼Œå¯ä»¥é€šè¿‡ç½‘ç»œæˆ–è€…å…¶ä»–I/Oè¿æ¥ï¼Œå¯ä»¥è®¿é—®å¯¹è±¡è¢«å¯¼å‡ºçš„æ–¹æ³•ã€‚åˆ›å»ºä¸€ä¸ªæœåŠ¡å™¨ä¹‹åï¼Œå¯¹è±¡å¯ä»¥æ³¨å†Œåˆ°æœåŠ¡å™¨ä¸Šï¼Œç„¶åå¯ä»¥è®©å¤–ç•Œè®¿é—®ã€‚é€šè¿‡è„‚è‚ªæ–¹å¼å¯¼å‡ºçš„æ–¹æ³•å¯ä»¥è¢«è¿œç¨‹è°ƒç”¨ã€‚ åŒæ—¶è¿˜æ”¯æŒå‘å¸ƒ/è®¢é˜…æ¨¡å¼ã€‚</p><p>ğŸ”è¯¦æƒ…ï¼š</p><ul><li><a href="https://blog.csdn.net/qq_36254699/article/details/118497242">https://blog.csdn.net/qq_36254699/article/details/118497242</a></li></ul><h2 id="2-Kademliaåè®®"><a href="#2-Kademliaåè®®" class="headerlink" title="2. Kademliaåè®®"></a>2. Kademliaåè®®</h2><p>Kad æ˜¯ä¸€ç§åˆ†å¸ƒå¼å“ˆå¸Œè¡¨ï¼ˆDHTï¼‰æŠ€æœ¯ï¼Œä¸è¿‡å’Œå…¶ä»– DHT å®ç°æŠ€æœ¯æ¯”è¾ƒï¼Œå¦‚Chordã€CANã€Pastry ç­‰ï¼ŒKad é€šè¿‡ç‹¬ç‰¹çš„ä»¥å¼‚æˆ–ç®—æ³•ï¼ˆXORï¼‰ä¸ºè·ç¦»åº¦é‡åŸºç¡€ï¼Œå»ºç«‹äº†ä¸€ç§å…¨æ–°çš„ DHT æ‹“æ‰‘ç»“æ„ï¼Œç›¸æ¯”äºå…¶ä»–ç®—æ³•ï¼Œå¤§å¤§æé«˜äº†è·¯ç”±æŸ¥è¯¢é€Ÿåº¦ã€‚</p><p>ğŸ”è¯¦æƒ…ï¼š</p><ul><li><a href="https://gitee.com/hbuzzs/go-ethereum-code-analysis/blob/analysis-zzs/references/Kademlia%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B.pdf">Kademliaåè®®ç®€ä»‹ä¸‹è½½åœ°å€</a></li></ul><h2 id="3-UDPåè®®"><a href="#3-UDPåè®®" class="headerlink" title="3. UDPåè®®"></a>3. UDPåè®®</h2><p>p2pçš„ç½‘ç»œå‘ç°åè®®ä½¿ç”¨äº†Kademlia protocol æ¥å¤„ç†ç½‘ç»œçš„èŠ‚ç‚¹å‘ç°ã€‚èŠ‚ç‚¹æŸ¥æ‰¾å’ŒèŠ‚ç‚¹æ›´æ–°ã€‚Kademlia protocolä½¿ç”¨äº†UDPåè®®æ¥è¿›è¡Œç½‘ç»œé€šä¿¡ã€‚</p><p>ğŸ”è¯¦æƒ…ï¼š</p><ul><li><a href="https://gitee.com/hbuzzs/go-ethereum-code-analysis/blob/analysis-zzs/p2p-udp.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">p2p-udp.goæºç åˆ†æ.</a></li></ul><h1 id="å‚è€ƒèµ„æ–™åœ°å€"><a href="#å‚è€ƒèµ„æ–™åœ°å€" class="headerlink" title="å‚è€ƒèµ„æ–™åœ°å€"></a>å‚è€ƒèµ„æ–™åœ°å€</h1><ul><li><a href="https://ethereum.org/en/whitepaper">ä»¥å¤ªåŠç™½çš®ä¹¦</a></li><li><a href="https://ethereum.github.io/yellowpaper/paper.pdf">ä»¥å¤ªåŠé»„çš®ä¹¦ï¼ˆè‹±æ–‡ç‰ˆï¼‰</a></li><li><a href="https://github.com/wanshan1024/ethereum_yellowpaper/blob/master/ethereum_yellow_paper_cn.pdf">ä»¥å¤ªåŠé»„çš®ä¹¦ï¼ˆä¸­æ–‡ç‰ˆï¼‰</a></li><li><a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis">åˆ†æå‚è€ƒèµ„æ–™</a></li><li><a href="https://segmentfault.com/a/1190000016050921">åšå®¢å‚è€ƒèµ„æ–™</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-ä»¥å¤ªåŠæºç åˆ†æ-RPC</title>
      <link href="/2021/07/05/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-RPC/"/>
      <url>/2021/07/05/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-RPC/</url>
      
        <content type="html"><![CDATA[<h1 id="ç‰ˆæœ¬è¯´æ˜"><a href="#ç‰ˆæœ¬è¯´æ˜" class="headerlink" title="ç‰ˆæœ¬è¯´æ˜"></a>ç‰ˆæœ¬è¯´æ˜</h1><p>æºç åˆ†æä½¿ç”¨çš„ç‰ˆæœ¬ä¸ºï¼š<a href="https://github.com/ethereum/go-ethereum/tree/v1.10.3">v1.10.3</a></p><h2 id="RPCåŒ…çš„å®˜æ–¹æ–‡æ¡£"><a href="#RPCåŒ…çš„å®˜æ–¹æ–‡æ¡£" class="headerlink" title="RPCåŒ…çš„å®˜æ–¹æ–‡æ¡£"></a>RPCåŒ…çš„å®˜æ–¹æ–‡æ¡£</h2><p>Package rpc provides access to the exported methods of an object across a network<br>or other I/O connection. After creating a server instance objects can be registered,<br>making it visible from the outside. Exported methods that follow specific<br>conventions can be called remotely. It also has support for the publish/subscribe<br>pattern.</p><p>rpcåŒ…æä¾›è¿™æ ·ä¸€ç§èƒ½åŠ›ï¼Œå¯ä»¥é€šè¿‡ç½‘ç»œæˆ–è€…å…¶ä»–I/Oè¿æ¥ï¼Œå¯ä»¥è®¿é—®å¯¹è±¡è¢«å¯¼å‡ºçš„æ–¹æ³•ã€‚åˆ›å»ºä¸€ä¸ªæœåŠ¡å™¨ä¹‹åï¼Œå¯¹è±¡å¯ä»¥æ³¨å†Œåˆ°æœåŠ¡å™¨ä¸Šï¼Œç„¶åå¯ä»¥è®©å¤–ç•Œè®¿é—®ã€‚é€šè¿‡è„‚è‚ªæ–¹å¼å¯¼å‡ºçš„æ–¹æ³•å¯ä»¥è¢«è¿œç¨‹è°ƒç”¨ã€‚ åŒæ—¶è¿˜æ”¯æŒå‘å¸ƒ/è®¢é˜…æ¨¡å¼ã€‚</p><p>Methods that satisfy the following criteria are made available for remote access:</p><ul><li>object must be exported</li><li>method must be exported</li><li>method returns 0, 1 (response or error) or 2 (response and error) values</li><li>method argument(s) must be exported or builtin types</li><li>method returned value(s) must be exported or builtin types</li></ul><p>ç¬¦åˆä»¥ä¸‹æ ‡å‡†çš„æ–¹æ³•å¯ç”¨äºè¿œç¨‹è®¿é—®ï¼š</p><ul><li>å¯¹è±¡å¿…é¡»å¯¼å‡º</li><li>æ–¹æ³•å¿…é¡»å¯¼å‡º</li><li>æ–¹æ³•è¿”å›0ï¼Œ1ï¼ˆå“åº”æˆ–é”™è¯¯ï¼‰æˆ–2ï¼ˆå“åº”å’Œé”™è¯¯ï¼‰å€¼</li><li>æ–¹æ³•å‚æ•°å¿…é¡»å¯¼å‡ºæˆ–æ˜¯å†…ç½®ç±»å‹</li><li>æ–¹æ³•è¿”å›å€¼å¿…é¡»å¯¼å‡ºæˆ–æ˜¯å†…ç½®ç±»å‹</li></ul><p>An example method:</p><pre><code>func (s *CalcService) Add(a, b int) (int, error)</code></pre><p>When the returned error isnâ€™t nil the returned integer is ignored and the error is<br>send back to the client. Otherwise the returned integer is send back to the client.</p><p>å½“è¿”å›çš„errorä¸ç­‰äºnilçš„æ—¶å€™ï¼Œè¿”å›çš„æ•´å½¢å€¼è¢«å¿½ç•¥ï¼Œerrorè¢«å‘é€å›å®¢æˆ·ç«¯ã€‚ å¦åˆ™æ•´å½¢çš„ä¼šè¿”å›è¢«å‘é€å›å®¢æˆ·ç«¯ã€‚</p><p>Optional arguments are supported by accepting pointer values as arguments. E.g.<br>if we want to do the addition in an optional finite field we can accept a mod<br>argument as pointer value.<br>é€šè¿‡æä¾›æŒ‡é’ˆç±»å‹çš„å‚æ•°å¯ä»¥ä½¿å¾—æ–¹æ³•æ”¯æŒå¯é€‰å‚æ•°ã€‚åé¢æœ‰ç‚¹çœ‹ä¸æ‡‚äº†ã€‚</p><pre><code> func (s *CalService) Add(a, b int, mod *int) (int, error)</code></pre><p>This RPC method can be called with 2 integers and a null value as third argument.<br>In that case the mod argument will be nil. Or it can be called with 3 integers,<br>in that case mod will be pointing to the given third argument. Since the optional<br>argument is the last argument the RPC package will also accept 2 integers as<br>arguments. It will pass the mod argument as nil to the RPC method.</p><p>RPCæ–¹æ³•å¯ä»¥é€šè¿‡ä¼ ä¸¤ä¸ªintegerå’Œä¸€ä¸ªnullå€¼ä½œä¸ºç¬¬ä¸‰ä¸ªå‚æ•°æ¥è°ƒç”¨ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹modå‚æ•°ä¼šè¢«è®¾ç½®ä¸ºnilã€‚æˆ–è€…å¯ä»¥ä¼ é€’ä¸‰ä¸ªinteger,è¿™æ ·modä¼šè¢«è®¾ç½®ä¸ºæŒ‡å‘ç¬¬ä¸‰ä¸ªå‚æ•°ã€‚å°½ç®¡å¯é€‰çš„å‚æ•°æ˜¯æœ€åçš„å‚æ•°ï¼ŒRPCåŒ…ä»»ç„¶æ¥æ”¶ä¼ é€’ä¸¤ä¸ªinteger,è¿™æ ·modå‚æ•°ä¼šè¢«è®¾ç½®ä¸ºnilã€‚</p><p>The server offers the ServeCodec method which accepts a ServerCodec instance. It will<br>read requests from the codec, process the request and sends the response back to the<br>client using the codec. The server can execute requests concurrently. Responses<br>can be sent back to the client out of order.</p><p>serveræä¾›äº†ServerCodecæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æ¥æ”¶ServerCodecå®ä¾‹ä½œä¸ºå‚æ•°ã€‚ æœåŠ¡å™¨ä¼šä½¿ç”¨codecè¯»å–è¯·æ±‚ï¼Œå¤„ç†è¯·æ±‚ï¼Œç„¶åé€šè¿‡codecå‘é€å›åº”ç»™å®¢æˆ·ç«¯ã€‚serverå¯ä»¥å¹¶å‘çš„æ‰§è¡Œè¯·æ±‚ã€‚responseçš„é¡ºåºå¯èƒ½å’Œrequestçš„é¡ºåºä¸ä¸€è‡´ã€‚</p><pre><code>//An example server which uses the JSON codec: type CalculatorService struct {} func (s *CalculatorService) Add(a, b int) int {    return a + b } func (s *CalculatorService Div(a, b int) (int, error) {    if b == 0 {        return 0, errors.New("divide by zero")    }    return a/b, nil }calculator := new(CalculatorService) server := NewServer() server.RegisterName("calculator", calculator") l, _ := net.ListenUnix("unix", &amp;net.UnixAddr{Net: "unix", Name: "/tmp/calculator.sock"}) for {    c, _ := l.AcceptUnix()    codec := v2.NewJSONCodec(c)    go server.ServeCodec(codec) }</code></pre><p>The package also supports the publish subscribe pattern through the use of subscriptions.<br>A method that is considered eligible for notifications must satisfy the following criteria:</p><ul><li>object must be exported</li><li>method must be exported</li><li>first method argument type must be context.Context</li><li>method argument(s) must be exported or builtin types</li><li>method must return the tuple Subscription, error</li></ul><p>è¯¥è½¯ä»¶åŒ…è¿˜é€šè¿‡ä½¿ç”¨è®¢é˜…æ¥æ”¯æŒå‘å¸ƒè®¢é˜…æ¨¡å¼ã€‚<br>è¢«è®¤ä¸ºç¬¦åˆé€šçŸ¥æ¡ä»¶çš„æ–¹æ³•å¿…é¡»æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š</p><ul><li>å¯¹è±¡å¿…é¡»å¯¼å‡º</li><li>æ–¹æ³•å¿…é¡»å¯¼å‡º</li><li>ç¬¬ä¸€ä¸ªæ–¹æ³•å‚æ•°ç±»å‹å¿…é¡»æ˜¯context.Context</li><li>æ–¹æ³•å‚æ•°å¿…é¡»å¯¼å‡ºæˆ–å†…ç½®ç±»å‹</li><li>æ–¹æ³•å¿…é¡»è¿”å›å…ƒç»„è®¢é˜…ï¼Œé”™è¯¯</li></ul><p>An example method:</p><pre><code> func (s *BlockChainService) NewBlocks(ctx context.Context) (Subscription, error) {     ... }</code></pre><p>Subscriptions are deleted when:</p><ul><li>the user sends an unsubscribe request</li><li>the connection which was used to create the subscription is closed. This can be initiated<br>by the client and server. The server will close the connection on an write error or when<br>the queue of buffered notifications gets too big.</li></ul><p>è®¢é˜…åœ¨ä¸‹é¢å‡ ç§æƒ…å†µä¸‹ä¼šè¢«åˆ é™¤</p><ul><li>ç”¨æˆ·å‘é€äº†ä¸€ä¸ªå–æ¶ˆè®¢é˜…çš„è¯·æ±‚</li><li>åˆ›å»ºè®¢é˜…çš„è¿æ¥è¢«å…³é—­ã€‚è¿™ç§æƒ…å†µå¯èƒ½ç”±å®¢æˆ·ç«¯æˆ–è€…æœåŠ¡å™¨è§¦å‘ã€‚ æœåŠ¡å™¨åœ¨å†™å…¥å‡ºé”™æˆ–è€…æ˜¯é€šçŸ¥é˜Ÿåˆ—é•¿åº¦å¤ªå¤§çš„æ—¶å€™ä¼šé€‰æ‹©å…³é—­è¿æ¥ã€‚</li></ul><h2 id="RPCåŒ…çš„å¤§è‡´ç»“æ„"><a href="#RPCåŒ…çš„å¤§è‡´ç»“æ„" class="headerlink" title="RPCåŒ…çš„å¤§è‡´ç»“æ„"></a>RPCåŒ…çš„å¤§è‡´ç»“æ„</h2><p>ç½‘ç»œåè®® channelså’ŒJsonæ ¼å¼çš„è¯·æ±‚å’Œå›åº”çš„ç¼–ç å’Œè§£ç éƒ½æ˜¯åŒæ—¶ä¸æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯æ‰“äº¤é“çš„ç±»ã€‚ç½‘ç»œåè®®channelsä¸»è¦æä¾›è¿æ¥å’Œæ•°æ®ä¼ è¾“çš„åŠŸèƒ½ã€‚ jsonæ ¼å¼çš„ç¼–ç å’Œè§£ç ä¸»è¦æä¾›è¯·æ±‚å’Œå›åº”çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–åŠŸèƒ½(Json -&gt; Goçš„å¯¹è±¡)ã€‚</p><p>[å¤–é“¾å›¾ç‰‡è½¬å­˜å¤±è´¥,æºç«™å¯èƒ½æœ‰é˜²ç›—é“¾æœºåˆ¶,å»ºè®®å°†å›¾ç‰‡ä¿å­˜ä¸‹æ¥ç›´æ¥ä¸Šä¼ (img-LKcBwinM-1625486180219)(picture/rpc_1.png)]</p><h2 id="æºç è§£æ"><a href="#æºç è§£æ" class="headerlink" title="æºç è§£æ"></a>æºç è§£æ</h2><h3 id="server-go"><a href="#server-go" class="headerlink" title="server.go"></a>server.go</h3><p>server.goä¸»è¦å®ç°äº†RPCæœåŠ¡ç«¯çš„æ ¸å¿ƒé€»è¾‘ã€‚ åŒ…æ‹¬RPCæ–¹æ³•çš„æ³¨å†Œï¼Œ è¯»å–è¯·æ±‚ï¼Œå¤„ç†è¯·æ±‚ï¼Œå‘é€å›åº”ç­‰é€»è¾‘ã€‚<br>serverçš„æ ¸å¿ƒæ•°æ®ç»“æ„æ˜¯Serverç»“æ„ä½“ã€‚ serviceså­—æ®µæ˜¯ä¸€ä¸ªmapï¼Œè®°å½•äº†æ‰€æœ‰æ³¨å†Œçš„æ–¹æ³•å’Œç±»ã€‚ runå‚æ•°æ˜¯ç”¨æ¥æ§åˆ¶Serverçš„è¿è¡Œå’Œåœæ­¢çš„ã€‚ codecsæ˜¯ä¸€ä¸ªsetã€‚ ç”¨æ¥å­˜å‚¨æ‰€æœ‰çš„ç¼–ç è§£ç å™¨ï¼Œå…¶å®å°±æ˜¯æ‰€æœ‰çš„è¿æ¥ã€‚ codecsMuæ˜¯ç”¨æ¥ä¿æŠ¤å¤šçº¿ç¨‹è®¿é—®codecsçš„é”ã€‚</p><p>serviceså­—æ®µçš„valueç±»å‹æ˜¯serviceç±»å‹ã€‚ serviceä»£è¡¨äº†ä¸€ä¸ªæ³¨å†Œåˆ°Serverçš„å®ä¾‹ï¼Œæ˜¯ä¸€ä¸ªå¯¹è±¡å’Œæ–¹æ³•çš„ç»„åˆã€‚ serviceå­—æ®µçš„nameä»£è¡¨äº†serviceçš„namespaceï¼Œ typå®ä¾‹çš„ç±»å‹ï¼Œ callbacksæ˜¯å®ä¾‹çš„å›è°ƒæ–¹æ³•ï¼Œ subscriptionsæ˜¯å®ä¾‹çš„è®¢é˜…æ–¹æ³•ã€‚</p><pre><code>type serviceRegistry map[string]*service // collection of servicestype callbacks map[string]*callback      // collection of RPC callbackstype subscriptions map[string]*callback type Server struct {    services serviceRegistry    run      int32    codecsMu sync.Mutex    codecs   *set.Set}// callback is a method callback which was registered in the servertype callback struct {    rcvr        reflect.Value  // receiver of method    method      reflect.Method // callback    argTypes    []reflect.Type // input argument types    hasCtx      bool           // method's first argument is a context (not included in argTypes)    errPos      int            // err return idx, of -1 when method cannot return error    isSubscribe bool           // indication if the callback is a subscription}// service represents a registered objecttype service struct {    name          string        // name for service    typ           reflect.Type  // receiver type    callbacks     callbacks     // registered handlers    subscriptions subscriptions // available subscriptions/notifications}</code></pre><p>Serverçš„åˆ›å»ºï¼ŒServeråˆ›å»ºçš„æ—¶å€™é€šè¿‡è°ƒç”¨server.RegisterNameæŠŠè‡ªå·±çš„å®ä¾‹æ³¨å†Œä¸Šæ¥ï¼Œæä¾›ä¸€äº›RPCæœåŠ¡çš„å…ƒä¿¡æ¯ã€‚</p><pre><code>const MetadataApi = "rpc"// NewServer will create a new server instance with no registered handlers.func NewServer() *Server {    server := &amp;Server{        services: make(serviceRegistry),        codecs:   set.New(),        run:      1,    }    // register a default service which will provide meta information about the RPC service such as the services and    // methods it offers.    rpcService := &amp;RPCService{server}    server.RegisterName(MetadataApi, rpcService)    return server}</code></pre><p>æœåŠ¡æ³¨å†Œserver.RegisterNameï¼ŒRegisterNameæ–¹æ³•ä¼šé€šè¿‡ä¼ å…¥çš„å‚æ•°æ¥åˆ›å»ºä¸€ä¸ªserviceå¯¹è±¡ï¼Œå¦‚è¿‡ä¼ å…¥çš„rcvrå®ä¾‹æ²¡æœ‰æ‰¾åˆ°ä»»ä½•åˆé€‚çš„æ–¹æ³•ï¼Œé‚£ä¹ˆä¼šè¿”å›é”™è¯¯ã€‚ å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œå°±æŠŠåˆ›å»ºçš„serviceå®ä¾‹åŠ å…¥serviceRegistryã€‚</p><pre><code>// RegisterName will create a service for the given rcvr type under the given name. When no methods on the given rcvr// match the criteria to be either a RPC method or a subscription an error is returned. Otherwise a new service is// created and added to the service collection this server instance serves.func (s *Server) RegisterName(name string, rcvr interface{}) error {    if s.services == nil {        s.services = make(serviceRegistry)    }    svc := new(service)    svc.typ = reflect.TypeOf(rcvr)    rcvrVal := reflect.ValueOf(rcvr)    if name == "" {        return fmt.Errorf("no service name for type %s", svc.typ.String())    }    //å¦‚æœå®ä¾‹çš„ç±»åä¸æ˜¯å¯¼å‡ºçš„(ç±»åçš„é¦–å­—æ¯å¤§å†™)ï¼Œå°±è¿”å›é”™è¯¯ã€‚    if !isExported(reflect.Indirect(rcvrVal).Type().Name()) {        return fmt.Errorf("%s is not exported", reflect.Indirect(rcvrVal).Type().Name())    }    //é€šè¿‡åå°„ä¿¡æ¯æ‰¾åˆ°åˆé€‚çš„callbacks å’Œsubscriptionsæ–¹æ³•    methods, subscriptions := suitableCallbacks(rcvrVal, svc.typ)    //å¦‚æœè¿™ä¸ªåå­—å½“å‰å·²ç»è¢«æ³¨å†Œè¿‡äº†ï¼Œé‚£ä¹ˆå¦‚æœæœ‰åŒåçš„æ–¹æ³•å°±ç”¨æ–°çš„æ›¿ä»£ï¼Œå¦è€…ç›´æ¥æ’å…¥ã€‚    // already a previous service register under given sname, merge methods/subscriptions    if regsvc, present := s.services[name]; present {        if len(methods) == 0 &amp;&amp; len(subscriptions) == 0 {            return fmt.Errorf("Service %T doesn't have any suitable methods/subscriptions to expose", rcvr)        }        for _, m := range methods {            regsvc.callbacks[formatName(m.method.Name)] = m        }        for _, s := range subscriptions {            regsvc.subscriptions[formatName(s.method.Name)] = s        }        return nil    }    svc.name = name    svc.callbacks, svc.subscriptions = methods, subscriptions    if len(svc.callbacks) == 0 &amp;&amp; len(svc.subscriptions) == 0 {        return fmt.Errorf("Service %T doesn't have any suitable methods/subscriptions to expose", rcvr)    }    s.services[svc.name] = svc    return nil}</code></pre><p>é€šè¿‡åå°„ä¿¡æ¯æ‰¾å‡ºåˆé€‚çš„æ–¹æ³•ï¼ŒsuitableCallbacksï¼Œè¿™ä¸ªæ–¹æ³•åœ¨utils.goé‡Œé¢ã€‚ è¿™ä¸ªæ–¹æ³•ä¼šéå†è¿™ä¸ªç±»å‹çš„æ‰€æœ‰æ–¹æ³•ï¼Œæ‰¾åˆ°é€‚é…RPC callbackæˆ–è€…subscription callbackç±»å‹æ ‡å‡†çš„æ–¹æ³•å¹¶è¿”å›ã€‚å…³äºRPCçš„æ ‡å‡†ï¼Œè¯·å‚è€ƒæ–‡æ¡£å¼€å¤´çš„RPCæ ‡å‡†ã€‚</p><pre><code>// suitableCallbacks iterates over the methods of the given type. It will determine if a method satisfies the criteria// for a RPC callback or a subscription callback and adds it to the collection of callbacks or subscriptions. See server// documentation for a summary of these criteria.func suitableCallbacks(rcvr reflect.Value, typ reflect.Type) (callbacks, subscriptions) {    callbacks := make(callbacks)    subscriptions := make(subscriptions)METHODS:    for m := 0; m &lt; typ.NumMethod(); m++ {        method := typ.Method(m)        mtype := method.Type        mname := formatName(method.Name)        if method.PkgPath != "" { // method must be exported            continue        }        var h callback        h.isSubscribe = isPubSub(mtype)        h.rcvr = rcvr        h.method = method        h.errPos = -1        firstArg := 1        numIn := mtype.NumIn()        if numIn &gt;= 2 &amp;&amp; mtype.In(1) == contextType {            h.hasCtx = true            firstArg = 2        }        if h.isSubscribe {            h.argTypes = make([]reflect.Type, numIn-firstArg) // skip rcvr type            for i := firstArg; i &lt; numIn; i++ {                argType := mtype.In(i)                if isExportedOrBuiltinType(argType) {                    h.argTypes[i-firstArg] = argType                } else {                    continue METHODS                }            }            subscriptions[mname] = &amp;h            continue METHODS        }        // determine method arguments, ignore first arg since it's the receiver type        // Arguments must be exported or builtin types        h.argTypes = make([]reflect.Type, numIn-firstArg)        for i := firstArg; i &lt; numIn; i++ {            argType := mtype.In(i)            if !isExportedOrBuiltinType(argType) {                continue METHODS            }            h.argTypes[i-firstArg] = argType        }        // check that all returned values are exported or builtin types        for i := 0; i &lt; mtype.NumOut(); i++ {            if !isExportedOrBuiltinType(mtype.Out(i)) {                continue METHODS            }        }        // when a method returns an error it must be the last returned value        h.errPos = -1        for i := 0; i &lt; mtype.NumOut(); i++ {            if isErrorType(mtype.Out(i)) {                h.errPos = i                break            }        }        if h.errPos &gt;= 0 &amp;&amp; h.errPos != mtype.NumOut()-1 {            continue METHODS        }        switch mtype.NumOut() {        case 0, 1, 2:            if mtype.NumOut() == 2 &amp;&amp; h.errPos == -1 { // method must one return value and 1 error                continue METHODS            }            callbacks[mname] = &amp;h        }    }    return callbacks, subscriptions}</code></pre><p>serverå¯åŠ¨å’ŒæœåŠ¡ï¼Œ serverçš„å¯åŠ¨å’ŒæœåŠ¡è¿™é‡Œå‚è€ƒipc.goä¸­çš„ä¸€éƒ¨åˆ†ä»£ç ã€‚å¯ä»¥çœ‹åˆ°æ¯Accept()ä¸€ä¸ªé“¾æ¥ï¼Œå°±å¯åŠ¨ä¸€ä¸ªgoroutineè°ƒç”¨srv.ServeCodecæ¥è¿›è¡ŒæœåŠ¡ï¼Œè¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡ºJsonCodecçš„åŠŸèƒ½ï¼ŒCodecç±»ä¼¼äºè£…é¥°å™¨æ¨¡å¼ï¼Œåœ¨è¿æ¥å¤–é¢åŒ…äº†ä¸€å±‚ã€‚Codecä¼šæ”¾åœ¨åç»­æ¥ä»‹ç»ï¼Œè¿™é‡Œå…ˆç®€å•äº†è§£ä¸€ä¸‹ã€‚</p><pre><code>func (srv *Server) ServeListener(l net.Listener) error {    for {        conn, err := l.Accept()        if err != nil {            return err        }        log.Trace(fmt.Sprint("accepted conn", conn.RemoteAddr()))        go srv.ServeCodec(NewJSONCodec(conn), OptionMethodInvocation|OptionSubscriptions)    }}</code></pre><p>ServeCodec, è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ï¼Œæä¾›äº†codec.Closeçš„å…³é—­åŠŸèƒ½ã€‚ serveRequestçš„ç¬¬äºŒä¸ªå‚æ•°singleShotæ˜¯æ§åˆ¶é•¿è¿æ¥è¿˜æ˜¯çŸ­è¿æ¥çš„å‚æ•°ï¼Œå¦‚æœsingleShotä¸ºçœŸï¼Œé‚£ä¹ˆå¤„ç†å®Œä¸€ä¸ªè¯·æ±‚ä¹‹åä¼šé€€å‡ºã€‚ ä¸è¿‡å’±ä»¬çš„serveRequestæ–¹æ³•æ˜¯ä¸€ä¸ªæ­»å¾ªç¯ï¼Œä¸é‡åˆ°å¼‚å¸¸ï¼Œæˆ–è€…å®¢æˆ·ç«¯ä¸»åŠ¨å…³é—­ï¼ŒæœåŠ¡ç«¯æ˜¯ä¸ä¼šå…³é—­çš„ã€‚ æ‰€ä»¥rpcæä¾›çš„æ˜¯é•¿è¿æ¥çš„åŠŸèƒ½ã€‚</p><pre><code>// ServeCodec reads incoming requests from codec, calls the appropriate callback and writes the// response back using the given codec. It will block until the codec is closed or the server is// stopped. In either case the codec is closed.func (s *Server) ServeCodec(codec ServerCodec, options CodecOption) {    defer codec.Close()    s.serveRequest(codec, false, options)}</code></pre><p>æˆ‘ä»¬çš„é‡ç£…æ–¹æ³•ç»ˆäºå‡ºåœºï¼ŒserveRequest è¿™ä¸ªæ–¹æ³•å°±æ˜¯Serverçš„ä¸»è¦å¤„ç†æµç¨‹ã€‚ä»codecè¯»å–è¯·æ±‚ï¼Œæ‰¾åˆ°å¯¹åº”çš„æ–¹æ³•å¹¶è°ƒç”¨ï¼Œç„¶åæŠŠå›åº”å†™å…¥codecã€‚</p><p>éƒ¨åˆ†æ ‡å‡†åº“çš„ä»£ç å¯ä»¥å‚è€ƒç½‘ä¸Šçš„ä½¿ç”¨æ•™ç¨‹ï¼Œ sync.WaitGroup å®ç°äº†ä¸€ä¸ªä¿¡å·é‡çš„åŠŸèƒ½ã€‚ Contextå®ç°ä¸Šä¸‹æ–‡ç®¡ç†ã€‚</p><pre><code>// serveRequest will reads requests from the codec, calls the RPC callback and// writes the response to the given codec.//// If singleShot is true it will process a single request, otherwise it will handle// requests until the codec returns an error when reading a request (in most cases// an EOF). It executes requests in parallel when singleShot is false.func (s *Server) serveRequest(codec ServerCodec, singleShot bool, options CodecOption) error {    var pend sync.WaitGroup    defer func() {        if err := recover(); err != nil {            const size = 64 &lt;&lt; 10            buf := make([]byte, size)            buf = buf[:runtime.Stack(buf, false)]            log.Error(string(buf))        }        s.codecsMu.Lock()        s.codecs.Remove(codec)        s.codecsMu.Unlock()    }()    ctx, cancel := context.WithCancel(context.Background())    defer cancel()    // if the codec supports notification include a notifier that callbacks can use    // to send notification to clients. It is thight to the codec/connection. If the    // connection is closed the notifier will stop and cancels all active subscriptions.    if options&amp;OptionSubscriptions == OptionSubscriptions {        ctx = context.WithValue(ctx, notifierKey{}, newNotifier(codec))    }    s.codecsMu.Lock()    if atomic.LoadInt32(&amp;s.run) != 1 { // server stopped        s.codecsMu.Unlock()        return &amp;shutdownError{}    }    s.codecs.Add(codec)    s.codecsMu.Unlock()    // test if the server is ordered to stop    for atomic.LoadInt32(&amp;s.run) == 1 {        reqs, batch, err := s.readRequest(codec)        if err != nil {            // If a parsing error occurred, send an error            if err.Error() != "EOF" {                log.Debug(fmt.Sprintf("read error %v\n", err))                codec.Write(codec.CreateErrorResponse(nil, err))            }            // Error or end of stream, wait for requests and tear down            //è¿™é‡Œä¸»è¦æ˜¯è€ƒè™‘å¤šçº¿ç¨‹å¤„ç†çš„æ—¶å€™ç­‰å¾…æ‰€æœ‰çš„requestå¤„ç†å®Œæ¯•ï¼Œ            //æ¯å¯åŠ¨ä¸€ä¸ªgoçº¿ç¨‹ä¼šè°ƒç”¨pend.Add(1)ã€‚             //å¤„ç†å®Œæˆåè°ƒç”¨pend.Done()ä¼šå‡å»1ã€‚å½“ä¸º0çš„æ—¶å€™ï¼ŒWait()æ–¹æ³•å°±ä¼šè¿”å›ã€‚            pend.Wait()            return nil        }        // check if server is ordered to shutdown and return an error        // telling the client that his request failed.        if atomic.LoadInt32(&amp;s.run) != 1 {            err = &amp;shutdownError{}            if batch {                resps := make([]interface{}, len(reqs))                for i, r := range reqs {                    resps[i] = codec.CreateErrorResponse(&amp;r.id, err)                }                codec.Write(resps)            } else {                codec.Write(codec.CreateErrorResponse(&amp;reqs[0].id, err))            }            return nil        }        // If a single shot request is executing, run and return immediately        //å¦‚æœåªæ‰§è¡Œä¸€æ¬¡ï¼Œé‚£ä¹ˆæ‰§è¡Œå®Œæˆåè¿”å›ã€‚        if singleShot {            if batch {                s.execBatch(ctx, codec, reqs)            } else {                s.exec(ctx, codec, reqs[0])            }            return nil        }        // For multi-shot connections, start a goroutine to serve and loop back        pend.Add(1)        //å¯åŠ¨çº¿ç¨‹å¯¹è¯·æ±‚è¿›è¡ŒæœåŠ¡ã€‚        go func(reqs []*serverRequest, batch bool) {            defer pend.Done()            if batch {                s.execBatch(ctx, codec, reqs)            } else {                s.exec(ctx, codec, reqs[0])            }        }(reqs, batch)    }    return nil}</code></pre><p>readRequestæ–¹æ³•ï¼Œä»codecè¯»å–è¯·æ±‚ï¼Œç„¶åæ ¹æ®è¯·æ±‚æŸ¥æ‰¾å¯¹åº”çš„æ–¹æ³•ç»„è£…æˆrequestså¯¹è±¡ã€‚<br>rpcRequestæ˜¯codecè¿”å›çš„è¯·æ±‚ç±»å‹ã€‚j</p><pre><code>type rpcRequest struct {    service  string    method   string    id       interface{}    isPubSub bool    params   interface{}    err      Error // invalid batch element}</code></pre><p>serverRequestè¿›è¡Œå¤„ç†ä¹‹åè¿”å›çš„request</p><pre><code>// serverRequest is an incoming requesttype serverRequest struct {    id            interface{}    svcname       string    callb         *callback    args          []reflect.Value    isUnsubscribe bool    err           Error}</code></pre><p>readRequestæ–¹æ³•ï¼Œä»codecè¯»å–è¯·æ±‚ï¼Œå¯¹è¯·æ±‚è¿›è¡Œå¤„ç†ç”ŸæˆserverRequestå¯¹è±¡è¿”å›ã€‚</p><pre><code>// readRequest requests the next (batch) request from the codec. It will return the collection// of requests, an indication if the request was a batch, the invalid request identifier and an// error when the request could not be read/parsed.func (s *Server) readRequest(codec ServerCodec) ([]*serverRequest, bool, Error) {    reqs, batch, err := codec.ReadRequestHeaders()    if err != nil {        return nil, batch, err    }    requests := make([]*serverRequest, len(reqs))    // æ ¹æ®reqsæ„å»ºrequests    // verify requests    for i, r := range reqs {        var ok bool        var svc *service        if r.err != nil {            requests[i] = &amp;serverRequest{id: r.id, err: r.err}            continue        }        //å¦‚æœè¯·æ±‚æ˜¯å‘é€/è®¢é˜…æ–¹é¢çš„è¯·æ±‚ï¼Œè€Œä¸”æ–¹æ³•åç§°æœ‰_unsubscribeåç¼€ã€‚        if r.isPubSub &amp;&amp; strings.HasSuffix(r.method, unsubscribeMethodSuffix) {            requests[i] = &amp;serverRequest{id: r.id, isUnsubscribe: true}            argTypes := []reflect.Type{reflect.TypeOf("")} // expect subscription id as first arg            if args, err := codec.ParseRequestArguments(argTypes, r.params); err == nil {                requests[i].args = args            } else {                requests[i].err = &amp;invalidParamsError{err.Error()}            }            continue        }        //å¦‚æœæ²¡æœ‰æ³¨å†Œè¿™ä¸ªæœåŠ¡ã€‚        if svc, ok = s.services[r.service]; !ok { // rpc method isn't available            requests[i] = &amp;serverRequest{id: r.id, err: &amp;methodNotFoundError{r.service, r.method}}            continue        }        //å¦‚æœæ˜¯å‘å¸ƒå’Œè®¢é˜…æ¨¡å¼ã€‚ è°ƒç”¨è®¢é˜…æ–¹æ³•ã€‚        if r.isPubSub { // eth_subscribe, r.method contains the subscription method name            if callb, ok := svc.subscriptions[r.method]; ok {                requests[i] = &amp;serverRequest{id: r.id, svcname: svc.name, callb: callb}                if r.params != nil &amp;&amp; len(callb.argTypes) &gt; 0 {                    argTypes := []reflect.Type{reflect.TypeOf("")}                    argTypes = append(argTypes, callb.argTypes...)                    if args, err := codec.ParseRequestArguments(argTypes, r.params); err == nil {                        requests[i].args = args[1:] // first one is service.method name which isn't an actual argument                    } else {                        requests[i].err = &amp;invalidParamsError{err.Error()}                    }                }            } else {                requests[i] = &amp;serverRequest{id: r.id, err: &amp;methodNotFoundError{r.method, r.method}}            }            continue        }        if callb, ok := svc.callbacks[r.method]; ok { // lookup RPC method            requests[i] = &amp;serverRequest{id: r.id, svcname: svc.name, callb: callb}            if r.params != nil &amp;&amp; len(callb.argTypes) &gt; 0 {                if args, err := codec.ParseRequestArguments(callb.argTypes, r.params); err == nil {                    requests[i].args = args                } else {                    requests[i].err = &amp;invalidParamsError{err.Error()}                }            }            continue        }        requests[i] = &amp;serverRequest{id: r.id, err: &amp;methodNotFoundError{r.service, r.method}}    }    return requests, batch, nil}</code></pre><p>execå’ŒexecBatchæ–¹æ³•,è°ƒç”¨s.handleæ–¹æ³•å¯¹requestè¿›è¡Œå¤„ç†ã€‚</p><pre><code>// exec executes the given request and writes the result back using the codec.func (s *Server) exec(ctx context.Context, codec ServerCodec, req *serverRequest) {    var response interface{}    var callback func()    if req.err != nil {        response = codec.CreateErrorResponse(&amp;req.id, req.err)    } else {        response, callback = s.handle(ctx, codec, req)    }    if err := codec.Write(response); err != nil {        log.Error(fmt.Sprintf("%v\n", err))        codec.Close()    }    // when request was a subscribe request this allows these subscriptions to be actived    if callback != nil {        callback()    }}// execBatch executes the given requests and writes the result back using the codec.// It will only write the response back when the last request is processed.func (s *Server) execBatch(ctx context.Context, codec ServerCodec, requests []*serverRequest) {    responses := make([]interface{}, len(requests))    var callbacks []func()    for i, req := range requests {        if req.err != nil {            responses[i] = codec.CreateErrorResponse(&amp;req.id, req.err)        } else {            var callback func()            if responses[i], callback = s.handle(ctx, codec, req); callback != nil {                callbacks = append(callbacks, callback)            }        }    }    if err := codec.Write(responses); err != nil {        log.Error(fmt.Sprintf("%v\n", err))        codec.Close()    }    // when request holds one of more subscribe requests this allows these subscriptions to be activated    for _, c := range callbacks {        c()    }}</code></pre><p>handleæ–¹æ³•ï¼Œæ‰§è¡Œä¸€ä¸ªrequestï¼Œç„¶åè¿”å›response</p><pre><code>// handle executes a request and returns the response from the callback.func (s *Server) handle(ctx context.Context, codec ServerCodec, req *serverRequest) (interface{}, func()) {    if req.err != nil {        return codec.CreateErrorResponse(&amp;req.id, req.err), nil    }    //å¦‚æœæ˜¯å–æ¶ˆè®¢é˜…çš„æ¶ˆæ¯ã€‚NotifierFromContext(ctx)è·å–ä¹‹å‰æˆ‘ä»¬å­˜å…¥ctxçš„notifierã€‚    if req.isUnsubscribe { // cancel subscription, first param must be the subscription id        if len(req.args) &gt;= 1 &amp;&amp; req.args[0].Kind() == reflect.String {            notifier, supported := NotifierFromContext(ctx)            if !supported { // interface doesn't support subscriptions (e.g. http)                return codec.CreateErrorResponse(&amp;req.id, &amp;callbackError{ErrNotificationsUnsupported.Error()}), nil            }            subid := ID(req.args[0].String())            if err := notifier.unsubscribe(subid); err != nil {                return codec.CreateErrorResponse(&amp;req.id, &amp;callbackError{err.Error()}), nil            }            return codec.CreateResponse(req.id, true), nil        }        return codec.CreateErrorResponse(&amp;req.id, &amp;invalidParamsError{"Expected subscription id as first argument"}), nil    }    //å¦‚æœæ˜¯è®¢é˜…æ¶ˆæ¯ã€‚ é‚£ä¹ˆåˆ›å»ºè®¢é˜…ã€‚å¹¶æ¿€æ´»è®¢é˜…ã€‚    if req.callb.isSubscribe {        subid, err := s.createSubscription(ctx, codec, req)        if err != nil {            return codec.CreateErrorResponse(&amp;req.id, &amp;callbackError{err.Error()}), nil        }        // active the subscription after the sub id was successfully sent to the client        activateSub := func() {            notifier, _ := NotifierFromContext(ctx)            notifier.activate(subid, req.svcname)        }        return codec.CreateResponse(req.id, subid), activateSub    }    // regular RPC call, prepare arguments    if len(req.args) != len(req.callb.argTypes) {        rpcErr := &amp;invalidParamsError{fmt.Sprintf("%s%s%s expects %d parameters, got %d",            req.svcname, serviceMethodSeparator, req.callb.method.Name,            len(req.callb.argTypes), len(req.args))}        return codec.CreateErrorResponse(&amp;req.id, rpcErr), nil    }    arguments := []reflect.Value{req.callb.rcvr}    if req.callb.hasCtx {        arguments = append(arguments, reflect.ValueOf(ctx))    }    if len(req.args) &gt; 0 {        arguments = append(arguments, req.args...)    }    //è°ƒç”¨æä¾›çš„rpcæ–¹æ³•ï¼Œå¹¶è·å–reply    // execute RPC method and return result    reply := req.callb.method.Func.Call(arguments)    if len(reply) == 0 {        return codec.CreateResponse(req.id, nil), nil    }    if req.callb.errPos &gt;= 0 { // test if method returned an error        if !reply[req.callb.errPos].IsNil() {            e := reply[req.callb.errPos].Interface().(error)            res := codec.CreateErrorResponse(&amp;req.id, &amp;callbackError{e.Error()})            return res, nil        }    }    return codec.CreateResponse(req.id, reply[0].Interface()), nil}</code></pre><h3 id="subscription-go-å‘å¸ƒè®¢é˜…æ¨¡å¼ã€‚"><a href="#subscription-go-å‘å¸ƒè®¢é˜…æ¨¡å¼ã€‚" class="headerlink" title="subscription.go å‘å¸ƒè®¢é˜…æ¨¡å¼ã€‚"></a>subscription.go å‘å¸ƒè®¢é˜…æ¨¡å¼ã€‚</h3><p>åœ¨ä¹‹å‰çš„server.goä¸­å°±æœ‰å‡ºç°äº†ä¸€äº›å‘å¸ƒè®¢é˜…æ¨¡å¼çš„ä»£ç ï¼Œ åœ¨è¿™é‡Œé›†ä¸­é˜è¿°ä¸€ä¸‹ã€‚</p><p>æˆ‘ä»¬åœ¨serveRequestçš„ä»£ç ä¸­ï¼Œå°±æœ‰è¿™æ ·çš„ä»£ç ã€‚</p><pre><code>å¦‚æœcodecæ”¯æŒ, å¯ä»¥é€šè¿‡ä¸€ä¸ªå«notifierçš„å¯¹è±¡æ‰§è¡Œå›è°ƒå‡½æ•°å‘é€æ¶ˆæ¯ç»™å®¢æˆ·ç«¯ã€‚ä»–å’Œcodec/connectionå…³ç³»å¾ˆç´§å¯†ã€‚ å¦‚æœè¿æ¥è¢«å…³é—­ï¼Œé‚£ä¹ˆnotifierä¼šå…³é—­ï¼Œå¹¶å–æ¶ˆæ‰æ‰€æœ‰æ¿€æ´»çš„è®¢é˜…ã€‚// if the codec supports notification include a notifier that callbacks can use// to send notification to clients. It is thight to the codec/connection. If the// connection is closed the notifier will stop and cancels all active subscriptions.if options&amp;OptionSubscriptions == OptionSubscriptions {    ctx = context.WithValue(ctx, notifierKey{}, newNotifier(codec))}</code></pre><p>åœ¨æœåŠ¡ä¸€ä¸ªå®¢æˆ·ç«¯è¿æ¥æ—¶å€™ï¼Œè°ƒç”¨newNotifieræ–¹æ³•åˆ›å»ºäº†ä¸€ä¸ªnotifierå¯¹è±¡å­˜å‚¨åˆ°ctxä¸­ã€‚å¯ä»¥è§‚å¯Ÿåˆ°Notifierå¯¹è±¡ä¿å­˜äº†codecçš„å®ä¾‹ï¼Œä¹Ÿå°±æ˜¯è¯´Notifierå¯¹è±¡ä¿å­˜äº†ç½‘ç»œè¿æ¥ï¼Œç”¨æ¥åœ¨éœ€è¦çš„æ—¶å€™å‘é€æ•°æ®ã€‚</p><pre><code>// newNotifier creates a new notifier that can be used to send subscription// notifications to the client.func newNotifier(codec ServerCodec) *Notifier {    return &amp;Notifier{        codec:    codec,        active:   make(map[ID]*Subscription),        inactive: make(map[ID]*Subscription),    }}</code></pre><p>ç„¶ååœ¨handleæ–¹æ³•ä¸­ï¼Œ æˆ‘ä»¬å¤„ç†ä¸€ç±»ç‰¹æ®Šçš„æ–¹æ³•ï¼Œè¿™ç§æ–¹æ³•è¢«æ ‡è¯†ä¸ºisSubscribe. è°ƒç”¨createSubscriptionæ–¹æ³•åˆ›å»ºäº†äº†ä¸€ä¸ªSubscriptionå¹¶è°ƒç”¨notifier.activateæ–¹æ³•å­˜å‚¨åˆ°notifierçš„æ¿€æ´»é˜Ÿåˆ—é‡Œé¢ã€‚ ä»£ç é‡Œé¢æœ‰ä¸€ä¸ªæŠ€å·§ã€‚ è¿™ä¸ªæ–¹æ³•è°ƒç”¨å®Œæˆåå¹¶æ²¡æœ‰ç›´æ¥æ¿€æ´»subscriptionï¼Œè€Œæ˜¯æŠŠæ¿€æ´»éƒ¨åˆ†çš„ä»£ç ä½œä¸ºä¸€ä¸ªå‡½æ•°è¿”å›å›å»ã€‚ç„¶ååœ¨execæˆ–è€…execBatchä»£ç é‡Œé¢ç­‰å¾…codec.CreateResponse(req.id, subid)è¿™ä¸ªresponseè¢«å‘é€ç»™å®¢æˆ·ç«¯ä¹‹åè¢«è°ƒç”¨ã€‚é¿å…å®¢æˆ·ç«¯è¿˜æ²¡æœ‰æ”¶åˆ°subscription IDçš„æ—¶å€™å°±æ”¶åˆ°äº†subscriptionä¿¡æ¯ã€‚</p><pre><code>if req.callb.isSubscribe {    subid, err := s.createSubscription(ctx, codec, req)    if err != nil {        return codec.CreateErrorResponse(&amp;req.id, &amp;callbackError{err.Error()}), nil    }    // active the subscription after the sub id was successfully sent to the client    activateSub := func() {        notifier, _ := NotifierFromContext(ctx)        notifier.activate(subid, req.svcname)    }    return codec.CreateResponse(req.id, subid), activateSub}</code></pre><p>createSubscriptionæ–¹æ³•ä¼šè°ƒç”¨æŒ‡å®šçš„æ³¨å†Œä¸Šæ¥çš„æ–¹æ³•ï¼Œå¹¶å¾—åˆ°å›åº”ã€‚</p><pre><code>// createSubscription will call the subscription callback and returns the subscription id or error.func (s *Server) createSubscription(ctx context.Context, c ServerCodec, req *serverRequest) (ID, error) {    // subscription have as first argument the context following optional arguments    args := []reflect.Value{req.callb.rcvr, reflect.ValueOf(ctx)}    args = append(args, req.args...)    reply := req.callb.method.Func.Call(args)    if !reply[1].IsNil() { // subscription creation failed        return "", reply[1].Interface().(error)    }    return reply[0].Interface().(*Subscription).ID, nil}</code></pre><p>åœ¨æ¥çœ‹çœ‹æˆ‘ä»¬çš„activateæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æ¿€æ´»äº†subscriptionã€‚ subscriptionåœ¨subscription IDè¢«å‘é€ç»™å®¢æˆ·ç«¯ä¹‹åè¢«æ¿€æ´»ï¼Œé¿å…å®¢æˆ·ç«¯è¿˜æ²¡æœ‰æ”¶åˆ°subscription IDçš„æ—¶å€™å°±æ”¶åˆ°äº†subscriptionä¿¡æ¯ã€‚</p><pre><code>// activate enables a subscription. Until a subscription is enabled all// notifications are dropped. This method is called by the RPC server after// the subscription ID was sent to client. This prevents notifications being// send to the client before the subscription ID is send to the client.func (n *Notifier) activate(id ID, namespace string) {    n.subMu.Lock()    defer n.subMu.Unlock()    if sub, found := n.inactive[id]; found {        sub.namespace = namespace        n.active[id] = sub        delete(n.inactive, id)    }}</code></pre><p>æˆ‘ä»¬å†æ¥çœ‹ä¸€ä¸ªå–æ¶ˆè®¢é˜…çš„å‡½æ•°</p><pre><code>// unsubscribe a subscription.// If the subscription could not be found ErrSubscriptionNotFound is returned.func (n *Notifier) unsubscribe(id ID) error {    n.subMu.Lock()    defer n.subMu.Unlock()    if s, found := n.active[id]; found {        close(s.err)        delete(n.active, id)        return nil    }    return ErrSubscriptionNotFound}</code></pre><p>æœ€åæ˜¯ä¸€ä¸ªå‘é€è®¢é˜…çš„å‡½æ•°ï¼Œè°ƒç”¨è¿™ä¸ªå‡½æ•°æŠŠæ•°æ®å‘é€åˆ°å®¢æˆ·ç«¯ï¼Œ è¿™ä¸ªä¹Ÿæ¯”è¾ƒç®€å•ã€‚</p><pre><code>// Notify sends a notification to the client with the given data as payload.// If an error occurs the RPC connection is closed and the error is returned.func (n *Notifier) Notify(id ID, data interface{}) error {    n.subMu.RLock()    defer n.subMu.RUnlock()    sub, active := n.active[id]    if active {        notification := n.codec.CreateNotification(string(id), sub.namespace, data)        if err := n.codec.Write(notification); err != nil {            n.codec.Close()            return err        }    }    return nil}</code></pre><p>å¦‚ä½•ä½¿ç”¨å»ºè®®é€šè¿‡subscription_test.goçš„TestNotificationsæ¥æŸ¥çœ‹å®Œæ•´çš„æµç¨‹ã€‚</p><h3 id="client-go-RPCå®¢æˆ·ç«¯æºç åˆ†æã€‚"><a href="#client-go-RPCå®¢æˆ·ç«¯æºç åˆ†æã€‚" class="headerlink" title="client.go  RPCå®¢æˆ·ç«¯æºç åˆ†æã€‚"></a>client.go  RPCå®¢æˆ·ç«¯æºç åˆ†æã€‚</h3><p>å®¢æˆ·ç«¯çš„ä¸»è¦åŠŸèƒ½æ˜¯æŠŠè¯·æ±‚å‘é€åˆ°æœåŠ¡ç«¯ï¼Œç„¶åæ¥æ”¶å›åº”ï¼Œå†æŠŠå›åº”ä¼ é€’ç»™è°ƒç”¨è€…ã€‚</p><p>å®¢æˆ·ç«¯çš„æ•°æ®ç»“æ„</p><pre><code>// Client represents a connection to an RPC server.type Client struct {    idCounter   uint32    //ç”Ÿæˆè¿æ¥çš„å‡½æ•°ï¼Œå®¢æˆ·ç«¯ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ç”Ÿæˆä¸€ä¸ªç½‘ç»œè¿æ¥å¯¹è±¡ã€‚    connectFunc func(ctx context.Context) (net.Conn, error)    //HTTPåè®®å’ŒéHTTPåè®®æœ‰ä¸åŒçš„å¤„ç†æµç¨‹ï¼Œ HTTPåè®®ä¸æ”¯æŒé•¿è¿æ¥ï¼Œ åªæ”¯æŒä¸€ä¸ªè¯·æ±‚å¯¹åº”ä¸€ä¸ªå›åº”çš„è¿™ç§æ¨¡å¼ï¼ŒåŒæ—¶ä¹Ÿä¸æ”¯æŒå‘å¸ƒ/è®¢é˜…æ¨¡å¼ã€‚     isHTTP      bool    // writeConn is only safe to access outside dispatch, with the    // write lock held. The write lock is taken by sending on    // requestOp and released by sending on sendDone.    //é€šè¿‡è¿™é‡Œçš„æ³¨é‡Šå¯ä»¥çœ‹åˆ°ï¼ŒwriteConnæ˜¯è°ƒç”¨è¿™ç”¨æ¥å†™å…¥è¯·æ±‚çš„ç½‘ç»œè¿æ¥å¯¹è±¡ï¼Œ    //åªæœ‰åœ¨dispatchæ–¹æ³•å¤–é¢è°ƒç”¨æ‰æ˜¯å®‰å…¨çš„ï¼Œè€Œä¸”éœ€è¦é€šè¿‡ç»™requestOpé˜Ÿåˆ—å‘é€è¯·æ±‚æ¥è·å–é”ï¼Œ    //è·å–é”ä¹‹åå°±å¯ä»¥æŠŠè¯·æ±‚å†™å…¥ç½‘ç»œï¼Œå†™å…¥å®Œæˆåå‘é€è¯·æ±‚ç»™sendDoneé˜Ÿåˆ—æ¥é‡Šæ”¾é”ï¼Œä¾›å…¶å®ƒçš„è¯·æ±‚ä½¿ç”¨ã€‚    writeConn net.Conn    // for dispatch    //ä¸‹é¢æœ‰å¾ˆå¤šçš„channelï¼Œchannelä¸€èˆ¬æ¥è¯´æ˜¯goroutineä¹‹é—´ç”¨æ¥é€šä¿¡çš„é€šé“ï¼Œåç»­ä¼šéšç€ä»£ç ä»‹ç»channelæ˜¯å¦‚ä½•ä½¿ç”¨çš„ã€‚    close       chan struct{}    didQuit     chan struct{}                  // closed when client quits    reconnected chan net.Conn                  // where write/reconnect sends the new connection    readErr     chan error                     // errors from read    readResp    chan []*jsonrpcMessage         // valid messages from read    requestOp   chan *requestOp                // for registering response IDs    sendDone    chan error                     // signals write completion, releases write lock    respWait    map[string]*requestOp          // active requests    subs        map[string]*ClientSubscription // active subscriptions}</code></pre><p>newClientï¼Œ æ–°å»ºä¸€ä¸ªå®¢æˆ·ç«¯ã€‚ é€šè¿‡è°ƒç”¨connectFuncæ–¹æ³•æ¥è·å–ä¸€ä¸ªç½‘ç»œè¿æ¥ï¼Œå¦‚æœç½‘ç»œè¿æ¥æ˜¯httpConnå¯¹è±¡çš„åŒ–ï¼Œé‚£ä¹ˆisHTTPè®¾ç½®ä¸ºtrueã€‚ç„¶åæ˜¯å¯¹è±¡çš„åˆå§‹åŒ–ï¼Œ å¦‚æœæ˜¯HTTPè¿æ¥çš„åŒ–ï¼Œç›´æ¥è¿”å›ï¼Œå¦è€…å°±å¯åŠ¨ä¸€ä¸ªgoroutineè°ƒç”¨dispatchæ–¹æ³•ã€‚ dispatchæ–¹æ³•æ˜¯æ•´ä¸ªclientçš„æŒ‡æŒ¥ä¸­å¿ƒï¼Œé€šè¿‡ä¸Šé¢æåˆ°çš„channelæ¥å’Œå…¶ä»–çš„goroutineæ¥è¿›è¡Œé€šä¿¡ï¼Œè·å–ä¿¡æ¯ï¼Œæ ¹æ®ä¿¡æ¯åšå‡ºå„ç§å†³ç­–ã€‚åç»­ä¼šè¯¦ç»†ä»‹ç»dispatchã€‚ å› ä¸ºHTTPçš„è°ƒç”¨æ–¹å¼éå¸¸ç®€å•ï¼Œ è¿™é‡Œå…ˆå¯¹HTTPçš„æ–¹å¼åšä¸€ä¸ªç®€å•çš„é˜è¿°ã€‚</p><pre><code>func newClient(initctx context.Context, connectFunc func(context.Context) (net.Conn, error)) (*Client, error) {    conn, err := connectFunc(initctx)    if err != nil {        return nil, err    }    _, isHTTP := conn.(*httpConn)    c := &amp;Client{        writeConn:   conn,        isHTTP:      isHTTP,        connectFunc: connectFunc,        close:       make(chan struct{}),        didQuit:     make(chan struct{}),        reconnected: make(chan net.Conn),        readErr:     make(chan error),        readResp:    make(chan []*jsonrpcMessage),        requestOp:   make(chan *requestOp),        sendDone:    make(chan error, 1),        respWait:    make(map[string]*requestOp),        subs:        make(map[string]*ClientSubscription),    }    if !isHTTP {        go c.dispatch(conn)    }    return c, nil}</code></pre><p>è¯·æ±‚è°ƒç”¨é€šè¿‡è°ƒç”¨clientçš„ Callæ–¹æ³•æ¥è¿›è¡ŒRPCè°ƒç”¨ã€‚</p><pre><code>// Call performs a JSON-RPC call with the given arguments and unmarshals into// result if no error occurred.//// The result must be a pointer so that package json can unmarshal into it. You// can also pass nil, in which case the result is ignored.è¿”å›å€¼å¿…é¡»æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œè¿™æ ·æ‰èƒ½æŠŠjsonå€¼è½¬æ¢æˆå¯¹è±¡ã€‚ å¦‚æœä½ ä¸å…³å¿ƒè¿”å›å€¼ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä¼ nilæ¥å¿½ç•¥ã€‚func (c *Client) Call(result interface{}, method string, args ...interface{}) error {    ctx := context.Background()    return c.CallContext(ctx, result, method, args...)}func (c *Client) CallContext(ctx context.Context, result interface{}, method string, args ...interface{}) error {    msg, err := c.newMessage(method, args...)    if err != nil {        return err    }    //æ„å»ºäº†ä¸€ä¸ªrequestOpå¯¹è±¡ã€‚ respæ˜¯è¯»å–è¿”å›çš„é˜Ÿåˆ—ï¼Œé˜Ÿåˆ—çš„é•¿åº¦æ˜¯1ã€‚    op := &amp;requestOp{ids: []json.RawMessage{msg.ID}, resp: make(chan *jsonrpcMessage, 1)}        if c.isHTTP {        err = c.sendHTTP(ctx, op, msg)    } else {        err = c.send(ctx, op, msg)    }    if err != nil {        return err    }    // dispatch has accepted the request and will close the channel it when it quits.    switch resp, err := op.wait(ctx); {    case err != nil:        return err    case resp.Error != nil:        return resp.Error    case len(resp.Result) == 0:        return ErrNoResult    default:        return json.Unmarshal(resp.Result, &amp;result)    }}</code></pre><p>sendHTTP,è¿™ä¸ªæ–¹æ³•ç›´æ¥è°ƒç”¨doRequestæ–¹æ³•è¿›è¡Œè¯·æ±‚æ‹¿åˆ°å›åº”ã€‚ç„¶åå†™å…¥åˆ°respé˜Ÿåˆ—å°±è¿”å›äº†ã€‚</p><pre><code>func (c *Client) sendHTTP(ctx context.Context, op *requestOp, msg interface{}) error {    hc := c.writeConn.(*httpConn)    respBody, err := hc.doRequest(ctx, msg)    if err != nil {        return err    }    defer respBody.Close()    var respmsg jsonrpcMessage    if err := json.NewDecoder(respBody).Decode(&amp;respmsg); err != nil {        return err    }    op.resp &lt;- &amp;respmsg    return nil}</code></pre><p>åœ¨çœ‹çœ‹ä¸Šé¢çš„å¦ä¸€ä¸ªæ–¹æ³• op.wait()æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šæŸ¥çœ‹ä¸¤ä¸ªé˜Ÿåˆ—çš„ä¿¡æ¯ã€‚å¦‚æœæ˜¯httpé‚£ä¹ˆä»respé˜Ÿåˆ—è·å–åˆ°å›åº”å°±ä¼šç›´æ¥è¿”å›ã€‚ è¿™æ ·æ•´ä¸ªHTTPçš„è¯·æ±‚è¿‡ç¨‹å°±å®Œæˆäº†ã€‚ ä¸­é—´æ²¡æœ‰æ¶‰åŠåˆ°å¤šçº¿ç¨‹é—®é¢˜ï¼Œéƒ½åœ¨ä¸€ä¸ªçº¿ç¨‹å†…éƒ¨å®Œæˆäº†ã€‚</p><pre><code>func (op *requestOp) wait(ctx context.Context) (*jsonrpcMessage, error) {    select {    case &lt;-ctx.Done():        return nil, ctx.Err()    case resp := &lt;-op.resp:        return resp, op.err    }}</code></pre><p>å¦‚æœä¸æ˜¯HTTPè¯·æ±‚å‘¢ã€‚ é‚£å¤„ç†çš„æµç¨‹å°±æ¯”è¾ƒå¤æ‚äº†ï¼Œ è¿˜è®°å¾—å¦‚æœä¸æ˜¯HTTPè¯·æ±‚ã€‚åœ¨newClientçš„æ—¶å€™æ˜¯å¯åŠ¨äº†ä¸€ä¸ªgoroutine è°ƒç”¨äº†dispatchæ–¹æ³•ã€‚ æˆ‘ä»¬å…ˆçœ‹éhttpçš„ sendæ–¹æ³•ã€‚</p><p>ä»æ³¨é‡Šæ¥çœ‹ã€‚ è¿™ä¸ªæ–¹æ³•æŠŠopå†™å…¥åˆ°requestOpè¿™ä¸ªé˜Ÿåˆ—ï¼Œæ³¨æ„çš„æ˜¯è¿™ä¸ªé˜Ÿåˆ—æ˜¯æ²¡æœ‰ç¼“å†²åŒºçš„ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœè¿™ä¸ªæ—¶å€™è¿™ä¸ªé˜Ÿåˆ—æ²¡æœ‰äººå¤„ç†çš„åŒ–ï¼Œè¿™ä¸ªè°ƒç”¨æ˜¯ä¼šé˜»å¡åœ¨è¿™é‡Œçš„ã€‚ è¿™å°±ç›¸å½“äºä¸€æŠŠé”ï¼Œå¦‚æœå‘é€opåˆ°requestOpæˆåŠŸäº†å°±æ‹¿åˆ°äº†é”ï¼Œå¯ä»¥ç»§ç»­ä¸‹ä¸€æ­¥ï¼Œä¸‹ä¸€æ­¥æ˜¯è°ƒç”¨writeæ–¹æ³•æŠŠè¯·æ±‚çš„å…¨éƒ¨å†…å®¹å‘é€åˆ°ç½‘ç»œä¸Šã€‚ç„¶åå‘é€æ¶ˆæ¯ç»™sendDoneé˜Ÿåˆ—ã€‚sendDoneå¯ä»¥çœ‹æˆæ˜¯é”çš„é‡Šæ”¾ï¼Œåç»­åœ¨dispatchæ–¹æ³•é‡Œé¢ä¼šè¯¦ç»†åˆ†æè¿™ä¸ªè¿‡ç¨‹ã€‚ ç„¶åè¿”å›ã€‚è¿”å›ä¹‹åæ–¹æ³•ä¼šé˜»å¡åœ¨op.waitæ–¹æ³•é‡Œé¢ã€‚ç›´åˆ°ä»op.respé˜Ÿåˆ—æ”¶åˆ°ä¸€ä¸ªå›åº”ï¼Œæˆ–è€…æ˜¯æ”¶åˆ°ä¸€ä¸ªctx.Done()æ¶ˆæ¯(è¿™ä¸ªæ¶ˆæ¯ä¸€èˆ¬ä¼šåœ¨å®Œæˆæˆ–è€…æ˜¯å¼ºåˆ¶é€€å‡ºçš„æ—¶å€™è·å–åˆ°ã€‚)</p><pre><code>// send registers op with the dispatch loop, then sends msg on the connection.// if sending fails, op is deregistered.func (c *Client) send(ctx context.Context, op *requestOp, msg interface{}) error {    select {    case c.requestOp &lt;- op:        log.Trace("", "msg", log.Lazy{Fn: func() string {            return fmt.Sprint("sending ", msg)        }})        err := c.write(ctx, msg)        c.sendDone &lt;- err        return err    case &lt;-ctx.Done():        // This can happen if the client is overloaded or unable to keep up with        // subscription notifications.        return ctx.Err()    case &lt;-c.didQuit:        //å·²ç»é€€å‡ºï¼Œå¯èƒ½è¢«è°ƒç”¨äº†Close        return ErrClientQuit    }}</code></pre><p>dispatchæ–¹æ³•</p><pre><code>// dispatch is the main loop of the client.// It sends read messages to waiting calls to Call and BatchCall// and subscription notifications to registered subscriptions.func (c *Client) dispatch(conn net.Conn) {    // Spawn the initial read loop.    go c.read(conn)    var (        lastOp        *requestOp    // tracks last send operation        requestOpLock = c.requestOp // nil while the send lock is held        reading       = true        // if true, a read loop is running    )    defer close(c.didQuit)    defer func() {        c.closeRequestOps(ErrClientQuit)        conn.Close()        if reading {            // Empty read channels until read is dead.            for {                select {                case &lt;-c.readResp:                case &lt;-c.readErr:                    return                }            }        }    }()    for {        select {        case &lt;-c.close:            return        // Read path.        case batch := &lt;-c.readResp:            //è¯»å–åˆ°ä¸€ä¸ªå›åº”ã€‚è°ƒç”¨ç›¸åº”çš„æ–¹æ³•å¤„ç†            for _, msg := range batch {                switch {                case msg.isNotification():                    log.Trace("", "msg", log.Lazy{Fn: func() string {                        return fmt.Sprint("&lt;-readResp: notification ", msg)                    }})                    c.handleNotification(msg)                case msg.isResponse():                    log.Trace("", "msg", log.Lazy{Fn: func() string {                        return fmt.Sprint("&lt;-readResp: response ", msg)                    }})                    c.handleResponse(msg)                default:                    log.Debug("", "msg", log.Lazy{Fn: func() string {                        return fmt.Sprint("&lt;-readResp: dropping weird message", msg)                    }})                    // TODO: maybe close                }            }        case err := &lt;-c.readErr:            //æ¥æ”¶åˆ°è¯»å–å¤±è´¥ä¿¡æ¯ï¼Œè¿™ä¸ªæ˜¯readçº¿ç¨‹ä¼ é€’è¿‡æ¥çš„ã€‚            log.Debug(fmt.Sprintf("&lt;-readErr: %v", err))            c.closeRequestOps(err)            conn.Close()            reading = false        case newconn := &lt;-c.reconnected:            //æ¥æ”¶åˆ°ä¸€ä¸ªé‡è¿æ¥ä¿¡æ¯            log.Debug(fmt.Sprintf("&lt;-reconnected: (reading=%t) %v", reading, conn.RemoteAddr()))            if reading {                //ç­‰å¾…ä¹‹å‰çš„è¿æ¥è¯»å–å®Œæˆã€‚                // Wait for the previous read loop to exit. This is a rare case.                conn.Close()                &lt;-c.readErr            }            //å¼€å¯é˜…è¯»çš„goroutine            go c.read(newconn)            reading = true            conn = newconn        // Send path.        case op := &lt;-requestOpLock:            // Stop listening for further send ops until the current one is done.            //æ¥æ”¶åˆ°ä¸€ä¸ªrequestOpæ¶ˆæ¯ï¼Œé‚£ä¹ˆè®¾ç½®requestOpLockä¸ºç©ºï¼Œ            //è¿™ä¸ªæ—¶å€™å¦‚æœæœ‰å…¶ä»–äººä¹Ÿå¸Œæœ›å‘é€opåˆ°requestOpï¼Œä¼šå› ä¸ºæ²¡æœ‰äººå¤„ç†è€Œé˜»å¡ã€‚            requestOpLock = nil            lastOp = op            //æŠŠè¿™ä¸ªopåŠ å…¥ç­‰å¾…é˜Ÿåˆ—ã€‚            for _, id := range op.ids {                c.respWait[string(id)] = op            }        case err := &lt;-c.sendDone:            //å½“opçš„è¯·æ±‚ä¿¡æ¯å·²ç»å‘é€åˆ°ç½‘ç»œä¸Šã€‚ä¼šå‘é€ä¿¡æ¯åˆ°sendDoneã€‚å¦‚æœå‘é€è¿‡ç¨‹å‡ºé”™ï¼Œé‚£ä¹ˆerr !=nilã€‚            if err != nil {                // Remove response handlers for the last send. We remove those here                // because the error is already handled in Call or BatchCall. When the                // read loop goes down, it will signal all other current operations.                //æŠŠæ‰€æœ‰çš„idä»ç­‰å¾…é˜Ÿåˆ—åˆ é™¤ã€‚                for _, id := range lastOp.ids {                    delete(c.respWait, string(id))                }            }            // Listen for send ops again.            //é‡æ–°å¼€å§‹å¤„ç†requestOpçš„æ¶ˆæ¯ã€‚            requestOpLock = c.requestOp            lastOp = nil        }    }}</code></pre><p>ä¸‹é¢é€šè¿‡ä¸‹é¢è¿™ç§å›¾æ¥è¯´æ˜dispatchçš„ä¸»è¦æµç¨‹ã€‚ä¸‹é¢å›¾ç‰‡ä¸­åœ†å½¢æ˜¯çº¿ç¨‹ã€‚ è“è‰²çŸ©å½¢æ˜¯channelã€‚ ç®­å¤´ä»£è¡¨äº†channelçš„æ•°æ®æµåŠ¨æ–¹å‘ã€‚</p><p>[å¤–é“¾å›¾ç‰‡è½¬å­˜å¤±è´¥,æºç«™å¯èƒ½æœ‰é˜²ç›—é“¾æœºåˆ¶,å»ºè®®å°†å›¾ç‰‡ä¿å­˜ä¸‹æ¥ç›´æ¥ä¸Šä¼ (img-M5kvNmUc-1625486180224)(picture/rpc_2.png)]</p><ul><li>å¤šçº¿ç¨‹ä¸²è¡Œå‘é€è¯·æ±‚åˆ°ç½‘ç»œä¸Šçš„æµç¨‹ é¦–å…ˆå‘é€requestOpè¯·æ±‚åˆ°dispatchè·å–åˆ°é”ï¼Œ ç„¶åæŠŠè¯·æ±‚ä¿¡æ¯å†™å…¥åˆ°ç½‘ç»œï¼Œç„¶åå‘é€sendDoneä¿¡æ¯åˆ°dispatchè§£é™¤é”ã€‚ é€šè¿‡requestOpå’ŒsendDoneè¿™ä¸¤ä¸ªchannelä»¥åŠdispatchä»£ç çš„é…åˆå®Œæˆäº†ä¸²è¡Œçš„å‘é€è¯·æ±‚åˆ°ç½‘ç»œä¸Šçš„åŠŸèƒ½ã€‚</li><li>è¯»å–è¿”å›ä¿¡æ¯ç„¶åè¿”å›ç»™è°ƒç”¨è€…çš„æµç¨‹ã€‚ æŠŠè¯·æ±‚ä¿¡æ¯å‘é€åˆ°ç½‘ç»œä¸Šä¹‹åï¼Œ å†…éƒ¨çš„goroutine readä¼šæŒç»­ä¸æ–­çš„ä»ç½‘ç»œä¸Šè¯»å–ä¿¡æ¯ã€‚ readè¯»å–åˆ°è¿”å›ä¿¡æ¯ä¹‹åï¼Œé€šè¿‡readRespé˜Ÿåˆ—å‘é€ç»™dispatchã€‚ dispatchæŸ¥æ‰¾åˆ°å¯¹åº”çš„è°ƒç”¨è€…ï¼Œç„¶åæŠŠè¿”å›ä¿¡æ¯å†™å…¥è°ƒç”¨è€…çš„respé˜Ÿåˆ—ä¸­ã€‚å®Œæˆè¿”å›ä¿¡æ¯çš„æµç¨‹ã€‚</li><li>é‡è¿æ¥æµç¨‹ã€‚ é‡è¿æ¥åœ¨å¤–éƒ¨è°ƒç”¨è€…å†™å…¥å¤±è´¥çš„æƒ…å†µä¸‹è¢«å¤–éƒ¨è°ƒç”¨è€…ä¸»åŠ¨è°ƒç”¨ã€‚ è°ƒç”¨å®Œæˆåå‘é€æ–°çš„è¿æ¥ç»™dispatchã€‚ dispatchæ”¶åˆ°æ–°çš„è¿æ¥ä¹‹åï¼Œä¼šç»ˆæ­¢ä¹‹å‰çš„è¿æ¥ï¼Œç„¶åå¯åŠ¨æ–°çš„read goroutineæ¥ä»æ–°çš„è¿æ¥ä¸Šè¯»å–ä¿¡æ¯ã€‚</li><li>å…³é—­æµç¨‹ã€‚ è°ƒç”¨è€…è°ƒç”¨Closeæ–¹æ³•ï¼ŒCloseæ–¹æ³•ä¼šå†™å…¥ä¿¡æ¯åˆ°closeé˜Ÿåˆ—ã€‚ dispatchæ¥æ”¶åˆ°closeä¿¡æ¯ä¹‹åã€‚ å…³é—­didQuité˜Ÿåˆ—ï¼Œå…³é—­è¿æ¥ï¼Œç­‰å¾…read goroutineåœæ­¢ã€‚ æ‰€æœ‰ç­‰å¾…åœ¨didQuité˜Ÿåˆ—ä¸Šé¢çš„å®¢æˆ·ç«¯è°ƒç”¨å…¨éƒ¨è¿”å›ã€‚</li></ul><h4 id="å®¢æˆ·ç«¯-è®¢é˜…æ¨¡å¼çš„ç‰¹æ®Šå¤„ç†"><a href="#å®¢æˆ·ç«¯-è®¢é˜…æ¨¡å¼çš„ç‰¹æ®Šå¤„ç†" class="headerlink" title="å®¢æˆ·ç«¯ è®¢é˜…æ¨¡å¼çš„ç‰¹æ®Šå¤„ç†"></a>å®¢æˆ·ç«¯ è®¢é˜…æ¨¡å¼çš„ç‰¹æ®Šå¤„ç†</h4><p>ä¸Šé¢æåˆ°çš„ä¸»è¦æµç¨‹æ˜¯æ–¹æ³•è°ƒç”¨çš„æµç¨‹ã€‚ ä»¥å¤ªåŠçš„RPCæ¡†æ¶è¿˜æ”¯æŒå‘å¸ƒå’Œè®¢é˜…çš„æ¨¡å¼ã€‚</p><p>æˆ‘ä»¬å…ˆçœ‹çœ‹è®¢é˜…çš„æ–¹æ³•ï¼Œä»¥å¤ªåŠæä¾›äº†å‡ ç§ä¸»è¦serviceçš„è®¢é˜…æ–¹å¼(EthSubscribe ShhSubscribe).åŒæ—¶ä¹Ÿæä¾›äº†è‡ªå®šä¹‰æœåŠ¡çš„è®¢é˜…æ–¹æ³•(Subscribe)ï¼Œ</p><pre><code>// EthSubscribe registers a subscripion under the "eth" namespace.func (c *Client) EthSubscribe(ctx context.Context, channel interface{}, args ...interface{}) (*ClientSubscription, error) {    return c.Subscribe(ctx, "eth", channel, args...)}// ShhSubscribe registers a subscripion under the "shh" namespace.func (c *Client) ShhSubscribe(ctx context.Context, channel interface{}, args ...interface{}) (*ClientSubscription, error) {    return c.Subscribe(ctx, "shh", channel, args...)}// Subscribe calls the "&lt;namespace&gt;_subscribe" method with the given arguments,// registering a subscription. Server notifications for the subscription are// sent to the given channel. The element type of the channel must match the// expected type of content returned by the subscription.//// The context argument cancels the RPC request that sets up the subscription but has no// effect on the subscription after Subscribe has returned.//// Slow subscribers will be dropped eventually. Client buffers up to 8000 notifications// before considering the subscriber dead. The subscription Err channel will receive// ErrSubscriptionQueueOverflow. Use a sufficiently large buffer on the channel or ensure// that the channel usually has at least one reader to prevent this issue.//Subscribeä¼šä½¿ç”¨ä¼ å…¥çš„å‚æ•°è°ƒç”¨"&lt;namespace&gt;_subscribe"æ–¹æ³•æ¥è®¢é˜…æŒ‡å®šçš„æ¶ˆæ¯ã€‚ //æœåŠ¡å™¨çš„é€šçŸ¥ä¼šå†™å…¥channelå‚æ•°æŒ‡å®šçš„é˜Ÿåˆ—ã€‚ channelå‚æ•°å¿…é¡»å’Œè¿”å›çš„ç±»å‹ç›¸åŒã€‚ //ctxå‚æ•°å¯ä»¥ç”¨æ¥å–æ¶ˆRPCçš„è¯·æ±‚ï¼Œä½†æ˜¯å¦‚æœè®¢é˜…å·²ç»å®Œæˆå°±ä¸ä¼šæœ‰æ•ˆæœäº†ã€‚ //å¤„ç†é€Ÿåº¦å¤ªæ…¢çš„è®¢é˜…è€…çš„æ¶ˆæ¯ä¼šè¢«åˆ é™¤ï¼Œæ¯ä¸ªå®¢æˆ·ç«¯æœ‰8000ä¸ªæ¶ˆæ¯çš„ç¼“å­˜ã€‚func (c *Client) Subscribe(ctx context.Context, namespace string, channel interface{}, args ...interface{}) (*ClientSubscription, error) {    // Check type of channel first.    chanVal := reflect.ValueOf(channel)    if chanVal.Kind() != reflect.Chan || chanVal.Type().ChanDir()&amp;reflect.SendDir == 0 {        panic("first argument to Subscribe must be a writable channel")    }    if chanVal.IsNil() {        panic("channel given to Subscribe must not be nil")    }    if c.isHTTP {        return nil, ErrNotificationsUnsupported    }    msg, err := c.newMessage(namespace+subscribeMethodSuffix, args...)    if err != nil {        return nil, err    }    //requestOpçš„å‚æ•°å’ŒCallè°ƒç”¨çš„ä¸ä¸€æ ·ã€‚ å¤šäº†ä¸€ä¸ªå‚æ•°sub.    op := &amp;requestOp{        ids:  []json.RawMessage{msg.ID},        resp: make(chan *jsonrpcMessage),        sub:  newClientSubscription(c, namespace, chanVal),    }    // Send the subscription request.    // The arrival and validity of the response is signaled on sub.quit.    if err := c.send(ctx, op, msg); err != nil {        return nil, err    }    if _, err := op.wait(ctx); err != nil {        return nil, err    }    return op.sub, nil}</code></pre><p>newClientSubscriptionæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å¯¹è±¡ClientSubscriptionï¼Œè¿™ä¸ªå¯¹è±¡æŠŠä¼ å…¥çš„channelå‚æ•°ä¿å­˜èµ·æ¥ã€‚ ç„¶åè‡ªå·±åˆåˆ›å»ºäº†ä¸‰ä¸ªchanå¯¹è±¡ã€‚åç»­ä¼šå¯¹è¯¦ç»†ä»‹ç»è¿™ä¸‰ä¸ªchanå¯¹è±¡</p><pre><code>func newClientSubscription(c *Client, namespace string, channel reflect.Value) *ClientSubscription {    sub := &amp;ClientSubscription{        client:    c,        namespace: namespace,        etype:     channel.Type().Elem(),        channel:   channel,        quit:      make(chan struct{}),        err:       make(chan error, 1),        in:        make(chan json.RawMessage),    }    return sub}</code></pre><p>ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºã€‚è®¢é˜…è¿‡ç¨‹æ ¹Callè¿‡ç¨‹å·®ä¸å¤šï¼Œæ„å»ºä¸€ä¸ªè®¢é˜…è¯·æ±‚ã€‚è°ƒç”¨sendå‘é€åˆ°ç½‘ç»œä¸Šï¼Œç„¶åç­‰å¾…è¿”å›ã€‚ æˆ‘ä»¬é€šè¿‡dispatchå¯¹è¿”å›ç»“æœçš„å¤„ç†æ¥çœ‹çœ‹è®¢é˜…å’ŒCallçš„ä¸åŒã€‚</p><pre><code>func (c *Client) handleResponse(msg *jsonrpcMessage) {    op := c.respWait[string(msg.ID)]    if op == nil {        log.Debug(fmt.Sprintf("unsolicited response %v", msg))        return    }    delete(c.respWait, string(msg.ID))    // For normal responses, just forward the reply to Call/BatchCall.    å¦‚æœop.subæ˜¯nilï¼Œæ™®é€šçš„RPCè¯·æ±‚ï¼Œè¿™ä¸ªå­—æ®µçš„å€¼æ˜¯ç©ºç™½çš„ï¼Œåªæœ‰è®¢é˜…è¯·æ±‚æ‰æœ‰å€¼ã€‚    if op.sub == nil {        op.resp &lt;- msg        return    }    // For subscription responses, start the subscription if the server    // indicates success. EthSubscribe gets unblocked in either case through    // the op.resp channel.    defer close(op.resp)    if msg.Error != nil {        op.err = msg.Error        return    }    if op.err = json.Unmarshal(msg.Result, &amp;op.sub.subid); op.err == nil {        //å¯åŠ¨ä¸€ä¸ªæ–°çš„goroutine å¹¶æŠŠop.sub.subidè®°å½•èµ·æ¥ã€‚        go op.sub.start()        c.subs[op.sub.subid] = op.sub    }}</code></pre><p>op.sub.startæ–¹æ³•ã€‚ è¿™ä¸ªgoroutineä¸“é—¨ç”¨æ¥å¤„ç†è®¢é˜…æ¶ˆæ¯ã€‚ä¸»è¦çš„åŠŸèƒ½æ˜¯ä»iné˜Ÿåˆ—é‡Œé¢è·å–è®¢é˜…æ¶ˆæ¯ï¼Œç„¶åæŠŠè®¢é˜…æ¶ˆæ¯æ”¾åˆ°bufferé‡Œé¢ã€‚ å¦‚æœèƒ½å¤Ÿæ•°æ®èƒ½å¤Ÿå‘é€ã€‚å°±ä»bufferé‡Œé¢å‘é€ä¸€äº›æ•°æ®ç»™ç”¨æˆ·ä¼ å…¥çš„é‚£ä¸ªchannelã€‚ å¦‚æœbufferè¶…è¿‡æŒ‡å®šçš„å¤§å°ï¼Œå°±ä¸¢å¼ƒã€‚</p><pre><code>func (sub *ClientSubscription) start() {    sub.quitWithError(sub.forward())}func (sub *ClientSubscription) forward() (err error, unsubscribeServer bool) {    cases := []reflect.SelectCase{        {Dir: reflect.SelectRecv, Chan: reflect.ValueOf(sub.quit)},        {Dir: reflect.SelectRecv, Chan: reflect.ValueOf(sub.in)},        {Dir: reflect.SelectSend, Chan: sub.channel},    }    buffer := list.New()    defer buffer.Init()    for {        var chosen int        var recv reflect.Value        if buffer.Len() == 0 {            // Idle, omit send case.            chosen, recv, _ = reflect.Select(cases[:2])        } else {            // Non-empty buffer, send the first queued item.            cases[2].Send = reflect.ValueOf(buffer.Front().Value)            chosen, recv, _ = reflect.Select(cases)        }        switch chosen {        case 0: // &lt;-sub.quit            return nil, false        case 1: // &lt;-sub.in            val, err := sub.unmarshal(recv.Interface().(json.RawMessage))            if err != nil {                return err, true            }            if buffer.Len() == maxClientSubscriptionBuffer {                return ErrSubscriptionQueueOverflow, true            }            buffer.PushBack(val)        case 2: // sub.channel&lt;-            cases[2].Send = reflect.Value{} // Don't hold onto the value.            buffer.Remove(buffer.Front())        }    }}</code></pre><p>å½“æ¥æ”¶åˆ°ä¸€æ¡Notificationæ¶ˆæ¯çš„æ—¶å€™ä¼šè°ƒç”¨handleNotificationæ–¹æ³•ã€‚ä¼šæŠŠæ¶ˆæ¯ä¼ é€ç»™iné˜Ÿåˆ—ã€‚</p><pre><code>func (c *Client) handleNotification(msg *jsonrpcMessage) {    if !strings.HasSuffix(msg.Method, notificationMethodSuffix) {        log.Debug(fmt.Sprint("dropping non-subscription message: ", msg))        return    }    var subResult struct {        ID     string          `json:"subscription"`        Result json.RawMessage `json:"result"`    }    if err := json.Unmarshal(msg.Params, &amp;subResult); err != nil {        log.Debug(fmt.Sprint("dropping invalid subscription message: ", msg))        return    }    if c.subs[subResult.ID] != nil {        c.subs[subResult.ID].deliver(subResult.Result)    }}func (sub *ClientSubscription) deliver(result json.RawMessage) (ok bool) {    select {    case sub.in &lt;- result:        return true    case &lt;-sub.quit:        return false    }}</code></pre><h1 id="å‚è€ƒèµ„æ–™åœ°å€"><a href="#å‚è€ƒèµ„æ–™åœ°å€" class="headerlink" title="å‚è€ƒèµ„æ–™åœ°å€"></a>å‚è€ƒèµ„æ–™åœ°å€</h1><ul><li><a href="https://ethereum.org/en/whitepaper">ä»¥å¤ªåŠç™½çš®ä¹¦</a></li><li><a href="https://ethereum.github.io/yellowpaper/paper.pdf">ä»¥å¤ªåŠé»„çš®ä¹¦ï¼ˆè‹±æ–‡ç‰ˆï¼‰</a></li><li><a href="https://github.com/wanshan1024/ethereum_yellowpaper/blob/master/ethereum_yellow_paper_cn.pdf">ä»¥å¤ªåŠé»„çš®ä¹¦ï¼ˆä¸­æ–‡ç‰ˆï¼‰</a></li><li><a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis">åˆ†æå‚è€ƒèµ„æ–™</a></li><li><a href="https://segmentfault.com/a/1190000016050921">åšå®¢å‚è€ƒèµ„æ–™</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-ethdbæºç åˆ†æ</title>
      <link href="/2021/06/05/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ethdb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/06/05/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ethdb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ç‰ˆæœ¬è¯´æ˜"><a href="#ç‰ˆæœ¬è¯´æ˜" class="headerlink" title="ç‰ˆæœ¬è¯´æ˜"></a>ç‰ˆæœ¬è¯´æ˜</h1><p>æºç åˆ†æä½¿ç”¨çš„ç‰ˆæœ¬ä¸ºï¼š<a href="https://github.com/ethereum/go-ethereum/tree/v1.10.3">v1.10.3</a></p><h1 id="ethdbæºç åˆ†æ"><a href="#ethdbæºç åˆ†æ" class="headerlink" title="ethdbæºç åˆ†æ"></a>ethdbæºç åˆ†æ</h1><p>go-ethereumæ‰€æœ‰çš„æ•°æ®å­˜å‚¨åœ¨levelDBè¿™ä¸ªGoogleå¼€æºçš„KeyValueæ–‡ä»¶æ•°æ®åº“ä¸­ï¼Œæ•´ä¸ªåŒºå—é“¾çš„æ‰€æœ‰æ•°æ®éƒ½å­˜å‚¨åœ¨ä¸€ä¸ªlevelDBçš„æ•°æ®åº“ä¸­ï¼ŒlevelDBæ”¯æŒæŒ‰ç…§æ–‡ä»¶å¤§å°åˆ‡åˆ†æ–‡ä»¶çš„åŠŸèƒ½ï¼Œæ‰€ä»¥æˆ‘ä»¬çœ‹åˆ°çš„åŒºå—é“¾çš„æ•°æ®éƒ½æ˜¯ä¸€ä¸ªä¸€ä¸ªå°æ–‡ä»¶ï¼Œå…¶å®è¿™äº›å°æ–‡ä»¶éƒ½æ˜¯åŒä¸€ä¸ªlevelDBå®ä¾‹ã€‚è¿™é‡Œç®€å•çš„çœ‹ä¸‹levelDBçš„goå°è£…ä»£ç ã€‚</p><p>levelDBå®˜æ–¹ç½‘ç«™ä»‹ç»çš„ç‰¹ç‚¹</p><p>ç‰¹ç‚¹ï¼š</p><ul><li>keyå’Œvalueéƒ½æ˜¯ä»»æ„é•¿åº¦çš„å­—èŠ‚æ•°ç»„ï¼›</li><li>entryï¼ˆå³ä¸€æ¡K-Vè®°å½•ï¼‰é»˜è®¤æ˜¯æŒ‰ç…§keyçš„å­—å…¸é¡ºåºå­˜å‚¨çš„ï¼Œå½“ç„¶å¼€å‘è€…ä¹Ÿå¯ä»¥é‡è½½è¿™ä¸ªæ’åºå‡½æ•°ï¼›</li><li>æä¾›çš„åŸºæœ¬æ“ä½œæ¥å£ï¼šPut()ã€Delete()ã€Get()ã€Batch()ï¼›</li><li>æ”¯æŒæ‰¹é‡æ“ä½œä»¥åŸå­æ“ä½œè¿›è¡Œï¼›</li><li>å¯ä»¥åˆ›å»ºæ•°æ®å…¨æ™¯çš„snapshot(å¿«ç…§)ï¼Œå¹¶å…è®¸åœ¨å¿«ç…§ä¸­æŸ¥æ‰¾æ•°æ®ï¼›</li><li>å¯ä»¥é€šè¿‡å‰å‘ï¼ˆæˆ–åå‘ï¼‰è¿­ä»£å™¨éå†æ•°æ®ï¼ˆè¿­ä»£å™¨ä¼šéšå«çš„åˆ›å»ºä¸€ä¸ªsnapshotï¼‰ï¼›</li><li>è‡ªåŠ¨ä½¿ç”¨Snappyå‹ç¼©æ•°æ®ï¼›</li><li>å¯ç§»æ¤æ€§ï¼›</li></ul><p>é™åˆ¶ï¼š</p><ul><li>éå…³ç³»å‹æ•°æ®æ¨¡å‹ï¼ˆNoSQLï¼‰ï¼Œä¸æ”¯æŒsqlè¯­å¥ï¼Œä¹Ÿä¸æ”¯æŒç´¢å¼•ï¼›</li><li>ä¸€æ¬¡åªå…è®¸ä¸€ä¸ªè¿›ç¨‹è®¿é—®ä¸€ä¸ªç‰¹å®šçš„æ•°æ®åº“ï¼›</li><li>æ²¡æœ‰å†…ç½®çš„C/Sæ¶æ„ï¼Œä½†å¼€å‘è€…å¯ä»¥ä½¿ç”¨LevelDBåº“è‡ªå·±å°è£…ä¸€ä¸ªserverï¼›</li></ul><p>æºç æ‰€åœ¨çš„ç›®å½•åœ¨ethereum/ethdbç›®å½•ã€‚ä»£ç æ¯”è¾ƒç®€å•ï¼Œ åˆ†ä¸ºä¸‹é¢å‡ ä¸ªæ–‡ä»¶</p><ul><li>testsuite.go</li><li>leveldb.go</li><li>leveldb_test.go</li><li>memorydb.go ä¾›æµ‹è¯•ç”¨çš„åŸºäºå†…å­˜çš„æ•°æ®åº“ï¼Œä¸ä¼šæŒä¹…åŒ–ä¸ºæ–‡ä»¶ï¼Œä»…ä¾›æµ‹è¯•</li><li>memorydb_test.go</li><li>batch.go</li><li>database.go levelDBçš„å°è£…ä»£ç </li><li>iterator.go</li></ul><p>çœ‹ä¸‹é¢çš„ä»£ç ï¼ŒåŸºæœ¬ä¸Šå®šä¹‰äº†KeyValueæ•°æ®åº“çš„åŸºæœ¬æ“ä½œï¼Œ Putï¼Œ Getï¼Œ Hasï¼Œ Deleteç­‰åŸºæœ¬æ“ä½œï¼ŒlevelDBæ˜¯ä¸æ”¯æŒSQLçš„ï¼ŒåŸºæœ¬å¯ä»¥ç†è§£ä¸ºæ•°æ®ç»“æ„é‡Œé¢çš„Mapã€‚</p><pre><code class="go">package ethdbconst IdealBatchSize = 100 * 1024// Putter wraps the database write operation supported by both batches and regular databases.//Putteræ¥å£å®šä¹‰äº†æ‰¹é‡æ“ä½œå’Œæ™®é€šæ“ä½œçš„å†™å…¥æ¥å£type Putter interface {    Put(key []byte, value []byte) error}// Database wraps all database operations. All methods are safe for concurrent use.//æ•°æ®åº“æ¥å£å®šä¹‰äº†æ‰€æœ‰çš„æ•°æ®åº“æ“ä½œï¼Œ æ‰€æœ‰çš„æ–¹æ³•éƒ½æ˜¯å¤šçº¿ç¨‹å®‰å…¨çš„ã€‚type Database interface {    Putter    Get(key []byte) ([]byte, error)    Has(key []byte) (bool, error)    Delete(key []byte) error    Close()    NewBatch() Batch}// Batch is a write-only database that commits changes to its host database// when Write is called. Batch cannot be used concurrently.//æ‰¹é‡æ“ä½œæ¥å£ï¼Œä¸èƒ½å¤šçº¿ç¨‹åŒæ—¶ä½¿ç”¨ï¼Œå½“Writeæ–¹æ³•è¢«è°ƒç”¨çš„æ—¶å€™ï¼Œæ•°æ®åº“ä¼šæäº¤å†™å…¥çš„æ›´æ”¹ã€‚type Batch interface {    Putter    ValueSize() int // amount of data in the batch    Write() error}</code></pre><h2 id="memory-database-go"><a href="#memory-database-go" class="headerlink" title="memory_database.go"></a>memory_database.go</h2><p>è¿™ä¸ªåŸºæœ¬ä¸Šå°±æ˜¯å°è£…äº†ä¸€ä¸ªå†…å­˜çš„Mapç»“æ„ã€‚ç„¶åä½¿ç”¨äº†ä¸€æŠŠé”æ¥å¯¹å¤šçº¿ç¨‹è¿›è¡Œèµ„æºçš„ä¿æŠ¤ã€‚</p><pre><code class="go">type MemDatabase struct {    db   map[string][]byte    lock sync.RWMutex}func NewMemDatabase() (*MemDatabase, error) {    return &amp;MemDatabase{        db: make(map[string][]byte),    }, nil}func (db *MemDatabase) Put(key []byte, value []byte) error {    db.lock.Lock()    defer db.lock.Unlock()    db.db[string(key)] = common.CopyBytes(value)    return nil}func (db *MemDatabase) Has(key []byte) (bool, error) {    db.lock.RLock()    defer db.lock.RUnlock()    _, ok := db.db[string(key)]    return ok, nil}</code></pre><p>ç„¶åæ˜¯Batchçš„æ“ä½œã€‚ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œä¸€çœ‹ä¾¿æ˜ç™½ã€‚</p><pre><code class="go">type kv struct{ k, v []byte }type memBatch struct {    db     *MemDatabase    writes []kv    size   int}func (b *memBatch) Put(key, value []byte) error {    b.writes = append(b.writes, kv{common.CopyBytes(key), common.CopyBytes(value)})    b.size += len(value)    return nil}func (b *memBatch) Write() error {    b.db.lock.Lock()    defer b.db.lock.Unlock()    for _, kv := range b.writes {        b.db.db[string(kv.k)] = kv.v    }    return nil}</code></pre><h2 id="database-go"><a href="#database-go" class="headerlink" title="database.go"></a>database.go</h2><p>è¿™ä¸ªå°±æ˜¯å®é™…ethereumå®¢æˆ·ç«¯ä½¿ç”¨çš„ä»£ç ï¼Œ å°è£…äº†levelDBçš„æ¥å£ã€‚</p><pre><code class="go">import (    "strconv"    "strings"    "sync"    "time"    "github.com/ethereum/go-ethereum/log"    "github.com/ethereum/go-ethereum/metrics"    "github.com/syndtr/goleveldb/leveldb"    "github.com/syndtr/goleveldb/leveldb/errors"    "github.com/syndtr/goleveldb/leveldb/filter"    "github.com/syndtr/goleveldb/leveldb/iterator"    "github.com/syndtr/goleveldb/leveldb/opt"    gometrics "github.com/rcrowley/go-metrics")</code></pre><p>ä½¿ç”¨äº†github.com/syndtr/goleveldb/leveldbçš„leveldbçš„å°è£…ï¼Œæ‰€ä»¥ä¸€äº›ä½¿ç”¨çš„æ–‡æ¡£å¯ä»¥åœ¨é‚£é‡Œæ‰¾åˆ°ã€‚å¯ä»¥çœ‹åˆ°ï¼Œæ•°æ®ç»“æ„ä¸»è¦å¢åŠ äº†å¾ˆå¤šçš„Mertricsç”¨æ¥è®°å½•æ•°æ®åº“çš„ä½¿ç”¨æƒ…å†µï¼Œå¢åŠ äº†quitChanç”¨æ¥å¤„ç†åœæ­¢æ—¶å€™çš„ä¸€äº›æƒ…å†µï¼Œè¿™ä¸ªåé¢ä¼šåˆ†æã€‚å¦‚æœä¸‹é¢ä»£ç å¯èƒ½æœ‰ç–‘é—®çš„åœ°æ–¹åº”è¯¥å†Filter: filter.NewBloomFilter(10)è¿™ä¸ªå¯ä»¥æš‚æ—¶ä¸ç”¨å…³æ³¨ï¼Œè¿™ä¸ªæ˜¯levelDBé‡Œé¢ç”¨æ¥è¿›è¡Œæ€§èƒ½ä¼˜åŒ–çš„ä¸€ä¸ªé€‰é¡¹ï¼Œå¯ä»¥ä¸ç”¨ç†ä¼šã€‚</p><pre><code class="go">type LDBDatabase struct {    fn string      // filename for reporting    db *leveldb.DB // LevelDB instance    getTimer       gometrics.Timer // Timer for measuring the database get request counts and latencies    putTimer       gometrics.Timer // Timer for measuring the database put request counts and latencies    ...metrics     quitLock sync.Mutex      // Mutex protecting the quit channel access    quitChan chan chan error // Quit channel to stop the metrics collection before closing the database    log log.Logger // Contextual logger tracking the database path}// NewLDBDatabase returns a LevelDB wrapped object.func NewLDBDatabase(file string, cache int, handles int) (*LDBDatabase, error) {    logger := log.New("database", file)    // Ensure we have some minimal caching and file guarantees    if cache &lt; 16 {        cache = 16    }    if handles &lt; 16 {        handles = 16    }    logger.Info("Allocated cache and file handles", "cache", cache, "handles", handles)    // Open the db and recover any potential corruptions    db, err := leveldb.OpenFile(file, &amp;opt.Options{        OpenFilesCacheCapacity: handles,        BlockCacheCapacity:     cache / 2 * opt.MiB,        WriteBuffer:            cache / 4 * opt.MiB, // Two of these are used internally        Filter:                 filter.NewBloomFilter(10),    })    if _, corrupted := err.(*errors.ErrCorrupted); corrupted {        db, err = leveldb.RecoverFile(file, nil)    }    // (Re)check for errors and abort if opening of the db failed    if err != nil {        return nil, err    }    return &amp;LDBDatabase{        fn:  file,        db:  db,        log: logger,    }, nil}</code></pre><p>å†çœ‹çœ‹ä¸‹é¢çš„Putå’ŒHasçš„ä»£ç ï¼Œå› ä¸ºgithub.com/syndtr/goleveldb/leveldbå°è£…ä¹‹åçš„ä»£ç æ˜¯æ”¯æŒå¤šçº¿ç¨‹åŒæ—¶è®¿é—®çš„ï¼Œæ‰€ä»¥ä¸‹é¢è¿™äº›ä»£ç æ˜¯ä¸ç”¨ä½¿ç”¨é”æ¥ä¿æŠ¤çš„ï¼Œè¿™ä¸ªå¯ä»¥æ³¨æ„ä¸€ä¸‹ã€‚è¿™é‡Œé¢å¤§éƒ¨åˆ†çš„ä»£ç éƒ½æ˜¯ç›´æ¥è°ƒç”¨leveldbçš„å°è£…ï¼Œæ‰€ä»¥ä¸è¯¦ç»†ä»‹ç»äº†ã€‚ æœ‰ä¸€ä¸ªæ¯”è¾ƒæœ‰æ„æ€çš„åœ°æ–¹æ˜¯Metricsä»£ç ã€‚</p><pre><code class="go">// Put puts the given key / value to the queuefunc (db *LDBDatabase) Put(key []byte, value []byte) error {    // Measure the database put latency, if requested    if db.putTimer != nil {        defer db.putTimer.UpdateSince(time.Now())    }    // Generate the data to write to disk, update the meter and write    //value = rle.Compress(value)    if db.writeMeter != nil {        db.writeMeter.Mark(int64(len(value)))    }    return db.db.Put(key, value, nil)}func (db *LDBDatabase) Has(key []byte) (bool, error) {    return db.db.Has(key, nil)}</code></pre><h2 id="Metricsçš„å¤„ç†"><a href="#Metricsçš„å¤„ç†" class="headerlink" title="Metricsçš„å¤„ç†"></a>Metricsçš„å¤„ç†</h2><p>ä¹‹å‰åœ¨åˆ›å»ºNewLDBDatabaseçš„æ—¶å€™ï¼Œå¹¶æ²¡æœ‰åˆå§‹åŒ–å†…éƒ¨çš„å¾ˆå¤šMertricsï¼Œè¿™ä¸ªæ—¶å€™Mertricsæ˜¯ä¸ºnilçš„ã€‚åˆå§‹åŒ–Mertricsæ˜¯åœ¨Meteræ–¹æ³•ä¸­ã€‚å¤–éƒ¨ä¼ å…¥äº†ä¸€ä¸ªprefixå‚æ•°ï¼Œç„¶ååˆ›å»ºäº†å„ç§Mertrics(å…·ä½“å¦‚ä½•åˆ›å»ºMerterï¼Œä¼šåç»­åœ¨Meterä¸“é¢˜è¿›è¡Œåˆ†æ),ç„¶ååˆ›å»ºäº†quitChanã€‚ æœ€åå¯åŠ¨äº†ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨äº†db.meteræ–¹æ³•ã€‚</p><pre><code class="go">// Meter configures the database metrics collectors andfunc (db *LDBDatabase) Meter(prefix string) {    // Short circuit metering if the metrics system is disabled    if !metrics.Enabled {        return    }    // Initialize all the metrics collector at the requested prefix    db.getTimer = metrics.NewTimer(prefix + "user/gets")    db.putTimer = metrics.NewTimer(prefix + "user/puts")    db.delTimer = metrics.NewTimer(prefix + "user/dels")    db.missMeter = metrics.NewMeter(prefix + "user/misses")    db.readMeter = metrics.NewMeter(prefix + "user/reads")    db.writeMeter = metrics.NewMeter(prefix + "user/writes")    db.compTimeMeter = metrics.NewMeter(prefix + "compact/time")    db.compReadMeter = metrics.NewMeter(prefix + "compact/input")    db.compWriteMeter = metrics.NewMeter(prefix + "compact/output")    // Create a quit channel for the periodic collector and run it    db.quitLock.Lock()    db.quitChan = make(chan chan error)    db.quitLock.Unlock()    go db.meter(3 * time.Second)}</code></pre><p>è¿™ä¸ªæ–¹æ³•æ¯3ç§’é’Ÿè·å–ä¸€æ¬¡leveldbå†…éƒ¨çš„è®¡æ•°å™¨ï¼Œç„¶åæŠŠä»–ä»¬å…¬å¸ƒåˆ°metricså­ç³»ç»Ÿã€‚ è¿™æ˜¯ä¸€ä¸ªæ— é™å¾ªç¯çš„æ–¹æ³•ï¼Œ ç›´åˆ°quitChanæ”¶åˆ°äº†ä¸€ä¸ªé€€å‡ºä¿¡å·ã€‚</p><pre><code class="go">// meter periodically retrieves internal leveldb counters and reports them to// the metrics subsystem.// This is how a stats table look like (currently)://ä¸‹é¢çš„æ³¨é‡Šå°±æ˜¯æˆ‘ä»¬è°ƒç”¨ db.db.GetProperty("leveldb.stats")è¿”å›çš„å­—ç¬¦ä¸²ï¼Œåç»­çš„ä»£ç éœ€è¦è§£æè¿™ä¸ªå­—ç¬¦ä¸²å¹¶æŠŠä¿¡æ¯å†™å…¥åˆ°Meterä¸­ã€‚//   Compactions//    Level |   Tables   |    Size(MB)   |    Time(sec)  |    Read(MB)   |   Write(MB)//   -------+------------+---------------+---------------+---------------+---------------//      0   |          0 |       0.00000 |       1.27969 |       0.00000 |      12.31098//      1   |         85 |     109.27913 |      28.09293 |     213.92493 |     214.26294//      2   |        523 |    1000.37159 |       7.26059 |      66.86342 |      66.77884//      3   |        570 |    1113.18458 |       0.00000 |       0.00000 |       0.00000func (db *LDBDatabase) meter(refresh time.Duration) {    // Create the counters to store current and previous values    counters := make([][]float64, 2)    for i := 0; i &lt; 2; i++ {        counters[i] = make([]float64, 3)    }    // Iterate ad infinitum and collect the stats    for i := 1; ; i++ {        // Retrieve the database stats        stats, err := db.db.GetProperty("leveldb.stats")        if err != nil {            db.log.Error("Failed to read database stats", "err", err)            return        }        // Find the compaction table, skip the header        lines := strings.Split(stats, "\n")        for len(lines) &gt; 0 &amp;&amp; strings.TrimSpace(lines[0]) != "Compactions" {            lines = lines[1:]        }        if len(lines) &lt;= 3 {            db.log.Error("Compaction table not found")            return        }        lines = lines[3:]        // Iterate over all the table rows, and accumulate the entries        for j := 0; j &lt; len(counters[i%2]); j++ {            counters[i%2][j] = 0        }        for _, line := range lines {            parts := strings.Split(line, "|")            if len(parts) != 6 {                break            }            for idx, counter := range parts[3:] {                value, err := strconv.ParseFloat(strings.TrimSpace(counter), 64)                if err != nil {                    db.log.Error("Compaction entry parsing failed", "err", err)                    return                }                counters[i%2][idx] += value            }        }        // Update all the requested meters        if db.compTimeMeter != nil {            db.compTimeMeter.Mark(int64((counters[i%2][0] - counters[(i-1)%2][0]) * 1000 * 1000 * 1000))        }        if db.compReadMeter != nil {            db.compReadMeter.Mark(int64((counters[i%2][1] - counters[(i-1)%2][1]) * 1024 * 1024))        }        if db.compWriteMeter != nil {            db.compWriteMeter.Mark(int64((counters[i%2][2] - counters[(i-1)%2][2]) * 1024 * 1024))        }        // Sleep a bit, then repeat the stats collection        select {        case errc := &lt;-db.quitChan:            // Quit requesting, stop hammering the database            errc &lt;- nil            return        case &lt;-time.After(refresh):            // Timeout, gather a new set of stats        }    }}</code></pre><h1 id="å‚è€ƒèµ„æ–™åœ°å€"><a href="#å‚è€ƒèµ„æ–™åœ°å€" class="headerlink" title="å‚è€ƒèµ„æ–™åœ°å€"></a>å‚è€ƒèµ„æ–™åœ°å€</h1><ul><li><a href="https://ethereum.org/en/whitepaper">ä»¥å¤ªåŠç™½çš®ä¹¦</a></li><li><a href="https://ethereum.github.io/yellowpaper/paper.pdf">ä»¥å¤ªåŠé»„çš®ä¹¦ï¼ˆè‹±æ–‡ç‰ˆï¼‰</a></li><li><a href="https://github.com/wanshan1024/ethereum_yellowpaper/blob/master/ethereum_yellow_paper_cn.pdf">ä»¥å¤ªåŠé»„çš®ä¹¦ï¼ˆä¸­æ–‡ç‰ˆï¼‰</a></li><li><a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis">åˆ†æå‚è€ƒèµ„æ–™</a></li><li><a href="https://segmentfault.com/a/1190000016050921">åšå®¢å‚è€ƒèµ„æ–™</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-å°è£…çš„ä¸€äº›åŸºç¡€å·¥å…·</title>
      <link href="/2021/05/27/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%B0%81%E8%A3%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/05/27/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%B0%81%E8%A3%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="å°è£…çš„ä¸€äº›åŸºç¡€å·¥å…·"><a href="#å°è£…çš„ä¸€äº›åŸºç¡€å·¥å…·" class="headerlink" title="å°è£…çš„ä¸€äº›åŸºç¡€å·¥å…·"></a>å°è£…çš„ä¸€äº›åŸºç¡€å·¥å…·</h1><p>åœ¨<a href="https://github.com/ethereum/go-ethereum">ä»¥å¤ªåŠ</a> é¡¹ç›®ä¸­ï¼Œå­˜åœ¨å¯¹golangç”Ÿæ€ä½“ç³»ä¸­ä¸€äº›ä¼˜ç§€å·¥å…·è¿›è¡Œå°è£…çš„å°æ¨¡å—ï¼Œç”±äºåŠŸèƒ½è¾ƒä¸ºå•ä¸€ï¼Œå•ç‹¬æˆç¯‡æ˜¾å¾—è¿‡äºå•è–„ã€‚ä½†æ˜¯ç”±äºä»¥å¤ªåŠå¯¹è¿™äº›å°å·¥å…·çš„å°è£…éå¸¸ä¼˜é›…ï¼Œå…·æœ‰å¾ˆå¼ºçš„ç‹¬ç«‹æ€§å’Œå®ç”¨æ€§ã€‚æˆ‘ä»¬åœ¨æ­¤ä½œä¸€äº›åˆ†æï¼Œè‡³å°‘å¯¹äºç†Ÿæ‚‰ä»¥å¤ªåŠæºç çš„ç¼–ç æ–¹å¼æ˜¯æœ‰å¸®åŠ©çš„ã€‚</p><h2 id="metricsï¼ˆæ¢é’ˆï¼‰"><a href="#metricsï¼ˆæ¢é’ˆï¼‰" class="headerlink" title="metricsï¼ˆæ¢é’ˆï¼‰"></a>metricsï¼ˆæ¢é’ˆï¼‰</h2><p>åœ¨<a href="/ethdb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">ethdbæºç åˆ†æ</a>ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†å¯¹<a href="https://github.com/syndtr/goleveldb">goleveldb</a>é¡¹ç›®çš„å°è£…ã€‚ethdbé™¤äº†å¯¹goleveldbæŠ½è±¡äº†ä¸€å±‚ï¼š</p><p><a href="https://github.com/ethereum/go-ethereum/blob/master/ethdb/interface.go#L29">type Database interface</a></p><p>ä»¥æ”¯æŒä¸MemDatabaseçš„åŒæ¥å£ä½¿ç”¨äº’æ¢å¤–ï¼Œè¿˜åœ¨LDBDatabaseä¸­ä½¿ç”¨å¾ˆå¤š<a href="https://github.com/rcrowley/go-metrics">gometrics</a>åŒ…ä¸‹é¢çš„æ¢é’ˆå·¥å…·ï¼Œä»¥åŠèƒ½å¯åŠ¨ä¸€ä¸ªgoroutineæ‰§è¡Œ</p><p><a href="https://github.com/ethereum/go-ethereum/blob/master/ethdb/database.go#L198">go db.meter(3 * time.Second)</a></p><p>ä»¥3ç§’ä¸ºå‘¨æœŸï¼Œæ”¶é›†ä½¿ç”¨goleveldbè¿‡ç¨‹ä¸­çš„å»¶æ—¶å’ŒI/Oæ•°æ®é‡ç­‰æŒ‡æ ‡ã€‚çœ‹èµ·æ¥å¾ˆæ–¹ä¾¿ï¼Œä½†é—®é¢˜æ˜¯æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨è¿™äº›æ”¶é›†æ¥çš„ä¿¡æ¯å‘¢ï¼Ÿ</p><h2 id="logï¼ˆæ—¥å¿—ï¼‰"><a href="#logï¼ˆæ—¥å¿—ï¼‰" class="headerlink" title="logï¼ˆæ—¥å¿—ï¼‰"></a>logï¼ˆæ—¥å¿—ï¼‰</h2><p>golangçš„å†…ç½®logåŒ…ä¸€ç›´è¢«ä½œä¸ºæ§½ç‚¹ï¼Œè€Œä»¥å¤ªåŠé¡¹ç›®ä¹Ÿä¸ä¾‹å¤–ã€‚æ•…å¼•å…¥äº†<a href="https://github.com/inconshreveable/log15">log15</a>ä»¥è§£å†³æ—¥å¿—ä½¿ç”¨ä¸ä¾¿çš„é—®é¢˜ã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-åˆ†æåŒ…Trie</title>
      <link href="/2021/05/27/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%86%E6%9E%90%E5%8C%85Trie/"/>
      <url>/2021/05/27/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%86%E6%9E%90%E5%8C%85Trie/</url>
      
        <content type="html"><![CDATA[<h1 id="ç‰ˆæœ¬è¯´æ˜"><a href="#ç‰ˆæœ¬è¯´æ˜" class="headerlink" title="ç‰ˆæœ¬è¯´æ˜"></a>ç‰ˆæœ¬è¯´æ˜</h1><p>æºç åˆ†æä½¿ç”¨çš„ç‰ˆæœ¬ä¸ºï¼š<a href="https://github.com/ethereum/go-ethereum/tree/v1.10.3">v1.10.3</a></p><h1 id="çŸ¥è¯†è¡¥å……"><a href="#çŸ¥è¯†è¡¥å……" class="headerlink" title="çŸ¥è¯†è¡¥å……"></a>çŸ¥è¯†è¡¥å……</h1><p>ä»¥å¤ªåŠæºç ä¸­çš„trieåŒ…å®ç°äº†Merkle Patricia Triesï¼ˆMPTï¼‰ï¼Œè¿™ç§æ•°æ®ç»“æ„å®é™…ä¸Šæ˜¯ä¸€ç§Trieæ ‘å˜ç§ã€‚</p><p>MPTæ˜¯ä»¥å¤ªåŠä¸­ä¸€ç§éå¸¸é‡è¦çš„æ•°æ®ç»“æ„ï¼Œç”¨æ¥å­˜å‚¨ç”¨æˆ·è´¦æˆ·çš„çŠ¶æ€åŠå…¶å˜æ›´ã€äº¤æ˜“ä¿¡æ¯ã€äº¤æ˜“çš„æ”¶æ®ä¿¡æ¯ã€‚</p><p>MPTå®é™…ä¸Šæ˜¯ä¸‰ç§æ•°æ®ç»“æ„çš„ç»„åˆï¼Œåˆ†åˆ«æ˜¯Merkleæ ‘ã€Patricia Trieã€å’ŒTrieæ ‘ã€‚</p><p>ä¸‹é¢åˆ†åˆ«ä»‹ç»è¿™ä¸‰ç§æ•°æ®ç»“æ„ã€‚</p><h2 id="Merkleæ ‘"><a href="#Merkleæ ‘" class="headerlink" title="Merkleæ ‘"></a>Merkleæ ‘</h2><p>Merkle Treeï¼Œé€šå¸¸ä¹Ÿè¢«ç§°ä½œHash Treeï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯å­˜å‚¨hashå€¼çš„ä¸€æ£µæ ‘ã€‚Merkleæ ‘çš„å¶å­æ˜¯æ•°æ®å—(ä¾‹å¦‚ï¼Œæ–‡ä»¶æˆ–è€…æ–‡ä»¶çš„é›†åˆ)çš„hashå€¼ã€‚éå¶èŠ‚ç‚¹æ˜¯å…¶å¯¹åº”å­èŠ‚ç‚¹ä¸²è”å­—ç¬¦ä¸²çš„hash</p><p><img src="https://img-blog.csdnimg.cn/20210527141955845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>Merkle Treeçš„ä¸»è¦ä½œç”¨æ˜¯å½“æˆ‘æ‹¿åˆ°Top Hashçš„æ—¶å€™ï¼Œè¿™ä¸ªhashå€¼ä»£è¡¨äº†æ•´é¢—æ ‘çš„ä¿¡æ¯æ‘˜è¦ï¼Œå½“æ ‘é‡Œé¢ä»»ä½•ä¸€ä¸ªæ•°æ®å‘ç”Ÿäº†å˜åŠ¨ï¼Œéƒ½ä¼šå¯¼è‡´Top Hashçš„å€¼å‘ç”Ÿå˜åŒ–ã€‚ è€ŒTop Hashçš„å€¼æ˜¯ä¼šå­˜å‚¨åˆ°åŒºå—é“¾çš„åŒºå—å¤´é‡Œé¢å»çš„ï¼Œ åŒºå—å¤´æ˜¯å¿…é¡»ç»è¿‡å·¥ä½œé‡è¯æ˜ã€‚ è¿™ä¹Ÿå°±æ˜¯è¯´æˆ‘åªè¦æ‹¿åˆ°ä¸€ä¸ªåŒºå—å¤´ï¼Œå°±å¯ä»¥å¯¹åŒºå—ä¿¡æ¯è¿›è¡ŒéªŒè¯ã€‚ æ›´åŠ è¯¦ç»†çš„ä¿¡æ¯è¯·å‚è€ƒé‚£ä¸ªåšå®¢ã€‚æœ‰è¯¦ç»†çš„ä»‹ç»ã€‚</p><h2 id="Patricia-Tries"><a href="#Patricia-Tries" class="headerlink" title="Patricia Tries"></a>Patricia Tries</h2><p>Patricia Trieså³ä¸ºå‰ç¼€æ ‘ï¼Œ<br>å‰ç¼€æ ‘è·ŸTrieæ ‘çš„ä¸åŒä¹‹å¤„åœ¨äºTrieæ ‘ç»™æ¯ä¸€ä¸ªå­—ç¬¦ä¸²åˆ†é…ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™æ ·å°†ä½¿é‚£äº›å¾ˆé•¿ä½†åˆæ²¡æœ‰å…¬å…±èŠ‚ç‚¹çš„å­—ç¬¦ä¸²çš„Trieæ ‘é€€åŒ–æˆæ•°ç»„ã€‚åœ¨ä»¥å¤ªåŠé‡Œé¢ä¼šç”±é»‘å®¢æ„é€ å¾ˆå¤šè¿™ç§èŠ‚ç‚¹é€ æˆæ‹’ç»æœåŠ¡æ”»å‡»ã€‚å‰ç¼€æ ‘çš„ä¸åŒä¹‹å¤„åœ¨äºå¦‚æœèŠ‚ç‚¹å…¬å…±å‰ç¼€ï¼Œé‚£ä¹ˆå°±ä½¿ç”¨å…¬å…±å‰ç¼€ï¼Œå¦åˆ™å°±æŠŠå‰©ä¸‹çš„æ‰€æœ‰èŠ‚ç‚¹æ’å…¥åŒä¸€ä¸ªèŠ‚ç‚¹ã€‚Patriciaç›¸å¯¹Tireçš„ä¼˜åŒ–æ­£å¦‚ä¸‹å›¾ï¼š<br><img src="https://img-blog.csdnimg.cn/20210527141719517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"><br><img src="https://img-blog.csdnimg.cn/20210527141728827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><table><thead><tr><th>Key</th><th>value</th></tr></thead><tbody><tr><td>6c0a5c71ec20bq3w</td><td>5</td></tr><tr><td>6c0a5c71ec20CX7j</td><td>27</td></tr><tr><td>6c0a5c71781a1FXq</td><td>18</td></tr><tr><td>6c0a5c71781a9Dog</td><td>64</td></tr><tr><td>6c0a8f743b95zUfe</td><td>30</td></tr><tr><td>6c0a8f743b95jx5R</td><td>2</td></tr><tr><td>6c0a8f740d16y03G</td><td>43</td></tr><tr><td>6c0a8f740d16vcc1</td><td>48</td></tr></tbody></table><h2 id="Trieæ ‘"><a href="#Trieæ ‘" class="headerlink" title="Trieæ ‘"></a>Trieæ ‘</h2><p>Trieæ ‘ï¼Œåˆç§°å­—å…¸æ ‘ï¼Œå•è¯æŸ¥æ‰¾æ ‘æˆ–è€…å‰ç¼€æ ‘ï¼Œæ˜¯ä¸€ç§ç”¨äºå¿«é€Ÿæ£€ç´¢çš„å¤šå‰æ ‘ç»“æ„ï¼Œå¦‚è‹±æ–‡å­—æ¯çš„å­—å…¸æ ‘æ˜¯ä¸€ä¸ª26å‰æ ‘ï¼Œæ•°å­—çš„å­—å…¸æ ‘æ˜¯ä¸€ä¸ª10å‰æ ‘ã€‚</p><p>Trieæ ‘å¯ä»¥åˆ©ç”¨å­—ç¬¦ä¸²çš„å…¬å…±å‰ç¼€æ¥èŠ‚çº¦å­˜å‚¨ç©ºé—´ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œè¯¥trieæ ‘ç”¨10ä¸ªèŠ‚ç‚¹ä¿å­˜äº†6ä¸ªå­—ç¬¦ä¸²ï¼šteaï¼Œtenï¼Œtoï¼Œinï¼Œinnï¼Œintï¼š</p><p><img src="https://img-blog.csdnimg.cn/20210527141507347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>åœ¨è¯¥trieæ ‘ä¸­ï¼Œå­—ç¬¦ä¸²inï¼Œinnå’Œintçš„å…¬å…±å‰ç¼€æ˜¯â€œinâ€ï¼Œå› æ­¤å¯ä»¥åªå­˜å‚¨ä¸€ä»½â€œinâ€ä»¥èŠ‚çœç©ºé—´ã€‚å½“ç„¶ï¼Œå¦‚æœç³»ç»Ÿä¸­å­˜åœ¨å¤§é‡å­—ç¬¦ä¸²ä¸”è¿™äº›å­—ç¬¦ä¸²åŸºæœ¬æ²¡æœ‰å…¬å…±å‰ç¼€ï¼Œåˆ™ç›¸åº”çš„trieæ ‘å°†éå¸¸æ¶ˆè€—å†…å­˜ï¼Œè¿™ä¹Ÿæ˜¯trieæ ‘çš„ä¸€ä¸ªç¼ºç‚¹ã€‚</p><p>Trieæ ‘çš„åŸºæœ¬æ€§è´¨å¯ä»¥å½’çº³ä¸ºï¼š</p><ul><li>æ ¹èŠ‚ç‚¹ä¸åŒ…å«å­—ç¬¦ï¼Œé™¤æ ¹èŠ‚ç‚¹ä»¥å¤–æ¯ä¸ªèŠ‚ç‚¹åªåŒ…å«ä¸€ä¸ªå­—ç¬¦</li><li>ä»æ ¹èŠ‚ç‚¹åˆ°æŸä¸€ä¸ªèŠ‚ç‚¹ï¼Œè·¯å¾„ä¸Šç»è¿‡çš„å­—ç¬¦è¿æ¥èµ·æ¥ï¼Œä¸ºè¯¥èŠ‚ç‚¹å¯¹åº”çš„å­—ç¬¦ä¸²</li><li>æ¯ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹åŒ…å«çš„å­—ç¬¦ä¸²ä¸ç›¸åŒ</li></ul><h2 id="ä»¥å¤ªåŠçš„MPT"><a href="#ä»¥å¤ªåŠçš„MPT" class="headerlink" title="ä»¥å¤ªåŠçš„MPT"></a>ä»¥å¤ªåŠçš„MPT</h2><p>æ¯ä¸€ä¸ªä»¥å¤ªåŠçš„åŒºå—å¤´åŒ…å«ä¸‰é¢—MPTæ ‘ï¼Œåˆ†åˆ«æ˜¯</p><ul><li>äº¤æ˜“æ ‘</li><li>æ”¶æ®æ ‘(äº¤æ˜“æ‰§è¡Œè¿‡ç¨‹ä¸­çš„ä¸€äº›æ•°æ®)</li><li>çŠ¶æ€æ ‘(è´¦å·ä¿¡æ¯ï¼Œ åˆçº¦è´¦æˆ·å’Œç”¨æˆ·è´¦æˆ·)</li></ul><p>ä¸‹å›¾ä¸­æ˜¯ä¸¤ä¸ªåŒºå—å¤´ï¼Œå…¶ä¸­state rootï¼Œtx root receipt rootåˆ†åˆ«å­˜å‚¨äº†è¿™ä¸‰æ£µæ ‘çš„æ ‘æ ¹ï¼Œç¬¬äºŒä¸ªåŒºå—æ˜¾ç¤ºäº†å½“è´¦å· 175çš„æ•°æ®å˜æ›´(27 -&gt; 45)çš„æ—¶å€™ï¼Œåªéœ€è¦å­˜å‚¨è·Ÿè¿™ä¸ªè´¦å·ç›¸å…³çš„éƒ¨åˆ†æ•°æ®ï¼Œè€Œä¸”è€çš„åŒºå—ä¸­çš„æ•°æ®è¿˜æ˜¯å¯ä»¥æ­£å¸¸è®¿é—®ã€‚(è¿™ä¸ªæœ‰ç‚¹ç±»ä¼¼ä¸å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ä¸­çš„ä¸å¯å˜çš„æ•°æ®ç»“æ„çš„å®ç°)</p><p><img src="https://img-blog.csdnimg.cn/20210527142811419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h1 id="æºç åˆ†æ"><a href="#æºç åˆ†æ" class="headerlink" title="æºç åˆ†æ"></a>æºç åˆ†æ</h1><h2 id="ç¼–ç è½¬æ¢ï¼šencoding-go"><a href="#ç¼–ç è½¬æ¢ï¼šencoding-go" class="headerlink" title="ç¼–ç è½¬æ¢ï¼šencoding.go"></a>ç¼–ç è½¬æ¢ï¼šencoding.go</h2><p>encoding.goä¸»è¦å¤„ç†trieæ ‘ä¸­çš„ä¸‰ç§ç¼–ç æ ¼å¼çš„ç›¸äº’è½¬æ¢çš„å·¥ä½œã€‚ ä¸‰ç§ç¼–ç æ ¼å¼åˆ†åˆ«ä¸ºä¸‹é¢çš„ä¸‰ç§ç¼–ç æ ¼å¼ã€‚</p><ul><li>KEYBYTES encodingè¿™ç§ç¼–ç æ ¼å¼å°±æ˜¯åŸç”Ÿçš„keyå­—èŠ‚æ•°ç»„ï¼Œå¤§éƒ¨åˆ†çš„Trieçš„APIéƒ½æ˜¯ä½¿ç”¨è¿™è¾¹ç¼–ç æ ¼å¼</li><li>HEX encoding è¿™ç§ç¼–ç æ ¼å¼æ¯ä¸€ä¸ªå­—èŠ‚åŒ…å«äº†Keyçš„ä¸€ä¸ªåŠå­—èŠ‚ï¼Œå°¾éƒ¨æ¥ä¸Šä¸€ä¸ªå¯é€‰çš„â€™ç»ˆç»“ç¬¦â€™,â€™ç»ˆç»“ç¬¦â€™ä»£è¡¨è¿™ä¸ªèŠ‚ç‚¹åˆ°åº•æ˜¯å¶å­èŠ‚ç‚¹è¿˜æ˜¯æ‰©å±•èŠ‚ç‚¹ã€‚å½“èŠ‚ç‚¹è¢«åŠ è½½åˆ°å†…å­˜é‡Œé¢çš„æ—¶å€™ä½¿ç”¨çš„æ˜¯è¿™ç§èŠ‚ç‚¹ï¼Œå› ä¸ºå®ƒçš„æ–¹ä¾¿è®¿é—®ã€‚</li><li>COMPACT encoding è¿™ç§ç¼–ç æ ¼å¼å°±æ˜¯ä¸Šé¢é»„çš®ä¹¦é‡Œé¢è¯´åˆ°çš„Hex-Prefix Encodingï¼Œè¿™ç§ç¼–ç æ ¼å¼å¯ä»¥çœ‹æˆæ˜¯HEX encodingè¿™ç§ç¼–ç æ ¼å¼çš„å¦å¤–ä¸€ç§ç‰ˆæœ¬ï¼Œå¯ä»¥åœ¨å­˜å‚¨åˆ°æ•°æ®åº“çš„æ—¶å€™èŠ‚çº¦ç£ç›˜ç©ºé—´ã€‚</li></ul><p>ç®€å•çš„ç†è§£ä¸ºï¼šå°†æ™®é€šçš„å­—èŠ‚åºåˆ—keybytesç¼–ç ä¸ºå¸¦æœ‰tæ ‡å¿—ä¸å¥‡æ•°ä¸ªåŠå­—èŠ‚nibbleæ ‡å¿—ä½çš„keybytes</p><ul><li>keybytesä¸ºæŒ‰å®Œæ•´å­—èŠ‚ï¼ˆ8bitï¼‰å­˜å‚¨çš„æ­£å¸¸ä¿¡æ¯</li><li>hexä¸ºæŒ‰ç…§åŠå­—èŠ‚nibbleï¼ˆ4bitï¼‰å‚¨å­˜ä¿¡æ¯çš„æ ¼å¼ã€‚ä¾›compactä½¿ç”¨</li></ul><p>ä¸ºäº†ä¾¿äºä½œé»„çš®ä¹¦ä¸­Modified Merkle Patricia Treeçš„èŠ‚ç‚¹çš„keyï¼Œç¼–ç ä¸ºå¶æ•°å­—èŠ‚é•¿åº¦çš„hexæ ¼å¼ã€‚å…¶ç¬¬ä¸€ä¸ªåŠå­—èŠ‚nibbleä¼šåœ¨ä½çš„2ä¸ªbitä½ä¸­ï¼Œç”±é«˜åˆ°ä½åˆ†åˆ«å­˜æ”¾tæ ‡å¿—ä¸å¥‡æ•°æ ‡å¿—ã€‚ç»compactç¼–ç çš„keybytesï¼Œåœ¨å¢åŠ äº†hexçš„tæ ‡å¿—ä¸åŠå­—èŠ‚nibbleä¸ºå¶æ•°ä¸ªï¼ˆå³å®Œæ•´çš„å­—èŠ‚ï¼‰çš„æƒ…å†µä¸‹ï¼Œä¾¿äºå­˜å‚¨</p><h2 id="æ•°æ®ç»“æ„ä¸æ–¹æ³•"><a href="#æ•°æ®ç»“æ„ä¸æ–¹æ³•" class="headerlink" title="æ•°æ®ç»“æ„ä¸æ–¹æ³•"></a>æ•°æ®ç»“æ„ä¸æ–¹æ³•</h2><h3 id="nodeï¼šnode-go"><a href="#nodeï¼šnode-go" class="headerlink" title="nodeï¼šnode.go"></a>nodeï¼šnode.go</h3><h4 id="nodeçš„ç»“æ„"><a href="#nodeçš„ç»“æ„" class="headerlink" title="nodeçš„ç»“æ„"></a>nodeçš„ç»“æ„</h4><p>å¯ä»¥çœ‹åˆ°nodeåˆ†ä¸º4ç§ç±»å‹ï¼š</p><ul><li>fullNodeï¼šé»„çš®ä¹¦é‡Œé¢çš„åˆ†æ”¯èŠ‚ç‚¹</li><li>shortNodeï¼šé»„çš®ä¹¦é‡Œé¢çš„æ‰©å±•èŠ‚ç‚¹å’Œå¶å­èŠ‚ç‚¹(é€šè¿‡shortNode.Valçš„ç±»å‹æ¥åˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹(shortNode.Valä¸ºvalueNode)è¿˜æ˜¯æ‹“å±•èŠ‚ç‚¹(é€šè¿‡shortNode.ValæŒ‡å‘ä¸‹ä¸€ä¸ªnode))</li><li>hashNode</li><li>valueNode</li></ul><pre><code class="go">type node interface {    fstring(string) string    cache() (hashNode, bool)}type (    fullNode struct {        Children [17]node // Actual trie node data to encode/decode (needs custom encoder)        flags    nodeFlag    }    shortNode struct {        Key   []byte        Val   node        flags nodeFlag    }    hashNode  []byte    valueNode []byte)</code></pre><h4 id="nodeçš„æ–¹æ³•"><a href="#nodeçš„æ–¹æ³•" class="headerlink" title="nodeçš„æ–¹æ³•"></a>nodeçš„æ–¹æ³•</h4><h3 id="Trieï¼štrie-go"><a href="#Trieï¼štrie-go" class="headerlink" title="Trieï¼štrie.go"></a>Trieï¼štrie.go</h3><h4 id="Trieçš„ç»“æ„"><a href="#Trieçš„ç»“æ„" class="headerlink" title="Trieçš„ç»“æ„"></a>Trieçš„ç»“æ„</h4><p>rootåŒ…å«äº†å½“å‰çš„rootèŠ‚ç‚¹ï¼Œ dbæ˜¯åç«¯çš„KVå­˜å‚¨ï¼Œtrieçš„ç»“æ„æœ€ç»ˆéƒ½æ˜¯éœ€è¦é€šè¿‡KVçš„å½¢å¼å­˜å‚¨åˆ°æ•°æ®åº“é‡Œé¢å»ï¼Œç„¶åå¯åŠ¨çš„æ—¶å€™æ˜¯éœ€è¦ä»æ•°æ®åº“é‡Œé¢åŠ è½½çš„ã€‚ originalRoot å¯åŠ¨åŠ è½½çš„æ—¶å€™çš„hashå€¼ï¼Œé€šè¿‡è¿™ä¸ªhashå€¼å¯ä»¥åœ¨æ•°æ®åº“é‡Œé¢æ¢å¤å‡ºæ•´é¢—çš„trieæ ‘ã€‚cachegenå­—æ®µæŒ‡ç¤ºäº†å½“å‰Trieæ ‘çš„cacheæ—¶ä»£ï¼Œæ¯æ¬¡è°ƒç”¨Commitæ“ä½œçš„æ—¶å€™ï¼Œä¼šå¢åŠ Trieæ ‘çš„cacheæ—¶ä»£ã€‚ cacheæ—¶ä»£ä¼šè¢«é™„åŠ åœ¨nodeèŠ‚ç‚¹ä¸Šé¢ï¼Œå¦‚æœå½“å‰çš„cacheæ—¶ä»£ - cachelimitå‚æ•° å¤§äºnodeçš„cacheæ—¶ä»£ï¼Œé‚£ä¹ˆnodeä¼šä»cacheé‡Œé¢å¸è½½ï¼Œä»¥ä¾¿èŠ‚çº¦å†…å­˜ã€‚ å…¶å®è¿™å°±æ˜¯ç¼“å­˜æ›´æ–°çš„LRUç®—æ³•ï¼Œ å¦‚æœä¸€ä¸ªç¼“å­˜åœ¨å¤šä¹…æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œé‚£ä¹ˆå°±ä»ç¼“å­˜é‡Œé¢ç§»é™¤ï¼Œä»¥èŠ‚çº¦å†…å­˜ç©ºé—´ã€‚</p><pre><code class="go">// Trie is a Merkle Patricia Trie.// The zero value is an empty trie with no database.// Use New to create a trie that sits on top of a database.//// Trie is not safe for concurrent use.type Trie struct {    db   *Database    root node    // Keep track of the number leafs which have been inserted since the last    // hashing operation. This number will not directly map to the number of    // actually unhashed nodes    unhashed int}</code></pre><h4 id="Trieçš„æ–¹æ³•"><a href="#Trieçš„æ–¹æ³•" class="headerlink" title="Trieçš„æ–¹æ³•"></a>Trieçš„æ–¹æ³•</h4><h5 id="1-Trieæ ‘çš„æ–°å»º"><a href="#1-Trieæ ‘çš„æ–°å»º" class="headerlink" title="1. Trieæ ‘çš„æ–°å»º"></a>1. Trieæ ‘çš„æ–°å»º</h5><p>Trieæ ‘çš„æ’å…¥ï¼ŒæŸ¥æ‰¾å’Œåˆ é™¤ Trieæ ‘çš„åˆå§‹åŒ–è°ƒç”¨Newå‡½æ•°ï¼Œå‡½æ•°æ¥å—ä¸€ä¸ªhashå€¼å’Œä¸€ä¸ªDatabaseå‚æ•°ï¼Œå¦‚æœhashå€¼ä¸æ˜¯ç©ºå€¼çš„åŒ–ï¼Œå°±è¯´æ˜æ˜¯ä»æ•°æ®åº“åŠ è½½ä¸€ä¸ªå·²ç»å­˜åœ¨çš„Trieæ ‘ï¼Œ å°±è°ƒç”¨trei.resolveHashæ–¹æ³•æ¥åŠ è½½æ•´é¢—Trieæ ‘ï¼Œè¿™ä¸ªæ–¹æ³•åç»­ä¼šä»‹ç»ã€‚ å¦‚æœrootæ˜¯ç©ºï¼Œé‚£ä¹ˆå°±æ–°å»ºä¸€é¢—Trieæ ‘è¿”å›</p><pre><code class="go">// New creates a trie with an existing root node from db.//// If root is the zero hash or the sha3 hash of an empty string, the// trie is initially empty and does not require a database. Otherwise,// New will panic if db is nil and returns a MissingNodeError if root does// not exist in the database. Accessing the trie loads nodes from db on demand.func New(root common.Hash, db *Database) (*Trie, error) {    if db == nil {        panic("trie.New called without a database")    }    trie := &amp;Trie{        db: db,    }    if root != (common.Hash{}) &amp;&amp; root != emptyRoot {        rootnode, err := trie.resolveHash(root[:], nil)        if err != nil {            return nil, err        }        trie.root = rootnode    }    return trie, nil}</code></pre><h5 id="2-Trieæ ‘çš„æ’å…¥"><a href="#2-Trieæ ‘çš„æ’å…¥" class="headerlink" title="2. Trieæ ‘çš„æ’å…¥"></a>2. Trieæ ‘çš„æ’å…¥</h5><p>Trieæ ‘çš„æ’å…¥ï¼Œè¿™æ˜¯ä¸€ä¸ªé€’å½’è°ƒç”¨çš„æ–¹æ³•ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¸€ç›´å¾€ä¸‹æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°å¯ä»¥æ’å…¥çš„ç‚¹ï¼Œè¿›è¡Œæ’å…¥æ“ä½œã€‚å‚æ•°nodeæ˜¯å½“å‰æ’å…¥çš„èŠ‚ç‚¹ï¼Œ prefixæ˜¯å½“å‰å·²ç»å¤„ç†å®Œçš„éƒ¨åˆ†keyï¼Œ keyæ˜¯è¿˜æ²¡æœ‰å¤„ç†ç©çš„éƒ¨åˆ†key, å®Œæ•´çš„key = prefix + keyã€‚ valueæ˜¯éœ€è¦æ’å…¥çš„å€¼ã€‚ è¿”å›å€¼boolæ˜¯æ“ä½œæ˜¯å¦æ”¹å˜äº†Trieæ ‘(dirty)ï¼Œnodeæ˜¯æ’å…¥å®Œæˆåçš„å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œ erroræ˜¯é”™è¯¯ä¿¡æ¯ã€‚</p><ul><li><p>å¦‚æœèŠ‚ç‚¹ç±»å‹æ˜¯nil(ä¸€é¢—å…¨æ–°çš„Trieæ ‘çš„èŠ‚ç‚¹å°±æ˜¯nilçš„),è¿™ä¸ªæ—¶å€™æ•´é¢—æ ‘æ˜¯ç©ºçš„ï¼Œç›´æ¥è¿”å›shortNode{key, value, t.newFlag()}ï¼Œ è¿™ä¸ªæ—¶å€™æ•´é¢—æ ‘çš„è·Ÿå°±å«æœ‰äº†ä¸€ä¸ªshortNodeèŠ‚ç‚¹ã€‚</p></li><li><p>å¦‚æœå½“å‰çš„æ ¹èŠ‚ç‚¹ç±»å‹æ˜¯shortNode(ä¹Ÿå°±æ˜¯å¶å­èŠ‚ç‚¹)ï¼Œé¦–å…ˆè®¡ç®—å…¬å…±å‰ç¼€ï¼Œå¦‚æœå…¬å…±å‰ç¼€å°±ç­‰äºkeyï¼Œé‚£ä¹ˆè¯´æ˜è¿™ä¸¤ä¸ªkeyæ˜¯ä¸€æ ·çš„ï¼Œå¦‚æœvalueä¹Ÿä¸€æ ·çš„(dirty == false)ï¼Œé‚£ä¹ˆè¿”å›é”™è¯¯ã€‚ å¦‚æœæ²¡æœ‰é”™è¯¯å°±æ›´æ–°shortNodeçš„å€¼ç„¶åè¿”å›ã€‚å¦‚æœå…¬å…±å‰ç¼€ä¸å®Œå…¨åŒ¹é…ï¼Œé‚£ä¹ˆå°±éœ€è¦æŠŠå…¬å…±å‰ç¼€æå–å‡ºæ¥å½¢æˆä¸€ä¸ªç‹¬ç«‹çš„èŠ‚ç‚¹(æ‰©å±•èŠ‚ç‚¹),æ‰©å±•èŠ‚ç‚¹åé¢è¿æ¥ä¸€ä¸ªbranchèŠ‚ç‚¹ï¼ŒbranchèŠ‚ç‚¹åé¢çœ‹æƒ…å†µè¿æ¥ä¸¤ä¸ªshortèŠ‚ç‚¹ã€‚é¦–å…ˆæ„å»ºä¸€ä¸ªbranchèŠ‚ç‚¹(branch := &amp;fullNode{flags: t.newFlag()}),ç„¶åå†branchèŠ‚ç‚¹çš„Childrenä½ç½®è°ƒç”¨t.insertæ’å…¥å‰©ä¸‹çš„ä¸¤ä¸ªshortèŠ‚ç‚¹ã€‚è¿™é‡Œæœ‰ä¸ªå°ç»†èŠ‚ï¼Œkeyçš„ç¼–ç æ˜¯HEX encoding,è€Œä¸”æœ«å°¾å¸¦äº†ä¸€ä¸ªç»ˆç»“ç¬¦ã€‚è€ƒè™‘æˆ‘ä»¬çš„æ ¹èŠ‚ç‚¹çš„keyæ˜¯abc0x16ï¼Œæˆ‘ä»¬æ’å…¥çš„èŠ‚ç‚¹çš„keyæ˜¯ab0x16ã€‚ä¸‹é¢çš„branch.Children[key[matchlen]]æ‰å¯ä»¥æ­£å¸¸è¿è¡Œï¼Œ0x16åˆšå¥½æŒ‡å‘äº†branchèŠ‚ç‚¹çš„ç¬¬17ä¸ªå­©å­ã€‚å¦‚æœåŒ¹é…çš„é•¿åº¦æ˜¯0ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›è¿™ä¸ªbranchèŠ‚ç‚¹ï¼Œå¦åˆ™è¿”å›shortNodeèŠ‚ç‚¹ä½œä¸ºå‰ç¼€èŠ‚ç‚¹ã€‚</p></li><li><p>å¦‚æœå½“å‰çš„èŠ‚ç‚¹æ˜¯fullNode(ä¹Ÿå°±æ˜¯branchèŠ‚ç‚¹)ï¼Œé‚£ä¹ˆç›´æ¥å¾€å¯¹åº”çš„å­©å­èŠ‚ç‚¹è°ƒç”¨insertæ–¹æ³•,ç„¶åæŠŠå¯¹åº”çš„å­©å­èŠ‚ç‚¹åªæƒ³æ–°ç”Ÿæˆçš„èŠ‚ç‚¹ã€‚</p></li><li><p>å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯hashNode, hashNodeçš„æ„æ€æ˜¯å½“å‰èŠ‚ç‚¹è¿˜æ²¡æœ‰åŠ è½½åˆ°å†…å­˜é‡Œé¢æ¥ï¼Œè¿˜æ˜¯å­˜æ”¾åœ¨æ•°æ®åº“é‡Œé¢ï¼Œé‚£ä¹ˆé¦–å…ˆè°ƒç”¨ t.resolveHash(n, prefix)æ¥åŠ è½½åˆ°å†…å­˜ï¼Œç„¶åå¯¹åŠ è½½å‡ºæ¥çš„èŠ‚ç‚¹è°ƒç”¨insertæ–¹æ³•æ¥è¿›è¡Œæ’å…¥ã€‚</p><pre><code class="go">func (t *Trie) insert(n node, prefix, key []byte, value node) (bool, node, error) {  if len(key) == 0 {      if v, ok := n.(valueNode); ok {          return !bytes.Equal(v, value.(valueNode)), value, nil      }      return true, value, nil  }  switch n := n.(type) {  case *shortNode:      matchlen := prefixLen(key, n.Key)      // If the whole key matches, keep this short node as is      // and only update the value.      if matchlen == len(n.Key) {          dirty, nn, err := t.insert(n.Val, append(prefix, key[:matchlen]...), key[matchlen:], value)          if !dirty || err != nil {              return false, n, err          }          return true, &amp;shortNode{n.Key, nn, t.newFlag()}, nil      }      // Otherwise branch out at the index where they differ.      branch := &amp;fullNode{flags: t.newFlag()}      var err error      _, branch.Children[n.Key[matchlen]], err = t.insert(nil, append(prefix, n.Key[:matchlen+1]...), n.Key[matchlen+1:], n.Val)      if err != nil {          return false, nil, err      }      _, branch.Children[key[matchlen]], err = t.insert(nil, append(prefix, key[:matchlen+1]...), key[matchlen+1:], value)      if err != nil {          return false, nil, err      }      // Replace this shortNode with the branch if it occurs at index 0.      if matchlen == 0 {          return true, branch, nil      }      // Otherwise, replace it with a short node leading up to the branch.      return true, &amp;shortNode{key[:matchlen], branch, t.newFlag()}, nil  case *fullNode:      dirty, nn, err := t.insert(n.Children[key[0]], append(prefix, key[0]), key[1:], value)      if !dirty || err != nil {          return false, n, err      }      n = n.copy()      n.flags = t.newFlag()      n.Children[key[0]] = nn      return true, n, nil  case nil:      return true, &amp;shortNode{key, value, t.newFlag()}, nil  case hashNode:      // We've hit a part of the trie that isn't loaded yet. Load      // the node and insert into it. This leaves all child nodes on      // the path to the value in the trie.      rn, err := t.resolveHash(n, prefix)      if err != nil {          return false, nil, err      }      dirty, nn, err := t.insert(rn, prefix, key, value)      if !dirty || err != nil {          return false, rn, err      }      return true, nn, nil  default:      panic(fmt.Sprintf("%T: invalid node: %v", n, n))  }}</code></pre><h5 id="3-Trieæ ‘çš„è·å–"><a href="#3-Trieæ ‘çš„è·å–" class="headerlink" title="3. Trieæ ‘çš„è·å–"></a>3. Trieæ ‘çš„è·å–</h5><p>Trieæ ‘çš„Getæ–¹æ³•ï¼ŒåŸºæœ¬ä¸Šå°±æ˜¯å¾ˆç®€å•çš„éå†Trieæ ‘ï¼Œæ¥è·å–Keyçš„ä¿¡æ¯ã€‚</p><pre><code class="go">// Get returns the value for key stored in the trie.// The value bytes must not be modified by the caller.func (t *Trie) Get(key []byte) []byte {  res, err := t.TryGet(key)  if err != nil {      log.Error(fmt.Sprintf("Unhandled trie error: %v", err))  }  return res}// TryGet returns the value for key stored in the trie.// The value bytes must not be modified by the caller.// If a node was not found in the database, a MissingNodeError is returned.func (t *Trie) TryGet(key []byte) ([]byte, error) {  value, newroot, didResolve, err := t.tryGet(t.root, keybytesToHex(key), 0)  if err == nil &amp;&amp; didResolve {      t.root = newroot  }  return value, err}func (t *Trie) tryGet(origNode node, key []byte, pos int) (value []byte, newnode node, didResolve bool, err error) {  switch n := (origNode).(type) {  case nil:      return nil, nil, false, nil  case valueNode:      return n, n, false, nil  case *shortNode:      if len(key)-pos &lt; len(n.Key) || !bytes.Equal(n.Key, key[pos:pos+len(n.Key)]) {          // key not found in trie          return nil, n, false, nil      }      value, newnode, didResolve, err = t.tryGet(n.Val, key, pos+len(n.Key))      if err == nil &amp;&amp; didResolve {          n = n.copy()          n.Val = newnode      }      return value, n, didResolve, err  case *fullNode:      value, newnode, didResolve, err = t.tryGet(n.Children[key[pos]], key, pos+1)      if err == nil &amp;&amp; didResolve {          n = n.copy()          n.Children[key[pos]] = newnode      }      return value, n, didResolve, err  case hashNode:      child, err := t.resolveHash(n, key[:pos])      if err != nil {          return nil, n, true, err      }      value, newnode, _, err := t.tryGet(child, key, pos)      return value, newnode, true, err  default:      panic(fmt.Sprintf("%T: invalid node: %v", origNode, origNode))  }}// TryGetNode attempts to retrieve a trie node by compact-encoded path. It is not// possible to use keybyte-encoding as the path might contain odd nibbles.func (t *Trie) TryGetNode(path []byte) ([]byte, int, error) {  item, newroot, resolved, err := t.tryGetNode(t.root, compactToHex(path), 0)  if err != nil {      return nil, resolved, err  }  if resolved &gt; 0 {      t.root = newroot  }  if item == nil {      return nil, resolved, nil  }  return item, resolved, err}func (t *Trie) tryGetNode(origNode node, path []byte, pos int) (item []byte, newnode node, resolved int, err error) {  // If we reached the requested path, return the current node  if pos &gt;= len(path) {      // Although we most probably have the original node expanded, encoding      // that into consensus form can be nasty (needs to cascade down) and      // time consuming. Instead, just pull the hash up from disk directly.      var hash hashNode      if node, ok := origNode.(hashNode); ok {          hash = node      } else {          hash, _ = origNode.cache()      }      if hash == nil {          return nil, origNode, 0, errors.New("non-consensus node")      }      blob, err := t.db.Node(common.BytesToHash(hash))      return blob, origNode, 1, err  }  // Path still needs to be traversed, descend into children  switch n := (origNode).(type) {  case nil:      // Non-existent path requested, abort      return nil, nil, 0, nil  case valueNode:      // Path prematurely ended, abort      return nil, nil, 0, nil  case *shortNode:      if len(path)-pos &lt; len(n.Key) || !bytes.Equal(n.Key, path[pos:pos+len(n.Key)]) {          // Path branches off from short node          return nil, n, 0, nil      }      item, newnode, resolved, err = t.tryGetNode(n.Val, path, pos+len(n.Key))      if err == nil &amp;&amp; resolved &gt; 0 {          n = n.copy()          n.Val = newnode      }      return item, n, resolved, err  case *fullNode:      item, newnode, resolved, err = t.tryGetNode(n.Children[path[pos]], path, pos+1)      if err == nil &amp;&amp; resolved &gt; 0 {          n = n.copy()          n.Children[path[pos]] = newnode      }      return item, n, resolved, err  case hashNode:      child, err := t.resolveHash(n, path[:pos])      if err != nil {          return nil, n, 1, err      }      item, newnode, resolved, err := t.tryGetNode(child, path, pos)      return item, newnode, resolved + 1, err  default:      panic(fmt.Sprintf("%T: invalid node: %v", origNode, origNode))  }}</code></pre></li></ul><h5 id="4-Trieæ ‘çš„åˆ é™¤"><a href="#4-Trieæ ‘çš„åˆ é™¤" class="headerlink" title="4. Trieæ ‘çš„åˆ é™¤"></a>4. Trieæ ‘çš„åˆ é™¤</h5><p>ä»£ç è·Ÿæ’å…¥æ¯”è¾ƒç±»ä¼¼</p><pre><code class="go">// Delete removes any existing value for key from the trie.func (t *Trie) Delete(key []byte) {    if err := t.TryDelete(key); err != nil {        log.Error(fmt.Sprintf("Unhandled trie error: %v", err))    }}// TryDelete removes any existing value for key from the trie.// If a node was not found in the database, a MissingNodeError is returned.func (t *Trie) TryDelete(key []byte) error {    t.unhashed++    k := keybytesToHex(key)    _, n, err := t.delete(t.root, nil, k)    if err != nil {        return err    }    t.root = n    return nil}// delete returns the new root of the trie with key deleted.// It reduces the trie to minimal form by simplifying// nodes on the way up after deleting recursively.func (t *Trie) delete(n node, prefix, key []byte) (bool, node, error) {    switch n := n.(type) {    case *shortNode:        matchlen := prefixLen(key, n.Key)        if matchlen &lt; len(n.Key) {            return false, n, nil // don't replace n on mismatch        }        if matchlen == len(key) {            return true, nil, nil // remove n entirely for whole matches        }        // The key is longer than n.Key. Remove the remaining suffix        // from the subtrie. Child can never be nil here since the        // subtrie must contain at least two other values with keys        // longer than n.Key.        dirty, child, err := t.delete(n.Val, append(prefix, key[:len(n.Key)]...), key[len(n.Key):])        if !dirty || err != nil {            return false, n, err        }        switch child := child.(type) {        case *shortNode:            // Deleting from the subtrie reduced it to another            // short node. Merge the nodes to avoid creating a            // shortNode{..., shortNode{...}}. Use concat (which            // always creates a new slice) instead of append to            // avoid modifying n.Key since it might be shared with            // other nodes.            return true, &amp;shortNode{concat(n.Key, child.Key...), child.Val, t.newFlag()}, nil        default:            return true, &amp;shortNode{n.Key, child, t.newFlag()}, nil        }    case *fullNode:        dirty, nn, err := t.delete(n.Children[key[0]], append(prefix, key[0]), key[1:])        if !dirty || err != nil {            return false, n, err        }        n = n.copy()        n.flags = t.newFlag()        n.Children[key[0]] = nn        // Check how many non-nil entries are left after deleting and        // reduce the full node to a short node if only one entry is        // left. Since n must've contained at least two children        // before deletion (otherwise it would not be a full node) n        // can never be reduced to nil.        //        // When the loop is done, pos contains the index of the single        // value that is left in n or -2 if n contains at least two        // values.        pos := -1        for i, cld := range &amp;n.Children {            if cld != nil {                if pos == -1 {                    pos = i                } else {                    pos = -2                    break                }            }        }        if pos &gt;= 0 {            if pos != 16 {                // If the remaining entry is a short node, it replaces                // n and its key gets the missing nibble tacked to the                // front. This avoids creating an invalid                // shortNode{..., shortNode{...}}.  Since the entry                // might not be loaded yet, resolve it just for this                // check.                cnode, err := t.resolve(n.Children[pos], prefix)                if err != nil {                    return false, nil, err                }                if cnode, ok := cnode.(*shortNode); ok {                    k := append([]byte{byte(pos)}, cnode.Key...)                    return true, &amp;shortNode{k, cnode.Val, t.newFlag()}, nil                }            }            // Otherwise, n is replaced by a one-nibble short node            // containing the child.            return true, &amp;shortNode{[]byte{byte(pos)}, n.Children[pos], t.newFlag()}, nil        }        // n still contains at least two values and cannot be reduced.        return true, n, nil    case valueNode:        return true, nil, nil    case nil:        return false, nil, nil    case hashNode:        // We've hit a part of the trie that isn't loaded yet. Load        // the node and delete from it. This leaves all child nodes on        // the path to the value in the trie.        rn, err := t.resolveHash(n, prefix)        if err != nil {            return false, nil, err        }        dirty, nn, err := t.delete(rn, prefix, key)        if !dirty || err != nil {            return false, rn, err        }        return true, nn, nil    default:        panic(fmt.Sprintf("%T: invalid node: %v (%v)", n, n, key))    }}</code></pre><h5 id="5-Trieæ ‘çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–"><a href="#5-Trieæ ‘çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–" class="headerlink" title="5. Trieæ ‘çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–"></a>5. Trieæ ‘çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–</h5><p>åºåˆ—åŒ–ä¸»è¦æ˜¯æŒ‡æŠŠå†…å­˜è¡¨ç¤ºçš„æ•°æ®å­˜æ”¾åˆ°æ•°æ®åº“é‡Œé¢ï¼Œ ååºåˆ—åŒ–æ˜¯æŒ‡æŠŠæ•°æ®åº“é‡Œé¢çš„Trieæ•°æ®åŠ è½½æˆå†…å­˜è¡¨ç¤ºçš„æ•°æ®ã€‚ åºåˆ—åŒ–çš„ç›®çš„ä¸»è¦æ˜¯æ–¹ä¾¿å­˜å‚¨ï¼Œå‡å°‘å­˜å‚¨å¤§å°ç­‰ã€‚ ååºåˆ—åŒ–çš„ç›®çš„æ˜¯æŠŠå­˜å‚¨çš„æ•°æ®åŠ è½½åˆ°å†…å­˜ï¼Œæ–¹ä¾¿Trieæ ‘çš„æ’å…¥ï¼ŒæŸ¥è¯¢ï¼Œä¿®æ”¹ç­‰éœ€æ±‚ã€‚</p><p>Trieçš„åºåˆ—åŒ–ä¸»è¦æ‰ä½œç”¨äº†å‰é¢ä»‹ç»çš„Compat Encodingå’Œ RLPç¼–ç æ ¼å¼ã€‚ åºåˆ—åŒ–çš„ç»“æ„åœ¨é»„çš®ä¹¦é‡Œé¢æœ‰è¯¦ç»†çš„ä»‹ç»ã€‚</p><p><img src="https://img-blog.csdnimg.cn/20210527171804758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>Trieæ ‘çš„ä½¿ç”¨æ–¹æ³•åœ¨trie_test.goé‡Œé¢æœ‰æ¯”è¾ƒè¯¦ç»†çš„å‚è€ƒã€‚ è¿™é‡Œæˆ‘åˆ—å‡ºä¸€ä¸ªç®€å•çš„ä½¿ç”¨æµç¨‹ã€‚é¦–å…ˆåˆ›å»ºä¸€ä¸ªç©ºçš„Trieæ ‘ï¼Œç„¶åæ’å…¥ä¸€äº›æ•°æ®ï¼Œæœ€åè°ƒç”¨trie.Commit()æ–¹æ³•è¿›è¡Œåºåˆ—åŒ–å¹¶å¾—åˆ°ä¸€ä¸ªhashå€¼(root), ä¹Ÿå°±æ˜¯ä¸Šå›¾ä¸­çš„KEC(c(J,0))æˆ–è€…æ˜¯TRIE(J)ã€‚</p><pre><code class="go">func TestInsert(t *testing.T) {    trie := newEmpty()    updateString(trie, "doe", "reindeer")    updateString(trie, "dog", "puppy")    updateString(trie, "dogglesworth", "cat")    exp := common.HexToHash("8aad789dff2f538bca5d8ea56e8abe10f4c7ba3a5dea95fea4cd6e7c3a1168d3")    root := trie.Hash()    if root != exp {        t.Errorf("case 1: exp %x got %x", exp, root)    }    trie = newEmpty()    updateString(trie, "A", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")    exp = common.HexToHash("d23786fb4a010da3ce639d66d5e904a11dbc02746d1ce25029e53290cabf28ab")    root, err := trie.Commit(nil)    if err != nil {        t.Fatalf("commit error: %v", err)    }    if root != exp {        t.Errorf("case 2: exp %x got %x", exp, root)    }}</code></pre><p>ä¸‹é¢æˆ‘ä»¬æ¥åˆ†æä¸‹Commit()çš„ä¸»è¦æµç¨‹ã€‚ ç»è¿‡ä¸€ç³»åˆ—çš„è°ƒç”¨ï¼Œæœ€ç»ˆè°ƒç”¨äº†hasher.goçš„hashæ–¹æ³•ã€‚</p><pre><code class="go">// Commit writes all nodes to the trie's memory database, tracking the internal// and external (for account tries) references.func (t *Trie) Commit(onleaf LeafCallback) (root common.Hash, err error) {    if t.db == nil {        panic("commit called on trie with nil database")    }    if t.root == nil {        return emptyRoot, nil    }    // Derive the hash for all dirty nodes first. We hold the assumption    // in the following procedure that all nodes are hashed.    rootHash := t.Hash()    h := newCommitter()    defer returnCommitterToPool(h)    // Do a quick check if we really need to commit, before we spin    // up goroutines. This can happen e.g. if we load a trie for reading storage    // values, but don't write to it.    if _, dirty := t.root.cache(); !dirty {        return rootHash, nil    }    var wg sync.WaitGroup    if onleaf != nil {        h.onleaf = onleaf        h.leafCh = make(chan *leaf, leafChanSize)        wg.Add(1)        go func() {            defer wg.Done()            h.commitLoop(t.db)        }()    }    var newRoot hashNode    newRoot, err = h.Commit(t.root, t.db)    if onleaf != nil {        // The leafch is created in newCommitter if there was an onleaf callback        // provided. The commitLoop only _reads_ from it, and the commit        // operation was the sole writer. Therefore, it's safe to close this        // channel here.        close(h.leafCh)        wg.Wait()    }    if err != nil {        return common.Hash{}, err    }    t.root = newRoot    return rootHash, nil}// Hash returns the root hash of the trie. It does not write to the// database and can be used even if the trie doesn't have one.func (t *Trie) Hash() common.Hash {    hash, cached, _ := t.hashRoot()    t.root = cached    return common.BytesToHash(hash.(hashNode))}</code></pre><p>ä¸‹é¢æˆ‘ä»¬ç®€å•ä»‹ç»ä¸‹hashæ–¹æ³•ï¼Œhashæ–¹æ³•ä¸»è¦åšäº†ä¸¤ä¸ªæ“ä½œã€‚ ä¸€ä¸ªæ˜¯ä¿ç•™åŸæœ‰çš„æ ‘å½¢ç»“æ„ï¼Œå¹¶ç”¨cacheå˜é‡ä¸­ï¼Œ å¦ä¸€ä¸ªæ˜¯è®¡ç®—åŸæœ‰æ ‘å½¢ç»“æ„çš„hashå¹¶æŠŠhashå€¼å­˜æ”¾åˆ°cacheå˜é‡ä¸­ä¿å­˜ä¸‹æ¥ã€‚</p><p>è®¡ç®—åŸæœ‰hashå€¼çš„ä¸»è¦æµç¨‹ï¼š</p><ul><li>å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯shortNode, è°ƒç”¨h.hashShortNodeChildren(n)æŠŠæ‰€æœ‰çš„å­èŠ‚ç‚¹çš„hashå€¼æ±‚å‡ºæ¥ï¼ŒæŠŠåŸæœ‰çš„å­èŠ‚ç‚¹æ›¿æ¢æˆå­èŠ‚ç‚¹çš„hashå€¼ã€‚ è¿™æ˜¯ä¸€ä¸ªé€’å½’è°ƒç”¨çš„è¿‡ç¨‹ï¼Œä¼šä»æ ‘å¶ä¾æ¬¡å¾€ä¸Šè®¡ç®—ç›´åˆ°æ ‘æ ¹ã€‚ç„¶åè°ƒç”¨shortnodeToHashæ–¹æ³•è®¡ç®—å½“å‰èŠ‚ç‚¹çš„hashå€¼ï¼Œå¹¶æŠŠå½“å‰èŠ‚ç‚¹çš„hashå€¼æ”¾å…¥cacheèŠ‚ç‚¹ï¼Œç„¶åè¿”å›ã€‚</li><li>å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯fullNode, è°ƒç”¨h.hashFullNodeChildren(n)æŠŠæ‰€æœ‰çš„å­èŠ‚ç‚¹çš„hashå€¼æ±‚å‡ºæ¥ï¼ŒæŠŠåŸæœ‰çš„å­èŠ‚ç‚¹æ›¿æ¢æˆå­èŠ‚ç‚¹çš„hashå€¼ã€‚ è¿™æ˜¯ä¸€ä¸ªé€’å½’è°ƒç”¨çš„è¿‡ç¨‹ï¼Œä¼šä»æ ‘å¶ä¾æ¬¡å¾€ä¸Šè®¡ç®—ç›´åˆ°æ ‘æ ¹ã€‚ç„¶åè°ƒç”¨fullnodeToHashæ–¹æ³•è®¡ç®—å½“å‰èŠ‚ç‚¹çš„hashå€¼ï¼Œå¹¶æŠŠå½“å‰èŠ‚ç‚¹çš„hashå€¼æ”¾å…¥cacheèŠ‚ç‚¹ï¼Œç„¶åè¿”å›ã€‚</li><li>å¦åˆ™çš„è¯è¿™ä¸ªèŠ‚ç‚¹æ²¡æœ‰childrenã€‚ç›´æ¥è¿”å›ã€‚<br>è¿”å›å€¼è¯´æ˜ï¼Œ cacheå˜é‡åŒ…å«äº†åŸæœ‰çš„nodeèŠ‚ç‚¹ï¼Œå¹¶ä¸”åŒ…å«äº†nodeèŠ‚ç‚¹çš„hashå€¼ã€‚ hashå˜é‡è¿”å›äº†å½“å‰èŠ‚ç‚¹çš„hashå€¼(è¿™ä¸ªå€¼å…¶å®æ˜¯æ ¹æ®nodeå’Œnodeçš„æ‰€æœ‰å­èŠ‚ç‚¹è®¡ç®—å‡ºæ¥çš„)ã€‚</li></ul><p>æœ‰ä¸€ä¸ªå°ç»†èŠ‚ï¼š æ ¹èŠ‚ç‚¹è°ƒç”¨hashå‡½æ•°çš„æ—¶å€™ï¼Œ forceå‚æ•°æ˜¯ä¸ºtrueçš„ï¼Œå…¶ä»–çš„å­èŠ‚ç‚¹è°ƒç”¨çš„æ—¶å€™forceå‚æ•°æ˜¯ä¸ºfalseçš„ã€‚ forceå‚æ•°çš„ç”¨é€”æ˜¯å½“||c(J,i)||&lt;32çš„æ—¶å€™ä¹Ÿå¯¹c(J,i)è¿›è¡Œhashè®¡ç®—ï¼Œè¿™æ ·ä¿è¯æ— è®ºå¦‚ä½•ä¹Ÿä¼šå¯¹æ ¹èŠ‚ç‚¹è¿›è¡ŒHashè®¡ç®—ã€‚</p><pre><code class="go">// hash collapses a node down into a hash node, also returning a copy of the// original node initialized with the computed hash to replace the original one.func (h *hasher) hash(n node, force bool) (hashed node, cached node) {    // Return the cached hash if it's available    if hash, _ := n.cache(); hash != nil {        return hash, n    }    // Trie not processed yet, walk the children    switch n := n.(type) {    case *shortNode:        collapsed, cached := h.hashShortNodeChildren(n)        hashed := h.shortnodeToHash(collapsed, force)        // We need to retain the possibly _not_ hashed node, in case it was too        // small to be hashed        if hn, ok := hashed.(hashNode); ok {            cached.flags.hash = hn        } else {            cached.flags.hash = nil        }        return hashed, cached    case *fullNode:        collapsed, cached := h.hashFullNodeChildren(n)        hashed = h.fullnodeToHash(collapsed, force)        if hn, ok := hashed.(hashNode); ok {            cached.flags.hash = hn        } else {            cached.flags.hash = nil        }        return hashed, cached    default:        // Value and hash nodes don't have children so they're left as were        return n, n    }}// shortnodeToHash creates a hashNode from a shortNode. The supplied shortnode// should have hex-type Key, which will be converted (without modification)// into compact form for RLP encoding.// If the rlp data is smaller than 32 bytes, `nil` is returned.func (h *hasher) shortnodeToHash(n *shortNode, force bool) node {    h.tmp.Reset()    if err := rlp.Encode(&amp;h.tmp, n); err != nil {        panic("encode error: " + err.Error())    }    if len(h.tmp) &lt; 32 &amp;&amp; !force {        return n // Nodes smaller than 32 bytes are stored inside their parent    }    return h.hashData(h.tmp)}</code></pre><p>hashShortNodeChildrenæ–¹æ³•,è¿™ä¸ªæ–¹æ³•æŠŠæ‰€æœ‰çš„å­èŠ‚ç‚¹æ›¿æ¢æˆä»–ä»¬çš„hashï¼Œå¯ä»¥çœ‹åˆ°cacheå˜é‡æ¥ç®¡äº†åŸæ¥çš„Trieæ ‘çš„å®Œæ•´ç»“æ„ï¼Œcollapsedå˜é‡æŠŠå­èŠ‚ç‚¹æ›¿æ¢æˆå­èŠ‚ç‚¹çš„hashå€¼ã€‚<br>é¦–å…ˆæŠŠcollapsed.Keyä»Hex Encoding æ›¿æ¢æˆ Compact Encoding, ç„¶åé€’å½’è°ƒç”¨hashæ–¹æ³•è®¡ç®—å­èŠ‚ç‚¹çš„hashå’Œcacheï¼Œè¿™æ ·å°±æŠŠå­èŠ‚ç‚¹æ›¿æ¢æˆäº†å­èŠ‚ç‚¹çš„hashå€¼ã€‚</p><pre><code class="go">// hashShortNodeChildren collapses the short node. The returned collapsed node// holds a live reference to the Key, and must not be modified.// The cachedfunc (h *hasher) hashShortNodeChildren(n *shortNode) (collapsed, cached *shortNode) {    // Hash the short node's child, caching the newly hashed subtree    collapsed, cached = n.copy(), n.copy()    // Previously, we did copy this one. We don't seem to need to actually    // do that, since we don't overwrite/reuse keys    //cached.Key = common.CopyBytes(n.Key)    collapsed.Key = hexToCompact(n.Key)    // Unless the child is a valuenode or hashnode, hash it    switch n.Val.(type) {    case *fullNode, *shortNode:        collapsed.Val, cached.Val = h.hash(n.Val, false)    }    return collapsed, cached}</code></pre><p>hashFullNodeChildrenæ–¹æ³•,è¿™ä¸ªæ–¹æ³•éå†æ¯ä¸ªå­èŠ‚ç‚¹ï¼ŒæŠŠå­èŠ‚ç‚¹æ›¿æ¢æˆå­èŠ‚ç‚¹çš„Hashå€¼ã€‚</p><pre><code class="go">func (h *hasher) hashFullNodeChildren(n *fullNode) (collapsed *fullNode, cached *fullNode) {    // Hash the full node's children, caching the newly hashed subtrees    cached = n.copy()    collapsed = n.copy()    if h.parallel {        var wg sync.WaitGroup        wg.Add(16)        for i := 0; i &lt; 16; i++ {            go func(i int) {                hasher := newHasher(false)                if child := n.Children[i]; child != nil {                    collapsed.Children[i], cached.Children[i] = hasher.hash(child, false)                } else {                    collapsed.Children[i] = nilValueNode                }                returnHasherToPool(hasher)                wg.Done()            }(i)        }        wg.Wait()    } else {        for i := 0; i &lt; 16; i++ {            if child := n.Children[i]; child != nil {                collapsed.Children[i], cached.Children[i] = h.hash(child, false)            } else {                collapsed.Children[i] = nilValueNode            }        }    }    return collapsed, cached}</code></pre><p>fullnodeToHashæ–¹æ³•å’ŒshortnodeToHashæ–¹æ³•ï¼š<br>ç›´æ¥è°ƒç”¨rlp.Encodeæ–¹æ³•å¯¹è¿™ä¸ªèŠ‚ç‚¹è¿›è¡Œç¼–ç ï¼ˆæ­¤æ—¶è®¤ä¸ºnodeçš„æ‰€æœ‰å­èŠ‚ç‚¹éƒ½æ›¿æ¢æˆäº†å­èŠ‚ç‚¹çš„hashå€¼ï¼‰</p><p>å¦‚æœç¼–ç åçš„å€¼å°äº32ï¼Œå¹¶ä¸”è¿™ä¸ªèŠ‚ç‚¹ä¸æ˜¯æ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå°±æŠŠä»–ä»¬ç›´æ¥å­˜å‚¨åœ¨ä»–ä»¬çš„çˆ¶èŠ‚ç‚¹é‡Œé¢ï¼Œå¦åˆ™è°ƒç”¨h.sha.Writeæ–¹æ³•è¿›è¡Œhashè®¡ç®—ï¼Œ ç„¶åæŠŠhashå€¼å’Œç¼–ç åçš„æ•°æ®å­˜å‚¨åˆ°æ•°æ®åº“é‡Œé¢ï¼Œç„¶åè¿”å›hashå€¼ã€‚</p><p>å¯ä»¥çœ‹åˆ°æ¯ä¸ªå€¼å¤§äº32çš„èŠ‚ç‚¹çš„å€¼å’Œhashéƒ½å­˜å‚¨åˆ°äº†æ•°æ®åº“é‡Œé¢ã€‚</p><pre><code class="go">// shortnodeToHash creates a hashNode from a shortNode. The supplied shortnode// should have hex-type Key, which will be converted (without modification)// into compact form for RLP encoding.// If the rlp data is smaller than 32 bytes, `nil` is returned.func (h *hasher) shortnodeToHash(n *shortNode, force bool) node {    h.tmp.Reset()    if err := rlp.Encode(&amp;h.tmp, n); err != nil {        panic("encode error: " + err.Error())    }    if len(h.tmp) &lt; 32 &amp;&amp; !force {        return n // Nodes smaller than 32 bytes are stored inside their parent    }    return h.hashData(h.tmp)}// shortnodeToHash is used to creates a hashNode from a set of hashNodes, (which// may contain nil values)func (h *hasher) fullnodeToHash(n *fullNode, force bool) node {    h.tmp.Reset()    // Generate the RLP encoding of the node    if err := n.EncodeRLP(&amp;h.tmp); err != nil {        panic("encode error: " + err.Error())    }    if len(h.tmp) &lt; 32 &amp;&amp; !force {        return n // Nodes smaller than 32 bytes are stored inside their parent    }    return h.hashData(h.tmp)}</code></pre><p>Trieçš„ååºåˆ—åŒ–è¿‡ç¨‹ã€‚è¿˜è®°å¾—ä¹‹å‰åˆ›å»ºTrieæ ‘çš„æµç¨‹ä¹ˆã€‚ å¦‚æœå‚æ•°rootçš„hashå€¼ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå°±ä¼šè°ƒç”¨rootnode, err := trie.resolveHash(root[:], nil) æ–¹æ³•æ¥å¾—åˆ°rootnodeèŠ‚ç‚¹ã€‚</p><p>é¦–å…ˆä»æ•°æ®åº“é‡Œé¢é€šè¿‡hashå€¼è·å–èŠ‚ç‚¹çš„RLPç¼–ç åçš„å†…å®¹ã€‚ ç„¶åè°ƒç”¨decodeNodeæ¥è§£æå†…å®¹ã€‚</p><pre><code class="go">func (it *nodeIterator) resolveHash(hash hashNode, path []byte) (node, error) {    if it.resolver != nil {        if blob, err := it.resolver.Get(hash); err == nil &amp;&amp; len(blob) &gt; 0 {            if resolved, err := decodeNode(hash, blob); err == nil {                return resolved, nil            }        }    }    resolved, err := it.trie.resolveHash(hash, path)    return resolved, err}</code></pre><p>decodeNodeæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æ ¹æ®rlpçš„listçš„é•¿åº¦æ¥åˆ¤æ–­è¿™ä¸ªç¼–ç åˆ°åº•å±äºä»€ä¹ˆèŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯2ä¸ªå­—æ®µé‚£ä¹ˆå°±æ˜¯shortNodeèŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯17ä¸ªå­—æ®µï¼Œé‚£ä¹ˆå°±æ˜¯fullNodeï¼Œç„¶ååˆ†åˆ«è°ƒç”¨å„è‡ªçš„è§£æå‡½æ•°ã€‚</p><pre><code class="go">// decodeNode parses the RLP encoding of a trie node.func decodeNode(hash, buf []byte, cachegen uint16) (node, error) {    if len(buf) == 0 {        return nil, io.ErrUnexpectedEOF    }    elems, _, err := rlp.SplitList(buf)    if err != nil {        return nil, fmt.Errorf("decode error: %v", err)    }    switch c, _ := rlp.CountValues(elems); c {    case 2:        n, err := decodeShort(hash, elems)        return n, wrapError(err, "short")    case 17:        n, err := decodeFull(hash, elems)        return n, wrapError(err, "full")    default:        return nil, fmt.Errorf("invalid number of list elements: %v", c)    }}</code></pre><p>decodeShortæ–¹æ³•ï¼Œé€šè¿‡keyæ˜¯å¦æœ‰ç»ˆç»“ç¬¦å·æ¥åˆ¤æ–­åˆ°åº•æ˜¯å¶å­èŠ‚ç‚¹è¿˜æ˜¯ä¸­é—´èŠ‚ç‚¹ã€‚å¦‚æœæœ‰ç»ˆç»“ç¬¦é‚£ä¹ˆå°±æ˜¯å¶å­ç»“ç‚¹ï¼Œé€šè¿‡SplitStringæ–¹æ³•è§£æå‡ºæ¥valç„¶åç”Ÿæˆä¸€ä¸ªshortNodeã€‚ ä¸è¿‡æ²¡æœ‰ç»ˆç»“ç¬¦ï¼Œé‚£ä¹ˆè¯´æ˜æ˜¯æ‰©å±•èŠ‚ç‚¹ï¼Œ é€šè¿‡decodeRefæ¥è§£æå‰©ä¸‹çš„èŠ‚ç‚¹ï¼Œç„¶åç”Ÿæˆä¸€ä¸ªshortNodeã€‚</p><pre><code class="go">func decodeShort(hash, buf, elems []byte, cachegen uint16) (node, error) {    kbuf, rest, err := rlp.SplitString(elems)    if err != nil {        return nil, err    }    flag := nodeFlag{hash: hash}    key := compactToHex(kbuf)    if hasTerm(key) {        // value node        val, _, err := rlp.SplitString(rest)        if err != nil {            return nil, fmt.Errorf("invalid value node: %v", err)        }        return &amp;shortNode{key, append(valueNode{}, val...), flag}, nil    }    r, _, err := decodeRef(rest)    if err != nil {        return nil, wrapError(err, "val")    }    return &amp;shortNode{key, r, flag}, nil}</code></pre><p>decodeRefæ–¹æ³•æ ¹æ®æ•°æ®ç±»å‹è¿›è¡Œè§£æï¼Œå¦‚æœç±»å‹æ˜¯listï¼Œé‚£ä¹ˆæœ‰å¯èƒ½æ˜¯å†…å®¹&lt;32çš„å€¼ï¼Œé‚£ä¹ˆè°ƒç”¨decodeNodeè¿›è¡Œè§£æã€‚ å¦‚æœæ˜¯ç©ºèŠ‚ç‚¹ï¼Œé‚£ä¹ˆè¿”å›ç©ºï¼Œå¦‚æœæ˜¯hashå€¼ï¼Œé‚£ä¹ˆæ„é€ ä¸€ä¸ªhashNodeè¿›è¡Œè¿”å›ï¼Œæ³¨æ„çš„æ˜¯è¿™é‡Œæ²¡æœ‰ç»§ç»­è¿›è¡Œè§£æï¼Œå¦‚æœéœ€è¦ç»§ç»­è§£æè¿™ä¸ªhashNodeï¼Œé‚£ä¹ˆéœ€è¦ç»§ç»­è°ƒç”¨resolveHashæ–¹æ³•ã€‚ åˆ°è¿™é‡ŒdecodeShortæ–¹æ³•å°±è°ƒç”¨å®Œæˆäº†ã€‚</p><pre><code class="go">func decodeRef(buf []byte, cachegen uint16) (node, []byte, error) {    kind, val, rest, err := rlp.Split(buf)    if err != nil {        return nil, buf, err    }    switch {    case kind == rlp.List:        // 'embedded' node reference. The encoding must be smaller        // than a hash in order to be valid.        if size := len(buf) - len(rest); size &gt; hashLen {            err := fmt.Errorf("oversized embedded node (size is %d bytes, want size &lt; %d)", size, hashLen)            return nil, buf, err        }        n, err := decodeNode(nil, buf)        return n, rest, err    case kind == rlp.String &amp;&amp; len(val) == 0:        // empty node        return nil, rest, nil    case kind == rlp.String &amp;&amp; len(val) == 32:        return append(hashNode{}, val...), rest, nil    default:        return nil, nil, fmt.Errorf("invalid RLP string size %d (want 0 or 32)", len(val))    }}</code></pre><p>decodeFullæ–¹æ³•ã€‚æ ¹decodeShortæ–¹æ³•çš„æµç¨‹å·®ä¸å¤šã€‚</p><pre><code class="go">func decodeFull(hash, buf, elems []byte, cachegen uint16) (*fullNode, error) {    n := &amp;fullNode{flags: nodeFlag{hash: hash}}    for i := 0; i &lt; 16; i++ {        cld, rest, err := decodeRef(elems)        if err != nil {            return n, wrapError(err, fmt.Sprintf("[%d]", i))        }        n.Children[i], elems = cld, rest    }    val, _, err := rlp.SplitString(elems)    if err != nil {        return n, err    }    if len(val) &gt; 0 {        n.Children[16] = append(valueNode{}, val...)    }    return n, nil}</code></pre><h2 id="Trieæ ‘çš„é»˜å…‹å°”è¯æ˜ï¼šproof-go"><a href="#Trieæ ‘çš„é»˜å…‹å°”è¯æ˜ï¼šproof-go" class="headerlink" title="Trieæ ‘çš„é»˜å…‹å°”è¯æ˜ï¼šproof.go"></a>Trieæ ‘çš„é»˜å…‹å°”è¯æ˜ï¼šproof.go</h2><p>ä¸»è¦æä¾›ä¸¤ä¸ªæ–¹æ³•ï¼ŒProveæ–¹æ³•è·å–æŒ‡å®šKeyçš„proofè¯æ˜ï¼Œ proofè¯æ˜æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æ‰€æœ‰èŠ‚ç‚¹çš„hashå€¼åˆ—è¡¨ã€‚ VerifyProofæ–¹æ³•ï¼Œæ¥å—ä¸€ä¸ªroothashå€¼å’Œproofè¯æ˜å’Œkeyæ¥éªŒè¯keyæ˜¯å¦å­˜åœ¨ã€‚</p><p>Proveæ–¹æ³•ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹ã€‚æŠŠç»è¿‡çš„èŠ‚ç‚¹çš„hashå€¼ä¸€ä¸ªä¸€ä¸ªå­˜å…¥åˆ°listä¸­ã€‚ç„¶åè¿”å›ã€‚</p><pre><code class="go">// Prove constructs a merkle proof for key. The result contains all encoded nodes// on the path to the value at key. The value itself is also included in the last// node and can be retrieved by verifying the proof.//// If the trie does not contain a value for key, the returned proof contains all// nodes of the longest existing prefix of the key (at least the root node), ending// with the node that proves the absence of the key.func (t *Trie) Prove(key []byte, fromLevel uint, proofDb ethdb.KeyValueWriter) error {    // Collect all nodes on the path to key.    key = keybytesToHex(key)    var nodes []node    tn := t.root    for len(key) &gt; 0 &amp;&amp; tn != nil {        switch n := tn.(type) {        case *shortNode:            if len(key) &lt; len(n.Key) || !bytes.Equal(n.Key, key[:len(n.Key)]) {                // The trie doesn't contain the key.                tn = nil            } else {                tn = n.Val                key = key[len(n.Key):]            }            nodes = append(nodes, n)        case *fullNode:            tn = n.Children[key[0]]            key = key[1:]            nodes = append(nodes, n)        case hashNode:            var err error            tn, err = t.resolveHash(n, nil)            if err != nil {                log.Error(fmt.Sprintf("Unhandled trie error: %v", err))                return err            }        default:            panic(fmt.Sprintf("%T: invalid node: %v", tn, tn))        }    }    hasher := newHasher(false)    defer returnHasherToPool(hasher)    for i, n := range nodes {        if fromLevel &gt; 0 {            fromLevel--            continue        }        var hn node        n, hn = hasher.proofHash(n)        if hash, ok := hn.(hashNode); ok || i == 0 {            // If the node's database encoding is a hash (or is the            // root node), it becomes a proof element.            enc, _ := rlp.EncodeToBytes(n)            if !ok {                hash = hasher.hashData(enc)            }            proofDb.Put(hash, enc)        }    }    return nil}</code></pre><p>VerifyProofæ–¹æ³•ï¼Œæ¥æ”¶ä¸€ä¸ªrootHashå‚æ•°ï¼Œkeyå‚æ•°ï¼Œå’ŒKeyValueReaderï¼Œ æ¥ä¸€ä¸ªä¸€ä¸ªéªŒè¯æ˜¯å¦èƒ½å¤Ÿå’Œæ•°æ®åº“é‡Œé¢çš„èƒ½å¤Ÿå¯¹åº”ä¸Šã€‚</p><pre><code class="go">// VerifyProof checks merkle proofs. The given proof must contain the value for// key in a trie with the given root hash. VerifyProof returns an error if the// proof contains invalid trie nodes or the wrong value.func VerifyProof(rootHash common.Hash, key []byte, proofDb ethdb.KeyValueReader) (value []byte, err error) {    key = keybytesToHex(key)    wantHash := rootHash    for i := 0; ; i++ {        buf, _ := proofDb.Get(wantHash[:])        if buf == nil {            return nil, fmt.Errorf("proof node %d (hash %064x) missing", i, wantHash)        }        n, err := decodeNode(wantHash[:], buf)        if err != nil {            return nil, fmt.Errorf("bad proof node %d: %v", i, err)        }        keyrest, cld := get(n, key, true)        switch cld := cld.(type) {        case nil:            // The trie doesn't contain the key.            return nil, nil        case hashNode:            key = keyrest            copy(wantHash[:], cld)        case valueNode:            return cld, nil        }    }}// get returns the child of the given node. Return nil if the// node with specified key doesn't exist at all.//// There is an additional flag `skipResolved`. If it's set then// all resolved nodes won't be returned.func get(tn node, key []byte, skipResolved bool) ([]byte, node) {    for {        switch n := tn.(type) {        case *shortNode:            if len(key) &lt; len(n.Key) || !bytes.Equal(n.Key, key[:len(n.Key)]) {                return nil, nil            }            tn = n.Val            key = key[len(n.Key):]            if !skipResolved {                return key, tn            }        case *fullNode:            tn = n.Children[key[0]]            key = key[1:]            if !skipResolved {                return key, tn            }        case hashNode:            return key, n        case nil:            return key, nil        case valueNode:            return nil, n        default:            panic(fmt.Sprintf("%T: invalid node: %v", tn, tn))        }    }}</code></pre><h2 id="Trieçš„åŠ å¯†ï¼šsecurity-trie-go"><a href="#Trieçš„åŠ å¯†ï¼šsecurity-trie-go" class="headerlink" title="Trieçš„åŠ å¯†ï¼šsecurity_trie.go"></a>Trieçš„åŠ å¯†ï¼šsecurity_trie.go</h2><p>ä¸ºäº†é¿å…åˆ»æ„ä½¿ç”¨å¾ˆé•¿çš„keyå¯¼è‡´è®¿é—®æ—¶é—´çš„å¢åŠ ï¼Œ security_trieåŒ…è£…äº†ä¸€ä¸‹trieæ ‘ï¼Œ æ‰€æœ‰çš„keyéƒ½è½¬æ¢æˆkeccak256ç®—æ³•è®¡ç®—çš„hashå€¼ã€‚åŒæ—¶åœ¨æ•°æ®åº“é‡Œé¢å­˜å‚¨hashå€¼å¯¹åº”çš„åŸå§‹çš„keyã€‚</p><pre><code class="go">// SecureTrie wraps a trie with key hashing. In a secure trie, all// access operations hash the key using keccak256. This prevents// calling code from creating long chains of nodes that// increase the access time.//// Contrary to a regular trie, a SecureTrie can only be created with// New and must have an attached database. The database also stores// the preimage of each key.//// SecureTrie is not safe for concurrent use.type SecureTrie struct {    trie             Trie    hashKeyBuf       [common.HashLength]byte    secKeyCache      map[string][]byte    secKeyCacheOwner *SecureTrie // Pointer to self, replace the key cache on mismatch}// NewSecure creates a trie with an existing root node from a backing database// and optional intermediate in-memory node pool.//// If root is the zero hash or the sha3 hash of an empty string, the// trie is initially empty. Otherwise, New will panic if db is nil// and returns MissingNodeError if the root node cannot be found.//// Accessing the trie loads nodes from the database or node pool on demand.// Loaded nodes are kept around until their 'cache generation' expires.// A new cache generation is created by each call to Commit.// cachelimit sets the number of past cache generations to keep.func NewSecure(root common.Hash, db *Database) (*SecureTrie, error) {    if db == nil {        panic("trie.NewSecure called without a database")    }    trie, err := New(root, db)    if err != nil {        return nil, err    }    return &amp;SecureTrie{trie: *trie}, nil}// Get returns the value for key stored in the trie.// The value bytes must not be modified by the caller.func (t *SecureTrie) Get(key []byte) []byte {    res, err := t.TryGet(key)    if err != nil {        log.Error(fmt.Sprintf("Unhandled trie error: %v", err))    }    return res}// TryGet returns the value for key stored in the trie.// The value bytes must not be modified by the caller.// If a node was not found in the database, a MissingNodeError is returned.func (t *SecureTrie) TryGet(key []byte) ([]byte, error) {    return t.trie.TryGet(t.hashKey(key))}// Commit writes all nodes and the secure hash pre-images to the trie's database.// Nodes are stored with their sha3 hash as the key.//// Committing flushes nodes from memory. Subsequent Get calls will load nodes// from the database.func (t *SecureTrie) Commit(onleaf LeafCallback) (root common.Hash, err error) {    // Write all the pre-images to the actual disk database    if len(t.getSecKeyCache()) &gt; 0 {        if t.trie.db.preimages != nil { // Ugly direct check but avoids the below write lock            t.trie.db.lock.Lock()            for hk, key := range t.secKeyCache {                t.trie.db.insertPreimage(common.BytesToHash([]byte(hk)), key)            }            t.trie.db.lock.Unlock()        }        t.secKeyCache = make(map[string][]byte)    }    // Commit the trie to its intermediate node database    return t.trie.Commit(onleaf)}</code></pre><h2 id="trieåŒ…ä¸­å…¶ä»–çš„åŠŸèƒ½"><a href="#trieåŒ…ä¸­å…¶ä»–çš„åŠŸèƒ½" class="headerlink" title="trieåŒ…ä¸­å…¶ä»–çš„åŠŸèƒ½"></a>trieåŒ…ä¸­å…¶ä»–çš„åŠŸèƒ½</h2><ul><li>databases.go trieæ•°æ®ç»“æ„å’Œç£ç›˜æ•°æ®åº“ä¹‹é—´çš„ä¸€ä¸ªå†™å…¥å±‚ï¼Œæ–¹ä¾¿trieä¸­èŠ‚ç‚¹çš„æ’å…¥åˆ é™¤æ“ä½œ</li><li>iterator.go éå†Trieçš„é”®å€¼è¿­ä»£å™¨</li></ul><h1 id="å‚è€ƒèµ„æ–™åœ°å€"><a href="#å‚è€ƒèµ„æ–™åœ°å€" class="headerlink" title="å‚è€ƒèµ„æ–™åœ°å€"></a>å‚è€ƒèµ„æ–™åœ°å€</h1><ul><li><a href="https://ethereum.org/en/whitepaper">ä»¥å¤ªåŠç™½çš®ä¹¦</a></li><li><a href="https://ethereum.github.io/yellowpaper/paper.pdf">ä»¥å¤ªåŠé»„çš®ä¹¦ï¼ˆè‹±æ–‡ç‰ˆï¼‰</a></li><li><a href="https://github.com/wanshan1024/ethereum_yellowpaper/blob/master/ethereum_yellow_paper_cn.pdf">ä»¥å¤ªåŠé»„çš®ä¹¦ï¼ˆä¸­æ–‡ç‰ˆï¼‰</a></li><li><a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis">åˆ†æå‚è€ƒèµ„æ–™</a></li><li><a href="https://segmentfault.com/a/1190000016050921">åšå®¢å‚è€ƒèµ„æ–™</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-accountsæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-accounts%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-accounts%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>accountsåŒ…å®ç°äº†ä»¥å¤ªåŠå®¢æˆ·ç«¯çš„é’±åŒ…å’Œè´¦æˆ·ç®¡ç†ã€‚ä»¥å¤ªåŠçš„é’±åŒ…æä¾›äº†keyStoreæ¨¡å¼å’Œusbä¸¤ç§é’±åŒ…ã€‚åŒæ—¶ä»¥å¤ªåŠçš„ åˆçº¦çš„ABIçš„ä»£ç ä¹Ÿæ”¾åœ¨äº†account/abiç›®å½•ã€‚ abié¡¹ç›®å¥½åƒè·Ÿè´¦æˆ·ç®¡ç†æ²¡æœ‰ä»€ä¹ˆå…³ç³»ã€‚ è¿™é‡Œæš‚æ—¶åªåˆ†æäº†è´¦å·ç®¡ç†çš„æ¥å£ã€‚ å…·ä½“çš„keystoreå’Œusbçš„å®ç°ä»£ç æš‚æ—¶ä¸ä¼šç»™å‡ºã€‚</p><p>è´¦å·æ˜¯é€šè¿‡æ•°æ®ç»“æ„å’Œæ¥å£æ¥å®šä¹‰äº†</p><h2 id="æ•°æ®ç»“æ„"><a href="#æ•°æ®ç»“æ„" class="headerlink" title="æ•°æ®ç»“æ„"></a>æ•°æ®ç»“æ„</h2><p>è´¦å·</p><pre><code>// Account represents an Ethereum account located at a specific location defined// by the optional URL field.// ä¸€ä¸ªè´¦å·æ˜¯20ä¸ªå­—èŠ‚çš„æ•°æ®ã€‚ URLæ˜¯å¯é€‰çš„å­—æ®µã€‚type Account struct {    Address common.Address `json:"address"` // Ethereum account address derived from the key    URL     URL            `json:"url"`     // Optional resource locator within a backend}const (    HashLength    = 32    AddressLength = 20)// Address represents the 20 byte address of an Ethereum account.type Address [AddressLength]byte</code></pre><p>é’±åŒ…ã€‚é’±åŒ…åº”è¯¥æ˜¯è¿™é‡Œé¢æœ€é‡è¦çš„ä¸€ä¸ªæ¥å£äº†ã€‚ å…·ä½“çš„é’±åŒ…ä¹Ÿæ˜¯å®ç°äº†è¿™ä¸ªæ¥å£ã€‚<br>é’±åŒ…åˆæœ‰æ‰€è°“çš„åˆ†å±‚ç¡®å®šæ€§é’±åŒ…å’Œæ™®é€šé’±åŒ…ã€‚</p><pre><code>// Wallet represents a software or hardware wallet that might contain one or more// accounts (derived from the same seed).// Wallet æ˜¯æŒ‡åŒ…å«äº†ä¸€ä¸ªæˆ–å¤šä¸ªè´¦æˆ·çš„è½¯ä»¶é’±åŒ…æˆ–è€…ç¡¬ä»¶é’±åŒ…type Wallet interface {    // URL retrieves the canonical path under which this wallet is reachable. It is    // user by upper layers to define a sorting order over all wallets from multiple    // backends.    // URL ç”¨æ¥è·å–è¿™ä¸ªé’±åŒ…å¯ä»¥è®¿é—®çš„è§„èŒƒè·¯å¾„ã€‚ å®ƒä¼šè¢«ä¸Šå±‚ä½¿ç”¨ç”¨æ¥ä»æ‰€æœ‰çš„åç«¯çš„é’±åŒ…æ¥æ’åºã€‚    URL() URL    // Status returns a textual status to aid the user in the current state of the    // wallet. It also returns an error indicating any failure the wallet might have    // encountered.    // ç”¨æ¥è¿”å›ä¸€ä¸ªæ–‡æœ¬å€¼ç”¨æ¥æ ‡è¯†å½“å‰é’±åŒ…çš„çŠ¶æ€ã€‚ åŒæ—¶ä¹Ÿä¼šè¿”å›ä¸€ä¸ªerrorç”¨æ¥æ ‡è¯†é’±åŒ…é‡åˆ°çš„ä»»ä½•é”™è¯¯ã€‚    Status() (string, error)    // Open initializes access to a wallet instance. It is not meant to unlock or    // decrypt account keys, rather simply to establish a connection to hardware    // wallets and/or to access derivation seeds.    // Open åˆå§‹åŒ–å¯¹é’±åŒ…å®ä¾‹çš„è®¿é—®ã€‚è¿™ä¸ªæ–¹æ³•å¹¶ä¸æ„å‘³ç€è§£é”æˆ–è€…è§£å¯†è´¦æˆ·ï¼Œè€Œæ˜¯ç®€å•åœ°å»ºç«‹ä¸ç¡¬ä»¶é’±åŒ…çš„è¿æ¥å’Œ/æˆ–è®¿é—®è¡ç”Ÿç§å­ã€‚    // The passphrase parameter may or may not be used by the implementation of a    // particular wallet instance. The reason there is no passwordless open method    // is to strive towards a uniform wallet handling, oblivious to the different    // backend providers.    // passphraseå‚æ•°å¯èƒ½åœ¨æŸäº›å®ç°ä¸­å¹¶ä¸éœ€è¦ã€‚ æ²¡æœ‰æä¾›ä¸€ä¸ªæ— passphraseå‚æ•°çš„Openæ–¹æ³•çš„åŸå› æ˜¯ä¸ºäº†æä¾›ä¸€ä¸ªç»Ÿä¸€çš„æ¥å£ã€‚     // Please note, if you open a wallet, you must close it to release any allocated    // resources (especially important when working with hardware wallets).    // è¯·æ³¨æ„ï¼Œå¦‚æœä½ openäº†ä¸€ä¸ªé’±åŒ…ï¼Œä½ å¿…é¡»closeå®ƒã€‚ä¸ç„¶æœ‰äº›èµ„æºå¯èƒ½æ²¡æœ‰é‡Šæ”¾ã€‚ ç‰¹åˆ«æ˜¯ä½¿ç”¨ç¡¬ä»¶é’±åŒ…çš„æ—¶å€™éœ€è¦ç‰¹åˆ«æ³¨æ„ã€‚    Open(passphrase string) error    // Close releases any resources held by an open wallet instance.    // Close é‡Šæ”¾ç”±Openæ–¹æ³•å ç”¨çš„ä»»ä½•èµ„æºã€‚    Close() error    // Accounts retrieves the list of signing accounts the wallet is currently aware    // of. For hierarchical deterministic wallets, the list will not be exhaustive,    // rather only contain the accounts explicitly pinned during account derivation.    // Accountsç”¨æ¥è·å–é’±åŒ…å‘ç°äº†è´¦æˆ·åˆ—è¡¨ã€‚ å¯¹äºåˆ†å±‚æ¬¡çš„é’±åŒ…ï¼Œ è¿™ä¸ªåˆ—è¡¨ä¸ä¼šè¯¦å°½çš„åˆ—å‡ºæ‰€æœ‰çš„è´¦å·ï¼Œ è€Œæ˜¯åªåŒ…å«åœ¨å¸æˆ·æ´¾ç”ŸæœŸé—´æ˜ç¡®å›ºå®šçš„å¸æˆ·ã€‚    Accounts() []Account    // Contains returns whether an account is part of this particular wallet or not.    // Contains è¿”å›ä¸€ä¸ªè´¦å·æ˜¯å¦å±äºæœ¬é’±åŒ…ã€‚    Contains(account Account) bool    // Derive attempts to explicitly derive a hierarchical deterministic account at    // the specified derivation path. If requested, the derived account will be added    // to the wallet's tracked account list.    // Deriveå°è¯•åœ¨æŒ‡å®šçš„æ´¾ç”Ÿè·¯å¾„ä¸Šæ˜¾å¼æ´¾ç”Ÿå‡ºåˆ†å±‚ç¡®å®šæ€§å¸æˆ·ã€‚ å¦‚æœpinä¸ºtrueï¼Œæ´¾ç”Ÿå¸æˆ·å°†è¢«æ·»åŠ åˆ°é’±åŒ…çš„è·Ÿè¸ªå¸æˆ·åˆ—è¡¨ä¸­ã€‚    Derive(path DerivationPath, pin bool) (Account, error)    // SelfDerive sets a base account derivation path from which the wallet attempts    // to discover non zero accounts and automatically add them to list of tracked    // accounts.    // SelfDeriveè®¾ç½®ä¸€ä¸ªåŸºæœ¬å¸æˆ·å¯¼å‡ºè·¯å¾„ï¼Œä»ä¸­é’±åŒ…å°è¯•å‘ç°éé›¶å¸æˆ·ï¼Œå¹¶è‡ªåŠ¨å°†å…¶æ·»åŠ åˆ°è·Ÿè¸ªå¸æˆ·åˆ—è¡¨ä¸­ã€‚    // Note, self derivaton will increment the last component of the specified path    // opposed to decending into a child path to allow discovering accounts starting    // from non zero components.    // æ³¨æ„ï¼ŒSelfDeriveå°†é€’å¢æŒ‡å®šè·¯å¾„çš„æœ€åä¸€ä¸ªç»„ä»¶ï¼Œè€Œä¸æ˜¯ä¸‹é™åˆ°å­è·¯å¾„ï¼Œä»¥å…è®¸ä»éé›¶ç»„ä»¶å¼€å§‹å‘ç°å¸æˆ·ã€‚    // You can disable automatic account discovery by calling SelfDerive with a nil    // chain state reader.    // ä½ å¯ä»¥é€šè¿‡ä¼ é€’ä¸€ä¸ªnilçš„ChainStateReaderæ¥ç¦ç”¨è‡ªåŠ¨è´¦å·å‘ç°ã€‚    SelfDerive(base DerivationPath, chain ethereum.ChainStateReader)    // SignHash requests the wallet to sign the given hash.    // SignHash è¯·æ±‚é’±åŒ…æ¥ç»™ä¼ å…¥çš„hashè¿›è¡Œç­¾åã€‚    // It looks up the account specified either solely via its address contained within,    // or optionally with the aid of any location metadata from the embedded URL field.    //å®ƒå¯ä»¥é€šè¿‡å…¶ä¸­åŒ…å«çš„åœ°å€ï¼ˆæˆ–å¯é€‰åœ°å€ŸåŠ©åµŒå…¥å¼URLå­—æ®µä¸­çš„ä»»ä½•ä½ç½®å…ƒæ•°æ®ï¼‰æ¥æŸ¥æ‰¾æŒ‡å®šçš„å¸æˆ·ã€‚    // If the wallet requires additional authentication to sign the request (e.g.    // a password to decrypt the account, or a PIN code o verify the transaction),    // an AuthNeededError instance will be returned, containing infos for the user    // about which fields or actions are needed. The user may retry by providing    // the needed details via SignHashWithPassphrase, or by other means (e.g. unlock    // the account in a keystore).    // å¦‚æœé’±åŒ…éœ€è¦é¢å¤–çš„éªŒè¯æ‰èƒ½ç­¾å(æ¯”å¦‚è¯´ éœ€è¦å¯†ç æ¥è§£é”è´¦å·ï¼Œ æˆ–è€…æ˜¯éœ€è¦ä¸€ä¸ªPIN ä»£ç æ¥éªŒè¯äº¤æ˜“ã€‚)    // ä¼šè¿”å›ä¸€ä¸ªAuthNeededErrorçš„é”™è¯¯ï¼Œé‡Œé¢åŒ…å«äº†ç”¨æˆ·çš„ä¿¡æ¯ï¼Œä»¥åŠå“ªäº›å­—æ®µæˆ–è€…æ“ä½œéœ€è¦æä¾›ã€‚    // ç”¨æˆ·å¯ä»¥é€šè¿‡ SignHashWithPassphraseæ¥ç­¾åæˆ–è€…é€šè¿‡å…¶ä»–æ‰‹æ®µ(åœ¨keystoreé‡Œé¢è§£é”è´¦å·)    SignHash(account Account, hash []byte) ([]byte, error)    // SignTx requests the wallet to sign the given transaction.    // SignTx è¯·æ±‚é’±åŒ…å¯¹æŒ‡å®šçš„äº¤æ˜“è¿›è¡Œç­¾åã€‚    // It looks up the account specified either solely via its address contained within,    // or optionally with the aid of any location metadata from the embedded URL field.    //     // If the wallet requires additional authentication to sign the request (e.g.    // a password to decrypt the account, or a PIN code o verify the transaction),    // an AuthNeededError instance will be returned, containing infos for the user    // about which fields or actions are needed. The user may retry by providing    // the needed details via SignTxWithPassphrase, or by other means (e.g. unlock    // the account in a keystore).    SignTx(account Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error)    // SignHashWithPassphrase requests the wallet to sign the given hash with the    // given passphrase as extra authentication information.    // SignHashWithPassphraseè¯·æ±‚é’±åŒ…ä½¿ç”¨ç»™å®šçš„passphraseæ¥ç­¾åç»™å®šçš„hash    // It looks up the account specified either solely via its address contained within,    // or optionally with the aid of any location metadata from the embedded URL field.    SignHashWithPassphrase(account Account, passphrase string, hash []byte) ([]byte, error)    // SignTxWithPassphrase requests the wallet to sign the given transaction, with the    // given passphrase as extra authentication information.    // SignHashWithPassphraseè¯·æ±‚é’±åŒ…ä½¿ç”¨ç»™å®šçš„passphraseæ¥ç­¾åç»™å®šçš„transaction    // It looks up the account specified either solely via its address contained within,    // or optionally with the aid of any location metadata from the embedded URL field.    SignTxWithPassphrase(account Account, passphrase string, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error)}</code></pre><p>åç«¯ Backend</p><pre><code>// Backend is a "wallet provider" that may contain a batch of accounts they can// sign transactions with and upon request, do so.// Backendæ˜¯ä¸€ä¸ªé’±åŒ…æä¾›å™¨ã€‚ å¯ä»¥åŒ…å«ä¸€æ‰¹è´¦å·ã€‚ä»–ä»¬å¯ä»¥æ ¹æ®è¯·æ±‚ç­¾ç½²äº¤æ˜“ï¼Œè¿™æ ·åšã€‚type Backend interface {    // Wallets retrieves the list of wallets the backend is currently aware of.    // Walletsè·å–å½“å‰èƒ½å¤ŸæŸ¥æ‰¾åˆ°çš„é’±åŒ…    // The returned wallets are not opened by default. For software HD wallets this    // means that no base seeds are decrypted, and for hardware wallets that no actual    // connection is established.    // è¿”å›çš„é’±åŒ…é»˜è®¤æ˜¯æ²¡æœ‰æ‰“å¼€çš„ã€‚     // The resulting wallet list will be sorted alphabetically based on its internal    // URL assigned by the backend. Since wallets (especially hardware) may come and    // go, the same wallet might appear at a different positions in the list during    // subsequent retrievals.    //æ‰€äº§ç”Ÿçš„é’±åŒ…åˆ—è¡¨å°†æ ¹æ®åç«¯åˆ†é…çš„å†…éƒ¨URLæŒ‰å­—æ¯é¡ºåºæ’åºã€‚ ç”±äºé’±åŒ…ï¼ˆç‰¹åˆ«æ˜¯ç¡¬ä»¶é’±åŒ…ï¼‰å¯èƒ½ä¼šæ‰“å¼€å’Œå…³é—­ï¼Œæ‰€ä»¥åœ¨éšåçš„æ£€ç´¢è¿‡ç¨‹ä¸­ï¼Œç›¸åŒçš„é’±åŒ…å¯èƒ½ä¼šå‡ºç°åœ¨åˆ—è¡¨ä¸­çš„ä¸åŒä½ç½®ã€‚    Wallets() []Wallet    // Subscribe creates an async subscription to receive notifications when the    // backend detects the arrival or departure of a wallet.    // è®¢é˜…åˆ›å»ºå¼‚æ­¥è®¢é˜…ï¼Œä»¥ä¾¿åœ¨åç«¯æ£€æµ‹åˆ°é’±åŒ…çš„åˆ°è¾¾æˆ–ç¦»å¼€æ—¶æ¥æ”¶é€šçŸ¥ã€‚    Subscribe(sink chan&lt;- WalletEvent) event.Subscription}</code></pre><h2 id="manager-go"><a href="#manager-go" class="headerlink" title="manager.go"></a>manager.go</h2><p>Manageræ˜¯ä¸€ä¸ªåŒ…å«æ‰€æœ‰ä¸œè¥¿çš„è´¦æˆ·ç®¡ç†å·¥å…·ã€‚ å¯ä»¥å’Œæ‰€æœ‰çš„Backendsæ¥é€šä¿¡æ¥ç­¾ç½²äº¤æ˜“ã€‚</p><p>æ•°æ®ç»“æ„</p><pre><code>// Manager is an overarching account manager that can communicate with various// backends for signing transactions.type Manager struct {    // æ‰€æœ‰å·²ç»æ³¨å†Œçš„Backend    backends map[reflect.Type][]Backend // Index of backends currently registered    // æ‰€æœ‰Backendçš„æ›´æ–°è®¢é˜…å™¨    updaters []event.Subscription       // Wallet update subscriptions for all backends    // backendæ›´æ–°çš„è®¢é˜…æ§½    updates  chan WalletEvent           // Subscription sink for backend wallet changes    // æ‰€æœ‰å·²ç»æ³¨å†Œçš„Backendsçš„é’±åŒ…çš„ç¼“å­˜    wallets  []Wallet                   // Cache of all wallets from all registered backends    // é’±åŒ…åˆ°è¾¾å’Œç¦»å¼€çš„é€šçŸ¥    feed event.Feed // Wallet feed notifying of arrivals/departures    // é€€å‡ºé˜Ÿåˆ—    quit chan chan error    lock sync.RWMutex}</code></pre><p>åˆ›å»ºManager</p><pre><code>// NewManager creates a generic account manager to sign transaction via various// supported backends.func NewManager(backends ...Backend) *Manager {    // Subscribe to wallet notifications from all backends    updates := make(chan WalletEvent, 4*len(backends))    subs := make([]event.Subscription, len(backends))    for i, backend := range backends {        subs[i] = backend.Subscribe(updates)    }    // Retrieve the initial list of wallets from the backends and sort by URL    var wallets []Wallet    for _, backend := range backends {        wallets = merge(wallets, backend.Wallets()...)    }    // Assemble the account manager and return    am := &amp;Manager{        backends: make(map[reflect.Type][]Backend),        updaters: subs,        updates:  updates,        wallets:  wallets,        quit:     make(chan chan error),    }    for _, backend := range backends {        kind := reflect.TypeOf(backend)        am.backends[kind] = append(am.backends[kind], backend)    }    go am.update()    return am}</code></pre><p>updateæ–¹æ³•ã€‚ æ˜¯ä¸€ä¸ªgoroutineã€‚ä¼šç›‘å¬æ‰€æœ‰backendè§¦å‘çš„æ›´æ–°ä¿¡æ¯ã€‚ ç„¶åè½¬å‘ç»™feed.</p><pre><code>// update is the wallet event loop listening for notifications from the backends// and updating the cache of wallets.func (am *Manager) update() {    // Close all subscriptions when the manager terminates    defer func() {        am.lock.Lock()        for _, sub := range am.updaters {            sub.Unsubscribe()        }        am.updaters = nil        am.lock.Unlock()    }()    // Loop until termination    for {        select {        case event := &lt;-am.updates:            // Wallet event arrived, update local cache            am.lock.Lock()            switch event.Kind {            case WalletArrived:                am.wallets = merge(am.wallets, event.Wallet)            case WalletDropped:                am.wallets = drop(am.wallets, event.Wallet)            }            am.lock.Unlock()            // Notify any listeners of the event            am.feed.Send(event)        case errc := &lt;-am.quit:            // Manager terminating, return            errc &lt;- nil            return        }    }}</code></pre><p>è¿”å›backend</p><pre><code>// Backends retrieves the backend(s) with the given type from the account manager.func (am *Manager) Backends(kind reflect.Type) []Backend {    return am.backends[kind]}</code></pre><p>è®¢é˜…æ¶ˆæ¯</p><pre><code>// Subscribe creates an async subscription to receive notifications when the// manager detects the arrival or departure of a wallet from any of its backends.func (am *Manager) Subscribe(sink chan&lt;- WalletEvent) event.Subscription {    return am.feed.Subscribe(sink)}</code></pre><p>å¯¹äºnodeæ¥è¯´ã€‚æ˜¯ä»€ä¹ˆæ—¶å€™åˆ›å»ºçš„è´¦å·ç®¡ç†å™¨ã€‚</p><pre><code>// New creates a new P2P node, ready for protocol registration.func New(conf *Config) (*Node, error) {    ...    am, ephemeralKeystore, err := makeAccountManager(conf)    func makeAccountManager(conf *Config) (*accounts.Manager, string, error) {    scryptN := keystore.StandardScryptN    scryptP := keystore.StandardScryptP    if conf.UseLightweightKDF {        scryptN = keystore.LightScryptN        scryptP = keystore.LightScryptP    }    var (        keydir    string        ephemeral string        err       error    )    switch {    case filepath.IsAbs(conf.KeyStoreDir):        keydir = conf.KeyStoreDir    case conf.DataDir != "":        if conf.KeyStoreDir == "" {            keydir = filepath.Join(conf.DataDir, datadirDefaultKeyStore)        } else {            keydir, err = filepath.Abs(conf.KeyStoreDir)        }    case conf.KeyStoreDir != "":        keydir, err = filepath.Abs(conf.KeyStoreDir)    default:        // There is no datadir.        keydir, err = ioutil.TempDir("", "go-ethereum-keystore")        ephemeral = keydir    }    if err != nil {        return nil, "", err    }    if err := os.MkdirAll(keydir, 0700); err != nil {        return nil, "", err    }    // Assemble the account manager and supported backends    // åˆ›å»ºäº†ä¸€ä¸ªKeyStoreçš„backend    backends := []accounts.Backend{        keystore.NewKeyStore(keydir, scryptN, scryptP),    }    // å¦‚æœæ˜¯USBé’±åŒ…ã€‚ éœ€è¦åšä¸€äº›é¢å¤–çš„æ“ä½œã€‚    if !conf.NoUSB {        // Start a USB hub for Ledger hardware wallets        if ledgerhub, err := usbwallet.NewLedgerHub(); err != nil {            log.Warn(fmt.Sprintf("Failed to start Ledger hub, disabling: %v", err))        } else {            backends = append(backends, ledgerhub)        }        // Start a USB hub for Trezor hardware wallets        if trezorhub, err := usbwallet.NewTrezorHub(); err != nil {            log.Warn(fmt.Sprintf("Failed to start Trezor hub, disabling: %v", err))        } else {            backends = append(backends, trezorhub)        }    }    return accounts.NewManager(backends...), ephemeral, nil}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-core-chain_indexeræºç è§£æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-chain_indexer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-chain_indexer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="chain-indexer-åŒºå—é“¾ç´¢å¼•"><a href="#chain-indexer-åŒºå—é“¾ç´¢å¼•" class="headerlink" title="chain_indexer åŒºå—é“¾ç´¢å¼•"></a>chain_indexer åŒºå—é“¾ç´¢å¼•</h2><p>chain_indexer.go æºç è§£æ</p><p>chain_indexer é¡¾åæ€ä¹‰ï¼Œ å°±æ˜¯ç”¨æ¥ç»™åŒºå—é“¾åˆ›å»ºç´¢å¼•çš„åŠŸèƒ½ã€‚ ä¹‹å‰åœ¨ethåè®®çš„æ—¶å€™ï¼Œä»‹ç»è¿‡BloomIndexerçš„åŠŸèƒ½ï¼Œå…¶å®BloomIndexeræ˜¯chain_indexerçš„ä¸€ä¸ªç‰¹æ®Šçš„å®ç°ï¼Œ å¯ä»¥ç†è§£ä¸ºæ´¾ç”Ÿç±»ï¼Œ ä¸»è¦çš„åŠŸèƒ½å…¶å®å®åœ¨chain_indexerè¿™é‡Œé¢å®ç°çš„ã€‚è™½è¯´æ˜¯æ´¾ç”Ÿç±»ï¼Œä½†æ˜¯chain_indexerå…¶å®å°±åªè¢«BloomIndexerä½¿ç”¨ã€‚ä¹Ÿå°±æ˜¯ç»™åŒºå—é“¾çš„å¸ƒéš†è¿‡æ»¤å™¨åˆ›å»ºäº†ç´¢å¼•ï¼Œä»¥ä¾¿å¿«é€Ÿçš„å“åº”ç”¨æˆ·çš„æ—¥å¿—æœç´¢åŠŸèƒ½ã€‚ ä¸‹é¢å°±æ¥åˆ†æè¿™éƒ¨åˆ†çš„ä»£ç ã€‚</p><h3 id="æ•°æ®ç»“æ„"><a href="#æ•°æ®ç»“æ„" class="headerlink" title="æ•°æ®ç»“æ„"></a>æ•°æ®ç»“æ„</h3><pre><code>// ChainIndexerBackend defines the methods needed to process chain segments in// the background and write the segment results into the database. These can be// used to create filter blooms or CHTs.// ChainIndexerBackendå®šä¹‰äº†å¤„ç†åŒºå—é“¾ç‰‡æ®µçš„æ–¹æ³•ï¼Œå¹¶æŠŠå¤„ç†ç»“æœå†™å…¥æ•°æ®åº“ã€‚ è¿™äº›å¯ä»¥ç”¨æ¥åˆ›å»ºå¸ƒéš†è¿‡æ»¤å™¨æˆ–è€…CHTs.// BloomIndexer å…¶å®å°±æ˜¯å®ç°äº†è¿™ä¸ªæ¥å£ ChainIndexerBackend è¿™é‡Œçš„CHTsä¸çŸ¥é“æ˜¯ä»€ä¹ˆä¸œè¥¿ã€‚type ChainIndexerBackend interface {    // Reset initiates the processing of a new chain segment, potentially terminating    // any partially completed operations (in case of a reorg).    // Reset æ–¹æ³•ç”¨æ¥åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„åŒºå—é“¾ç‰‡æ®µï¼Œå¯èƒ½ä¼šç»ˆæ­¢ä»»ä½•æ²¡æœ‰å®Œæˆçš„æ“ä½œã€‚    Reset(section uint64)    // Process crunches through the next header in the chain segment. The caller    // will ensure a sequential order of headers.    // å¯¹åŒºå—é“¾ç‰‡æ®µä¸­çš„ä¸‹ä¸€ä¸ªåŒºå—å¤´è¿›è¡Œå¤„ç†ã€‚ è°ƒç”¨è€…å°†ç¡®ä¿åŒºå—å¤´çš„è¿ç»­é¡ºåºã€‚    Process(header *types.Header)    // Commit finalizes the section metadata and stores it into the database.    å®ŒæˆåŒºå—é“¾ç‰‡æ®µçš„å…ƒæ•°æ®å¹¶å°†å…¶å­˜å‚¨åˆ°æ•°æ®åº“ä¸­ã€‚        Commit() error}// ChainIndexer does a post-processing job for equally sized sections of the// canonical chain (like BlooomBits and CHT structures). A ChainIndexer is// connected to the blockchain through the event system by starting a// ChainEventLoop in a goroutine.// ChainIndexer å¯¹åŒºå—é“¾è¿›è¡Œ å¤§å°ç›¸ç­‰çš„ç‰‡æ®µ è¿›è¡Œå¤„ã€‚ ChainIndexeråœ¨ChainEventLoopæ–¹æ³•ä¸­é€šè¿‡äº‹ä»¶ç³»ç»Ÿä¸åŒºå—é“¾é€šä¿¡ï¼Œ// Further child ChainIndexers can be added which use the output of the parent// section indexer. These child indexers receive new head notifications only// after an entire section has been finished or in case of rollbacks that might// affect already finished sections.//æ›´è¿œå¯ä»¥æ·»åŠ ä½¿ç”¨çˆ¶sectionç´¢å¼•å™¨çš„è¾“å‡ºçš„æ›´å¤šå­é“¾å¼ç´¢å¼•å™¨ã€‚ è¿™äº›å­é“¾å¼ç´¢å¼•å™¨åªæœ‰åœ¨æ•´ä¸ªéƒ¨åˆ†å®Œæˆåæˆ–åœ¨å¯èƒ½å½±å“å·²å®Œæˆéƒ¨åˆ†çš„å›æ»šçš„æƒ…å†µä¸‹æ‰æ¥æ”¶æ–°çš„å¤´éƒ¨é€šçŸ¥ã€‚type ChainIndexer struct {    chainDb  ethdb.Database      // Chain database to index the data from åŒºå—é“¾æ‰€åœ¨çš„æ•°æ®åº“    indexDb  ethdb.Database      // Prefixed table-view of the db to write index metadata into ç´¢å¼•å­˜å‚¨çš„æ•°æ®åº“    backend  ChainIndexerBackend // Background processor generating the index data content  ç´¢å¼•ç”Ÿæˆçš„åç«¯ã€‚    children []*ChainIndexer     // Child indexers to cascade chain updates to    å­ç´¢å¼•    active uint32          // Flag whether the event loop was started    update chan struct{}   // Notification channel that headers should be processed  æ¥æ”¶åˆ°çš„headers    quit   chan chan error // Quit channel to tear down running goroutines    sectionSize uint64 // Number of blocks in a single chain segment to process    sectionçš„å¤§å°ã€‚ é»˜è®¤æ˜¯4096ä¸ªåŒºå—ä¸ºä¸€ä¸ªsection    confirmsReq uint64 // Number of confirmations before processing a completed segment   å¤„ç†å®Œæˆçš„æ®µä¹‹å‰çš„ç¡®è®¤æ¬¡æ•°    storedSections uint64 // Number of sections successfully indexed into the database  æˆåŠŸç´¢å¼•åˆ°æ•°æ®åº“çš„éƒ¨åˆ†æ•°é‡    knownSections  uint64 // Number of sections known to be complete (block wise) å·²çŸ¥å®Œæˆçš„éƒ¨åˆ†æ•°é‡    cascadedHead   uint64 // Block number of the last completed section cascaded to subindexers çº§è”åˆ°å­ç´¢å¼•çš„æœ€åä¸€ä¸ªå®Œæˆéƒ¨åˆ†çš„å—å·    throttling time.Duration // Disk throttling to prevent a heavy upgrade from hogging resources ç£ç›˜é™åˆ¶ï¼Œä»¥é˜²æ­¢å¤§é‡èµ„æºçš„å¤§é‡å‡çº§    log  log.Logger    lock sync.RWMutex}</code></pre><p>æ„é€ å‡½æ•°NewChainIndexer, </p><pre><code>è¿™ä¸ªæ–¹æ³•æ˜¯åœ¨eth/bloombits.goé‡Œé¢è¢«è°ƒç”¨çš„const (    // bloomConfirms is the number of confirmation blocks before a bloom section is    // considered probably final and its rotated bits are calculated.    // bloomConfirms ç”¨æ¥è¡¨ç¤ºç¡®è®¤åŒºå—æ•°é‡ï¼Œ è¡¨ç¤ºç»è¿‡è¿™ä¹ˆå¤šåŒºå—ä¹‹åï¼Œ bloom sectionè¢«è®¤ä¸ºæ˜¯å·²ç»ä¸ä¼šæ›´æ”¹äº†ã€‚    bloomConfirms = 256    // bloomThrottling is the time to wait between processing two consecutive index    // sections. It's useful during chain upgrades to prevent disk overload.    // bloomThrottlingæ˜¯å¤„ç†ä¸¤ä¸ªè¿ç»­ç´¢å¼•æ®µä¹‹é—´çš„ç­‰å¾…æ—¶é—´ã€‚ åœ¨åŒºå—é“¾å‡çº§è¿‡ç¨‹ä¸­é˜²æ­¢ç£ç›˜è¿‡è½½æ˜¯å¾ˆæœ‰ç”¨çš„ã€‚    bloomThrottling = 100 * time.Millisecond)func NewBloomIndexer(db ethdb.Database, size uint64) *core.ChainIndexer {    backend := &amp;BloomIndexer{        db:   db,        size: size,    }    // å¯ä»¥çœ‹åˆ°indexDbå’ŒchainDbå®é™…æ˜¯åŒä¸€ä¸ªæ•°æ®åº“ï¼Œ ä½†æ˜¯indexDbçš„æ¯ä¸ªkeyå‰é¢é™„åŠ äº†ä¸€ä¸ªBloomBitsIndexPrefixçš„å‰ç¼€ã€‚    table := ethdb.NewTable(db, string(core.BloomBitsIndexPrefix))    return core.NewChainIndexer(db, table, backend, size, bloomConfirms, bloomThrottling, "bloombits")}// NewChainIndexer creates a new chain indexer to do background processing on// chain segments of a given size after certain number of confirmations passed.// The throttling parameter might be used to prevent database thrashing.func NewChainIndexer(chainDb, indexDb ethdb.Database, backend ChainIndexerBackend, section, confirm uint64, throttling time.Duration, kind string) *ChainIndexer {    c := &amp;ChainIndexer{        chainDb:     chainDb,        indexDb:     indexDb,        backend:     backend,        update:      make(chan struct{}, 1),        quit:        make(chan chan error),        sectionSize: section,        confirmsReq: confirm,        throttling:  throttling,        log:         log.New("type", kind),    }    // Initialize database dependent fields and start the updater    c.loadValidSections()    go c.updateLoop()    return c}</code></pre><p>loadValidSections,ç”¨æ¥ä»æ•°æ®åº“é‡Œé¢åŠ è½½æˆ‘ä»¬ä¹‹å‰çš„å¤„ç†ä¿¡æ¯ï¼Œ storedSectionsè¡¨ç¤ºæˆ‘ä»¬å·²ç»å¤„ç†åˆ°å“ªé‡Œäº†ã€‚</p><pre><code>// loadValidSections reads the number of valid sections from the index database// and caches is into the local state.func (c *ChainIndexer) loadValidSections() {    data, _ := c.indexDb.Get([]byte("count"))    if len(data) == 8 {        c.storedSections = binary.BigEndian.Uint64(data[:])    }}</code></pre><p>updateLoop,æ˜¯ä¸»è¦çš„äº‹ä»¶å¾ªç¯ï¼Œç”¨äºè°ƒç”¨backendæ¥å¤„ç†åŒºå—é“¾sectionï¼Œè¿™ä¸ªéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ‰€æœ‰çš„ä¸»ç´¢å¼•èŠ‚ç‚¹å’Œæ‰€æœ‰çš„ child indexer éƒ½ä¼šå¯åŠ¨è¿™ä¸ªgoroutine æ–¹æ³•ã€‚</p><pre><code>func (c *ChainIndexer) updateLoop() {    var (        updating bool        updated  time.Time    )    for {        select {        case errc := &lt;-c.quit:            // Chain indexer terminating, report no failure and abort            errc &lt;- nil            return        case &lt;-c.update:  //å½“éœ€è¦ä½¿ç”¨backendå¤„ç†çš„æ—¶å€™ï¼Œå…¶ä»–goroutineä¼šå¾€è¿™ä¸ªchannelä¸Šé¢å‘é€æ¶ˆæ¯            // Section headers completed (or rolled back), update the index            c.lock.Lock()            if c.knownSections &gt; c.storedSections { // å¦‚æœå½“å‰ä»¥çŸ¥çš„Section å¤§äºå·²ç»å­˜å‚¨çš„Section                // Periodically print an upgrade log message to the user                // æ¯éš”8ç§’æ‰“å°ä¸€æ¬¡æ—¥å¿—ä¿¡æ¯ã€‚                if time.Since(updated) &gt; 8*time.Second {                    if c.knownSections &gt; c.storedSections+1 {                        updating = true                        c.log.Info("Upgrading chain index", "percentage", c.storedSections*100/c.knownSections)                    }                    updated = time.Now()                }                // Cache the current section count and head to allow unlocking the mutex                section := c.storedSections                var oldHead common.Hash                if section &gt; 0 { // section - 1 ä»£è¡¨sectionçš„ä¸‹æ ‡æ˜¯ä»0å¼€å§‹çš„ã€‚                     // sectionHeadç”¨æ¥è·å–sectionçš„æœ€åä¸€ä¸ªåŒºå—çš„hashå€¼ã€‚                    oldHead = c.sectionHead(section - 1)                }                // Process the newly defined section in the background                c.lock.Unlock()                // å¤„ç† è¿”å›æ–°çš„sectionçš„æœ€åä¸€ä¸ªåŒºå—çš„hashå€¼                newHead, err := c.processSection(section, oldHead)                if err != nil {                    c.log.Error("Section processing failed", "error", err)                }                c.lock.Lock()                // If processing succeeded and no reorgs occcurred, mark the section completed                if err == nil &amp;&amp; oldHead == c.sectionHead(section-1) {                    c.setSectionHead(section, newHead) // æ›´æ–°æ•°æ®åº“çš„çŠ¶æ€                    c.setValidSections(section + 1)    // æ›´æ–°æ•°æ®åº“çŠ¶æ€                    if c.storedSections == c.knownSections &amp;&amp; updating {                        updating = false                        c.log.Info("Finished upgrading chain index")                    }                    // cascadedHead æ˜¯æ›´æ–°åçš„sectionçš„æœ€åä¸€ä¸ªåŒºå—çš„é«˜åº¦                    // ç”¨æ³•æ˜¯ä»€ä¹ˆ ï¼Ÿ                    c.cascadedHead = c.storedSections*c.sectionSize - 1                    for _, child := range c.children {                        c.log.Trace("Cascading chain index update", "head", c.cascadedHead)                        child.newHead(c.cascadedHead, false)                    }                } else { //å¦‚æœå¤„ç†å¤±è´¥ï¼Œé‚£ä¹ˆåœ¨æœ‰æ–°çš„é€šçŸ¥ä¹‹å‰ä¸ä¼šé‡è¯•ã€‚                    // If processing failed, don't retry until further notification                    c.log.Debug("Chain index processing failed", "section", section, "err", err)                    c.knownSections = c.storedSections                }            }            // If there are still further sections to process, reschedule            // å¦‚æœè¿˜æœ‰sectionç­‰å¾…å¤„ç†ï¼Œé‚£ä¹ˆç­‰å¾…throttlingæ—¶é—´å†å¤„ç†ã€‚é¿å…ç£ç›˜è¿‡è½½ã€‚            if c.knownSections &gt; c.storedSections {                time.AfterFunc(c.throttling, func() {                    select {                    case c.update &lt;- struct{}{}:                    default:                    }                })            }            c.lock.Unlock()        }    }}</code></pre><p>Startæ–¹æ³•ã€‚ è¿™ä¸ªæ–¹æ³•åœ¨ethåè®®å¯åŠ¨çš„æ—¶å€™è¢«è°ƒç”¨,è¿™ä¸ªæ–¹æ³•æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ªæ˜¯å½“å‰çš„åŒºå—å¤´ï¼Œä¸€ä¸ªæ˜¯äº‹ä»¶è®¢é˜…å™¨ï¼Œé€šè¿‡è¿™ä¸ªè®¢é˜…å™¨å¯ä»¥è·å–åŒºå—é“¾çš„æ”¹å˜ä¿¡æ¯ã€‚</p><pre><code>eth.bloomIndexer.Start(eth.blockchain.CurrentHeader(), eth.blockchain.SubscribeChainEvent)// Start creates a goroutine to feed chain head events into the indexer for// cascading background processing. Children do not need to be started, they// are notified about new events by their parents.// å­é“¾ä¸éœ€è¦è¢«å¯åŠ¨ã€‚ ä»¥ä¸ºä»–ä»¬çš„çˆ¶èŠ‚ç‚¹ä¼šé€šçŸ¥ä»–ä»¬ã€‚func (c *ChainIndexer) Start(currentHeader *types.Header, chainEventer func(ch chan&lt;- ChainEvent) event.Subscription) {    go c.eventLoop(currentHeader, chainEventer)}// eventLoop is a secondary - optional - event loop of the indexer which is only// started for the outermost indexer to push chain head events into a processing// queue.// eventLoop å¾ªç¯åªä¼šåœ¨æœ€å¤–é¢çš„ç´¢å¼•èŠ‚ç‚¹è¢«è°ƒç”¨ã€‚ æ‰€æœ‰çš„Child indexerä¸ä¼šè¢«å¯åŠ¨è¿™ä¸ªæ–¹æ³•ã€‚ func (c *ChainIndexer) eventLoop(currentHeader *types.Header, chainEventer func(ch chan&lt;- ChainEvent) event.Subscription) {    // Mark the chain indexer as active, requiring an additional teardown    atomic.StoreUint32(&amp;c.active, 1)    events := make(chan ChainEvent, 10)    sub := chainEventer(events)    defer sub.Unsubscribe()    // Fire the initial new head event to start any outstanding processing    // è®¾ç½®æˆ‘ä»¬çš„å…¶å®çš„åŒºå—é«˜åº¦ï¼Œç”¨æ¥è§¦å‘ä¹‹å‰æœªå®Œæˆçš„æ“ä½œã€‚    c.newHead(currentHeader.Number.Uint64(), false)    var (        prevHeader = currentHeader        prevHash   = currentHeader.Hash()    )    for {        select {        case errc := &lt;-c.quit:            // Chain indexer terminating, report no failure and abort            errc &lt;- nil            return        case ev, ok := &lt;-events:            // Received a new event, ensure it's not nil (closing) and update            if !ok {                errc := &lt;-c.quit                errc &lt;- nil                return            }            header := ev.Block.Header()            if header.ParentHash != prevHash { //å¦‚æœå‡ºç°äº†åˆ†å‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬é¦–å…ˆ                //æ‰¾åˆ°å…¬å…±ç¥–å…ˆï¼Œ ä»å…¬å…±ç¥–å…ˆä¹‹åçš„ç´¢å¼•éœ€è¦é‡å»ºã€‚                 c.newHead(FindCommonAncestor(c.chainDb, prevHeader, header).Number.Uint64(), true)            }            // è®¾ç½®æ–°çš„head            c.newHead(header.Number.Uint64(), false)            prevHeader, prevHash = header, header.Hash()        }    }}</code></pre><p>newHeadæ–¹æ³•,é€šçŸ¥indexeræ–°çš„åŒºå—é“¾å¤´ï¼Œæˆ–è€…æ˜¯éœ€è¦é‡å»ºç´¢å¼•ï¼ŒnewHeadæ–¹æ³•ä¼šè§¦å‘</p><pre><code>// newHead notifies the indexer about new chain heads and/or reorgs.func (c *ChainIndexer) newHead(head uint64, reorg bool) {    c.lock.Lock()    defer c.lock.Unlock()    // If a reorg happened, invalidate all sections until that point    if reorg { // éœ€è¦é‡å»ºç´¢å¼• ä»headå¼€å§‹çš„æ‰€æœ‰sectionéƒ½éœ€è¦é‡å»ºã€‚        // Revert the known section number to the reorg point        changed := head / c.sectionSize        if changed &lt; c.knownSections {            c.knownSections = changed        }        // Revert the stored sections from the database to the reorg point        // å°†å­˜å‚¨çš„éƒ¨åˆ†ä»æ•°æ®åº“æ¢å¤åˆ°ç´¢å¼•é‡å»ºç‚¹        if changed &lt; c.storedSections {            c.setValidSections(changed)        }        // Update the new head number to te finalized section end and notify children        // ç”Ÿæˆæ–°çš„head å¹¶é€šçŸ¥æ‰€æœ‰çš„å­ç´¢å¼•        head = changed * c.sectionSize        if head &lt; c.cascadedHead {            c.cascadedHead = head            for _, child := range c.children {                child.newHead(c.cascadedHead, true)            }        }        return    }    // No reorg, calculate the number of newly known sections and update if high enough    var sections uint64    if head &gt;= c.confirmsReq {        sections = (head + 1 - c.confirmsReq) / c.sectionSize        if sections &gt; c.knownSections {            c.knownSections = sections            select {            case c.update &lt;- struct{}{}:            default:            }        }    }}</code></pre><p>çˆ¶å­ç´¢å¼•æ•°æ®çš„å…³ç³»<br>çˆ¶Indexerè´Ÿè½½äº‹ä»¶çš„ç›‘å¬ç„¶åæŠŠç»“æœé€šè¿‡newHeadä¼ é€’ç»™å­Indexerçš„updateLoopæ¥å¤„ç†ã€‚</p><p><img src="/images/ethereum/source_analysis/chainindexer_1.png" alt="image"></p><p>setValidSectionsæ–¹æ³•ï¼Œå†™å…¥å½“å‰å·²ç»å­˜å‚¨çš„sectionsçš„æ•°é‡ã€‚ å¦‚æœä¼ å…¥çš„å€¼å°äºå·²ç»å­˜å‚¨çš„æ•°é‡ï¼Œé‚£ä¹ˆä»æ•°æ®åº“é‡Œé¢åˆ é™¤å¯¹åº”çš„section</p><pre><code>// setValidSections writes the number of valid sections to the index databasefunc (c *ChainIndexer) setValidSections(sections uint64) {    // Set the current number of valid sections in the database    var data [8]byte    binary.BigEndian.PutUint64(data[:], sections)    c.indexDb.Put([]byte("count"), data[:])    // Remove any reorged sections, caching the valids in the mean time    for c.storedSections &gt; sections {        c.storedSections--        c.removeSectionHead(c.storedSections)    }    c.storedSections = sections // needed if new &gt; old}</code></pre><p>processSection</p><pre><code>// processSection processes an entire section by calling backend functions while// ensuring the continuity of the passed headers. Since the chain mutex is not// held while processing, the continuity can be broken by a long reorg, in which// case the function returns with an error.//processSectioné€šè¿‡è°ƒç”¨åç«¯å‡½æ•°æ¥å¤„ç†æ•´ä¸ªéƒ¨åˆ†ï¼ŒåŒæ—¶ç¡®ä¿ä¼ é€’çš„å¤´æ–‡ä»¶çš„è¿ç»­æ€§ã€‚ ç”±äºé“¾æ¥äº’æ–¥é”åœ¨å¤„ç†è¿‡ç¨‹ä¸­æ²¡æœ‰ä¿æŒï¼Œè¿ç»­æ€§å¯èƒ½ä¼šè¢«é‡æ–°æ‰“æ–­ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå‡½æ•°è¿”å›ä¸€ä¸ªé”™è¯¯ã€‚func (c *ChainIndexer) processSection(section uint64, lastHead common.Hash) (common.Hash, error) {    c.log.Trace("Processing new chain section", "section", section)    // Reset and partial processing    c.backend.Reset(section)    for number := section * c.sectionSize; number &lt; (section+1)*c.sectionSize; number++ {        hash := GetCanonicalHash(c.chainDb, number)        if hash == (common.Hash{}) {            return common.Hash{}, fmt.Errorf("canonical block #%d unknown", number)        }        header := GetHeader(c.chainDb, hash, number)        if header == nil {            return common.Hash{}, fmt.Errorf("block #%d [%xâ€¦] not found", number, hash[:4])        } else if header.ParentHash != lastHead {            return common.Hash{}, fmt.Errorf("chain reorged during section processing")        }        c.backend.Process(header)        lastHead = header.Hash()    }    if err := c.backend.Commit(); err != nil {        c.log.Error("Section commit failed", "error", err)        return common.Hash{}, err    }    return lastHead, nil}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-core-genesisåˆ›ä¸–åŒºå—æºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-genesis%E5%88%9B%E4%B8%96%E5%8C%BA%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-genesis%E5%88%9B%E4%B8%96%E5%8C%BA%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>genesis æ˜¯åˆ›ä¸–åŒºå—çš„æ„æ€. ä¸€ä¸ªåŒºå—é“¾å°±æ˜¯ä»åŒä¸€ä¸ªåˆ›ä¸–åŒºå—å¼€å§‹,é€šè¿‡è§„åˆ™å½¢æˆçš„.ä¸åŒçš„ç½‘ç»œæœ‰ä¸åŒçš„åˆ›ä¸–åŒºå—, ä¸»ç½‘ç»œå’Œæµ‹è¯•ç½‘è·¯çš„åˆ›ä¸–åŒºå—æ˜¯ä¸åŒçš„.</p><p>è¿™ä¸ªæ¨¡å—æ ¹æ®ä¼ å…¥çš„genesisçš„åˆå§‹å€¼å’Œdatabaseï¼Œæ¥è®¾ç½®genesisçš„çŠ¶æ€ï¼Œå¦‚æœä¸å­˜åœ¨åˆ›ä¸–åŒºå—ï¼Œé‚£ä¹ˆåœ¨databaseé‡Œé¢åˆ›å»ºå®ƒã€‚</p><p>æ•°æ®ç»“æ„</p><pre><code>// Genesis specifies the header fields, state of a genesis block. It also defines hard// fork switch-over blocks through the chain configuration.// GenesisæŒ‡å®šheaderçš„å­—æ®µï¼Œèµ·å§‹å—çš„çŠ¶æ€ã€‚ å®ƒè¿˜é€šè¿‡é…ç½®æ¥å®šä¹‰ç¡¬å‰åˆ‡æ¢å—ã€‚type Genesis struct {    Config     *params.ChainConfig `json:"config"`    Nonce      uint64              `json:"nonce"`    Timestamp  uint64              `json:"timestamp"`    ExtraData  []byte              `json:"extraData"`    GasLimit   uint64              `json:"gasLimit"   gencodec:"required"`    Difficulty *big.Int            `json:"difficulty" gencodec:"required"`    Mixhash    common.Hash         `json:"mixHash"`    Coinbase   common.Address      `json:"coinbase"`    Alloc      GenesisAlloc        `json:"alloc"      gencodec:"required"`    // These fields are used for consensus tests. Please don't use them    // in actual genesis blocks.    Number     uint64      `json:"number"`    GasUsed    uint64      `json:"gasUsed"`    ParentHash common.Hash `json:"parentHash"`}// GenesisAlloc specifies the initial state that is part of the genesis block.// GenesisAlloc æŒ‡å®šäº†æœ€å¼€å§‹çš„åŒºå—çš„åˆå§‹çŠ¶æ€.type GenesisAlloc map[common.Address]GenesisAccount</code></pre><p>SetupGenesisBlock,</p><pre><code>// SetupGenesisBlock writes or updates the genesis block in db.// // The block that will be used is:////                          genesis == nil       genesis != nil//                       +------------------------------------------//     db has no genesis |  main-net default  |  genesis//     db has genesis    |  from DB           |  genesis (if compatible)//// The stored chain configuration will be updated if it is compatible (i.e. does not// specify a fork block below the local head block). In case of a conflict, the// error is a *params.ConfigCompatError and the new, unwritten config is returned.// å¦‚æœå­˜å‚¨çš„åŒºå—é“¾é…ç½®ä¸å…¼å®¹é‚£ä¹ˆä¼šè¢«æ›´æ–°(). ä¸ºäº†é¿å…å‘ç”Ÿå†²çª,ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯,å¹¶ä¸”æ–°çš„é…ç½®å’ŒåŸæ¥çš„é…ç½®ä¼šè¿”å›.// The returned chain configuration is never nil.// genesis å¦‚æœæ˜¯ testnet dev æˆ–è€…æ˜¯ rinkeby æ¨¡å¼ï¼Œ é‚£ä¹ˆä¸ä¸ºnilã€‚å¦‚æœæ˜¯mainnetæˆ–è€…æ˜¯ç§æœ‰é“¾æ¥ã€‚é‚£ä¹ˆä¸ºç©ºfunc SetupGenesisBlock(db ethdb.Database, genesis *Genesis) (*params.ChainConfig, common.Hash, error) {    if genesis != nil &amp;&amp; genesis.Config == nil {        return params.AllProtocolChanges, common.Hash{}, errGenesisNoConfig    }    // Just commit the new block if there is no stored genesis block.    stored := GetCanonicalHash(db, 0) //è·å–genesiså¯¹åº”çš„åŒºå—    if (stored == common.Hash{}) { //å¦‚æœæ²¡æœ‰åŒºå— æœ€å¼€å§‹å¯åŠ¨gethä¼šè¿›å…¥è¿™é‡Œã€‚        if genesis == nil {             //å¦‚æœgenesisæ˜¯nil è€Œä¸”storedä¹Ÿæ˜¯nil é‚£ä¹ˆä½¿ç”¨ä¸»ç½‘ç»œ            // å¦‚æœæ˜¯test  dev  rinkeby é‚£ä¹ˆgenesisä¸ä¸ºç©º ä¼šè®¾ç½®ä¸ºå„è‡ªçš„genesis            log.Info("Writing default main-net genesis block")            genesis = DefaultGenesisBlock()        } else { // å¦åˆ™ä½¿ç”¨é…ç½®çš„åŒºå—            log.Info("Writing custom genesis block")        }        // å†™å…¥æ•°æ®åº“        block, err := genesis.Commit(db)        return genesis.Config, block.Hash(), err    }    // Check whether the genesis block is already written.    if genesis != nil { //å¦‚æœgenesiså­˜åœ¨è€Œä¸”åŒºå—ä¹Ÿå­˜åœ¨ é‚£ä¹ˆå¯¹æ¯”è¿™ä¸¤ä¸ªåŒºå—æ˜¯å¦ç›¸åŒ        block, _ := genesis.ToBlock()        hash := block.Hash()        if hash != stored {            return genesis.Config, block.Hash(), &amp;GenesisMismatchError{stored, hash}        }    }    // Get the existing chain configuration.    // è·å–å½“å‰å­˜åœ¨çš„åŒºå—é“¾çš„genesisé…ç½®    newcfg := genesis.configOrDefault(stored)    // è·å–å½“å‰çš„åŒºå—é“¾çš„é…ç½®    storedcfg, err := GetChainConfig(db, stored)    if err != nil {        if err == ErrChainConfigNotFound {            // This case happens if a genesis write was interrupted.            log.Warn("Found genesis block without chain config")            err = WriteChainConfig(db, stored, newcfg)        }        return newcfg, stored, err    }    // Special case: don't change the existing config of a non-mainnet chain if no new    // config is supplied. These chains would get AllProtocolChanges (and a compat error)    // if we just continued here.    // ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœæ²¡æœ‰æä¾›æ–°çš„é…ç½®ï¼Œè¯·ä¸è¦æ›´æ”¹éä¸»ç½‘é“¾çš„ç°æœ‰é…ç½®ã€‚     // å¦‚æœæˆ‘ä»¬ç»§ç»­è¿™é‡Œï¼Œè¿™äº›é“¾ä¼šå¾—åˆ°AllProtocolChangesï¼ˆå’Œcompaté”™è¯¯ï¼‰ã€‚    if genesis == nil &amp;&amp; stored != params.MainnetGenesisHash {        return storedcfg, stored, nil   // å¦‚æœæ˜¯ç§æœ‰é“¾æ¥ä¼šä»è¿™é‡Œé€€å‡ºã€‚    }    // Check config compatibility and write the config. Compatibility errors    // are returned to the caller unless we're already at block zero.    // æ£€æŸ¥é…ç½®çš„å…¼å®¹æ€§,é™¤éæˆ‘ä»¬åœ¨åŒºå—0,å¦åˆ™è¿”å›å…¼å®¹æ€§é”™è¯¯.    height := GetBlockNumber(db, GetHeadHeaderHash(db))    if height == missingNumber {        return newcfg, stored, fmt.Errorf("missing block number for head header hash")    }    compatErr := storedcfg.CheckCompatible(newcfg, height)    // å¦‚æœåŒºå—å·²ç»å†™å…¥æ•°æ®äº†,é‚£ä¹ˆå°±ä¸èƒ½æ›´æ”¹genesisé…ç½®äº†    if compatErr != nil &amp;&amp; height != 0 &amp;&amp; compatErr.RewindTo != 0 {        return newcfg, stored, compatErr    }    // å¦‚æœæ˜¯ä¸»ç½‘ç»œä¼šä»è¿™é‡Œé€€å‡ºã€‚    return newcfg, stored, WriteChainConfig(db, stored, newcfg)}</code></pre><p>ToBlock, è¿™ä¸ªæ–¹æ³•ä½¿ç”¨genesisçš„æ•°æ®ï¼Œä½¿ç”¨åŸºäºå†…å­˜çš„æ•°æ®åº“ï¼Œç„¶ååˆ›å»ºäº†ä¸€ä¸ªblockå¹¶è¿”å›ã€‚</p><pre><code>// ToBlock creates the block and state of a genesis specification.func (g *Genesis) ToBlock() (*types.Block, *state.StateDB) {    db, _ := ethdb.NewMemDatabase()    statedb, _ := state.New(common.Hash{}, state.NewDatabase(db))    for addr, account := range g.Alloc {        statedb.AddBalance(addr, account.Balance)        statedb.SetCode(addr, account.Code)        statedb.SetNonce(addr, account.Nonce)        for key, value := range account.Storage {            statedb.SetState(addr, key, value)        }    }    root := statedb.IntermediateRoot(false)    head := &amp;types.Header{        Number:     new(big.Int).SetUint64(g.Number),        Nonce:      types.EncodeNonce(g.Nonce),        Time:       new(big.Int).SetUint64(g.Timestamp),        ParentHash: g.ParentHash,        Extra:      g.ExtraData,        GasLimit:   new(big.Int).SetUint64(g.GasLimit),        GasUsed:    new(big.Int).SetUint64(g.GasUsed),        Difficulty: g.Difficulty,        MixDigest:  g.Mixhash,        Coinbase:   g.Coinbase,        Root:       root,    }    if g.GasLimit == 0 {        head.GasLimit = params.GenesisGasLimit    }    if g.Difficulty == nil {        head.Difficulty = params.GenesisDifficulty    }    return types.NewBlock(head, nil, nil, nil), statedb}</code></pre><p>Commitæ–¹æ³•å’ŒMustCommitæ–¹æ³•, Commitæ–¹æ³•æŠŠç»™å®šçš„genesisçš„blockå’Œstateå†™å…¥æ•°æ®åº“ï¼Œ è¿™ä¸ªblockè¢«è®¤ä¸ºæ˜¯è§„èŒƒçš„åŒºå—é“¾å¤´ã€‚</p><pre><code>// Commit writes the block and state of a genesis specification to the database.// The block is committed as the canonical head block.func (g *Genesis) Commit(db ethdb.Database) (*types.Block, error) {    block, statedb := g.ToBlock()    if block.Number().Sign() != 0 {        return nil, fmt.Errorf("can't commit genesis block with number &gt; 0")    }    if _, err := statedb.CommitTo(db, false); err != nil {        return nil, fmt.Errorf("cannot write state: %v", err)    }    // å†™å…¥æ€»éš¾åº¦    if err := WriteTd(db, block.Hash(), block.NumberU64(), g.Difficulty); err != nil {        return nil, err    }    // å†™å…¥åŒºå—    if err := WriteBlock(db, block); err != nil {        return nil, err    }    // å†™å…¥åŒºå—æ”¶æ®    if err := WriteBlockReceipts(db, block.Hash(), block.NumberU64(), nil); err != nil {        return nil, err    }    // å†™å…¥   headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash    if err := WriteCanonicalHash(db, block.Hash(), block.NumberU64()); err != nil {        return nil, err    }    // å†™å…¥  "LastBlock" -&gt; hash    if err := WriteHeadBlockHash(db, block.Hash()); err != nil {        return nil, err    }    // å†™å…¥ "LastHeader" -&gt; hash    if err := WriteHeadHeaderHash(db, block.Hash()); err != nil {        return nil, err    }    config := g.Config    if config == nil {        config = params.AllProtocolChanges    }    // å†™å…¥ ethereum-config-hash -&gt; config    return block, WriteChainConfig(db, block.Hash(), config)}// MustCommit writes the genesis block and state to db, panicking on error.// The block is committed as the canonical head block.func (g *Genesis) MustCommit(db ethdb.Database) *types.Block {    block, err := g.Commit(db)    if err != nil {        panic(err)    }    return block}</code></pre><p>è¿”å›å„ç§æ¨¡å¼çš„é»˜è®¤Genesis</p><pre><code>// DefaultGenesisBlock returns the Ethereum main net genesis block.func DefaultGenesisBlock() *Genesis {    return &amp;Genesis{        Config:     params.MainnetChainConfig,        Nonce:      66,        ExtraData:  hexutil.MustDecode("0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"),        GasLimit:   5000,        Difficulty: big.NewInt(17179869184),        Alloc:      decodePrealloc(mainnetAllocData),    }}// DefaultTestnetGenesisBlock returns the Ropsten network genesis block.func DefaultTestnetGenesisBlock() *Genesis {    return &amp;Genesis{        Config:     params.TestnetChainConfig,        Nonce:      66,        ExtraData:  hexutil.MustDecode("0x3535353535353535353535353535353535353535353535353535353535353535"),        GasLimit:   16777216,        Difficulty: big.NewInt(1048576),        Alloc:      decodePrealloc(testnetAllocData),    }}// DefaultRinkebyGenesisBlock returns the Rinkeby network genesis block.func DefaultRinkebyGenesisBlock() *Genesis {    return &amp;Genesis{        Config:     params.RinkebyChainConfig,        Timestamp:  1492009146,        ExtraData:  hexutil.MustDecode("0x52657370656374206d7920617574686f7269746168207e452e436172746d616e42eb768f2244c8811c63729a21a3569731535f067ffc57839b00206d1ad20c69a1981b489f772031b279182d99e65703f0076e4812653aab85fca0f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),        GasLimit:   4700000,        Difficulty: big.NewInt(1),        Alloc:      decodePrealloc(rinkebyAllocData),    }}// DevGenesisBlock returns the 'geth --dev' genesis block.func DevGenesisBlock() *Genesis {    return &amp;Genesis{        Config:     params.AllProtocolChanges,        Nonce:      42,        GasLimit:   4712388,        Difficulty: big.NewInt(131072),        Alloc:      decodePrealloc(devAllocData),    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-core-state-processæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-state-process%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-state-process%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="StateTransition"><a href="#StateTransition" class="headerlink" title="StateTransition"></a>StateTransition</h2><p>çŠ¶æ€è½¬æ¢æ¨¡å‹</p><pre><code>/*The State Transitioning ModelçŠ¶æ€è½¬æ¢æ¨¡å‹A state transition is a change made when a transaction is applied to the current world stateçŠ¶æ€è½¬æ¢ æ˜¯æŒ‡ç”¨å½“å‰çš„world stateæ¥æ‰§è¡Œäº¤æ˜“ï¼Œå¹¶æ”¹å˜å½“å‰çš„world stateThe state transitioning model does all all the necessary work to work out a valid new state root.çŠ¶æ€è½¬æ¢åšäº†æ‰€æœ‰æ‰€éœ€çš„å·¥ä½œæ¥äº§ç”Ÿä¸€ä¸ªæ–°çš„æœ‰æ•ˆçš„state root1) Nonce handling  Nonce å¤„ç†2) Pre pay gas     é¢„å…ˆæ”¯ä»˜Gas3) Create a new state object if the recipient is \0*32 å¦‚æœæ¥æ”¶äººæ˜¯ç©ºï¼Œé‚£ä¹ˆåˆ›å»ºä¸€ä¸ªæ–°çš„state object4) Value transfer  è½¬è´¦== If contract creation ==  4a) Attempt to run transaction data å°è¯•è¿è¡Œè¾“å…¥çš„æ•°æ®  4b) If valid, use result as code for the new state object å¦‚æœæœ‰æ•ˆï¼Œé‚£ä¹ˆç”¨è¿è¡Œçš„ç»“æœä½œä¸ºæ–°çš„state objectçš„code== end ==5) Run Script section è¿è¡Œè„šæœ¬éƒ¨åˆ†6) Derive new state root å¯¼å‡ºæ–°çš„state root*/type StateTransition struct {    gp         *GasPool   //ç”¨æ¥è¿½è¸ªåŒºå—å†…éƒ¨çš„Gasçš„ä½¿ç”¨æƒ…å†µ    msg        Message        // Message Call    gas        uint64    gasPrice   *big.Int        // gasçš„ä»·æ ¼    initialGas *big.Int        // æœ€å¼€å§‹çš„gas    value      *big.Int        // è½¬è´¦çš„å€¼    data       []byte        // è¾“å…¥æ•°æ®    state      vm.StateDB    // StateDB    evm        *vm.EVM        // è™šæ‹Ÿæœº}// Message represents a message sent to a contract.type Message interface {    From() common.Address    //FromFrontier() (common.Address, error)    To() *common.Address    //     GasPrice() *big.Int  // Message çš„ GasPrice    Gas() *big.Int        //message çš„ GasLimit    Value() *big.Int    Nonce() uint64    CheckNonce() bool    Data() []byte}</code></pre><p>æ„é€ </p><pre><code>// NewStateTransition initialises and returns a new state transition object.func NewStateTransition(evm *vm.EVM, msg Message, gp *GasPool) *StateTransition {    return &amp;StateTransition{        gp:         gp,        evm:        evm,        msg:        msg,        gasPrice:   msg.GasPrice(),        initialGas: new(big.Int),        value:      msg.Value(),        data:       msg.Data(),        state:      evm.StateDB,    }}</code></pre><p>æ‰§è¡ŒMessage</p><pre><code>// ApplyMessage computes the new state by applying the given message// against the old state within the environment.// ApplyMessage é€šè¿‡åº”ç”¨ç»™å®šçš„Message å’ŒçŠ¶æ€æ¥ç”Ÿæˆæ–°çš„çŠ¶æ€// ApplyMessage returns the bytes returned by any EVM execution (if it took place),// the gas used (which includes gas refunds) and an error if it failed. An error always// indicates a core error meaning that the message would always fail for that particular// state and would never be accepted within a block.// ApplyMessageè¿”å›ç”±ä»»ä½•EVMæ‰§è¡Œï¼ˆå¦‚æœå‘ç”Ÿï¼‰è¿”å›çš„å­—èŠ‚ï¼Œ// ä½¿ç”¨çš„Gasï¼ˆåŒ…æ‹¬Gasé€€æ¬¾ï¼‰ï¼Œå¦‚æœå¤±è´¥åˆ™è¿”å›é”™è¯¯ã€‚ ä¸€ä¸ªé”™è¯¯æ€»æ˜¯è¡¨ç¤ºä¸€ä¸ªæ ¸å¿ƒé”™è¯¯ï¼Œ// æ„å‘³ç€è¿™ä¸ªæ¶ˆæ¯å¯¹äºè¿™ä¸ªç‰¹å®šçš„çŠ¶æ€å°†æ€»æ˜¯å¤±è´¥ï¼Œå¹¶ä¸”æ°¸è¿œä¸ä¼šåœ¨ä¸€ä¸ªå—ä¸­è¢«æ¥å—ã€‚func ApplyMessage(evm *vm.EVM, msg Message, gp *GasPool) ([]byte, *big.Int, bool, error) {    st := NewStateTransition(evm, msg, gp)    ret, _, gasUsed, failed, err := st.TransitionDb()    return ret, gasUsed, failed, err}</code></pre><p>TransitionDb</p><pre><code>// TransitionDb will transition the state by applying the current message and returning the result// including the required gas for the operation as well as the used gas. It returns an error if it// failed. An error indicates a consensus issue.// TransitionDb func (st *StateTransition) TransitionDb() (ret []byte, requiredGas, usedGas *big.Int, failed bool, err error) {    if err = st.preCheck(); err != nil {        return    }    msg := st.msg    sender := st.from() // err checked in preCheck    homestead := st.evm.ChainConfig().IsHomestead(st.evm.BlockNumber)    contractCreation := msg.To() == nil // å¦‚æœmsg.Toæ˜¯nil é‚£ä¹ˆè®¤ä¸ºæ˜¯ä¸€ä¸ªåˆçº¦åˆ›å»º    // Pay intrinsic gas    // TODO convert to uint64    // è®¡ç®—æœ€å¼€å§‹çš„Gas  g0    intrinsicGas := IntrinsicGas(st.data, contractCreation, homestead)    if intrinsicGas.BitLen() &gt; 64 {        return nil, nil, nil, false, vm.ErrOutOfGas    }    if err = st.useGas(intrinsicGas.Uint64()); err != nil {        return nil, nil, nil, false, err    }    var (        evm = st.evm        // vm errors do not effect consensus and are therefor        // not assigned to err, except for insufficient balance        // error.        vmerr error    )    if contractCreation { //å¦‚æœæ˜¯åˆçº¦åˆ›å»ºï¼Œ é‚£ä¹ˆè°ƒç”¨evmçš„Createæ–¹æ³•        ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)    } else {        // Increment the nonce for the next transaction        // å¦‚æœæ˜¯æ–¹æ³•è°ƒç”¨ã€‚é‚£ä¹ˆé¦–å…ˆè®¾ç½®senderçš„nonceã€‚        st.state.SetNonce(sender.Address(), st.state.GetNonce(sender.Address())+1)        ret, st.gas, vmerr = evm.Call(sender, st.to().Address(), st.data, st.gas, st.value)    }    if vmerr != nil {        log.Debug("VM returned with error", "err", vmerr)        // The only possible consensus-error would be if there wasn't        // sufficient balance to make the transfer happen. The first        // balance transfer may never fail.        if vmerr == vm.ErrInsufficientBalance {            return nil, nil, nil, false, vmerr        }    }    requiredGas = new(big.Int).Set(st.gasUsed()) // è®¡ç®—è¢«ä½¿ç”¨çš„Gasæ•°é‡    st.refundGas()  //è®¡ç®—Gasçš„é€€è´¹ ä¼šå¢åŠ åˆ° st.gasä¸Šé¢ã€‚ æ‰€ä»¥çŸ¿å·¥æ‹¿åˆ°çš„æ˜¯é€€ç¨åçš„    st.state.AddBalance(st.evm.Coinbase, new(big.Int).Mul(st.gasUsed(), st.gasPrice)) // ç»™çŸ¿å·¥å¢åŠ æ”¶å…¥ã€‚    // requiredGaså’ŒgasUsedçš„åŒºåˆ«ä¸€ä¸ªæ˜¯æ²¡æœ‰é€€ç¨çš„ï¼Œ ä¸€ä¸ªæ˜¯é€€ç¨äº†çš„ã€‚    // çœ‹ä¸Šé¢çš„è°ƒç”¨ ApplyMessageç›´æ¥ä¸¢å¼ƒäº†requiredGas, è¯´æ˜è¿”å›çš„æ˜¯é€€ç¨äº†çš„ã€‚    return ret, requiredGas, st.gasUsed(), vmerr != nil, err}</code></pre><p>å…³äºg0çš„è®¡ç®—ï¼Œåœ¨é»„çš®ä¹¦ä¸Šç”±è¯¦ç»†çš„ä»‹ç»<br>å’Œé»„çš®ä¹¦æœ‰ä¸€å®šå‡ºå…¥çš„éƒ¨åˆ†åœ¨äºif contractCreation &amp;&amp; homestead {igas.SetUint64(params.TxGasContractCreation) è¿™æ˜¯å› ä¸º Gtxcreate+Gtransaction = TxGasContractCreation</p><pre><code>func IntrinsicGas(data []byte, contractCreation, homestead bool) *big.Int {    igas := new(big.Int)    if contractCreation &amp;&amp; homestead {        igas.SetUint64(params.TxGasContractCreation)    } else {        igas.SetUint64(params.TxGas)    }    if len(data) &gt; 0 {        var nz int64        for _, byt := range data {            if byt != 0 {                nz++            }        }        m := big.NewInt(nz)        m.Mul(m, new(big.Int).SetUint64(params.TxDataNonZeroGas))        igas.Add(igas, m)        m.SetInt64(int64(len(data)) - nz)        m.Mul(m, new(big.Int).SetUint64(params.TxDataZeroGas))        igas.Add(igas, m)    }    return igas}</code></pre><p>æ‰§è¡Œå‰çš„æ£€æŸ¥</p><pre><code>func (st *StateTransition) preCheck() error {    msg := st.msg    sender := st.from()    // Make sure this transaction's nonce is correct    if msg.CheckNonce() {        nonce := st.state.GetNonce(sender.Address())        // å½“å‰æœ¬åœ°çš„nonce éœ€è¦å’Œ msgçš„Nonceä¸€æ · ä¸ç„¶å°±æ˜¯çŠ¶æ€ä¸åŒæ­¥äº†ã€‚        if nonce &lt; msg.Nonce() {            return ErrNonceTooHigh        } else if nonce &gt; msg.Nonce() {            return ErrNonceTooLow        }    }    return st.buyGas()}</code></pre><p>buyGasï¼Œ å®ç°Gasçš„é¢„æ‰£è´¹ï¼Œ  é¦–å…ˆå°±æ‰£é™¤ä½ çš„GasLimit * GasPriceçš„é’±ã€‚ ç„¶åæ ¹æ®è®¡ç®—å®Œçš„çŠ¶æ€åœ¨é€€è¿˜ä¸€éƒ¨åˆ†ã€‚</p><pre><code>func (st *StateTransition) buyGas() error {    mgas := st.msg.Gas()    if mgas.BitLen() &gt; 64 {        return vm.ErrOutOfGas    }    mgval := new(big.Int).Mul(mgas, st.gasPrice)    var (        state  = st.state        sender = st.from()    )    if state.GetBalance(sender.Address()).Cmp(mgval) &lt; 0 {        return errInsufficientBalanceForGas    }    if err := st.gp.SubGas(mgas); err != nil { // ä»åŒºå—çš„gaspoolé‡Œé¢å‡å»ï¼Œ å› ä¸ºåŒºå—æ˜¯ç”±GasLimité™åˆ¶æ•´ä¸ªåŒºå—çš„Gasä½¿ç”¨çš„ã€‚         return err    }    st.gas += mgas.Uint64()    st.initialGas.Set(mgas)    state.SubBalance(sender.Address(), mgval)    // ä»è´¦å·é‡Œé¢å‡å» GasLimit * GasPrice    return nil}    </code></pre><p>é€€ç¨ï¼Œé€€ç¨æ˜¯ä¸ºäº†å¥–åŠ±å¤§å®¶è¿è¡Œä¸€äº›èƒ½å¤Ÿå‡è½»åŒºå—é“¾è´Ÿæ‹…çš„æŒ‡ä»¤ï¼Œ æ¯”å¦‚æ¸…ç©ºè´¦æˆ·çš„storage. æˆ–è€…æ˜¯è¿è¡Œsuicideå‘½ä»¤æ¥æ¸…ç©ºè´¦å·ã€‚</p><pre><code>func (st *StateTransition) refundGas() {    // Return eth for remaining gas to the sender account,    // exchanged at the original rate.    sender := st.from() // err already checked    remaining := new(big.Int).Mul(new(big.Int).SetUint64(st.gas), st.gasPrice)    // é¦–å…ˆæŠŠç”¨æˆ·è¿˜å‰©ä¸‹çš„Gasè¿˜å›å»ã€‚    st.state.AddBalance(sender.Address(), remaining)    // Apply refund counter, capped to half of the used gas.    // ç„¶åé€€ç¨çš„æ€»é‡‘é¢ä¸ä¼šè¶…è¿‡ç”¨æˆ·Gasæ€»ä½¿ç”¨çš„1/2ã€‚     uhalf := remaining.Div(st.gasUsed(), common.Big2)    refund := math.BigMin(uhalf, st.state.GetRefund())    st.gas += refund.Uint64()    // æŠŠé€€ç¨çš„é‡‘é¢åŠ åˆ°ç”¨æˆ·è´¦æˆ·ä¸Šã€‚    st.state.AddBalance(sender.Address(), refund.Mul(refund, st.gasPrice))    // Also return remaining gas to the block gas counter so it is    // available for the next transaction.    // åŒæ—¶ä¹ŸæŠŠé€€ç¨çš„é’±è¿˜ç»™gaspoolç»™ä¸‹ä¸ªäº¤æ˜“è…¾ç‚¹Gasç©ºé—´ã€‚    st.gp.AddGas(new(big.Int).SetUint64(st.gas))}</code></pre><h2 id="StateProcessor"><a href="#StateProcessor" class="headerlink" title="StateProcessor"></a>StateProcessor</h2><p>StateTransitionæ˜¯ç”¨æ¥å¤„ç†ä¸€ä¸ªä¸€ä¸ªçš„äº¤æ˜“çš„ã€‚é‚£ä¹ˆStateProcessorå°±æ˜¯ç”¨æ¥å¤„ç†åŒºå—çº§åˆ«çš„äº¤æ˜“çš„ã€‚</p><p>ç»“æ„å’Œæ„é€ </p><pre><code>// StateProcessor is a basic Processor, which takes care of transitioning// state from one point to another.//// StateProcessor implements Processor.type StateProcessor struct {    config *params.ChainConfig // Chain configuration options    bc     *BlockChain         // Canonical block chain    engine consensus.Engine    // Consensus engine used for block rewards}// NewStateProcessor initialises a new StateProcessor.func NewStateProcessor(config *params.ChainConfig, bc *BlockChain, engine consensus.Engine) *StateProcessor {    return &amp;StateProcessor{        config: config,        bc:     bc,        engine: engine,    }}</code></pre><p>Processï¼Œè¿™ä¸ªæ–¹æ³•ä¼šè¢«blockchainè°ƒç”¨ã€‚</p><pre><code>// Process processes the state changes according to the Ethereum rules by running// the transaction messages using the statedb and applying any rewards to both// the processor (coinbase) and any included uncles.// Process æ ¹æ®ä»¥å¤ªåŠè§„åˆ™è¿è¡Œäº¤æ˜“ä¿¡æ¯æ¥å¯¹statedbè¿›è¡ŒçŠ¶æ€æ”¹å˜ï¼Œä»¥åŠå¥–åŠ±æŒ–çŸ¿è€…æˆ–è€…æ˜¯å…¶ä»–çš„å”çˆ¶èŠ‚ç‚¹ã€‚// Process returns the receipts and logs accumulated during the process and// returns the amount of gas that was used in the process. If any of the// transactions failed to execute due to insufficient gas it will return an error.// Processè¿”å›æ‰§è¡Œè¿‡ç¨‹ä¸­ç´¯è®¡çš„æ”¶æ®å’Œæ—¥å¿—ï¼Œå¹¶è¿”å›è¿‡ç¨‹ä¸­ä½¿ç”¨çš„Gasã€‚ å¦‚æœç”±äºGasä¸è¶³è€Œå¯¼è‡´ä»»ä½•äº¤æ˜“æ‰§è¡Œå¤±è´¥ï¼Œå°†è¿”å›é”™è¯¯ã€‚func (p *StateProcessor) Process(block *types.Block, statedb *state.StateDB, cfg vm.Config) (types.Receipts, []*types.Log, *big.Int, error) {    var (        receipts     types.Receipts        totalUsedGas = big.NewInt(0)        header       = block.Header()        allLogs      []*types.Log        gp           = new(GasPool).AddGas(block.GasLimit())    )    // Mutate the the block and state according to any hard-fork specs    // DAO äº‹ä»¶çš„ç¡¬åˆ†å‰å¤„ç†     if p.config.DAOForkSupport &amp;&amp; p.config.DAOForkBlock != nil &amp;&amp; p.config.DAOForkBlock.Cmp(block.Number()) == 0 {        misc.ApplyDAOHardFork(statedb)    }    // Iterate over and process the individual transactions    for i, tx := range block.Transactions() {        statedb.Prepare(tx.Hash(), block.Hash(), i)        receipt, _, err := ApplyTransaction(p.config, p.bc, nil, gp, statedb, header, tx, totalUsedGas, cfg)        if err != nil {            return nil, nil, nil, err        }        receipts = append(receipts, receipt)        allLogs = append(allLogs, receipt.Logs...)    }    // Finalize the block, applying any consensus engine specific extras (e.g. block rewards)    p.engine.Finalize(p.bc, header, statedb, block.Transactions(), block.Uncles(), receipts)    // è¿”å›æ”¶æ® æ—¥å¿— æ€»çš„Gasä½¿ç”¨é‡å’Œnil    return receipts, allLogs, totalUsedGas, nil}</code></pre><p>ApplyTransaction</p><pre><code>// ApplyTransaction attempts to apply a transaction to the given state database// and uses the input parameters for its environment. It returns the receipt// for the transaction, gas used and an error if the transaction failed,// indicating the block was invalid.ApplyTransactionå°è¯•å°†äº‹åŠ¡åº”ç”¨äºç»™å®šçš„çŠ¶æ€æ•°æ®åº“ï¼Œå¹¶ä½¿ç”¨å…¶ç¯å¢ƒçš„è¾“å…¥å‚æ•°ã€‚ //å®ƒè¿”å›äº‹åŠ¡çš„æ”¶æ®ï¼Œä½¿ç”¨çš„Gaså’Œé”™è¯¯ï¼Œå¦‚æœäº¤æ˜“å¤±è´¥ï¼Œè¡¨æ˜å—æ˜¯æ— æ•ˆçš„ã€‚func ApplyTransaction(config *params.ChainConfig, bc *BlockChain, author *common.Address, gp *GasPool, statedb *state.StateDB, header *types.Header, tx *types.Transaction, usedGas *big.Int, cfg vm.Config) (*types.Receipt, *big.Int, error) {    // æŠŠäº¤æ˜“è½¬æ¢æˆMessage     // è¿™é‡Œå¦‚ä½•éªŒè¯æ¶ˆæ¯ç¡®å®æ˜¯Senderå‘é€çš„ã€‚ TODO    msg, err := tx.AsMessage(types.MakeSigner(config, header.Number))    if err != nil {        return nil, nil, err    }    // Create a new context to be used in the EVM environment    // æ¯ä¸€ä¸ªäº¤æ˜“éƒ½åˆ›å»ºäº†æ–°çš„è™šæ‹Ÿæœºç¯å¢ƒã€‚    context := NewEVMContext(msg, header, bc, author)    // Create a new environment which holds all relevant information    // about the transaction and calling mechanisms.    vmenv := vm.NewEVM(context, statedb, config, cfg)    // Apply the transaction to the current state (included in the env)    _, gas, failed, err := ApplyMessage(vmenv, msg, gp)    if err != nil {        return nil, nil, err    }    // Update the state with pending changes    // æ±‚å¾—ä¸­é—´çŠ¶æ€    var root []byte    if config.IsByzantium(header.Number) {        statedb.Finalise(true)    } else {        root = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes()    }    usedGas.Add(usedGas, gas)    // Create a new receipt for the transaction, storing the intermediate root and gas used by the tx    // based on the eip phase, we're passing wether the root touch-delete accounts.    // åˆ›å»ºä¸€ä¸ªæ”¶æ®, ç”¨æ¥å­˜å‚¨ä¸­é—´çŠ¶æ€çš„root, ä»¥åŠäº¤æ˜“ä½¿ç”¨çš„gas    receipt := types.NewReceipt(root, failed, usedGas)    receipt.TxHash = tx.Hash()    receipt.GasUsed = new(big.Int).Set(gas)    // if the transaction created a contract, store the creation address in the receipt.    // å¦‚æœæ˜¯åˆ›å»ºåˆçº¦çš„äº¤æ˜“.é‚£ä¹ˆæˆ‘ä»¬æŠŠåˆ›å»ºåœ°å€å­˜å‚¨åˆ°æ”¶æ®é‡Œé¢.    if msg.To() == nil {        receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce())    }    // Set the receipt logs and create a bloom for filtering    receipt.Logs = statedb.GetLogs(tx.Hash())    receipt.Bloom = types.CreateBloom(types.Receipts{receipt})    // æ‹¿åˆ°æ‰€æœ‰çš„æ—¥å¿—å¹¶åˆ›å»ºæ—¥å¿—çš„å¸ƒéš†è¿‡æ»¤å™¨.    return receipt, gas, err}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-core-vm-jumptable-instruction</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-vm-jumptable-instruction/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-vm-jumptable-instruction/</url>
      
        <content type="html"><![CDATA[<p>jumptable. æ˜¯ä¸€ä¸ª [256]operation çš„æ•°æ®ç»“æ„. æ¯ä¸ªä¸‹æ ‡å¯¹åº”äº†ä¸€ç§æŒ‡ä»¤, ä½¿ç”¨operationæ¥å­˜å‚¨äº†æŒ‡ä»¤å¯¹åº”çš„å¤„ç†é€»è¾‘, gasæ¶ˆè€—, å †æ ˆéªŒè¯æ–¹æ³•, memoryä½¿ç”¨çš„å¤§å°ç­‰åŠŸèƒ½.</p><h2 id="jumptable"><a href="#jumptable" class="headerlink" title="jumptable"></a>jumptable</h2><p>æ•°æ®ç»“æ„operationå­˜å‚¨äº†ä¸€æ¡æŒ‡ä»¤çš„æ‰€éœ€è¦çš„å‡½æ•°.</p><pre><code>type operation struct {    // op is the operation function  æ‰§è¡Œå‡½æ•°    execute executionFunc    // gasCost is the gas function and returns the gas required for execution gasæ¶ˆè€—å‡½æ•°    gasCost gasFunc    // validateStack validates the stack (size) for the operation å †æ ˆå¤§å°éªŒè¯å‡½æ•°    validateStack stackValidationFunc    // memorySize returns the memory size required for the operation éœ€è¦çš„å†…å­˜å¤§å°    memorySize memorySizeFunc    halts   bool // indicates whether the operation shoult halt further execution è¡¨ç¤ºæ“ä½œæ˜¯å¦åœæ­¢è¿›ä¸€æ­¥æ‰§è¡Œ    jumps   bool // indicates whether the program counter should not increment æŒ‡ç¤ºç¨‹åºè®¡æ•°å™¨æ˜¯å¦ä¸å¢åŠ     writes  bool // determines whether this a state modifying operation ç¡®å®šè¿™æ˜¯å¦æ˜¯ä¸€ä¸ªçŠ¶æ€ä¿®æ”¹æ“ä½œ    valid   bool // indication whether the retrieved operation is valid and known æŒ‡ç¤ºæ£€ç´¢åˆ°çš„æ“ä½œæ˜¯å¦æœ‰æ•ˆå¹¶ä¸”å·²çŸ¥    reverts bool // determines whether the operation reverts state (implicitly halts)ç¡®å®šæ“ä½œæ˜¯å¦æ¢å¤çŠ¶æ€ï¼ˆéšå¼åœæ­¢ï¼‰    returns bool // determines whether the opertions sets the return data content ç¡®å®šæ“ä½œæ˜¯å¦è®¾ç½®äº†è¿”å›æ•°æ®å†…å®¹}</code></pre><p>æŒ‡ä»¤é›†, ä¸‹é¢å®šä¹‰äº†ä¸‰ç§æŒ‡ä»¤é›†,é’ˆå¯¹ä¸‰ç§ä¸åŒçš„ä»¥å¤ªåŠç‰ˆæœ¬, </p><p>var (<br>    frontierInstructionSet  = NewFrontierInstructionSet()<br>    homesteadInstructionSet = NewHomesteadInstructionSet()<br>    byzantiumInstructionSet = NewByzantiumInstructionSet()<br>)<br>NewByzantiumInstructionSet æ‹œå åº­ç‰ˆæœ¬é¦–å…ˆè°ƒç”¨NewHomesteadInstructionSetåˆ›é€ äº†å‰ä¸€ä¸ªç‰ˆæœ¬çš„æŒ‡ä»¤,ç„¶åå¢åŠ è‡ªå·±ç‰¹æœ‰çš„æŒ‡ä»¤.STATICCALL ,RETURNDATASIZE ,RETURNDATACOPY ,REVERT</p><pre><code>// NewByzantiumInstructionSet returns the frontier, homestead and// byzantium instructions.func NewByzantiumInstructionSet() [256]operation {    // instructions that can be executed during the homestead phase.    instructionSet := NewHomesteadInstructionSet()    instructionSet[STATICCALL] = operation{        execute:       opStaticCall,        gasCost:       gasStaticCall,        validateStack: makeStackFunc(6, 1),        memorySize:    memoryStaticCall,        valid:         true,        returns:       true,    }    instructionSet[RETURNDATASIZE] = operation{        execute:       opReturnDataSize,        gasCost:       constGasFunc(GasQuickStep),        validateStack: makeStackFunc(0, 1),        valid:         true,    }    instructionSet[RETURNDATACOPY] = operation{        execute:       opReturnDataCopy,        gasCost:       gasReturnDataCopy,        validateStack: makeStackFunc(3, 0),        memorySize:    memoryReturnDataCopy,        valid:         true,    }    instructionSet[REVERT] = operation{        execute:       opRevert,        gasCost:       gasRevert,        validateStack: makeStackFunc(2, 0),        memorySize:    memoryRevert,        valid:         true,        reverts:       true,        returns:       true,    }    return instructionSet}</code></pre><p>NewHomesteadInstructionSet</p><pre><code>// NewHomesteadInstructionSet returns the frontier and homestead// instructions that can be executed during the homestead phase.func NewHomesteadInstructionSet() [256]operation {    instructionSet := NewFrontierInstructionSet()    instructionSet[DELEGATECALL] = operation{        execute:       opDelegateCall,        gasCost:       gasDelegateCall,        validateStack: makeStackFunc(6, 1),        memorySize:    memoryDelegateCall,        valid:         true,        returns:       true,    }    return instructionSet}</code></pre><h2 id="instruction-go"><a href="#instruction-go" class="headerlink" title="instruction.go"></a>instruction.go</h2><p>å› ä¸ºæŒ‡ä»¤å¾ˆå¤š,æ‰€ä»¥ä¸ä¸€ä¸€åˆ—å‡ºæ¥,  åªåˆ—ä¸¾å‡ ä¸ªä¾‹å­. è™½ç„¶ç»„åˆèµ·æ¥çš„åŠŸèƒ½å¯ä»¥å¾ˆå¤æ‚,ä½†æ˜¯å•ä¸ªæŒ‡ä»¤æ¥è¯´,è¿˜æ˜¯æ¯”è¾ƒç›´è§‚çš„.</p><pre><code>func opPc(pc *uint64, evm *EVM, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {    stack.push(evm.interpreter.intPool.get().SetUint64(*pc))    return nil, nil}func opMsize(pc *uint64, evm *EVM, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {    stack.push(evm.interpreter.intPool.get().SetInt64(int64(memory.Len())))    return nil, nil}</code></pre><h2 id="gas-table-go"><a href="#gas-table-go" class="headerlink" title="gas_table.go"></a>gas_table.go</h2><p>gas_tableè¿”å›äº†å„ç§æŒ‡ä»¤æ¶ˆè€—çš„gasçš„å‡½æ•°<br>è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼åŸºæœ¬ä¸Šåªæœ‰errGasUintOverflow æ•´æ•°æº¢å‡ºçš„é”™è¯¯.</p><pre><code>func gasBalance(gt params.GasTable, evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {    return gt.Balance, nil}func gasExtCodeSize(gt params.GasTable, evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {    return gt.ExtcodeSize, nil}func gasSLoad(gt params.GasTable, evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {    return gt.SLoad, nil}func gasExp(gt params.GasTable, evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {    expByteLen := uint64((stack.data[stack.len()-2].BitLen() + 7) / 8)    var (        gas      = expByteLen * gt.ExpByte // no overflow check required. Max is 256 * ExpByte gas        overflow bool    )    if gas, overflow = math.SafeAdd(gas, GasSlowStep); overflow {        return 0, errGasUintOverflow    }    return gas, nil}</code></pre><h2 id="interpreter-go-è§£é‡Šå™¨"><a href="#interpreter-go-è§£é‡Šå™¨" class="headerlink" title="interpreter.go  è§£é‡Šå™¨"></a>interpreter.go  è§£é‡Šå™¨</h2><p>æ•°æ®ç»“æ„</p><pre><code>// Config are the configuration options for the Interpretertype Config struct {    // Debug enabled debugging Interpreter options    Debug bool    // EnableJit enabled the JIT VM    EnableJit bool    // ForceJit forces the JIT VM    ForceJit bool    // Tracer is the op code logger    Tracer Tracer    // NoRecursion disabled Interpreter call, callcode,    // delegate call and create.    NoRecursion bool    // Disable gas metering    DisableGasMetering bool    // Enable recording of SHA3/keccak preimages    EnablePreimageRecording bool    // JumpTable contains the EVM instruction table. This    // may be left uninitialised and will be set to the default    // table.    JumpTable [256]operation}// Interpreter is used to run Ethereum based contracts and will utilise the// passed evmironment to query external sources for state information.// The Interpreter will run the byte code VM or JIT VM based on the passed// configuration.type Interpreter struct {    evm      *EVM    cfg      Config    gasTable params.GasTable   // æ ‡è¯†äº†å¾ˆå¤šæ“ä½œçš„Gasä»·æ ¼    intPool  *intPool    readOnly   bool   // Whether to throw on stateful modifications    returnData []byte // Last CALL's return data for subsequent reuse æœ€åä¸€ä¸ªå‡½æ•°çš„è¿”å›å€¼}</code></pre><p>æ„é€ å‡½æ•°</p><pre><code>// NewInterpreter returns a new instance of the Interpreter.func NewInterpreter(evm *EVM, cfg Config) *Interpreter {    // We use the STOP instruction whether to see    // the jump table was initialised. If it was not    // we'll set the default jump table.    // ç”¨ä¸€ä¸ªSTOPæŒ‡ä»¤æµ‹è¯•JumpTableæ˜¯å¦å·²ç»è¢«åˆå§‹åŒ–äº†, å¦‚æœæ²¡æœ‰è¢«åˆå§‹åŒ–,é‚£ä¹ˆè®¾ç½®ä¸ºé»˜è®¤å€¼    if !cfg.JumpTable[STOP].valid {         switch {        case evm.ChainConfig().IsByzantium(evm.BlockNumber):            cfg.JumpTable = byzantiumInstructionSet        case evm.ChainConfig().IsHomestead(evm.BlockNumber):            cfg.JumpTable = homesteadInstructionSet        default:            cfg.JumpTable = frontierInstructionSet        }    }    return &amp;Interpreter{        evm:      evm,        cfg:      cfg,        gasTable: evm.ChainConfig().GasTable(evm.BlockNumber),        intPool:  newIntPool(),    }}</code></pre><p>è§£é‡Šå™¨ä¸€å…±å°±ä¸¤ä¸ªæ–¹æ³•enforceRestrictionsæ–¹æ³•å’ŒRunæ–¹æ³•.</p><pre><code>func (in *Interpreter) enforceRestrictions(op OpCode, operation operation, stack *Stack) error {    if in.evm.chainRules.IsByzantium {        if in.readOnly {            // If the interpreter is operating in readonly mode, make sure no            // state-modifying operation is performed. The 3rd stack item            // for a call operation is the value. Transferring value from one            // account to the others means the state is modified and should also            // return with an error.            if operation.writes || (op == CALL &amp;&amp; stack.Back(2).BitLen() &gt; 0) {                return errWriteProtection            }        }    }    return nil}// Run loops and evaluates the contract's code with the given input data and returns// the return byte-slice and an error if one occurred.// ç”¨ç»™å®šçš„å…¥å‚å¾ªç¯æ‰§è¡Œåˆçº¦çš„ä»£ç ï¼Œå¹¶è¿”å›è¿”å›çš„å­—èŠ‚ç‰‡æ®µï¼Œå¦‚æœå‘ç”Ÿé”™è¯¯åˆ™è¿”å›é”™è¯¯ã€‚// It's important to note that any errors returned by the interpreter should be// considered a revert-and-consume-all-gas operation. No error specific checks// should be handled to reduce complexity and errors further down the in.// é‡è¦çš„æ˜¯è¦æ³¨æ„ï¼Œè§£é‡Šå™¨è¿”å›çš„ä»»ä½•é”™è¯¯éƒ½ä¼šæ¶ˆè€—å…¨éƒ¨gasã€‚ ä¸ºäº†å‡å°‘å¤æ‚æ€§,æ²¡æœ‰ç‰¹åˆ«çš„é”™è¯¯å¤„ç†æµç¨‹ã€‚func (in *Interpreter) Run(snapshot int, contract *Contract, input []byte) (ret []byte, err error) {    // Increment the call depth which is restricted to 1024    in.evm.depth++    defer func() { in.evm.depth-- }()    // Reset the previous call's return data. It's unimportant to preserve the old buffer    // as every returning call will return new data anyway.    in.returnData = nil    // Don't bother with the execution if there's no code.    if len(contract.Code) == 0 {        return nil, nil    }    codehash := contract.CodeHash // codehash is used when doing jump dest caching    if codehash == (common.Hash{}) {        codehash = crypto.Keccak256Hash(contract.Code)    }    var (        op    OpCode        // current opcode        mem   = NewMemory() // bound memory        stack = newstack()  // local stack        // For optimisation reason we're using uint64 as the program counter.        // It's theoretically possible to go above 2^64. The YP defines the PC        // to be uint256. Practically much less so feasible.        pc   = uint64(0) // program counter        cost uint64        // copies used by tracer        stackCopy = newstack() // stackCopy needed for Tracer since stack is mutated by 63/64 gas rule         pcCopy uint64 // needed for the deferred Tracer        gasCopy uint64 // for Tracer to log gas remaining before execution        logged bool // deferred Tracer should ignore already logged steps    )    contract.Input = input    defer func() {        if err != nil &amp;&amp; !logged &amp;&amp; in.cfg.Debug {            in.cfg.Tracer.CaptureState(in.evm, pcCopy, op, gasCopy, cost, mem, stackCopy, contract, in.evm.depth, err)        }    }()    // The Interpreter main run loop (contextual). This loop runs until either an    // explicit STOP, RETURN or SELFDESTRUCT is executed, an error occurred during    // the execution of one of the operations or until the done flag is set by the    // parent context.    // è§£é‡Šå™¨çš„ä¸»è¦å¾ªç¯ï¼Œ ç›´åˆ°é‡åˆ°STOPï¼ŒRETURNï¼ŒSELFDESTRUCTæŒ‡ä»¤è¢«æ‰§è¡Œï¼Œæˆ–è€…æ˜¯é‡åˆ°ä»»æ„é”™è¯¯ï¼Œæˆ–è€…è¯´done æ ‡å¿—è¢«çˆ¶contextè®¾ç½®ã€‚    for atomic.LoadInt32(&amp;in.evm.abort) == 0 {        // Get the memory location of pc        // éš¾é“ä¸‹ä¸€ä¸ªéœ€è¦æ‰§è¡Œçš„æŒ‡ä»¤        op = contract.GetOp(pc)        if in.cfg.Debug {            logged = false            pcCopy = uint64(pc)            gasCopy = uint64(contract.Gas)            stackCopy = newstack()            for _, val := range stack.data {                stackCopy.push(val)            }        }        // get the operation from the jump table matching the opcode        // é€šè¿‡JumpTableæ‹¿åˆ°å¯¹åº”çš„operation        operation := in.cfg.JumpTable[op]        // è¿™é‡Œæ£€æŸ¥äº†åªè¯»æ¨¡å¼ä¸‹é¢ä¸èƒ½æ‰§è¡ŒwritesæŒ‡ä»¤        // staticCallçš„æƒ…å†µä¸‹ä¼šè®¾ç½®ä¸ºreadonlyæ¨¡å¼        if err := in.enforceRestrictions(op, operation, stack); err != nil {            return nil, err        }        // if the op is invalid abort the process and return an error        if !operation.valid { //æ£€æŸ¥æŒ‡ä»¤æ˜¯å¦éæ³•            return nil, fmt.Errorf("invalid opcode 0x%x", int(op))        }        // validate the stack and make sure there enough stack items available        // to perform the operation        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„å †æ ˆç©ºé—´ã€‚ åŒ…æ‹¬å…¥æ ˆå’Œå‡ºæ ˆ        if err := operation.validateStack(stack); err != nil {            return nil, err        }        var memorySize uint64        // calculate the new memory size and expand the memory to fit        // the operation        if operation.memorySize != nil { // è®¡ç®—å†…å­˜ä½¿ç”¨é‡ï¼Œéœ€è¦æ”¶è´¹            memSize, overflow := bigUint64(operation.memorySize(stack))            if overflow {                return nil, errGasUintOverflow            }            // memory is expanded in words of 32 bytes. Gas            // is also calculated in words.            if memorySize, overflow = math.SafeMul(toWordSize(memSize), 32); overflow {                return nil, errGasUintOverflow            }        }        if !in.cfg.DisableGasMetering { //è¿™ä¸ªå‚æ•°åœ¨æœ¬åœ°æ¨¡æ‹Ÿæ‰§è¡Œçš„æ—¶å€™æ¯”è¾ƒæœ‰ç”¨ï¼Œå¯ä»¥ä¸æ¶ˆè€—æˆ–è€…æ£€æŸ¥GASæ‰§è¡Œäº¤æ˜“å¹¶å¾—åˆ°è¿”å›ç»“æœ            // consume the gas and return an error if not enough gas is available.            // cost is explicitly set so that the capture state defer method cas get the proper cost            // è®¡ç®—gasçš„Cost å¹¶ä½¿ç”¨ï¼Œå¦‚æœä¸å¤Ÿï¼Œå°±è¿”å›OutOfGasé”™è¯¯ã€‚            cost, err = operation.gasCost(in.gasTable, in.evm, contract, stack, mem, memorySize)            if err != nil || !contract.UseGas(cost) {                return nil, ErrOutOfGas            }        }        if memorySize &gt; 0 { //æ‰©å¤§å†…å­˜èŒƒå›´            mem.Resize(memorySize)        }        if in.cfg.Debug {            in.cfg.Tracer.CaptureState(in.evm, pc, op, gasCopy, cost, mem, stackCopy, contract, in.evm.depth, err)            logged = true        }        // execute the operation        // æ‰§è¡Œå‘½ä»¤        res, err := operation.execute(&amp;pc, in.evm, contract, mem, stack)        // verifyPool is a build flag. Pool verification makes sure the integrity        // of the integer pool by comparing values to a default value.        if verifyPool {            verifyIntegerPool(in.intPool)        }        // if the operation clears the return data (e.g. it has returning data)        // set the last return to the result of the operation.        if operation.returns { //å¦‚æœæœ‰è¿”å›å€¼ï¼Œé‚£ä¹ˆå°±è®¾ç½®è¿”å›å€¼ã€‚ æ³¨æ„åªæœ‰æœ€åä¸€ä¸ªè¿”å›æœ‰æ•ˆæœã€‚            in.returnData = res        }        switch {        case err != nil:            return nil, err        case operation.reverts:            return res, errExecutionReverted        case operation.halts:            return res, nil        case !operation.jumps:            pc++        }    }    return nil, nil}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-core-vm-stack-memoryæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-vm-stack-memory%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-vm-stack-memory%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>vmä½¿ç”¨äº†stack.goé‡Œé¢çš„å¯¹è±¡Stackæ¥ä½œä¸ºè™šæ‹Ÿæœºçš„å †æ ˆã€‚memoryä»£è¡¨äº†è™šæ‹Ÿæœºé‡Œé¢ä½¿ç”¨çš„å†…å­˜å¯¹è±¡ã€‚</p><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯ç”¨1024ä¸ªbig.Intçš„å®šé•¿æ•°ç»„æ¥ä½œä¸ºå †æ ˆçš„å­˜å‚¨ã€‚</p><p>æ„é€ </p><pre><code>// stack is an object for basic stack operations. Items popped to the stack are// expected to be changed and modified. stack does not take care of adding newly// initialised objects.type Stack struct {    data []*big.Int}func newstack() *Stack {    return &amp;Stack{data: make([]*big.Int, 0, 1024)}}</code></pre><p>pushæ“ä½œ </p><pre><code>func (st *Stack) push(d *big.Int) { //è¿½åŠ åˆ°æœ€æœ«å°¾    // NOTE push limit (1024) is checked in baseCheck    //stackItem := new(big.Int).Set(d)    //st.data = append(st.data, stackItem)    st.data = append(st.data, d)}func (st *Stack) pushN(ds ...*big.Int) {    st.data = append(st.data, ds...)}</code></pre><p>popæ“ä½œ</p><pre><code>func (st *Stack) pop() (ret *big.Int) { //ä»æœ€æœ«å°¾å–å‡ºã€‚    ret = st.data[len(st.data)-1]    st.data = st.data[:len(st.data)-1]    return}</code></pre><p>äº¤æ¢å…ƒç´ çš„å€¼æ“ä½œï¼Œè¿˜æœ‰è¿™ç§æ“ä½œï¼Ÿ</p><pre><code>func (st *Stack) swap(n int) {     // äº¤æ¢å †æ ˆé¡¶çš„å…ƒç´ å’Œç¦»æ ˆé¡¶nè·ç¦»çš„å…ƒç´ çš„å€¼ã€‚    st.data[st.len()-n], st.data[st.len()-1] = st.data[st.len()-1], st.data[st.len()-n]}</code></pre><p>dupæ“ä½œ åƒå¤åˆ¶æŒ‡å®šä½ç½®çš„å€¼åˆ°å †é¡¶</p><pre><code>func (st *Stack) dup(pool *intPool, n int) {    st.push(pool.get().Set(st.data[st.len()-n]))}</code></pre><p>peek æ“ä½œ. å·çœ‹æ ˆé¡¶å…ƒç´ </p><pre><code>func (st *Stack) peek() *big.Int {    return st.data[st.len()-1]}</code></pre><p>Back å·çœ‹æŒ‡å®šä½ç½®çš„å…ƒç´ </p><pre><code>// Back returns the n'th item in stackfunc (st *Stack) Back(n int) *big.Int {    return st.data[st.len()-n-1]}</code></pre><p>require ä¿è¯å †æ ˆå…ƒç´ çš„æ•°é‡è¦å¤§äºç­‰äºn.</p><pre><code>func (st *Stack) require(n int) error {    if st.len() &lt; n {        return fmt.Errorf("stack underflow (%d &lt;=&gt; %d)", len(st.data), n)    }    return nil}</code></pre><h2 id="intpool"><a href="#intpool" class="headerlink" title="intpool"></a>intpool</h2><p>éå¸¸ç®€å•. å°±æ˜¯256å¤§å°çš„ big.intçš„æ± ,ç”¨æ¥åŠ é€Ÿbit.Intçš„åˆ†é…</p><pre><code>var checkVal = big.NewInt(-42)const poolLimit = 256// intPool is a pool of big integers that// can be reused for all big.Int operations.type intPool struct {    pool *Stack}func newIntPool() *intPool {    return &amp;intPool{pool: newstack()}}func (p *intPool) get() *big.Int {    if p.pool.len() &gt; 0 {        return p.pool.pop()    }    return new(big.Int)}func (p *intPool) put(is ...*big.Int) {    if len(p.pool.data) &gt; poolLimit {        return    }    for _, i := range is {        // verifyPool is a build flag. Pool verification makes sure the integrity        // of the integer pool by comparing values to a default value.        if verifyPool {            i.Set(checkVal)        }        p.pool.push(i)    }}</code></pre><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>æ„é€ , memoryçš„å­˜å‚¨å°±æ˜¯byte[]. è¿˜æœ‰ä¸€ä¸ªlastGasCostçš„è®°å½•.</p><pre><code>type Memory struct {    store       []byte    lastGasCost uint64}func NewMemory() *Memory {    return &amp;Memory{}}</code></pre><p>ä½¿ç”¨é¦–å…ˆéœ€è¦ä½¿ç”¨Resizeåˆ†é…ç©ºé—´</p><pre><code>// Resize resizes the memory to sizefunc (m *Memory) Resize(size uint64) {    if uint64(m.Len()) &lt; size {        m.store = append(m.store, make([]byte, size-uint64(m.Len()))...)    }}</code></pre><p>ç„¶åä½¿ç”¨Setæ¥è®¾ç½®å€¼</p><pre><code>// Set sets offset + size to valuefunc (m *Memory) Set(offset, size uint64, value []byte) {    // length of store may never be less than offset + size.    // The store should be resized PRIOR to setting the memory    if size &gt; uint64(len(m.store)) {        panic("INVALID memory: store empty")    }    // It's possible the offset is greater than 0 and size equals 0. This is because    // the calcMemSize (common.go) could potentially return 0 when size is zero (NO-OP)    if size &gt; 0 {        copy(m.store[offset:offset+size], value)    }}</code></pre><p>Getæ¥å–å€¼, ä¸€ä¸ªæ˜¯è·å–æ‹·è´, ä¸€ä¸ªæ˜¯è·å–æŒ‡é’ˆ.</p><pre><code>// Get returns offset + size as a new slicefunc (self *Memory) Get(offset, size int64) (cpy []byte) {    if size == 0 {        return nil    }    if len(self.store) &gt; int(offset) {        cpy = make([]byte, size)        copy(cpy, self.store[offset:offset+size])        return    }    return}// GetPtr returns the offset + sizefunc (self *Memory) GetPtr(offset, size int64) []byte {    if size == 0 {        return nil    }    if len(self.store) &gt; int(offset) {        return self.store[offset : offset+size]    }    return nil}</code></pre><h2 id="ä¸€äº›é¢å¤–çš„å¸®åŠ©å‡½æ•°-åœ¨stack-table-goé‡Œé¢"><a href="#ä¸€äº›é¢å¤–çš„å¸®åŠ©å‡½æ•°-åœ¨stack-table-goé‡Œé¢" class="headerlink" title="ä¸€äº›é¢å¤–çš„å¸®åŠ©å‡½æ•° åœ¨stack_table.goé‡Œé¢"></a>ä¸€äº›é¢å¤–çš„å¸®åŠ©å‡½æ•° åœ¨stack_table.goé‡Œé¢</h2><pre><code>func makeStackFunc(pop, push int) stackValidationFunc {    return func(stack *Stack) error {        if err := stack.require(pop); err != nil {            return err        }        if stack.len()+push-pop &gt; int(params.StackLimit) {            return fmt.Errorf("stack limit reached %d (%d)", stack.len(), params.StackLimit)        }        return nil    }}func makeDupStackFunc(n int) stackValidationFunc {    return makeStackFunc(n, n+1)}func makeSwapStackFunc(n int) stackValidationFunc {    return makeStackFunc(n, n)}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-eth-downloader-peeræºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-downloader-peer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-downloader-peer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>peeræ¨¡å—åŒ…å«äº†downloaderä½¿ç”¨çš„peerèŠ‚ç‚¹ï¼Œå°è£…äº†ååé‡ï¼Œæ˜¯å¦ç©ºé—²ï¼Œå¹¶è®°å½•äº†ä¹‹å‰å¤±è´¥çš„ä¿¡æ¯ã€‚</p><h2 id="peer"><a href="#peer" class="headerlink" title="peer"></a>peer</h2><pre><code>// peerConnection represents an active peer from which hashes and blocks are retrieved.type peerConnection struct {    id string // Unique identifier of the peer    headerIdle  int32 // Current header activity state of the peer (idle = 0, active = 1) å½“å‰çš„headerè·å–çš„å·¥ä½œçŠ¶æ€ã€‚    blockIdle   int32 // Current block activity state of the peer (idle = 0, active = 1)    å½“å‰çš„åŒºå—è·å–çš„å·¥ä½œçŠ¶æ€    receiptIdle int32 // Current receipt activity state of the peer (idle = 0, active = 1) å½“å‰çš„æ”¶æ®è·å–çš„å·¥ä½œçŠ¶æ€    stateIdle   int32 // Current node data activity state of the peer (idle = 0, active = 1) å½“å‰èŠ‚ç‚¹çŠ¶æ€çš„å·¥ä½œçŠ¶æ€    headerThroughput  float64 // Number of headers measured to be retrievable per second    //è®°å½•æ¯ç§’èƒ½å¤Ÿæ¥æ”¶å¤šå°‘ä¸ªåŒºå—å¤´çš„åº¦é‡å€¼    blockThroughput   float64 // Number of blocks (bodies) measured to be retrievable per second  //è®°å½•æ¯ç§’èƒ½å¤Ÿæ¥æ”¶å¤šå°‘ä¸ªåŒºå—çš„åº¦é‡å€¼    receiptThroughput float64 // Number of receipts measured to be retrievable per second è®°å½•æ¯ç§’èƒ½å¤Ÿæ¥æ”¶å¤šå°‘ä¸ªæ”¶æ®çš„åº¦é‡å€¼    stateThroughput   float64 // Number of node data pieces measured to be retrievable per second  è®°å½•æ¯ç§’èƒ½å¤Ÿæ¥æ”¶å¤šå°‘ä¸ªè´¦æˆ·çŠ¶æ€çš„åº¦é‡å€¼    rtt time.Duration // Request round trip time to track responsiveness (QoS)  è¯·æ±‚å›åº”æ—¶é—´    headerStarted  time.Time // Time instance when the last header fetch was started    è®°å½•æœ€åä¸€ä¸ªheader fetchçš„è¯·æ±‚æ—¶é—´    blockStarted   time.Time // Time instance when the last block (body) fetch was started    receiptStarted time.Time // Time instance when the last receipt fetch was started    stateStarted   time.Time // Time instance when the last node data fetch was started        lacking map[common.Hash]struct{} // Set of hashes not to request (didn't have previously)  è®°å½•çš„Hashå€¼ä¸ä¼šå»è¯·æ±‚ï¼Œä¸€èˆ¬æ˜¯å› ä¸ºä¹‹å‰çš„è¯·æ±‚å¤±è´¥    peer Peer            // ethçš„peer    version int        // Eth protocol version number to switch strategies    log     log.Logger // Contextual logger to add extra infos to peer logs    lock    sync.RWMutex}</code></pre><p>FetchXXX<br>FetchHeaders FetchBodiesç­‰å‡½æ•° ä¸»è¦è°ƒç”¨äº†eth.peerçš„åŠŸèƒ½æ¥è¿›è¡Œå‘é€æ•°æ®è¯·æ±‚ã€‚</p><pre><code>// FetchHeaders sends a header retrieval request to the remote peer.func (p *peerConnection) FetchHeaders(from uint64, count int) error {    // Sanity check the protocol version    if p.version &lt; 62 {        panic(fmt.Sprintf("header fetch [eth/62+] requested on eth/%d", p.version))    }    // Short circuit if the peer is already fetching    if !atomic.CompareAndSwapInt32(&amp;p.headerIdle, 0, 1) {        return errAlreadyFetching    }    p.headerStarted = time.Now()    // Issue the header retrieval request (absolut upwards without gaps)    go p.peer.RequestHeadersByNumber(from, count, 0, false)    return nil}</code></pre><p>SetXXXIdleå‡½æ•°<br>SetHeadersIdle, SetBlocksIdle ç­‰å‡½æ•° è®¾ç½®peerçš„çŠ¶æ€ä¸ºç©ºé—²çŠ¶æ€ï¼Œå…è®¸å®ƒæ‰§è¡Œæ–°çš„è¯·æ±‚ã€‚ åŒæ—¶è¿˜ä¼šé€šè¿‡æœ¬æ¬¡ä¼ è¾“çš„æ•°æ®çš„å¤šå°‘æ¥é‡æ–°è¯„ä¼°é“¾è·¯çš„ååé‡ã€‚</p><pre><code>// SetHeadersIdle sets the peer to idle, allowing it to execute new header retrieval// requests. Its estimated header retrieval throughput is updated with that measured// just now.func (p *peerConnection) SetHeadersIdle(delivered int) {    p.setIdle(p.headerStarted, delivered, &amp;p.headerThroughput, &amp;p.headerIdle)}</code></pre><p>setIdle</p><pre><code>// setIdle sets the peer to idle, allowing it to execute new retrieval requests.// Its estimated retrieval throughput is updated with that measured just now.func (p *peerConnection) setIdle(started time.Time, delivered int, throughput *float64, idle *int32) {    // Irrelevant of the scaling, make sure the peer ends up idle    defer atomic.StoreInt32(idle, 0)    p.lock.Lock()    defer p.lock.Unlock()    // If nothing was delivered (hard timeout / unavailable data), reduce throughput to minimum    if delivered == 0 {        *throughput = 0        return    }    // Otherwise update the throughput with a new measurement    elapsed := time.Since(started) + 1 // +1 (ns) to ensure non-zero divisor    measured := float64(delivered) / (float64(elapsed) / float64(time.Second))        // measurementImpact = 0.1 , æ–°çš„ååé‡=è€çš„ååé‡*0.9 + è¿™æ¬¡çš„ååé‡*0.1    *throughput = (1-measurementImpact)*(*throughput) + measurementImpact*measured        // æ›´æ–°RTT    p.rtt = time.Duration((1-measurementImpact)*float64(p.rtt) + measurementImpact*float64(elapsed))    p.log.Trace("Peer throughput measurements updated",        "hps", p.headerThroughput, "bps", p.blockThroughput,        "rps", p.receiptThroughput, "sps", p.stateThroughput,        "miss", len(p.lacking), "rtt", p.rtt)}</code></pre><p>XXXCapacityå‡½æ•°ï¼Œç”¨æ¥è¿”å›å½“å‰çš„é“¾æ¥å…è®¸çš„ååé‡ã€‚</p><pre><code>// HeaderCapacity retrieves the peers header download allowance based on its// previously discovered throughput.func (p *peerConnection) HeaderCapacity(targetRTT time.Duration) int {    p.lock.RLock()    defer p.lock.RUnlock()    // è¿™é‡Œæœ‰ç‚¹å¥‡æ€ªï¼ŒtargetRTTè¶Šå¤§ï¼Œè¯·æ±‚çš„æ•°é‡å°±è¶Šå¤šã€‚    return int(math.Min(1+math.Max(1, p.headerThroughput*float64(targetRTT)/float64(time.Second)), float64(MaxHeaderFetch)))}</code></pre><p>Lacks ç”¨æ¥æ ‡è®°ä¸Šæ¬¡æ˜¯å¦å¤±è´¥ï¼Œä»¥ä¾¿ä¸‹æ¬¡åŒæ ·çš„è¯·æ±‚ä¸é€šè¿‡è¿™ä¸ªpeer</p><pre><code>    // MarkLacking appends a new entity to the set of items (blocks, receipts, states)    // that a peer is known not to have (i.e. have been requested before). If the    // set reaches its maximum allowed capacity, items are randomly dropped off.    func (p *peerConnection) MarkLacking(hash common.Hash) {        p.lock.Lock()        defer p.lock.Unlock()            for len(p.lacking) &gt;= maxLackingHashes {            for drop := range p.lacking {                delete(p.lacking, drop)                break            }        }        p.lacking[hash] = struct{}{}    }        // Lacks retrieves whether the hash of a blockchain item is on the peers lacking    // list (i.e. whether we know that the peer does not have it).    func (p *peerConnection) Lacks(hash common.Hash) bool {        p.lock.RLock()        defer p.lock.RUnlock()            _, ok := p.lacking[hash]        return ok    }</code></pre><h2 id="peerSet"><a href="#peerSet" class="headerlink" title="peerSet"></a>peerSet</h2><pre><code>// peerSet represents the collection of active peer participating in the chain// download procedure.type peerSet struct {    peers        map[string]*peerConnection    newPeerFeed  event.Feed    peerDropFeed event.Feed    lock         sync.RWMutex}</code></pre><p>Register å’Œ UnRegister</p><pre><code>// Register injects a new peer into the working set, or returns an error if the// peer is already known.//// The method also sets the starting throughput values of the new peer to the// average of all existing peers, to give it a realistic chance of being used// for data retrievals.func (ps *peerSet) Register(p *peerConnection) error {    // Retrieve the current median RTT as a sane default    p.rtt = ps.medianRTT()    // Register the new peer with some meaningful defaults    ps.lock.Lock()    if _, ok := ps.peers[p.id]; ok {        ps.lock.Unlock()        return errAlreadyRegistered    }    if len(ps.peers) &gt; 0 {        p.headerThroughput, p.blockThroughput, p.receiptThroughput, p.stateThroughput = 0, 0, 0, 0        for _, peer := range ps.peers {            peer.lock.RLock()            p.headerThroughput += peer.headerThroughput            p.blockThroughput += peer.blockThroughput            p.receiptThroughput += peer.receiptThroughput            p.stateThroughput += peer.stateThroughput            peer.lock.RUnlock()        }        p.headerThroughput /= float64(len(ps.peers))        p.blockThroughput /= float64(len(ps.peers))        p.receiptThroughput /= float64(len(ps.peers))        p.stateThroughput /= float64(len(ps.peers))    }    ps.peers[p.id] = p    ps.lock.Unlock()    ps.newPeerFeed.Send(p)    return nil}// Unregister removes a remote peer from the active set, disabling any further// actions to/from that particular entity.func (ps *peerSet) Unregister(id string) error {    ps.lock.Lock()    p, ok := ps.peers[id]    if !ok {        defer ps.lock.Unlock()        return errNotRegistered    }    delete(ps.peers, id)    ps.lock.Unlock()    ps.peerDropFeed.Send(p)    return nil}</code></pre><p>XXXIdlePeers</p><pre><code>// HeaderIdlePeers retrieves a flat list of all the currently header-idle peers// within the active peer set, ordered by their reputation.func (ps *peerSet) HeaderIdlePeers() ([]*peerConnection, int) {    idle := func(p *peerConnection) bool {        return atomic.LoadInt32(&amp;p.headerIdle) == 0    }    throughput := func(p *peerConnection) float64 {        p.lock.RLock()        defer p.lock.RUnlock()        return p.headerThroughput    }    return ps.idlePeers(62, 64, idle, throughput)}// idlePeers retrieves a flat list of all currently idle peers satisfying the// protocol version constraints, using the provided function to check idleness.// The resulting set of peers are sorted by their measure throughput.func (ps *peerSet) idlePeers(minProtocol, maxProtocol int, idleCheck func(*peerConnection) bool, throughput func(*peerConnection) float64) ([]*peerConnection, int) {    ps.lock.RLock()    defer ps.lock.RUnlock()    idle, total := make([]*peerConnection, 0, len(ps.peers)), 0    for _, p := range ps.peers { //é¦–å…ˆæŠ½å–idleçš„peer        if p.version &gt;= minProtocol &amp;&amp; p.version &lt;= maxProtocol {            if idleCheck(p) {                idle = append(idle, p)            }            total++        }    }    for i := 0; i &lt; len(idle); i++ { // å†’æ³¡æ’åºï¼Œ ä»ååé‡å¤§åˆ°ååé‡å°ã€‚        for j := i + 1; j &lt; len(idle); j++ {            if throughput(idle[i]) &lt; throughput(idle[j]) {                idle[i], idle[j] = idle[j], idle[i]            }        }    }    return idle, total}</code></pre><p>medianRTT,æ±‚å¾—peersetçš„RTTçš„ä¸­ä½æ•°ï¼Œ</p><pre><code>// medianRTT returns the median RTT of te peerset, considering only the tuning// peers if there are more peers available.func (ps *peerSet) medianRTT() time.Duration {    // Gather all the currnetly measured round trip times    ps.lock.RLock()    defer ps.lock.RUnlock()    rtts := make([]float64, 0, len(ps.peers))    for _, p := range ps.peers {        p.lock.RLock()        rtts = append(rtts, float64(p.rtt))        p.lock.RUnlock()    }    sort.Float64s(rtts)    median := rttMaxEstimate    if qosTuningPeers &lt;= len(rtts) {        median = time.Duration(rtts[qosTuningPeers/2]) // Median of our tuning peers    } else if len(rtts) &gt; 0 {        median = time.Duration(rtts[len(rtts)/2]) // Median of our connected peers (maintain even like this some baseline qos)    }    // Restrict the RTT into some QoS defaults, irrelevant of true RTT    if median &lt; rttMinEstimate {        median = rttMinEstimate    }    if median &gt; rttMaxEstimate {        median = rttMaxEstimate    }    return median}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-eth-downloader-statesync</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-downloader-statesync/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-downloader-statesync/</url>
      
        <content type="html"><![CDATA[<p>statesync ç”¨æ¥è·å–pivot pointæ‰€æŒ‡å®šçš„åŒºå—çš„æ‰€æœ‰çš„state çš„trieæ ‘ï¼Œä¹Ÿå°±æ˜¯æ‰€æœ‰çš„è´¦å·çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ™®é€šè´¦å·å’Œåˆçº¦è´¦æˆ·ã€‚</p><h2 id="æ•°æ®ç»“æ„"><a href="#æ•°æ®ç»“æ„" class="headerlink" title="æ•°æ®ç»“æ„"></a>æ•°æ®ç»“æ„</h2><p>stateSyncè°ƒåº¦ä¸‹è½½ç”±ç»™å®šstate rootæ‰€å®šä¹‰çš„ç‰¹å®šstate trieçš„è¯·æ±‚ã€‚</p><pre><code>// stateSync schedules requests for downloading a particular state trie defined// by a given state root.type stateSync struct {    d *Downloader // Downloader instance to access and manage current peerset    sched  *trie.TrieSync             // State trie sync scheduler defining the tasks    keccak hash.Hash                  // Keccak256 hasher to verify deliveries with    tasks  map[common.Hash]*stateTask // Set of tasks currently queued for retrieval    numUncommitted   int    bytesUncommitted int    deliver    chan *stateReq // Delivery channel multiplexing peer responses    cancel     chan struct{}  // Channel to signal a termination request    cancelOnce sync.Once      // Ensures cancel only ever gets called once    done       chan struct{}  // Channel to signal termination completion    err        error          // Any error hit during sync (set before completion)}</code></pre><p>æ„é€ å‡½æ•°</p><pre><code>func newStateSync(d *Downloader, root common.Hash) *stateSync {    return &amp;stateSync{        d:       d,        sched:   state.NewStateSync(root, d.stateDB),        keccak:  sha3.NewKeccak256(),        tasks:   make(map[common.Hash]*stateTask),        deliver: make(chan *stateReq),        cancel:  make(chan struct{}),        done:    make(chan struct{}),    }}</code></pre><p>NewStateSync</p><pre><code>// NewStateSync create a new state trie download scheduler.func NewStateSync(root common.Hash, database trie.DatabaseReader) *trie.TrieSync {    var syncer *trie.TrieSync    callback := func(leaf []byte, parent common.Hash) error {        var obj Account        if err := rlp.Decode(bytes.NewReader(leaf), &amp;obj); err != nil {            return err        }        syncer.AddSubTrie(obj.Root, 64, parent, nil)        syncer.AddRawEntry(common.BytesToHash(obj.CodeHash), 64, parent)        return nil    }    syncer = trie.NewTrieSync(root, database, callback)    return syncer}</code></pre><p>syncStateï¼Œ è¿™ä¸ªå‡½æ•°æ˜¯downloaderè°ƒç”¨çš„ã€‚</p><pre><code>// syncState starts downloading state with the given root hash.func (d *Downloader) syncState(root common.Hash) *stateSync {    s := newStateSync(d, root)    select {    case d.stateSyncStart &lt;- s:    case &lt;-d.quitCh:        s.err = errCancelStateFetch        close(s.done)    }    return s}</code></pre><h2 id="å¯åŠ¨"><a href="#å¯åŠ¨" class="headerlink" title="å¯åŠ¨"></a>å¯åŠ¨</h2><p>åœ¨downloaderä¸­å¯åŠ¨äº†ä¸€ä¸ªæ–°çš„goroutine æ¥è¿è¡ŒstateFetcherå‡½æ•°ã€‚ è¿™ä¸ªå‡½æ•°é¦–å…ˆè¯•å›¾å¾€stateSyncStarté€šé“æ¥ä»¥è·å–ä¿¡æ¯ã€‚  è€ŒsyncStateè¿™ä¸ªå‡½æ•°ä¼šç»™stateSyncStarté€šé“å‘é€æ•°æ®ã€‚</p><pre><code>// stateFetcher manages the active state sync and accepts requests// on its behalf.func (d *Downloader) stateFetcher() {    for {        select {        case s := &lt;-d.stateSyncStart:            for next := s; next != nil; { // è¿™ä¸ªforå¾ªç¯ä»£è¡¨äº†downloaderå¯ä»¥é€šè¿‡å‘é€ä¿¡å·æ¥éšæ—¶æ”¹å˜éœ€è¦åŒæ­¥çš„å¯¹è±¡ã€‚                next = d.runStateSync(next)            }        case &lt;-d.stateCh:            // Ignore state responses while no sync is running.        case &lt;-d.quitCh:            return        }    }}</code></pre><p>æˆ‘ä»¬ä¸‹é¢çœ‹çœ‹å“ªé‡Œä¼šè°ƒç”¨syncState()å‡½æ•°ã€‚processFastSyncContentè¿™ä¸ªå‡½æ•°ä¼šåœ¨æœ€å¼€å§‹å‘ç°peerçš„æ—¶å€™å¯åŠ¨ã€‚</p><pre><code>// processFastSyncContent takes fetch results from the queue and writes them to the// database. It also controls the synchronisation of state nodes of the pivot block.func (d *Downloader) processFastSyncContent(latest *types.Header) error {    // Start syncing state of the reported head block.    // This should get us most of the state of the pivot block.    stateSync := d.syncState(latest.Root)</code></pre><p>runStateSync,è¿™ä¸ªæ–¹æ³•ä»stateChè·å–å·²ç»ä¸‹è½½å¥½çš„çŠ¶æ€ï¼Œç„¶åæŠŠä»–æŠ•é€’åˆ°deliveré€šé“ä¸Šç­‰å¾…åˆ«äººå¤„ç†ã€‚</p><pre><code>// runStateSync runs a state synchronisation until it completes or another root// hash is requested to be switched over to.func (d *Downloader) runStateSync(s *stateSync) *stateSync {    var (        active   = make(map[string]*stateReq) // Currently in-flight requests        finished []*stateReq                  // Completed or failed requests        timeout  = make(chan *stateReq)       // Timed out active requests    )    defer func() {        // Cancel active request timers on exit. Also set peers to idle so they're        // available for the next sync.        for _, req := range active {            req.timer.Stop()            req.peer.SetNodeDataIdle(len(req.items))        }    }()    // Run the state sync.    // è¿è¡ŒçŠ¶æ€åŒæ­¥    go s.run()    defer s.Cancel()    // Listen for peer departure events to cancel assigned tasks    peerDrop := make(chan *peerConnection, 1024)    peerSub := s.d.peers.SubscribePeerDrops(peerDrop)    defer peerSub.Unsubscribe()    for {        // Enable sending of the first buffered element if there is one.        var (            deliverReq   *stateReq            deliverReqCh chan *stateReq        )        if len(finished) &gt; 0 {            deliverReq = finished[0]            deliverReqCh = s.deliver        }        select {        // The stateSync lifecycle:        // å¦å¤–ä¸€ä¸ªstateSyncç”³è¯·è¿è¡Œã€‚ æˆ‘ä»¬é€€å‡ºã€‚        case next := &lt;-d.stateSyncStart:            return next        case &lt;-s.done:            return nil        // Send the next finished request to the current sync:        // å‘é€å·²ç»ä¸‹è½½å¥½çš„æ•°æ®ç»™sync        case deliverReqCh &lt;- deliverReq:            finished = append(finished[:0], finished[1:]...)        // Handle incoming state packs:        // å¤„ç†è¿›å…¥çš„æ•°æ®åŒ…ã€‚ downloaderæ¥æ”¶åˆ°stateçš„æ•°æ®ä¼šå‘é€åˆ°è¿™ä¸ªé€šé“ä¸Šé¢ã€‚        case pack := &lt;-d.stateCh:            // Discard any data not requested (or previsouly timed out)            req := active[pack.PeerId()]            if req == nil {                log.Debug("Unrequested node data", "peer", pack.PeerId(), "len", pack.Items())                continue            }            // Finalize the request and queue up for processing            req.timer.Stop()            req.response = pack.(*statePack).states            finished = append(finished, req)            delete(active, pack.PeerId())            // Handle dropped peer connections:        case p := &lt;-peerDrop:            // Skip if no request is currently pending            req := active[p.id]            if req == nil {                continue            }            // Finalize the request and queue up for processing            req.timer.Stop()            req.dropped = true            finished = append(finished, req)            delete(active, p.id)        // Handle timed-out requests:        case req := &lt;-timeout:            // If the peer is already requesting something else, ignore the stale timeout.            // This can happen when the timeout and the delivery happens simultaneously,            // causing both pathways to trigger.            if active[req.peer.id] != req {                continue            }            // Move the timed out data back into the download queue            finished = append(finished, req)            delete(active, req.peer.id)        // Track outgoing state requests:        case req := &lt;-d.trackStateReq:            // If an active request already exists for this peer, we have a problem. In            // theory the trie node schedule must never assign two requests to the same            // peer. In practive however, a peer might receive a request, disconnect and            // immediately reconnect before the previous times out. In this case the first            // request is never honored, alas we must not silently overwrite it, as that            // causes valid requests to go missing and sync to get stuck.            if old := active[req.peer.id]; old != nil {                log.Warn("Busy peer assigned new state fetch", "peer", old.peer.id)                // Make sure the previous one doesn't get siletly lost                old.timer.Stop()                old.dropped = true                finished = append(finished, old)            }            // Start a timer to notify the sync loop if the peer stalled.            req.timer = time.AfterFunc(req.timeout, func() {                select {                case timeout &lt;- req:                case &lt;-s.done:                    // Prevent leaking of timer goroutines in the unlikely case where a                    // timer is fired just before exiting runStateSync.                }            })            active[req.peer.id] = req        }    }}</code></pre><p>runå’Œloopæ–¹æ³•ï¼Œè·å–ä»»åŠ¡ï¼Œåˆ†é…ä»»åŠ¡ï¼Œè·å–ç»“æœã€‚</p><pre><code>func (s *stateSync) run() {    s.err = s.loop()    close(s.done)}// loop is the main event loop of a state trie sync. It it responsible for the// assignment of new tasks to peers (including sending it to them) as well as// for the processing of inbound data. Note, that the loop does not directly// receive data from peers, rather those are buffered up in the downloader and// pushed here async. The reason is to decouple processing from data receipt// and timeouts.func (s *stateSync) loop() error {    // Listen for new peer events to assign tasks to them    newPeer := make(chan *peerConnection, 1024)    peerSub := s.d.peers.SubscribeNewPeers(newPeer)    defer peerSub.Unsubscribe()    // Keep assigning new tasks until the sync completes or aborts    // ä¸€ç›´ç­‰åˆ° syncå®Œæˆæˆ–è€…è¢«è¢«ç»ˆæ­¢    for s.sched.Pending() &gt; 0 {        // æŠŠæ•°æ®ä»ç¼“å­˜é‡Œé¢åˆ·æ–°åˆ°æŒä¹…åŒ–å­˜å‚¨é‡Œé¢ã€‚ è¿™ä¹Ÿå°±æ˜¯å‘½ä»¤è¡Œ --cacheæŒ‡å®šçš„å¤§å°ã€‚        if err := s.commit(false); err != nil {            return err        }        // æŒ‡æ´¾ä»»åŠ¡ï¼Œ        s.assignTasks()        // Tasks assigned, wait for something to happen        select {        case &lt;-newPeer:            // New peer arrived, try to assign it download tasks        case &lt;-s.cancel:            return errCancelStateFetch        case req := &lt;-s.deliver:            // æ¥æ”¶åˆ°runStateSyncæ–¹æ³•æŠ•é€’è¿‡æ¥çš„è¿”å›ä¿¡æ¯ï¼Œæ³¨æ„ è¿”å›ä¿¡æ¯é‡Œé¢åŒ…å«äº†æˆåŠŸè¯·æ±‚çš„ä¹ŸåŒ…å«äº†æœªæˆåŠŸè¯·æ±‚çš„ã€‚            // Response, disconnect or timeout triggered, drop the peer if stalling            log.Trace("Received node data response", "peer", req.peer.id, "count", len(req.response), "dropped", req.dropped, "timeout", !req.dropped &amp;&amp; req.timedOut())            if len(req.items) &lt;= 2 &amp;&amp; !req.dropped &amp;&amp; req.timedOut() {                // 2 items are the minimum requested, if even that times out, we've no use of                // this peer at the moment.                log.Warn("Stalling state sync, dropping peer", "peer", req.peer.id)                s.d.dropPeer(req.peer.id)            }            // Process all the received blobs and check for stale delivery            stale, err := s.process(req)            if err != nil {                log.Warn("Node data write error", "err", err)                return err            }            // The the delivery contains requested data, mark the node idle (otherwise it's a timed out delivery)            if !stale {                req.peer.SetNodeDataIdle(len(req.response))            }        }    }    return s.commit(true)}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-ethæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>ethçš„æºç åˆä¸‹é¢å‡ ä¸ªåŒ…</p><ul><li>downloader         ä¸»è¦ç”¨äºå’Œç½‘ç»œåŒæ­¥ï¼ŒåŒ…å«äº†ä¼ ç»ŸåŒæ­¥æ–¹å¼å’Œå¿«é€ŸåŒæ­¥æ–¹å¼</li><li>fetcher            ä¸»è¦ç”¨äºåŸºäºå—é€šçŸ¥çš„åŒæ­¥ï¼Œæ¥æ”¶åˆ°å½“æˆ‘ä»¬æ¥æ”¶åˆ°NewBlockHashesMsgæ¶ˆæ¯å¾—æ—¶å€™ï¼Œæˆ‘ä»¬åªæ”¶åˆ°äº†å¾ˆå¤šBlockçš„hashå€¼ã€‚ éœ€è¦é€šè¿‡hashå€¼æ¥åŒæ­¥åŒºå—ã€‚</li><li>filter            æä¾›åŸºäºRPCçš„è¿‡æ»¤åŠŸèƒ½ï¼ŒåŒ…æ‹¬å®æ—¶æ•°æ®çš„åŒæ­¥(PendingTx)ï¼Œå’Œå†å²çš„æ—¥å¿—æŸ¥è¯¢(Log filter)</li><li>gasprice            æä¾›gasçš„ä»·æ ¼å»ºè®®ï¼Œ æ ¹æ®è¿‡å»å‡ ä¸ªåŒºå—çš„gaspriceï¼Œæ¥å¾—åˆ°å½“å‰çš„gaspriceçš„å»ºè®®ä»·æ ¼</li></ul><p>eth åè®®éƒ¨åˆ†æºç åˆ†æ</p><ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" title="ä»¥å¤ªåŠçš„ç½‘ç»œåè®®å¤§æ¦‚æµç¨‹">ä»¥å¤ªåŠçš„ç½‘ç»œåè®®å¤§æ¦‚æµç¨‹</a></li></ul><p>fetcheréƒ¨åˆ†çš„æºç åˆ†æ</p><ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-fetcher%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="fetchéƒ¨åˆ†æºç åˆ†æ">fetchéƒ¨åˆ†æºç åˆ†æ</a></li></ul><p>downloader éƒ¨åˆ†æºç åˆ†æ</p><ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8Afast%20sync%E7%AE%97%E6%B3%95/" title="èŠ‚ç‚¹å¿«é€ŸåŒæ­¥ç®—æ³•">èŠ‚ç‚¹å¿«é€ŸåŒæ­¥ç®—æ³•</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-downloader-queue.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="ç”¨æ¥æä¾›ä¸‹è½½ä»»åŠ¡çš„è°ƒåº¦å’Œç»“æœç»„è£… queue.go">ç”¨æ¥æä¾›ä¸‹è½½ä»»åŠ¡çš„è°ƒåº¦å’Œç»“æœç»„è£… queue.go</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-downloader-peer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="ç”¨æ¥ä»£è¡¨å¯¹ç«¯ï¼Œæä¾›QoSç­‰åŠŸèƒ½ peer.go">ç”¨æ¥ä»£è¡¨å¯¹ç«¯ï¼Œæä¾›QoSç­‰åŠŸèƒ½ peer.go</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-downloader-statesync/" title="å¿«é€ŸåŒæ­¥ç®—æ³• ç”¨æ¥æä¾›Pivot pointçš„ state-rootçš„åŒæ­¥ statesync.go">å¿«é€ŸåŒæ­¥ç®—æ³• ç”¨æ¥æä¾›Pivot pointçš„ state-rootçš„åŒæ­¥ statesync.go</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-downloader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="åŒæ­¥çš„å¤§è‡´æµç¨‹çš„åˆ†æ">åŒæ­¥çš„å¤§è‡´æµç¨‹çš„åˆ†æ</a></li></ul><p>filter éƒ¨åˆ†æºç åˆ†æ</p><ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-bloombits%E5%92%8Cfilter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="æä¾›å¸ƒéš†è¿‡æ»¤å™¨çš„æŸ¥è¯¢å’ŒRPCè¿‡æ»¤åŠŸèƒ½">æä¾›å¸ƒéš†è¿‡æ»¤å™¨çš„æŸ¥è¯¢å’ŒRPCè¿‡æ»¤åŠŸèƒ½</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-eventæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-event%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-event%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>eventåŒ…å®ç°äº†åŒä¸€ä¸ªè¿›ç¨‹å†…éƒ¨çš„äº‹ä»¶å‘å¸ƒå’Œè®¢é˜…æ¨¡å¼ã€‚</p><h2 id="event-go"><a href="#event-go" class="headerlink" title="event.go"></a>event.go</h2><p>ç›®å‰è¿™éƒ¨åˆ†ä»£ç è¢«æ ‡è®°ä¸ºDeprecatedï¼Œå‘ŠçŸ¥ç”¨æˆ·ä½¿ç”¨Feedè¿™ä¸ªå¯¹è±¡ã€‚ ä¸è¿‡åœ¨ä»£ç ä¸­ä»»ç„¶æœ‰ä½¿ç”¨ã€‚ è€Œä¸”è¿™éƒ¨åˆ†çš„ä»£ç ä¹Ÿä¸å¤šã€‚ å°±ç®€å•ä»‹ç»ä¸€ä¸‹ã€‚</p><p>æ•°æ®ç»“æ„<br>TypeMuxæ˜¯ä¸»è¦çš„ä½¿ç”¨ã€‚ submè®°å½•äº†æ‰€æœ‰çš„è®¢é˜…è€…ã€‚ å¯ä»¥çœ‹åˆ°æ¯ä¸­ç±»å‹éƒ½å¯ä»¥æœ‰å¾ˆå¤šçš„è®¢é˜…è€…ã€‚</p><pre><code>// TypeMuxEvent is a time-tagged notification pushed to subscribers.type TypeMuxEvent struct {    Time time.Time    Data interface{}}// A TypeMux dispatches events to registered receivers. Receivers can be// registered to handle events of certain type. Any operation// called after mux is stopped will return ErrMuxClosed.//// The zero value is ready to use.//// Deprecated: use Feedtype TypeMux struct {    mutex   sync.RWMutex    subm    map[reflect.Type][]*TypeMuxSubscription    stopped bool}</code></pre><p>åˆ›å»ºä¸€ä¸ªè®¢é˜…,å¯ä»¥åŒæ—¶è®¢é˜…å¤šç§ç±»å‹ã€‚</p><pre><code>// Subscribe creates a subscription for events of the given types. The// subscription's channel is closed when it is unsubscribed// or the mux is closed.func (mux *TypeMux) Subscribe(types ...interface{}) *TypeMuxSubscription {    sub := newsub(mux)    mux.mutex.Lock()    defer mux.mutex.Unlock()    if mux.stopped {        // set the status to closed so that calling Unsubscribe after this        // call will short circuit.        sub.closed = true        close(sub.postC)    } else {        if mux.subm == nil {            mux.subm = make(map[reflect.Type][]*TypeMuxSubscription)        }        for _, t := range types {            rtyp := reflect.TypeOf(t)            oldsubs := mux.subm[rtyp]            if find(oldsubs, sub) != -1 {                panic(fmt.Sprintf("event: duplicate type %s in Subscribe", rtyp))            }            subs := make([]*TypeMuxSubscription, len(oldsubs)+1)            copy(subs, oldsubs)            subs[len(oldsubs)] = sub            mux.subm[rtyp] = subs        }    }    return sub}// TypeMuxSubscription is a subscription established through TypeMux.type TypeMuxSubscription struct {    mux     *TypeMux    created time.Time    closeMu sync.Mutex    closing chan struct{}    closed  bool    // these two are the same channel. they are stored separately so    // postC can be set to nil without affecting the return value of    // Chan.    postMu sync.RWMutex    // readC å’Œ postC å…¶å®æ˜¯åŒä¸€ä¸ªchannelã€‚ ä¸è¿‡ä¸€ä¸ªæ˜¯ä»channelè¯» ä¸€ä¸ªåªä»channelå†™    // å•æ–¹å‘çš„channel    readC  &lt;-chan *TypeMuxEvent    postC  chan&lt;- *TypeMuxEvent}func newsub(mux *TypeMux) *TypeMuxSubscription {    c := make(chan *TypeMuxEvent)    return &amp;TypeMuxSubscription{        mux:     mux,        created: time.Now(),        readC:   c,        postC:   c,        closing: make(chan struct{}),    }}</code></pre><p>å‘å¸ƒä¸€ä¸ªeventåˆ°TypeMuxä¸Šé¢ï¼Œè¿™ä¸ªæ—¶å€™æ‰€æœ‰è®¢é˜…äº†è¿™ä¸ªç±»å‹çš„éƒ½ä¼šæ”¶åˆ°è¿™ä¸ªæ¶ˆæ¯ã€‚</p><pre><code>// Post sends an event to all receivers registered for the given type.// It returns ErrMuxClosed if the mux has been stopped.func (mux *TypeMux) Post(ev interface{}) error {    event := &amp;TypeMuxEvent{        Time: time.Now(),        Data: ev,    }    rtyp := reflect.TypeOf(ev)    mux.mutex.RLock()    if mux.stopped {        mux.mutex.RUnlock()        return ErrMuxClosed    }    subs := mux.subm[rtyp]    mux.mutex.RUnlock()    for _, sub := range subs {        // é˜»å¡å¼çš„æŠ•é€’ã€‚         sub.deliver(event)    }    return nil}func (s *TypeMuxSubscription) deliver(event *TypeMuxEvent) {    // Short circuit delivery if stale event    if s.created.After(event.Time) {        return    }    // Otherwise deliver the event    s.postMu.RLock()    defer s.postMu.RUnlock()    select {    //é˜»å¡æ–¹å¼çš„æ–¹æ³•    case s.postC &lt;- event:    case &lt;-s.closing:    }}</code></pre><h2 id="feed-go"><a href="#feed-go" class="headerlink" title="feed.go"></a>feed.go</h2><p>ç›®å‰ä¸»è¦ä½¿ç”¨çš„å¯¹è±¡ã€‚å–ä»£äº†å‰é¢è¯´çš„event.goå†…éƒ¨çš„TypeMux</p><p>feedæ•°æ®ç»“æ„</p><pre><code>// Feed implements one-to-many subscriptions where the carrier of events is a channel.// Values sent to a Feed are delivered to all subscribed channels simultaneously.// Feed å®ç°äº† 1å¯¹å¤šçš„è®¢é˜…æ¨¡å¼ï¼Œä½¿ç”¨äº†channelæ¥ä¼ é€’äº‹ä»¶ã€‚ å‘é€ç»™Feedçš„å€¼ä¼šåŒæ—¶è¢«ä¼ é€’ç»™æ‰€æœ‰è®¢é˜…çš„channelã€‚// Feeds can only be used with a single type. The type is determined by the first Send or// Subscribe operation. Subsequent calls to these methods panic if the type does not// match.// Feedåªèƒ½è¢«å•ä¸ªç±»å‹ä½¿ç”¨ã€‚è¿™ä¸ªå’Œä¹‹å‰çš„eventä¸åŒï¼Œeventå¯ä»¥ä½¿ç”¨å¤šä¸ªç±»å‹ã€‚ ç±»å‹è¢«ç¬¬ä¸€ä¸ªSendè°ƒç”¨æˆ–è€…æ˜¯Subscribeè°ƒç”¨å†³å®šã€‚ åç»­çš„è°ƒç”¨å¦‚æœç±»å‹å’Œå…¶ä¸ä¸€è‡´ä¼španic// The zero value is ready to use.type Feed struct {    once      sync.Once        // ensures that init only runs once    sendLock  chan struct{}    // sendLock has a one-element buffer and is empty when held.It protects sendCases.    removeSub chan interface{} // interrupts Send    sendCases caseList         // the active set of select cases used by Send    // The inbox holds newly subscribed channels until they are added to sendCases.    mu     sync.Mutex    inbox  caseList    etype  reflect.Type    closed bool}</code></pre><p>åˆå§‹åŒ– åˆå§‹åŒ–ä¼šè¢«onceæ¥ä¿æŠ¤ä¿è¯åªä¼šè¢«æ‰§è¡Œä¸€æ¬¡ã€‚</p><pre><code>func (f *Feed) init() {    f.removeSub = make(chan interface{})    f.sendLock = make(chan struct{}, 1)    f.sendLock &lt;- struct{}{}    f.sendCases = caseList{{Chan: reflect.ValueOf(f.removeSub), Dir: reflect.SelectRecv}}}</code></pre><p>è®¢é˜…ï¼Œè®¢é˜…æŠ•é€’äº†ä¸€ä¸ªchannelã€‚ ç›¸å¯¹ä¸eventçš„ä¸åŒã€‚eventçš„è®¢é˜…æ˜¯ä¼ å…¥äº†éœ€è¦è®¢é˜…çš„ç±»å‹ï¼Œç„¶åchannelæ˜¯åœ¨eventçš„è®¢é˜…ä»£ç é‡Œé¢æ„å»ºç„¶åè¿”å›çš„ã€‚ è¿™ç§ç›´æ¥æŠ•é€’channelçš„æ¨¡å¼å¯èƒ½ä¼šæ›´åŠ çµæ´»ã€‚<br>ç„¶åæ ¹æ®ä¼ å…¥çš„channelç”Ÿæˆäº†SelectCaseã€‚æ”¾å…¥inboxã€‚ </p><pre><code>// Subscribe adds a channel to the feed. Future sends will be delivered on the channel// until the subscription is canceled. All channels added must have the same element type.//// The channel should have ample buffer space to avoid blocking other subscribers.// Slow subscribers are not dropped.func (f *Feed) Subscribe(channel interface{}) Subscription {    f.once.Do(f.init)    chanval := reflect.ValueOf(channel)    chantyp := chanval.Type()    if chantyp.Kind() != reflect.Chan || chantyp.ChanDir()&amp;reflect.SendDir == 0 { // å¦‚æœç±»å‹ä¸æ˜¯channelã€‚ æˆ–è€…æ˜¯channelçš„æ–¹å‘ä¸èƒ½å‘é€æ•°æ®ã€‚é‚£ä¹ˆé”™è¯¯é€€å‡ºã€‚        panic(errBadChannel)    }    sub := &amp;feedSub{feed: f, channel: chanval, err: make(chan error, 1)}    f.mu.Lock()    defer f.mu.Unlock()    if !f.typecheck(chantyp.Elem()) {        panic(feedTypeError{op: "Subscribe", got: chantyp, want: reflect.ChanOf(reflect.SendDir, f.etype)})    }    // Add the select case to the inbox.    // The next Send will add it to f.sendCases.    cas := reflect.SelectCase{Dir: reflect.SelectSend, Chan: chanval}    f.inbox = append(f.inbox, cas)    return sub}</code></pre><p>Sendæ–¹æ³•,feedçš„Sendæ–¹æ³•ä¸æ˜¯éå†æ‰€æœ‰çš„channelç„¶åé˜»å¡æ–¹å¼çš„å‘é€ã€‚è¿™æ ·å¯èƒ½å¯¼è‡´æ…¢çš„å®¢æˆ·ç«¯å½±å“å¿«çš„å®¢æˆ·ç«¯ã€‚ è€Œæ˜¯ä½¿ç”¨åå°„çš„æ–¹å¼ä½¿ç”¨SelectCaseã€‚ é¦–å…ˆè°ƒç”¨éé˜»å¡æ–¹å¼çš„TrySendæ¥å°è¯•å‘é€ã€‚è¿™æ ·å¦‚æœæ²¡æœ‰æ…¢çš„å®¢æˆ·ç«¯ã€‚æ•°æ®ä¼šç›´æ¥å…¨éƒ¨å‘é€å®Œæˆã€‚ å¦‚æœTrySendéƒ¨åˆ†å®¢æˆ·ç«¯å¤±è´¥ã€‚ é‚£ä¹ˆåç»­åœ¨å¾ªç¯Selectçš„æ–¹å¼å‘é€ã€‚ æˆ‘çŒœæµ‹è¿™ä¹Ÿæ˜¯feedä¼šå–ä»£eventçš„åŸå› ã€‚</p><pre><code>// Send delivers to all subscribed channels simultaneously.// It returns the number of subscribers that the value was sent to.func (f *Feed) Send(value interface{}) (nsent int) {    f.once.Do(f.init)    &lt;-f.sendLock    // Add new cases from the inbox after taking the send lock.    f.mu.Lock()    f.sendCases = append(f.sendCases, f.inbox...)    f.inbox = nil    f.mu.Unlock()    // Set the sent value on all channels.    rvalue := reflect.ValueOf(value)    if !f.typecheck(rvalue.Type()) {        f.sendLock &lt;- struct{}{}        panic(feedTypeError{op: "Send", got: rvalue.Type(), want: f.etype})    }    for i := firstSubSendCase; i &lt; len(f.sendCases); i++ {        f.sendCases[i].Send = rvalue    }    // Send until all channels except removeSub have been chosen.    cases := f.sendCases    for {        // Fast path: try sending without blocking before adding to the select set.        // This should usually succeed if subscribers are fast enough and have free        // buffer space.        for i := firstSubSendCase; i &lt; len(cases); i++ {            if cases[i].Chan.TrySend(rvalue) {                nsent++                cases = cases.deactivate(i)                i--            }        }        if len(cases) == firstSubSendCase {            break        }        // Select on all the receivers, waiting for them to unblock.        chosen, recv, _ := reflect.Select(cases)        if chosen == 0 /* &lt;-f.removeSub */ {            index := f.sendCases.find(recv.Interface())            f.sendCases = f.sendCases.delete(index)            if index &gt;= 0 &amp;&amp; index &lt; len(cases) {                cases = f.sendCases[:len(cases)-1]            }        } else {            cases = cases.deactivate(chosen)            nsent++        }    }    // Forget about the sent value and hand off the send lock.    for i := firstSubSendCase; i &lt; len(f.sendCases); i++ {        f.sendCases[i].Send = reflect.Value{}    }    f.sendLock &lt;- struct{}{}    return nsent}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-go-ethereumæºç é˜…è¯»ç¯å¢ƒæ­å»º</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-go-ethereum%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-go-ethereum%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="go-ethereumæºç è§£æ"><a href="#go-ethereumæºç è§£æ" class="headerlink" title="go-ethereumæºç è§£æ"></a>go-ethereumæºç è§£æ</h2><p>å› ä¸ºgo ethereumæ˜¯æœ€è¢«å¹¿æ³›ä½¿ç”¨çš„ä»¥å¤ªåŠå®¢æˆ·ç«¯ï¼Œ æ‰€ä»¥åç»­çš„æºç åˆ†æéƒ½ä»githubä¸Šé¢çš„è¿™ä»½ä»£ç è¿›è¡Œåˆ†æã€‚ </p><h3 id="æ­å»ºgo-ethereumè°ƒè¯•ç¯å¢ƒ"><a href="#æ­å»ºgo-ethereumè°ƒè¯•ç¯å¢ƒ" class="headerlink" title="æ­å»ºgo ethereumè°ƒè¯•ç¯å¢ƒ"></a>æ­å»ºgo ethereumè°ƒè¯•ç¯å¢ƒ</h3><h4 id="windows-10-64bit"><a href="#windows-10-64bit" class="headerlink" title="windows 10 64bit"></a>windows 10 64bit</h4><p>é¦–å…ˆä¸‹è½½goå®‰è£…åŒ…è¿›è¡Œå®‰è£…ï¼Œå› ä¸ºGOçš„ç½‘ç«™è¢«å¢™ï¼Œæ‰€ä»¥ä»ä¸‹é¢åœ°å€ä¸‹è½½ã€‚</p><pre><code>https://studygolang.com/dl/golang/go1.9.1.windows-amd64.msi</code></pre><p>å®‰è£…å¥½ä¹‹åï¼Œè®¾ç½®ç¯å¢ƒå˜é‡ï¼ŒæŠŠC:\Go\binç›®å½•æ·»åŠ åˆ°ä½ çš„PATHç¯å¢ƒå˜é‡ï¼Œ ç„¶åå¢åŠ ä¸€ä¸ªGOPATHçš„ç¯å¢ƒå˜é‡ï¼ŒGOPATHçš„å€¼è®¾ç½®ä¸ºä½ çš„GOè¯­è¨€ä¸‹è½½çš„ä»£ç è·¯å¾„(æˆ‘è®¾ç½®çš„æ˜¯C:\GOPATH)</p><p><img src="https://raw.githubusercontent.com/wugang33/go-ethereum-code-analysis/master/picture/go_env_1.png" alt="image"></p><p>å®‰è£…gitå·¥å…·ï¼Œè¯·å‚è€ƒç½‘ç»œä¸Šçš„æ•™ç¨‹å®‰è£…gitå·¥å…·ï¼Œ goè¯­è¨€ä»githubè‡ªåŠ¨ä¸‹è½½ä»£ç éœ€è¦gitå·¥å…·çš„æ”¯æŒ</p><p>æ‰“å¼€å‘½ä»¤è¡Œå·¥å…·ä¸‹è½½ go-ethereumçš„ä»£ç </p><pre><code>go get github.com/ethereum/go-ethereum</code></pre><p>å‘½ä»¤æ‰§è¡ŒæˆåŠŸä¹‹åï¼Œä»£ç å°±ä¼šä¸‹è½½åˆ°ä¸‹é¢è¿™ä¸ªç›®å½•ï¼Œ%GOPATH%\src\github.com\ethereum\go-ethereum<br>å¦‚æœæ‰§è¡Œè¿‡ç¨‹ä¸­å‡ºç°</p><pre><code># github.com/ethereum/go-ethereum/crypto/secp256k1exec: "gcc": executable file not found in %PATH%</code></pre><p>åˆ™éœ€è¦å®‰è£…gccå·¥å…·ï¼Œæˆ‘ä»¬ä»ä¸‹é¢åœ°å€ä¸‹è½½å¹¶å®‰è£…</p><pre><code>http://tdm-gcc.tdragon.net/download</code></pre><p>æ¥ä¸‹æ¥å®‰è£…IDEå·¥å…·ã€‚ æˆ‘æ˜¯ç”¨çš„IDEæ˜¯JetBrainsçš„Goglandã€‚ å¯ä»¥åœ¨ä¸‹é¢åœ°å€ä¸‹è½½</p><pre><code>https://download.jetbrains.com/go/gogland-173.2696.28.exe</code></pre><p>å®‰è£…å®Œæˆåæ‰“å¼€IDE. é€‰æ‹©File -&gt; Open -&gt; é€‰æ‹©GOPATH\src\github.com\ethereum\go-ethereumç›®å½•æ‰“å¼€ã€‚</p><p>ç„¶åæ‰“å¼€go-ethereum/rlp/decode_test.go. åœ¨ç¼–è¾‘æ¡†å³é”®é€‰æ‹©è¿è¡Œï¼Œ å¦‚æœè¿è¡ŒæˆåŠŸï¼Œä»£è¡¨ç¯å¢ƒæ­å»ºå®Œæˆã€‚</p><p><img src="https://raw.githubusercontent.com/wugang33/go-ethereum-code-analysis/master/picture/go_env_2.png" alt="image"></p><h3 id="Ubuntu-16-04-64bit"><a href="#Ubuntu-16-04-64bit" class="headerlink" title="Ubuntu 16.04 64bit"></a>Ubuntu 16.04 64bit</h3><p>goå®‰è£…åŒ…è¿›è¡Œå®‰è£…</p><pre><code>apt install golang-go git -y</code></pre><p>golangç¯å¢ƒé…ç½®ï¼š</p><pre><code>ç¼–è¾‘/etc/profileæ–‡ä»¶ï¼Œåœ¨è¯¥æ–‡ä»¶ä¸­åŠ å…¥ä»¥ä¸‹å†…å®¹ï¼šexport GOROOT=/usr/bin/go  export GOPATH=/root/home/goprojectexport GOBIN=/root/home/goproject/binexport GOLIB=/root/home/goproject/export PATH=$PATH:$GOBIN:$GOPATH/bin:$GOROOT/bin</code></pre><p>æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼Œä½¿å¾—ç¯å¢ƒå˜é‡ç”Ÿæ•ˆï¼š<br></p><pre><code># source /etc/profile</code></pre><p>ä¸‹è½½æºç ï¼š</p><pre><code>#cd  /root/home/goproject; mkdir srcï¼› cd src  #è¿›å…¥goé¡¹ç›®ç›®å½•ï¼Œå¹¶åˆ›å»ºsrcç›®å½•, å¹¶è¿›å…¥srcç›®å½•#git clone https://github.com/ethereum/go-ethereum</code></pre><p>ä½¿ç”¨vimæˆ–å…¶ä»–IDEæ‰“å¼€å³å¯ï¼›</p><h3 id="go-ethereum-ç›®å½•å¤§æ¦‚ä»‹ç»"><a href="#go-ethereum-ç›®å½•å¤§æ¦‚ä»‹ç»" class="headerlink" title="go ethereum ç›®å½•å¤§æ¦‚ä»‹ç»"></a>go ethereum ç›®å½•å¤§æ¦‚ä»‹ç»</h3><p>go-ethereumé¡¹ç›®çš„ç»„ç»‡ç»“æ„åŸºæœ¬ä¸Šæ˜¯æŒ‰ç…§åŠŸèƒ½æ¨¡å—åˆ’åˆ†çš„ç›®å½•ï¼Œä¸‹é¢ç®€å•ä»‹ç»ä¸€ä¸‹å„ä¸ªç›®å½•çš„ç»“æ„ï¼Œæ¯ä¸ªç›®å½•åœ¨GOè¯­è¨€é‡Œé¢åˆè¢«æˆä¸ºä¸€ä¸ªPackage,æˆ‘ç†è§£è·ŸJavaé‡Œé¢çš„Packageåº”è¯¥æ˜¯å·®ä¸å¤šçš„æ„æ€ã€‚</p><pre><code>accounts            å®ç°äº†ä¸€ä¸ªé«˜ç­‰çº§çš„ä»¥å¤ªåŠè´¦æˆ·ç®¡ç†bmt            äºŒè¿›åˆ¶çš„é»˜å…‹å°”æ ‘çš„å®ç°build            ä¸»è¦æ˜¯ç¼–è¯‘å’Œæ„å»ºçš„ä¸€äº›è„šæœ¬å’Œé…ç½®cmd            å‘½ä»¤è¡Œå·¥å…·ï¼Œåˆåˆ†äº†å¾ˆå¤šçš„å‘½ä»¤è¡Œå·¥å…·ï¼Œä¸‹é¢ä¸€ä¸ªä¸€ä¸ªä»‹ç»    /abigen        Source code generator to convert Ethereum contract definitions into easy to use, compile-time type-safe Go packages    /bootnode    å¯åŠ¨ä¸€ä¸ªä»…ä»…å®ç°ç½‘ç»œå‘ç°çš„èŠ‚ç‚¹    /evm        ä»¥å¤ªåŠè™šæ‹Ÿæœºçš„å¼€å‘å·¥å…·ï¼Œ ç”¨æ¥æä¾›ä¸€ä¸ªå¯é…ç½®çš„ï¼Œå—éš”ç¦»çš„ä»£ç è°ƒè¯•ç¯å¢ƒ    /faucet            /geth        ä»¥å¤ªåŠå‘½ä»¤è¡Œå®¢æˆ·ç«¯ï¼Œæœ€é‡è¦çš„ä¸€ä¸ªå·¥å…·    /p2psim        æä¾›äº†ä¸€ä¸ªå·¥å…·æ¥æ¨¡æ‹Ÿhttpçš„API    /puppeth    åˆ›å»ºä¸€ä¸ªæ–°çš„ä»¥å¤ªåŠç½‘ç»œçš„å‘å¯¼    /rlpdump     æä¾›äº†ä¸€ä¸ªRLPæ•°æ®çš„æ ¼å¼åŒ–è¾“å‡º    /swarm        swarmç½‘ç»œçš„æ¥å…¥ç‚¹    /util        æä¾›äº†ä¸€äº›å…¬å…±çš„å·¥å…·    /wnode        è¿™æ˜¯ä¸€ä¸ªç®€å•çš„WhisperèŠ‚ç‚¹ã€‚ å®ƒå¯ä»¥ç”¨ä½œç‹¬ç«‹çš„å¼•å¯¼èŠ‚ç‚¹ã€‚æ­¤å¤–ï¼Œå¯ä»¥ç”¨äºä¸åŒçš„æµ‹è¯•å’Œè¯Šæ–­ç›®çš„ã€‚common            æä¾›äº†ä¸€äº›å…¬å…±çš„å·¥å…·ç±»compression        Package rle implements the run-length encoding used for Ethereum data.consensus        æä¾›äº†ä»¥å¤ªåŠçš„ä¸€äº›å…±è¯†ç®—æ³•ï¼Œæ¯”å¦‚ethhash, clique(proof-of-authority)console            consoleç±»contracts    core            ä»¥å¤ªåŠçš„æ ¸å¿ƒæ•°æ®ç»“æ„å’Œç®—æ³•(è™šæ‹Ÿæœºï¼ŒçŠ¶æ€ï¼ŒåŒºå—é“¾ï¼Œå¸ƒéš†è¿‡æ»¤å™¨)crypto            åŠ å¯†å’Œhashç®—æ³•ï¼Œeth            å®ç°äº†ä»¥å¤ªåŠçš„åè®®ethclient        æä¾›äº†ä»¥å¤ªåŠçš„RPCå®¢æˆ·ç«¯ethdb            ethçš„æ•°æ®åº“(åŒ…æ‹¬å®é™…ä½¿ç”¨çš„leveldbå’Œä¾›æµ‹è¯•ä½¿ç”¨çš„å†…å­˜æ•°æ®åº“)ethstats        æä¾›ç½‘ç»œçŠ¶æ€çš„æŠ¥å‘Ševent            å¤„ç†å®æ—¶çš„äº‹ä»¶les            å®ç°äº†ä»¥å¤ªåŠçš„è½»é‡çº§åè®®å­é›†light            å®ç°ä¸ºä»¥å¤ªåŠè½»é‡çº§å®¢æˆ·ç«¯æä¾›æŒ‰éœ€æ£€ç´¢çš„åŠŸèƒ½log            æä¾›å¯¹äººæœºéƒ½å‹å¥½çš„æ—¥å¿—ä¿¡æ¯metrics            æä¾›ç£ç›˜è®¡æ•°å™¨miner            æä¾›ä»¥å¤ªåŠçš„åŒºå—åˆ›å»ºå’ŒæŒ–çŸ¿mobile            ç§»åŠ¨ç«¯ä½¿ç”¨çš„ä¸€äº›warppernode            ä»¥å¤ªåŠçš„å¤šç§ç±»å‹çš„èŠ‚ç‚¹p2p            ä»¥å¤ªåŠp2pç½‘ç»œåè®®rlp            ä»¥å¤ªåŠåºåˆ—åŒ–å¤„ç†rpc            è¿œç¨‹æ–¹æ³•è°ƒç”¨swarm            swarmç½‘ç»œå¤„ç†tests            æµ‹è¯•trie            ä»¥å¤ªåŠé‡è¦çš„æ•°æ®ç»“æ„Package trie implements Merkle Patricia Tries.whisper            æä¾›äº†whisperèŠ‚ç‚¹çš„åè®®ã€‚</code></pre><p>å¯ä»¥çœ‹åˆ°ä»¥å¤ªåŠçš„ä»£ç é‡è¿˜æ˜¯æŒºå¤§çš„ï¼Œä½†æ˜¯ç²—ç•¥çœ‹ï¼Œä»£ç ç»“æ„è¿˜æ˜¯æŒºå¥½çš„ã€‚æˆ‘å¸Œæœ›å…ˆä»ä¸€äº›æ¯”è¾ƒç‹¬ç«‹çš„æ¨¡å—æ¥è¿›è¡Œåˆ†æã€‚ç„¶ååœ¨æ·±å…¥åˆ†æå†…éƒ¨çš„ä»£ç ã€‚é‡ç‚¹å¯èƒ½é›†ä¸­åœ¨é»„çš®ä¹¦é‡Œé¢æ²¡æœ‰æ¶‰åŠåˆ°çš„p2pç½‘ç»œç­‰æ¨¡å—ã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-nodeæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-node%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-node%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>nodeåœ¨go ethereumä¸­ä»£è¡¨äº†ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¯èƒ½æ˜¯å…¨èŠ‚ç‚¹ï¼Œå¯èƒ½æ˜¯è½»é‡çº§èŠ‚ç‚¹ã€‚ nodeå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªè¿›ç¨‹ï¼Œä»¥å¤ªåŠç”±è¿è¡Œåœ¨ä¸–ç•Œå„åœ°çš„å¾ˆå¤šä¸­ç±»å‹çš„nodeç»„æˆã€‚</p><p>ä¸€ä¸ªå…¸å‹çš„nodeå°±æ˜¯ä¸€ä¸ªp2pçš„èŠ‚ç‚¹ã€‚ è¿è¡Œäº†p2pç½‘ç»œåè®®ï¼ŒåŒæ—¶æ ¹æ®èŠ‚ç‚¹ç±»å‹ä¸åŒï¼Œè¿è¡Œäº†ä¸åŒçš„ä¸šåŠ¡å±‚åè®®(ä»¥åŒºåˆ«ç½‘ç»œå±‚åè®®ã€‚ å‚è€ƒp2p peerä¸­çš„Protocolæ¥å£)ã€‚</p><p>nodeçš„ç»“æ„ã€‚</p><pre><code>// Node is a container on which services can be registered.type Node struct {    eventmux *event.TypeMux // Event multiplexer used between the services of a stack    config   *Config    accman   *accounts.Manager    ephemeralKeystore string         // if non-empty, the key directory that will be removed by Stop    instanceDirLock   flock.Releaser // prevents concurrent use of instance directory    serverConfig p2p.Config    server       *p2p.Server // Currently running P2P networking layer    serviceFuncs []ServiceConstructor     // Service constructors (in dependency order)    services     map[reflect.Type]Service // Currently running services    rpcAPIs       []rpc.API   // List of APIs currently provided by the node    inprocHandler *rpc.Server // In-process RPC request handler to process the API requests    ipcEndpoint string       // IPC endpoint to listen at (empty = IPC disabled)    ipcListener net.Listener // IPC RPC listener socket to serve API requests    ipcHandler  *rpc.Server  // IPC RPC request handler to process the API requests    httpEndpoint  string       // HTTP endpoint (interface + port) to listen at (empty = HTTP disabled)    httpWhitelist []string     // HTTP RPC modules to allow through this endpoint    httpListener  net.Listener // HTTP RPC listener socket to server API requests    httpHandler   *rpc.Server  // HTTP RPC request handler to process the API requests    wsEndpoint string       // Websocket endpoint (interface + port) to listen at (empty = websocket disabled)    wsListener net.Listener // Websocket RPC listener socket to server API requests    wsHandler  *rpc.Server  // Websocket RPC request handler to process the API requests    stop chan struct{} // Channel to wait for termination notifications    lock sync.RWMutex}</code></pre><p>èŠ‚ç‚¹çš„åˆå§‹åŒ–, èŠ‚ç‚¹çš„åˆå§‹åŒ–å¹¶ä¸ä¾èµ–å…¶ä»–çš„å¤–éƒ¨ç»„ä»¶ï¼Œ åªä¾èµ–ä¸€ä¸ªConfigå¯¹è±¡ã€‚</p><pre><code>// New creates a new P2P node, ready for protocol registration.func New(conf *Config) (*Node, error) {    // Copy config and resolve the datadir so future changes to the current    // working directory don't affect the node.    confCopy := *conf    conf = &amp;confCopy    if conf.DataDir != "" {  //è½¬åŒ–ä¸ºç»å¯¹è·¯å¾„ã€‚        absdatadir, err := filepath.Abs(conf.DataDir)        if err != nil {            return nil, err        }        conf.DataDir = absdatadir    }    // Ensure that the instance name doesn't cause weird conflicts with    // other files in the data directory.    if strings.ContainsAny(conf.Name, `/\`) {        return nil, errors.New(`Config.Name must not contain '/' or '\'`)    }    if conf.Name == datadirDefaultKeyStore {        return nil, errors.New(`Config.Name cannot be "` + datadirDefaultKeyStore + `"`)    }    if strings.HasSuffix(conf.Name, ".ipc") {        return nil, errors.New(`Config.Name cannot end in ".ipc"`)    }    // Ensure that the AccountManager method works before the node has started.    // We rely on this in cmd/geth.    am, ephemeralKeystore, err := makeAccountManager(conf)    if err != nil {        return nil, err    }    // Note: any interaction with Config that would create/touch files    // in the data directory or instance directory is delayed until Start.    return &amp;Node{        accman:            am,        ephemeralKeystore: ephemeralKeystore,        config:            conf,        serviceFuncs:      []ServiceConstructor{},        ipcEndpoint:       conf.IPCEndpoint(),        httpEndpoint:      conf.HTTPEndpoint(),        wsEndpoint:        conf.WSEndpoint(),        eventmux:          new(event.TypeMux),    }, nil}</code></pre><h3 id="node-æœåŠ¡å’Œåè®®çš„æ³¨å†Œ"><a href="#node-æœåŠ¡å’Œåè®®çš„æ³¨å†Œ" class="headerlink" title="node æœåŠ¡å’Œåè®®çš„æ³¨å†Œ"></a>node æœåŠ¡å’Œåè®®çš„æ³¨å†Œ</h3><p>å› ä¸ºnodeå¹¶æ²¡æœ‰è´Ÿè´£å…·ä½“çš„ä¸šåŠ¡é€»è¾‘ã€‚æ‰€ä»¥å…·ä½“çš„ä¸šåŠ¡é€»è¾‘æ˜¯é€šè¿‡æ³¨å†Œçš„æ–¹å¼æ¥æ³¨å†Œåˆ°nodeé‡Œé¢æ¥çš„ã€‚<br>å…¶ä»–æ¨¡å—é€šè¿‡Registeræ–¹æ³•æ¥æ³¨å†Œäº†ä¸€ä¸ª æœåŠ¡æ„é€ å‡½æ•°ã€‚ ä½¿ç”¨è¿™ä¸ªæœåŠ¡æ„é€ å‡½æ•°å¯ä»¥ç”ŸæˆæœåŠ¡ã€‚</p><pre><code>// Register injects a new service into the node's stack. The service created by// the passed constructor must be unique in its type with regard to sibling ones.func (n *Node) Register(constructor ServiceConstructor) error {    n.lock.Lock()    defer n.lock.Unlock()    if n.server != nil {        return ErrNodeRunning    }    n.serviceFuncs = append(n.serviceFuncs, constructor)    return nil}</code></pre><p>æœåŠ¡æ˜¯ä»€ä¹ˆ</p><pre><code>type ServiceConstructor func(ctx *ServiceContext) (Service, error)// Service is an individual protocol that can be registered into a node.//// Notes://// â€¢ Service life-cycle management is delegated to the node. The service is allowed to// initialize itself upon creation, but no goroutines should be spun up outside of the// Start method.//// â€¢ Restart logic is not required as the node will create a fresh instance// every time a service is started.// æœåŠ¡çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†å·²ç»ä»£ç†ç»™nodeç®¡ç†ã€‚è¯¥æœåŠ¡å…è®¸åœ¨åˆ›å»ºæ—¶è‡ªåŠ¨åˆå§‹åŒ–ï¼Œä½†æ˜¯åœ¨Startæ–¹æ³•ä¹‹å¤–ä¸åº”è¯¥å¯åŠ¨goroutinesã€‚// é‡æ–°å¯åŠ¨é€»è¾‘ä¸æ˜¯å¿…éœ€çš„ï¼Œå› ä¸ºèŠ‚ç‚¹å°†åœ¨æ¯æ¬¡å¯åŠ¨æœåŠ¡æ—¶åˆ›å»ºä¸€ä¸ªæ–°çš„å®ä¾‹ã€‚type Service interface {    // Protocols retrieves the P2P protocols the service wishes to start.    // æœåŠ¡å¸Œæœ›æä¾›çš„p2påè®®    Protocols() []p2p.Protocol        // APIs retrieves the list of RPC descriptors the service provides    // æœåŠ¡å¸Œæœ›æä¾›çš„RPCæ–¹æ³•çš„æè¿°    APIs() []rpc.API    // Start is called after all services have been constructed and the networking    // layer was also initialized to spawn any goroutines required by the service.    // æ‰€æœ‰æœåŠ¡å·²ç»æ„å»ºå®Œæˆåï¼Œè°ƒç”¨å¼€å§‹ï¼Œå¹¶ä¸”ç½‘ç»œå±‚ä¹Ÿè¢«åˆå§‹åŒ–ä»¥äº§ç”ŸæœåŠ¡æ‰€éœ€çš„ä»»ä½•goroutineã€‚    Start(server *p2p.Server) error    // Stop terminates all goroutines belonging to the service, blocking until they    // are all terminated.        // Stopæ–¹æ³•ä¼šåœæ­¢è¿™ä¸ªæœåŠ¡æ‹¥æœ‰çš„æ‰€æœ‰goroutineã€‚ éœ€è¦é˜»å¡åˆ°æ‰€æœ‰çš„goroutineéƒ½å·²ç»ç»ˆæ­¢    Stop() error}</code></pre><h3 id="nodeçš„å¯åŠ¨"><a href="#nodeçš„å¯åŠ¨" class="headerlink" title="nodeçš„å¯åŠ¨"></a>nodeçš„å¯åŠ¨</h3><p>nodeçš„å¯åŠ¨è¿‡ç¨‹ä¼šåˆ›å»ºå’Œè¿è¡Œä¸€ä¸ªp2pçš„èŠ‚ç‚¹ã€‚</p><pre><code>// Start create a live P2P node and starts running it.func (n *Node) Start() error {    n.lock.Lock()    defer n.lock.Unlock()    // Short circuit if the node's already running    if n.server != nil {        return ErrNodeRunning    }    if err := n.openDataDir(); err != nil {        return err    }    // Initialize the p2p server. This creates the node key and    // discovery databases.    n.serverConfig = n.config.P2P    n.serverConfig.PrivateKey = n.config.NodeKey()    n.serverConfig.Name = n.config.NodeName()    if n.serverConfig.StaticNodes == nil {        // å¤„ç†é…ç½®æ–‡ä»¶static-nodes.json        n.serverConfig.StaticNodes = n.config.StaticNodes()    }    if n.serverConfig.TrustedNodes == nil {        // å¤„ç†é…ç½®æ–‡ä»¶trusted-nodes.json        n.serverConfig.TrustedNodes = n.config.TrustedNodes()    }    if n.serverConfig.NodeDatabase == "" {        n.serverConfig.NodeDatabase = n.config.NodeDB()    }    //åˆ›å»ºäº†p2pæœåŠ¡å™¨    running := &amp;p2p.Server{Config: n.serverConfig}    log.Info("Starting peer-to-peer node", "instance", n.serverConfig.Name)    // Otherwise copy and specialize the P2P configuration    services := make(map[reflect.Type]Service)    for _, constructor := range n.serviceFuncs {        // Create a new context for the particular service        ctx := &amp;ServiceContext{            config:         n.config,            services:       make(map[reflect.Type]Service),            EventMux:       n.eventmux,            AccountManager: n.accman,        }        for kind, s := range services { // copy needed for threaded access            ctx.services[kind] = s        }        // Construct and save the service        // åˆ›å»ºæ‰€æœ‰æ³¨å†Œçš„æœåŠ¡ã€‚        service, err := constructor(ctx)        if err != nil {            return err        }        kind := reflect.TypeOf(service)        if _, exists := services[kind]; exists {            return &amp;DuplicateServiceError{Kind: kind}        }        services[kind] = service    }    // Gather the protocols and start the freshly assembled P2P server    // æ”¶é›†æ‰€æœ‰çš„p2pçš„protocolså¹¶æ’å…¥p2p.Rrotocols    for _, service := range services {        running.Protocols = append(running.Protocols, service.Protocols()...)    }    // å¯åŠ¨äº†p2pæœåŠ¡å™¨    if err := running.Start(); err != nil {        return convertFileLockError(err)    }    // Start each of the services    // å¯åŠ¨æ¯ä¸€ä¸ªæœåŠ¡    started := []reflect.Type{}    for kind, service := range services {        // Start the next service, stopping all previous upon failure        if err := service.Start(running); err != nil {            for _, kind := range started {                services[kind].Stop()            }            running.Stop()            return err        }        // Mark the service started for potential cleanup        started = append(started, kind)    }    // Lastly start the configured RPC interfaces    // æœ€åå¯åŠ¨RPCæœåŠ¡    if err := n.startRPC(services); err != nil {        for _, service := range services {            service.Stop()        }        running.Stop()        return err    }    // Finish initializing the startup    n.services = services    n.server = running    n.stop = make(chan struct{})    return nil}</code></pre><p>startRPC,è¿™ä¸ªæ–¹æ³•æ”¶é›†æ‰€æœ‰çš„apisã€‚ å¹¶ä¾æ¬¡è°ƒç”¨å¯åŠ¨å„ä¸ªRPCæœåŠ¡å™¨ï¼Œ é»˜è®¤æ˜¯å¯åŠ¨InProcå’ŒIPCã€‚ å¦‚æœæŒ‡å®šä¹Ÿå¯ä»¥é…ç½®æ˜¯å¦å¯åŠ¨HTTPå’Œwebsocketã€‚</p><pre><code>// startRPC is a helper method to start all the various RPC endpoint during node// startup. It's not meant to be called at any time afterwards as it makes certain// assumptions about the state of the node.func (n *Node) startRPC(services map[reflect.Type]Service) error {    // Gather all the possible APIs to surface    apis := n.apis()    for _, service := range services {        apis = append(apis, service.APIs()...)    }    // Start the various API endpoints, terminating all in case of errors    if err := n.startInProc(apis); err != nil {        return err    }    if err := n.startIPC(apis); err != nil {        n.stopInProc()        return err    }    if err := n.startHTTP(n.httpEndpoint, apis, n.config.HTTPModules, n.config.HTTPCors); err != nil {        n.stopIPC()        n.stopInProc()        return err    }    if err := n.startWS(n.wsEndpoint, apis, n.config.WSModules, n.config.WSOrigins, n.config.WSExposeAll); err != nil {        n.stopHTTP()        n.stopIPC()        n.stopInProc()        return err    }    // All API endpoints started successfully    n.rpcAPIs = apis    return nil}</code></pre><p>startXXX æ˜¯å…·ä½“çš„RPCçš„å¯åŠ¨ï¼Œæµç¨‹éƒ½æ˜¯å¤§åŒå°å¼‚ã€‚åœ¨v1.8.12 ç‰ˆæœ¬ä¸­ node\node.go æ–‡ä»¶ä¸­startIPC()ã€startHTTP()ã€startWS()ä¸‰ä¸ªæ–¹æ³•çš„å…·ä½“å¯åŠ¨æ–¹å¼å°è£…åˆ° rpc\endpoints.go æ–‡ä»¶å¯¹åº”å‡½æ•°ä¸­</p><p>// StartWSEndpoint starts a websocket endpoint<br>func StartWSEndpoint(endpoint string, apis []API, modules []string, wsOrigins []string, exposeAll bool) (net.Listener, *Server, error) {</p><pre><code>// Generate the whitelist based on the allowed modules// ç”Ÿæˆç™½åå•whitelist := make(map[string]bool)for _, module := range modules {    whitelist[module] = true}// Register all the APIs exposed by the serviceshandler := NewServer()for _, api := range apis {    if exposeAll || whitelist[api.Namespace] || (len(whitelist) == 0 &amp;&amp; api.Public) {        // åªæœ‰è¿™å‡ ç§æƒ…å†µä¸‹æ‰ä¼šæŠŠè¿™ä¸ªapiè¿›è¡Œæ³¨å†Œã€‚        if err := handler.RegisterName(api.Namespace, api.Service); err != nil {            return nil, nil, err        }        log.Debug("WebSocket registered", "service", api.Service, "namespace", api.Namespace)    }}// All APIs registered, start the HTTP listener// æ‰€æœ‰ APIs éƒ½å·²ç»æ³¨å†Œï¼Œå¯åŠ¨ HTTP ç›‘å¬å™¨var (    listener net.Listener    err      error)if listener, err = net.Listen("tcp", endpoint); err != nil {    return nil, nil, err}go NewWSServer(wsOrigins, handler).Serve(listener)return listener, handler, err</code></pre><p>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-p2p-database.goæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-database.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-database.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>p2påŒ…å®ç°äº†é€šç”¨çš„p2pç½‘ç»œåè®®ã€‚åŒ…æ‹¬èŠ‚ç‚¹çš„æŸ¥æ‰¾ï¼ŒèŠ‚ç‚¹çŠ¶æ€çš„ç»´æŠ¤ï¼ŒèŠ‚ç‚¹è¿æ¥çš„å»ºç«‹ç­‰p2pçš„åŠŸèƒ½ã€‚p2p åŒ…å®ç°çš„æ˜¯é€šç”¨çš„p2påè®®ã€‚ æŸä¸€ç§å…·ä½“çš„åè®®(æ¯”å¦‚ethåè®®ã€‚ whisperåè®®ã€‚ swarmåè®®)è¢«å°è£…æˆç‰¹å®šçš„æ¥å£æ³¨å…¥p2påŒ…ã€‚æ‰€ä»¥p2på†…éƒ¨ä¸åŒ…å«å…·ä½“åè®®çš„å®ç°ã€‚ åªå®Œæˆäº†p2pç½‘ç»œåº”è¯¥åšçš„äº‹æƒ…ã€‚</p><h2 id="discover-discv5-èŠ‚ç‚¹å‘ç°"><a href="#discover-discv5-èŠ‚ç‚¹å‘ç°" class="headerlink" title="discover / discv5 èŠ‚ç‚¹å‘ç°"></a>discover / discv5 èŠ‚ç‚¹å‘ç°</h2><p>ç›®å‰ä½¿ç”¨çš„åŒ…æ˜¯discoverã€‚ discv5æ˜¯æœ€è¿‘æ‰å¼€å‘çš„åŠŸèƒ½ï¼Œè¿˜æ˜¯å±äºå®éªŒæ€§è´¨ï¼ŒåŸºæœ¬ä¸Šæ˜¯discoveråŒ…çš„ä¸€äº›ä¼˜åŒ–ã€‚ è¿™é‡Œæˆ‘ä»¬æš‚æ—¶åªåˆ†ædiscoverçš„ä»£ç ã€‚ å¯¹å…¶å®Œæˆçš„åŠŸèƒ½åšä¸€ä¸ªåŸºæœ¬çš„ä»‹ç»ã€‚</p><h3 id="database-go"><a href="#database-go" class="headerlink" title="database.go"></a>database.go</h3><p>é¡¾åæ€ä¹‰ï¼Œè¿™ä¸ªæ–‡ä»¶å†…éƒ¨ä¸»è¦å®ç°äº†èŠ‚ç‚¹çš„æŒä¹…åŒ–ï¼Œå› ä¸ºp2pç½‘ç»œèŠ‚ç‚¹çš„èŠ‚ç‚¹å‘ç°å’Œç»´æŠ¤éƒ½æ˜¯æ¯”è¾ƒèŠ±æ—¶é—´çš„ï¼Œä¸ºäº†åå¤å¯åŠ¨çš„æ—¶å€™ï¼Œèƒ½å¤ŸæŠŠä¹‹å‰çš„å·¥ä½œç»§æ‰¿ä¸‹æ¥ï¼Œé¿å…æ¯æ¬¡éƒ½é‡æ–°å‘ç°ã€‚ æ‰€ä»¥æŒä¹…åŒ–çš„å·¥ä½œæ˜¯å¿…é¡»çš„ã€‚</p><p>ä¹‹å‰æˆ‘ä»¬åˆ†æäº†ethdbçš„ä»£ç å’Œtrieçš„ä»£ç ï¼Œtrieçš„æŒä¹…åŒ–å·¥ä½œä½¿ç”¨äº†leveldbã€‚ è¿™é‡ŒåŒæ ·ä¹Ÿä½¿ç”¨äº†leveldbã€‚ ä¸è¿‡p2pçš„leveldbå®ä¾‹å’Œä¸»è¦çš„åŒºå—é“¾çš„leveldbå®ä¾‹ä¸æ˜¯åŒä¸€ä¸ªã€‚</p><p>newNodeDB,æ ¹æ®å‚æ•°pathæ¥çœ‹æ‰“å¼€åŸºäºå†…å­˜çš„æ•°æ®åº“ï¼Œè¿˜æ˜¯åŸºäºæ–‡ä»¶çš„æ•°æ®åº“ã€‚</p><pre><code>// newNodeDB creates a new node database for storing and retrieving infos about// known peers in the network. If no path is given, an in-memory, temporary// database is constructed.func newNodeDB(path string, version int, self NodeID) (*nodeDB, error) {    if path == "" {        return newMemoryNodeDB(self)    }    return newPersistentNodeDB(path, version, self)}// newMemoryNodeDB creates a new in-memory node database without a persistent// backend.func newMemoryNodeDB(self NodeID) (*nodeDB, error) {    db, err := leveldb.Open(storage.NewMemStorage(), nil)    if err != nil {        return nil, err    }    return &amp;nodeDB{        lvl:  db,        self: self,        quit: make(chan struct{}),    }, nil}// newPersistentNodeDB creates/opens a leveldb backed persistent node database,// also flushing its contents in case of a version mismatch.func newPersistentNodeDB(path string, version int, self NodeID) (*nodeDB, error) {    opts := &amp;opt.Options{OpenFilesCacheCapacity: 5}    db, err := leveldb.OpenFile(path, opts)    if _, iscorrupted := err.(*errors.ErrCorrupted); iscorrupted {        db, err = leveldb.RecoverFile(path, nil)    }    if err != nil {        return nil, err    }    // The nodes contained in the cache correspond to a certain protocol version.    // Flush all nodes if the version doesn't match.    currentVer := make([]byte, binary.MaxVarintLen64)    currentVer = currentVer[:binary.PutVarint(currentVer, int64(version))]    blob, err := db.Get(nodeDBVersionKey, nil)    switch err {    case leveldb.ErrNotFound:        // Version not found (i.e. empty cache), insert it        if err := db.Put(nodeDBVersionKey, currentVer, nil); err != nil {            db.Close()            return nil, err        }    case nil:        // Version present, flush if different        //ç‰ˆæœ¬ä¸åŒï¼Œå…ˆåˆ é™¤æ‰€æœ‰çš„æ•°æ®åº“æ–‡ä»¶ï¼Œé‡æ–°åˆ›å»ºä¸€ä¸ªã€‚        if !bytes.Equal(blob, currentVer) {            db.Close()            if err = os.RemoveAll(path); err != nil {                return nil, err            }            return newPersistentNodeDB(path, version, self)        }    }    return &amp;nodeDB{        lvl:  db,        self: self,        quit: make(chan struct{}),    }, nil}</code></pre><p>Nodeçš„å­˜å‚¨ï¼ŒæŸ¥è¯¢å’Œåˆ é™¤    </p><pre><code>// node retrieves a node with a given id from the database.func (db *nodeDB) node(id NodeID) *Node {    blob, err := db.lvl.Get(makeKey(id, nodeDBDiscoverRoot), nil)    if err != nil {        return nil    }    node := new(Node)    if err := rlp.DecodeBytes(blob, node); err != nil {        log.Error("Failed to decode node RLP", "err", err)        return nil    }    node.sha = crypto.Keccak256Hash(node.ID[:])    return node}// updateNode inserts - potentially overwriting - a node into the peer database.func (db *nodeDB) updateNode(node *Node) error {    blob, err := rlp.EncodeToBytes(node)    if err != nil {        return err    }    return db.lvl.Put(makeKey(node.ID, nodeDBDiscoverRoot), blob, nil)}// deleteNode deletes all information/keys associated with a node.func (db *nodeDB) deleteNode(id NodeID) error {    deleter := db.lvl.NewIterator(util.BytesPrefix(makeKey(id, "")), nil)    for deleter.Next() {        if err := db.lvl.Delete(deleter.Key(), nil); err != nil {            return err        }    }    return nil}</code></pre><p>Nodeçš„ç»“æ„</p><pre><code>type Node struct {    IP       net.IP // len 4 for IPv4 or 16 for IPv6    UDP, TCP uint16 // port numbers    ID       NodeID // the node's public key    // This is a cached copy of sha3(ID) which is used for node    // distance calculations. This is part of Node in order to make it    // possible to write tests that need a node at a certain distance.    // In those tests, the content of sha will not actually correspond    // with ID.    sha common.Hash    // whether this node is currently being pinged in order to replace    // it in a bucket    contested bool}</code></pre><p>èŠ‚ç‚¹è¶…æ—¶å¤„ç†</p><pre><code>// ensureExpirer is a small helper method ensuring that the data expiration// mechanism is running. If the expiration goroutine is already running, this// method simply returns.// ensureExpireræ–¹æ³•ç”¨æ¥ç¡®ä¿expireræ–¹æ³•åœ¨è¿è¡Œã€‚ å¦‚æœexpirerå·²ç»è¿è¡Œï¼Œé‚£ä¹ˆè¿™ä¸ªæ–¹æ³•å°±ç›´æ¥è¿”å›ã€‚// è¿™ä¸ªæ–¹æ³•è®¾ç½®çš„ç›®çš„æ˜¯ä¸ºäº†åœ¨ç½‘ç»œæˆåŠŸå¯åŠ¨ååœ¨å¼€å§‹è¿›è¡Œæ•°æ®è¶…æ—¶ä¸¢å¼ƒçš„å·¥ä½œ(ä»¥é˜²ä¸€äº›æ½œåœ¨çš„æœ‰ç”¨çš„ç§å­èŠ‚ç‚¹è¢«ä¸¢å¼ƒ)ã€‚// The goal is to start the data evacuation only after the network successfully// bootstrapped itself (to prevent dumping potentially useful seed nodes). Since// it would require significant overhead to exactly trace the first successful// convergence, it's simpler to "ensure" the correct state when an appropriate// condition occurs (i.e. a successful bonding), and discard further events.func (db *nodeDB) ensureExpirer() {    db.runner.Do(func() { go db.expirer() })}// expirer should be started in a go routine, and is responsible for looping ad// infinitum and dropping stale data from the database.func (db *nodeDB) expirer() {    tick := time.Tick(nodeDBCleanupCycle)    for {        select {        case &lt;-tick:            if err := db.expireNodes(); err != nil {                log.Error("Failed to expire nodedb items", "err", err)            }        case &lt;-db.quit:            return        }    }}// expireNodes iterates over the database and deletes all nodes that have not// been seen (i.e. received a pong from) for some allotted time.//è¿™ä¸ªæ–¹æ³•éå†æ‰€æœ‰çš„èŠ‚ç‚¹ï¼Œå¦‚æœæŸä¸ªèŠ‚ç‚¹æœ€åæ¥æ”¶æ¶ˆæ¯è¶…è¿‡æŒ‡å®šå€¼ï¼Œé‚£ä¹ˆå°±åˆ é™¤è¿™ä¸ªèŠ‚ç‚¹ã€‚func (db *nodeDB) expireNodes() error {    threshold := time.Now().Add(-nodeDBNodeExpiration)    // Find discovered nodes that are older than the allowance    it := db.lvl.NewIterator(nil, nil)    defer it.Release()    for it.Next() {        // Skip the item if not a discovery node        id, field := splitKey(it.Key())        if field != nodeDBDiscoverRoot {            continue        }        // Skip the node if not expired yet (and not self)        if !bytes.Equal(id[:], db.self[:]) {            if seen := db.lastPong(id); seen.After(threshold) {                continue            }        }        // Otherwise delete all associated information        db.deleteNode(id)    }    return nil}</code></pre><p>ä¸€äº›çŠ¶æ€æ›´æ–°å‡½æ•°</p><pre><code>// lastPing retrieves the time of the last ping packet send to a remote node,// requesting binding.func (db *nodeDB) lastPing(id NodeID) time.Time {    return time.Unix(db.fetchInt64(makeKey(id, nodeDBDiscoverPing)), 0)}// updateLastPing updates the last time we tried contacting a remote node.func (db *nodeDB) updateLastPing(id NodeID, instance time.Time) error {    return db.storeInt64(makeKey(id, nodeDBDiscoverPing), instance.Unix())}// lastPong retrieves the time of the last successful contact from remote node.func (db *nodeDB) lastPong(id NodeID) time.Time {    return time.Unix(db.fetchInt64(makeKey(id, nodeDBDiscoverPong)), 0)}// updateLastPong updates the last time a remote node successfully contacted.func (db *nodeDB) updateLastPong(id NodeID, instance time.Time) error {    return db.storeInt64(makeKey(id, nodeDBDiscoverPong), instance.Unix())}// findFails retrieves the number of findnode failures since bonding.func (db *nodeDB) findFails(id NodeID) int {    return int(db.fetchInt64(makeKey(id, nodeDBDiscoverFindFails)))}// updateFindFails updates the number of findnode failures since bonding.func (db *nodeDB) updateFindFails(id NodeID, fails int) error {    return db.storeInt64(makeKey(id, nodeDBDiscoverFindFails), int64(fails))}</code></pre><p>ä»æ•°æ®åº“é‡Œé¢éšæœºæŒ‘é€‰åˆé€‚ç§å­èŠ‚ç‚¹</p><pre><code>// querySeeds retrieves random nodes to be used as potential seed nodes// for bootstrapping.func (db *nodeDB) querySeeds(n int, maxAge time.Duration) []*Node {    var (        now   = time.Now()        nodes = make([]*Node, 0, n)        it    = db.lvl.NewIterator(nil, nil)        id    NodeID    )    defer it.Release()seek:    for seeks := 0; len(nodes) &lt; n &amp;&amp; seeks &lt; n*5; seeks++ {        // Seek to a random entry. The first byte is incremented by a        // random amount each time in order to increase the likelihood        // of hitting all existing nodes in very small databases.        ctr := id[0]        rand.Read(id[:])        id[0] = ctr + id[0]%16        it.Seek(makeKey(id, nodeDBDiscoverRoot))        n := nextNode(it)        if n == nil {            id[0] = 0            continue seek // iterator exhausted        }        if n.ID == db.self {            continue seek        }        if now.Sub(db.lastPong(n.ID)) &gt; maxAge {            continue seek        }        for i := range nodes {            if nodes[i].ID == n.ID {                continue seek // duplicate            }        }        nodes = append(nodes, n)    }    return nodes}// reads the next node record from the iterator, skipping over other// database entries.func nextNode(it iterator.Iterator) *Node {    for end := false; !end; end = !it.Next() {        id, field := splitKey(it.Key())        if field != nodeDBDiscoverRoot {            continue        }        var n Node        if err := rlp.DecodeBytes(it.Value(), &amp;n); err != nil {            log.Warn("Failed to decode node RLP", "id", id, "err", err)            continue        }        return &amp;n    }    return nil}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-p2p-dial.goæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-dial.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-dial.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>dial.goåœ¨p2pé‡Œé¢ä¸»è¦è´Ÿè´£å»ºç«‹é“¾æ¥çš„éƒ¨åˆ†å·¥ä½œã€‚ æ¯”å¦‚å‘ç°å»ºç«‹é“¾æ¥çš„èŠ‚ç‚¹ã€‚ ä¸èŠ‚ç‚¹å»ºç«‹é“¾æ¥ã€‚ é€šè¿‡discoveræ¥æŸ¥æ‰¾æŒ‡å®šèŠ‚ç‚¹çš„åœ°å€ã€‚ç­‰åŠŸèƒ½ã€‚</p><p>dial.goé‡Œé¢åˆ©ç”¨ä¸€ä¸ªdailstateçš„æ•°æ®ç»“æ„æ¥å­˜å‚¨ä¸­é—´çŠ¶æ€,æ˜¯dialåŠŸèƒ½é‡Œé¢çš„æ ¸å¿ƒæ•°æ®ç»“æ„ã€‚</p><pre><code>// dialstate schedules dials and discovery lookups.// it get's a chance to compute new tasks on every iteration// of the main loop in Server.run.type dialstate struct {    maxDynDials int                        //æœ€å¤§çš„åŠ¨æ€èŠ‚ç‚¹é“¾æ¥æ•°é‡    ntab        discoverTable            //discoverTable ç”¨æ¥åšèŠ‚ç‚¹æŸ¥è¯¢çš„    netrestrict *netutil.Netlist    lookupRunning bool    dialing       map[discover.NodeID]connFlag        //æ­£åœ¨é“¾æ¥çš„èŠ‚ç‚¹    lookupBuf     []*discover.Node // current discovery lookup results //å½“å‰çš„discoveryæŸ¥è¯¢ç»“æœ    randomNodes   []*discover.Node // filled from Table //ä»discoverTableéšæœºæŸ¥è¯¢çš„èŠ‚ç‚¹    static        map[discover.NodeID]*dialTask  //é™æ€çš„èŠ‚ç‚¹ã€‚     hist          *dialHistory    start     time.Time        // time when the dialer was first used    bootnodes []*discover.Node // default dials when there are no peers //è¿™ä¸ªæ˜¯å†…ç½®çš„èŠ‚ç‚¹ã€‚ å¦‚æœæ²¡æœ‰æ‰¾åˆ°å…¶ä»–èŠ‚ç‚¹ã€‚é‚£ä¹ˆä½¿ç”¨é“¾æ¥è¿™äº›èŠ‚ç‚¹ã€‚}</code></pre><p>dailstateçš„åˆ›å»ºè¿‡ç¨‹ã€‚</p><pre><code>func newDialState(static []*discover.Node, bootnodes []*discover.Node, ntab discoverTable, maxdyn int, netrestrict *netutil.Netlist) *dialstate {    s := &amp;dialstate{        maxDynDials: maxdyn,        ntab:        ntab,        netrestrict: netrestrict,        static:      make(map[discover.NodeID]*dialTask),        dialing:     make(map[discover.NodeID]connFlag),        bootnodes:   make([]*discover.Node, len(bootnodes)),        randomNodes: make([]*discover.Node, maxdyn/2),        hist:        new(dialHistory),    }    copy(s.bootnodes, bootnodes)    for _, n := range static {        s.addStatic(n)    }    return s}</code></pre><p>dailæœ€é‡è¦çš„æ–¹æ³•æ˜¯newTasksæ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•ç”¨æ¥ç”Ÿæˆtaskã€‚ taskæ˜¯ä¸€ä¸ªæ¥å£ã€‚æœ‰ä¸€ä¸ªDoçš„æ–¹æ³•ã€‚</p><pre><code>type task interface {    Do(*Server)}func (s *dialstate) newTasks(nRunning int, peers map[discover.NodeID]*Peer, now time.Time) []task {    if s.start == (time.Time{}) {        s.start = now    }    var newtasks []task    //addDialæ˜¯ä¸€ä¸ªå†…éƒ¨æ–¹æ³•ï¼Œ é¦–å…ˆé€šè¿‡checkDialæ£€æŸ¥èŠ‚ç‚¹ã€‚ç„¶åè®¾ç½®çŠ¶æ€ï¼Œæœ€åæŠŠèŠ‚ç‚¹å¢åŠ åˆ°newtasksé˜Ÿåˆ—é‡Œé¢ã€‚    addDial := func(flag connFlag, n *discover.Node) bool {        if err := s.checkDial(n, peers); err != nil {            log.Trace("Skipping dial candidate", "id", n.ID, "addr", &amp;net.TCPAddr{IP: n.IP, Port: int(n.TCP)}, "err", err)            return false        }        s.dialing[n.ID] = flag        newtasks = append(newtasks, &amp;dialTask{flags: flag, dest: n})        return true    }    // Compute number of dynamic dials necessary at this point.    needDynDials := s.maxDynDials    //é¦–å…ˆåˆ¤æ–­å·²ç»å»ºç«‹çš„è¿æ¥çš„ç±»å‹ã€‚å¦‚æœæ˜¯åŠ¨æ€ç±»å‹ã€‚é‚£ä¹ˆéœ€è¦å»ºç«‹åŠ¨æ€é“¾æ¥æ•°é‡å‡å°‘ã€‚    for _, p := range peers {        if p.rw.is(dynDialedConn) {            needDynDials--        }    }    //ç„¶åå†åˆ¤æ–­æ­£åœ¨å»ºç«‹çš„é“¾æ¥ã€‚å¦‚æœæ˜¯åŠ¨æ€ç±»å‹ã€‚é‚£ä¹ˆéœ€è¦å»ºç«‹åŠ¨æ€é“¾æ¥æ•°é‡å‡å°‘ã€‚    for _, flag := range s.dialing {        if flag&amp;dynDialedConn != 0 {            needDynDials--        }    }    // Expire the dial history on every invocation.    s.hist.expire(now)    // Create dials for static nodes if they are not connected.    //æŸ¥çœ‹æ‰€æœ‰çš„é™æ€ç±»å‹ã€‚å¦‚æœå¯ä»¥é‚£ä¹ˆä¹Ÿåˆ›å»ºé“¾æ¥ã€‚    for id, t := range s.static {        err := s.checkDial(t.dest, peers)        switch err {        case errNotWhitelisted, errSelf:            log.Warn("Removing static dial candidate", "id", t.dest.ID, "addr", &amp;net.TCPAddr{IP: t.dest.IP, Port: int(t.dest.TCP)}, "err", err)            delete(s.static, t.dest.ID)        case nil:            s.dialing[id] = t.flags            newtasks = append(newtasks, t)        }    }    // If we don't have any peers whatsoever, try to dial a random bootnode. This    // scenario is useful for the testnet (and private networks) where the discovery    // table might be full of mostly bad peers, making it hard to find good ones.    //å¦‚æœå½“å‰è¿˜æ²¡æœ‰ä»»ä½•é“¾æ¥ã€‚ è€Œä¸”20ç§’(fallbackInterval)å†…æ²¡æœ‰åˆ›å»ºä»»ä½•é“¾æ¥ã€‚ é‚£ä¹ˆå°±ä½¿ç”¨bootnodeåˆ›å»ºé“¾æ¥ã€‚    if len(peers) == 0 &amp;&amp; len(s.bootnodes) &gt; 0 &amp;&amp; needDynDials &gt; 0 &amp;&amp; now.Sub(s.start) &gt; fallbackInterval {        bootnode := s.bootnodes[0]        s.bootnodes = append(s.bootnodes[:0], s.bootnodes[1:]...)        s.bootnodes = append(s.bootnodes, bootnode)        if addDial(dynDialedConn, bootnode) {            needDynDials--        }    }    // Use random nodes from the table for half of the necessary    // dynamic dials.    //å¦åˆ™ä½¿ç”¨1/2çš„éšæœºèŠ‚ç‚¹åˆ›å»ºé“¾æ¥ã€‚    randomCandidates := needDynDials / 2    if randomCandidates &gt; 0 {        n := s.ntab.ReadRandomNodes(s.randomNodes)        for i := 0; i &lt; randomCandidates &amp;&amp; i &lt; n; i++ {            if addDial(dynDialedConn, s.randomNodes[i]) {                needDynDials--            }        }    }    // Create dynamic dials from random lookup results, removing tried    // items from the result buffer.    i := 0    for ; i &lt; len(s.lookupBuf) &amp;&amp; needDynDials &gt; 0; i++ {        if addDial(dynDialedConn, s.lookupBuf[i]) {            needDynDials--        }    }    s.lookupBuf = s.lookupBuf[:copy(s.lookupBuf, s.lookupBuf[i:])]    // Launch a discovery lookup if more candidates are needed.    // å¦‚æœå°±ç®—è¿™æ ·ä¹Ÿä¸èƒ½åˆ›å»ºè¶³å¤ŸåŠ¨æ€é“¾æ¥ã€‚ é‚£ä¹ˆåˆ›å»ºä¸€ä¸ªdiscoverTaskç”¨æ¥å†ç½‘ç»œä¸ŠæŸ¥æ‰¾å…¶ä»–çš„èŠ‚ç‚¹ã€‚æ”¾å…¥lookupBuf    if len(s.lookupBuf) &lt; needDynDials &amp;&amp; !s.lookupRunning {        s.lookupRunning = true        newtasks = append(newtasks, &amp;discoverTask{})    }    // Launch a timer to wait for the next node to expire if all    // candidates have been tried and no task is currently active.    // This should prevent cases where the dialer logic is not ticked    // because there are no pending events.    // å¦‚æœå½“å‰æ²¡æœ‰ä»»ä½•ä»»åŠ¡éœ€è¦åšï¼Œé‚£ä¹ˆåˆ›å»ºä¸€ä¸ªç¡çœ çš„ä»»åŠ¡è¿”å›ã€‚    if nRunning == 0 &amp;&amp; len(newtasks) == 0 &amp;&amp; s.hist.Len() &gt; 0 {        t := &amp;waitExpireTask{s.hist.min().exp.Sub(now)}        newtasks = append(newtasks, t)    }    return newtasks}</code></pre><p>checkDialæ–¹æ³•ï¼Œ ç”¨æ¥æ£€æŸ¥ä»»åŠ¡æ˜¯å¦éœ€è¦åˆ›å»ºé“¾æ¥ã€‚ </p><pre><code>func (s *dialstate) checkDial(n *discover.Node, peers map[discover.NodeID]*Peer) error {    _, dialing := s.dialing[n.ID]    switch {    case dialing:                    //æ­£åœ¨åˆ›å»º        return errAlreadyDialing    case peers[n.ID] != nil:        //å·²ç»é“¾æ¥äº†        return errAlreadyConnected    case s.ntab != nil &amp;&amp; n.ID == s.ntab.Self().ID:    //å»ºç«‹çš„å¯¹è±¡ä¸æ˜¯è‡ªå·±        return errSelf    case s.netrestrict != nil &amp;&amp; !s.netrestrict.Contains(n.IP): //ç½‘ç»œé™åˆ¶ã€‚ å¯¹æ–¹çš„IPåœ°å€ä¸åœ¨ç™½åå•é‡Œé¢ã€‚        return errNotWhitelisted    case s.hist.contains(n.ID):    // è¿™ä¸ªIDæ›¾ç»é“¾æ¥è¿‡ã€‚         return errRecentlyDialed    }    return nil}</code></pre><p>taskDoneæ–¹æ³•ã€‚ è¿™ä¸ªæ–¹æ³•å†taskå®Œæˆä¹‹åä¼šè¢«è°ƒç”¨ã€‚ æŸ¥çœ‹taskçš„ç±»å‹ã€‚å¦‚æœæ˜¯é“¾æ¥ä»»åŠ¡ï¼Œé‚£ä¹ˆå¢åŠ åˆ°histé‡Œé¢ã€‚ å¹¶ä»æ­£åœ¨é“¾æ¥çš„é˜Ÿåˆ—åˆ é™¤ã€‚ å¦‚æœæ˜¯æŸ¥è¯¢ä»»åŠ¡ã€‚ æŠŠæŸ¥è¯¢çš„è®°è¿‡æ”¾åœ¨lookupBufé‡Œé¢ã€‚</p><pre><code>func (s *dialstate) taskDone(t task, now time.Time) {    switch t := t.(type) {    case *dialTask:        s.hist.add(t.dest.ID, now.Add(dialHistoryExpiration))        delete(s.dialing, t.dest.ID)    case *discoverTask:        s.lookupRunning = false        s.lookupBuf = append(s.lookupBuf, t.results...)    }}</code></pre><p>dialTask.Doæ–¹æ³•ï¼Œä¸åŒçš„taskæœ‰ä¸åŒçš„Doæ–¹æ³•ã€‚ dailTaskä¸»è¦è´Ÿè´£å»ºç«‹é“¾æ¥ã€‚ å¦‚æœt.destæ˜¯æ²¡æœ‰ipåœ°å€çš„ã€‚ é‚£ä¹ˆå°è¯•é€šè¿‡resolveæŸ¥è¯¢ipåœ°å€ã€‚ ç„¶åè°ƒç”¨dialæ–¹æ³•åˆ›å»ºé“¾æ¥ã€‚ å¯¹äºé™æ€çš„èŠ‚ç‚¹ã€‚å¦‚æœç¬¬ä¸€æ¬¡å¤±è´¥ï¼Œé‚£ä¹ˆä¼šå°è¯•å†æ¬¡resolveé™æ€èŠ‚ç‚¹ã€‚ç„¶åå†å°è¯•dialï¼ˆå› ä¸ºé™æ€èŠ‚ç‚¹çš„ipæ˜¯é…ç½®çš„ã€‚ å¦‚æœé™æ€èŠ‚ç‚¹çš„ipåœ°å€å˜åŠ¨ã€‚é‚£ä¹ˆæˆ‘ä»¬å°è¯•resolveé™æ€èŠ‚ç‚¹çš„æ–°åœ°å€ï¼Œç„¶åè°ƒç”¨é“¾æ¥ã€‚ï¼‰</p><pre><code>func (t *dialTask) Do(srv *Server) {    if t.dest.Incomplete() {        if !t.resolve(srv) {            return        }    }    success := t.dial(srv, t.dest)    // Try resolving the ID of static nodes if dialing failed.    if !success &amp;&amp; t.flags&amp;staticDialedConn != 0 {        if t.resolve(srv) {            t.dial(srv, t.dest)        }    }}</code></pre><p>resolveæ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•ä¸»è¦è°ƒç”¨äº†discoverç½‘ç»œçš„Resolveæ–¹æ³•ã€‚å¦‚æœå¤±è´¥ï¼Œé‚£ä¹ˆè¶…æ—¶å†è¯•</p><pre><code>// resolve attempts to find the current endpoint for the destination// using discovery.//// Resolve operations are throttled with backoff to avoid flooding the// discovery network with useless queries for nodes that don't exist.// The backoff delay resets when the node is found.func (t *dialTask) resolve(srv *Server) bool {    if srv.ntab == nil {        log.Debug("Can't resolve node", "id", t.dest.ID, "err", "discovery is disabled")        return false    }    if t.resolveDelay == 0 {        t.resolveDelay = initialResolveDelay    }    if time.Since(t.lastResolved) &lt; t.resolveDelay {        return false    }    resolved := srv.ntab.Resolve(t.dest.ID)    t.lastResolved = time.Now()    if resolved == nil {        t.resolveDelay *= 2        if t.resolveDelay &gt; maxResolveDelay {            t.resolveDelay = maxResolveDelay        }        log.Debug("Resolving node failed", "id", t.dest.ID, "newdelay", t.resolveDelay)        return false    }    // The node was found.    t.resolveDelay = initialResolveDelay    t.dest = resolved    log.Debug("Resolved node", "id", t.dest.ID, "addr", &amp;net.TCPAddr{IP: t.dest.IP, Port: int(t.dest.TCP)})    return true}</code></pre><p>dialæ–¹æ³•,è¿™ä¸ªæ–¹æ³•è¿›è¡Œäº†å®é™…çš„ç½‘ç»œè¿æ¥æ“ä½œã€‚ ä¸»è¦é€šè¿‡srv.SetupConnæ–¹æ³•æ¥å®Œæˆï¼Œ åç»­å†åˆ†æServer.goçš„æ—¶å€™å†åˆ†æè¿™ä¸ªæ–¹æ³•ã€‚</p><pre><code>// dial performs the actual connection attempt.func (t *dialTask) dial(srv *Server, dest *discover.Node) bool {    fd, err := srv.Dialer.Dial(dest)    if err != nil {        log.Trace("Dial error", "task", t, "err", err)        return false    }    mfd := newMeteredConn(fd, false)    srv.SetupConn(mfd, t.flags, dest)    return true}</code></pre><p>discoverTaskå’ŒwaitExpireTaskçš„Doæ–¹æ³•ï¼Œ</p><pre><code>func (t *discoverTask) Do(srv *Server) {    // newTasks generates a lookup task whenever dynamic dials are    // necessary. Lookups need to take some time, otherwise the    // event loop spins too fast.    next := srv.lastLookup.Add(lookupInterval)    if now := time.Now(); now.Before(next) {        time.Sleep(next.Sub(now))    }    srv.lastLookup = time.Now()    var target discover.NodeID    rand.Read(target[:])    t.results = srv.ntab.Lookup(target)}func (t waitExpireTask) Do(*Server) {    time.Sleep(t.Duration)}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-p2p-natæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-nat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-nat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>natæ˜¯ç½‘ç»œåœ°å€è½¬æ¢çš„æ„æ€ã€‚  è¿™éƒ¨åˆ†çš„æºç æ¯”è¾ƒç‹¬ç«‹è€Œä¸”å•ä¸€ï¼Œè¿™é‡Œå°±æš‚æ—¶ä¸åˆ†æäº†ã€‚ å¤§å®¶äº†è§£åŸºæœ¬çš„åŠŸèƒ½å°±è¡Œäº†ã€‚</p><p>natä¸‹é¢æœ‰upnpå’Œpmpä¸¤ç§ç½‘ç»œåè®®ã€‚ </p><h3 id="upnpçš„åº”ç”¨åœºæ™¯-pmpæ˜¯å’Œupnpç±»ä¼¼çš„åè®®"><a href="#upnpçš„åº”ç”¨åœºæ™¯-pmpæ˜¯å’Œupnpç±»ä¼¼çš„åè®®" class="headerlink" title="upnpçš„åº”ç”¨åœºæ™¯(pmpæ˜¯å’Œupnpç±»ä¼¼çš„åè®®)"></a>upnpçš„åº”ç”¨åœºæ™¯(pmpæ˜¯å’Œupnpç±»ä¼¼çš„åè®®)</h3><p>å¦‚æœç”¨æˆ·æ˜¯é€šè¿‡NATæ¥å…¥Internetçš„ï¼ŒåŒæ—¶éœ€è¦ä½¿ç”¨BCã€ç”µéª¡eMuleç­‰P2Pè¿™æ ·çš„è½¯ä»¶ï¼Œè¿™æ—¶UPnPåŠŸèƒ½å°±ä¼šå¸¦æ¥å¾ˆå¤§çš„ä¾¿åˆ©ã€‚åˆ©ç”¨UPnPèƒ½è‡ªåŠ¨çš„æŠŠBCã€ç”µéª¡eMuleç­‰ä¾¦å¬çš„ç«¯å£å·æ˜ å°„åˆ°å…¬ç½‘ä¸Šï¼Œä»¥ä¾¿å…¬ç½‘ä¸Šçš„ç”¨æˆ·ä¹Ÿèƒ½å¯¹NATç§ç½‘ä¾§å‘èµ·è¿æ¥ã€‚</p><p>ä¸»è¦åŠŸèƒ½å°±æ˜¯æä¾›æ¥å£å¯ä»¥æŠŠå†…ç½‘çš„IP+ç«¯å£ æ˜ å°„ä¸º  è·¯ç”±å™¨çš„IP+ç«¯å£ã€‚ è¿™æ ·å°±ç­‰äºå†…ç½‘çš„ç¨‹åºæœ‰äº†å¤–ç½‘çš„IPåœ°å€ï¼Œ è¿™æ ·å…¬ç½‘çš„ç”¨æˆ·å°±å¯ä»¥ç›´æ¥å¯¹ä½ è¿›è¡Œè®¿é—®äº†ã€‚ ä¸ç„¶å°±éœ€è¦é€šè¿‡UDPæ‰“æ´è¿™ç§æ–¹å¼æ¥è¿›è¡Œè®¿é—®ã€‚</p><h3 id="p2pä¸­çš„UDPåè®®"><a href="#p2pä¸­çš„UDPåè®®" class="headerlink" title="p2pä¸­çš„UDPåè®®"></a>p2pä¸­çš„UDPåè®®</h3><p>ç°åœ¨å¤§éƒ¨åˆ†ç”¨æˆ·è¿è¡Œçš„ç¯å¢ƒéƒ½æ˜¯å†…ç½‘ç¯å¢ƒã€‚ å†…ç½‘ç¯å¢ƒä¸‹ç›‘å¬çš„ç«¯å£ï¼Œå…¶ä»–å…¬ç½‘çš„ç¨‹åºæ˜¯æ— æ³•ç›´æ¥è®¿é—®çš„ã€‚éœ€è¦ç»è¿‡ä¸€ä¸ªæ‰“æ´çš„è¿‡ç¨‹ã€‚ åŒæ–¹æ‰èƒ½è”é€šã€‚è¿™å°±æ˜¯æ‰€è°“çš„UDPæ‰“æ´ã€‚</p><p><img src="/images/ethereum/source_analysis/nat_1.png" alt="image"><br>å¤–ç½‘å¸Œæœ›ç›´æ¥è®¿é—®å†…ç½‘ä¸Šçš„ç¨‹åºæ˜¯æ— æ³•å®ç°çš„ã€‚ å› ä¸ºè·¯ç”±å™¨å¹¶ä¸çŸ¥é“å¦‚ä½•è·¯ç”±æ•°æ®ç»™å†…ç½‘çš„è¿™ä¸ªç¨‹åºã€‚</p><p>é‚£ä¹ˆæˆ‘ä»¬é¦–å…ˆé€šè¿‡å†…ç½‘çš„ç¨‹åºè”ç³»å¤–ç½‘çš„ç¨‹åºï¼Œè¿™æ ·è·¯ç”±å™¨å°±ä¼šè‡ªåŠ¨ç»™å†…ç½‘çš„è¿™ä¸ªç¨‹åºåˆ†é…ä¸€ä¸ªç«¯å£ã€‚å¹¶åœ¨è·¯ç”±å™¨é‡Œé¢è®°å½•ä¸€æ¡æ˜ å°„ 192.168.1.1:3003 -&gt; 111.21.12.12:3003 ã€‚è¿™ä¸ªæ˜ å°„å…³ç³»éšç€æ—¶é—´ä¼šè€åŒ–æœ€ç»ˆæ¶ˆå¤±ã€‚</p><p><img src="/images/ethereum/source_analysis/nat_2.png" alt="image"></p><p>ç­‰è·¯ç”±å™¨å»ºç«‹è¿™æ ·çš„æ˜ å°„å…³ç³»åã€‚ äº’è”ç½‘ä¸Šçš„å…¶ä»–ç¨‹åºå°±å¯ä»¥å¿«ä¹çš„è®¿é—®111.21.12.12:3003è¿™ä¸ªç«¯å£äº†ã€‚å› ä¸ºæ‰€æœ‰é€åˆ°è¿™ä¸ªç«¯å£çš„æ•°æ®æœ€ç»ˆä¼šè¢«è·¯ç”±åˆ°192.168.1.1:3003è¿™ä¸ªç«¯å£ã€‚è¿™å°±æ˜¯æ‰€è°“çš„æ‰“æ´çš„è¿‡ç¨‹ã€‚</p><p><img src="/images/ethereum/source_analysis/nat_3.png" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-p2p-peer.goæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-peer.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-peer.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>åœ¨p2pä»£ç é‡Œé¢ã€‚ peerä»£è¡¨äº†ä¸€æ¡åˆ›å»ºå¥½çš„ç½‘ç»œé“¾è·¯ã€‚åœ¨ä¸€æ¡é“¾è·¯ä¸Šå¯èƒ½è¿è¡Œç€å¤šä¸ªåè®®ã€‚æ¯”å¦‚ä»¥å¤ªåŠçš„åè®®(eth)ã€‚ Swarmçš„åè®®ã€‚ æˆ–è€…æ˜¯Whisperçš„åè®®ã€‚</p><p>peerçš„ç»“æ„</p><pre><code>type protoRW struct {    Protocol    in     chan Msg        // receices read messages    closed &lt;-chan struct{} // receives when peer is shutting down    wstart &lt;-chan struct{} // receives when write may start    werr   chan&lt;- error    // for write results    offset uint64    w      MsgWriter}// Protocol represents a P2P subprotocol implementation.type Protocol struct {    // Name should contain the official protocol name,    // often a three-letter word.    Name string    // Version should contain the version number of the protocol.    Version uint    // Length should contain the number of message codes used    // by the protocol.    Length uint64    // Run is called in a new groutine when the protocol has been    // negotiated with a peer. It should read and write messages from    // rw. The Payload for each message must be fully consumed.    //    // The peer connection is closed when Start returns. It should return    // any protocol-level error (such as an I/O error) that is    // encountered.    Run func(peer *Peer, rw MsgReadWriter) error    // NodeInfo is an optional helper method to retrieve protocol specific metadata    // about the host node.    NodeInfo func() interface{}    // PeerInfo is an optional helper method to retrieve protocol specific metadata    // about a certain peer in the network. If an info retrieval function is set,    // but returns nil, it is assumed that the protocol handshake is still running.    PeerInfo func(id discover.NodeID) interface{}}// Peer represents a connected remote node.type Peer struct {    rw      *conn    running map[string]*protoRW   //è¿è¡Œçš„åè®®    log     log.Logger    created mclock.AbsTime    wg       sync.WaitGroup    protoErr chan error    closed   chan struct{}    disc     chan DiscReason    // events receives message send / receive events if set    events *event.Feed}</code></pre><p>peerçš„åˆ›å»ºï¼Œæ ¹æ®åŒ¹é…æ‰¾åˆ°å½“å‰Peeræ”¯æŒçš„protomap</p><pre><code>func newPeer(conn *conn, protocols []Protocol) *Peer {    protomap := matchProtocols(protocols, conn.caps, conn)    p := &amp;Peer{        rw:       conn,        running:  protomap,        created:  mclock.Now(),        disc:     make(chan DiscReason),        protoErr: make(chan error, len(protomap)+1), // protocols + pingLoop        closed:   make(chan struct{}),        log:      log.New("id", conn.id, "conn", conn.flags),    }    return p}</code></pre><p>peerçš„å¯åŠ¨ï¼Œ å¯åŠ¨äº†ä¸¤ä¸ªgoroutineçº¿ç¨‹ã€‚ ä¸€ä¸ªæ˜¯è¯»å–ã€‚ä¸€ä¸ªæ˜¯æ‰§è¡Œpingæ“ä½œã€‚</p><pre><code>func (p *Peer) run() (remoteRequested bool, err error) {    var (        writeStart = make(chan struct{}, 1)  //ç”¨æ¥æ§åˆ¶ä»€ä¹ˆæ—¶å€™å¯ä»¥å†™å…¥çš„ç®¡é“ã€‚        writeErr   = make(chan error, 1)        readErr    = make(chan error, 1)        reason     DiscReason // sent to the peer    )    p.wg.Add(2)    go p.readLoop(readErr)    go p.pingLoop()    // Start all protocol handlers.    writeStart &lt;- struct{}{}    //å¯åŠ¨æ‰€æœ‰çš„åè®®ã€‚    p.startProtocols(writeStart, writeErr)    // Wait for an error or disconnect.loop:    for {        select {        case err = &lt;-writeErr:            // A write finished. Allow the next write to start if            // there was no error.            if err != nil {                reason = DiscNetworkError                break loop            }            writeStart &lt;- struct{}{}        case err = &lt;-readErr:            if r, ok := err.(DiscReason); ok {                remoteRequested = true                reason = r            } else {                reason = DiscNetworkError            }            break loop        case err = &lt;-p.protoErr:            reason = discReasonForError(err)            break loop        case err = &lt;-p.disc:            break loop        }    }    close(p.closed)    p.rw.close(reason)    p.wg.Wait()    return remoteRequested, err}</code></pre><p>startProtocolsæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•éå†æ‰€æœ‰çš„åè®®ã€‚</p><pre><code>func (p *Peer) startProtocols(writeStart &lt;-chan struct{}, writeErr chan&lt;- error) {    p.wg.Add(len(p.running))    for _, proto := range p.running {        proto := proto        proto.closed = p.closed        proto.wstart = writeStart        proto.werr = writeErr        var rw MsgReadWriter = proto        if p.events != nil {            rw = newMsgEventer(rw, p.events, p.ID(), proto.Name)        }        p.log.Trace(fmt.Sprintf("Starting protocol %s/%d", proto.Name, proto.Version))        // ç­‰äºè¿™é‡Œä¸ºæ¯ä¸€ä¸ªåè®®éƒ½å¼€å¯äº†ä¸€ä¸ªgoroutineã€‚ è°ƒç”¨å…¶Runæ–¹æ³•ã€‚        go func() {            // proto.Run(p, rw)è¿™ä¸ªæ–¹æ³•åº”è¯¥æ˜¯ä¸€ä¸ªæ­»å¾ªç¯ã€‚ å¦‚æœè¿”å›å°±è¯´æ˜é‡åˆ°äº†é”™è¯¯ã€‚            err := proto.Run(p, rw)            if err == nil {                p.log.Trace(fmt.Sprintf("Protocol %s/%d returned", proto.Name, proto.Version))                err = errProtocolReturned            } else if err != io.EOF {                p.log.Trace(fmt.Sprintf("Protocol %s/%d failed", proto.Name, proto.Version), "err", err)            }            p.protoErr &lt;- err            p.wg.Done()        }()    }}</code></pre><p>å›è¿‡å¤´æ¥å†çœ‹çœ‹readLoopæ–¹æ³•ã€‚ è¿™ä¸ªæ–¹æ³•ä¹Ÿæ˜¯ä¸€ä¸ªæ­»å¾ªç¯ã€‚ è°ƒç”¨p.rwæ¥è¯»å–ä¸€ä¸ªMsg(è¿™ä¸ªrwå®é™…æ˜¯ä¹‹å‰æåˆ°çš„frameRLPxçš„å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯åˆ†å¸§ä¹‹åçš„å¯¹è±¡ã€‚ç„¶åæ ¹æ®Msgçš„ç±»å‹è¿›è¡Œå¯¹åº”çš„å¤„ç†ï¼Œå¦‚æœMsgçš„ç±»å‹æ˜¯å†…éƒ¨è¿è¡Œçš„åè®®çš„ç±»å‹ã€‚é‚£ä¹ˆå‘é€åˆ°å¯¹åº”åè®®çš„proto.iné˜Ÿåˆ—ä¸Šé¢ã€‚</p><pre><code>func (p *Peer) readLoop(errc chan&lt;- error) {    defer p.wg.Done()    for {        msg, err := p.rw.ReadMsg()        if err != nil {            errc &lt;- err            return        }        msg.ReceivedAt = time.Now()        if err = p.handle(msg); err != nil {            errc &lt;- err            return        }    }}func (p *Peer) handle(msg Msg) error {    switch {    case msg.Code == pingMsg:        msg.Discard()        go SendItems(p.rw, pongMsg)    case msg.Code == discMsg:        var reason [1]DiscReason        // This is the last message. We don't need to discard or        // check errors because, the connection will be closed after it.        rlp.Decode(msg.Payload, &amp;reason)        return reason[0]    case msg.Code &lt; baseProtocolLength:        // ignore other base protocol messages        return msg.Discard()    default:        // it's a subprotocol message        proto, err := p.getProto(msg.Code)        if err != nil {            return fmt.Errorf("msg code out of range: %v", msg.Code)        }        select {        case proto.in &lt;- msg:            return nil        case &lt;-p.closed:            return io.EOF        }    }    return nil}</code></pre><p>åœ¨çœ‹çœ‹pingLoopã€‚è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ã€‚å°±æ˜¯å®šæ—¶çš„å‘é€pingMsgæ¶ˆæ¯åˆ°å¯¹ç«¯ã€‚</p><pre><code>func (p *Peer) pingLoop() {    ping := time.NewTimer(pingInterval)    defer p.wg.Done()    defer ping.Stop()    for {        select {        case &lt;-ping.C:            if err := SendItems(p.rw, pingMsg); err != nil {                p.protoErr &lt;- err                return            }            ping.Reset(pingInterval)        case &lt;-p.closed:            return        }    }}</code></pre><p>æœ€åå†çœ‹çœ‹protoRWçš„readå’Œwriteæ–¹æ³•ã€‚ å¯ä»¥çœ‹åˆ°è¯»å–å’Œå†™å…¥éƒ½æ˜¯é˜»å¡å¼çš„ã€‚</p><pre><code>func (rw *protoRW) WriteMsg(msg Msg) (err error) {    if msg.Code &gt;= rw.Length {        return newPeerError(errInvalidMsgCode, "not handled")    }    msg.Code += rw.offset    select {    case &lt;-rw.wstart:  //ç­‰åˆ°å¯ä»¥å†™å…¥çš„å—åœ¨æ‰§è¡Œå†™å…¥ã€‚ è¿™éš¾é“æ˜¯ä¸ºäº†å¤šçº¿ç¨‹æ§åˆ¶ä¹ˆã€‚        err = rw.w.WriteMsg(msg)        // Report write status back to Peer.run. It will initiate        // shutdown if the error is non-nil and unblock the next write        // otherwise. The calling protocol code should exit for errors        // as well but we don't want to rely on that.        rw.werr &lt;- err    case &lt;-rw.closed:        err = fmt.Errorf("shutting down")    }    return err}func (rw *protoRW) ReadMsg() (Msg, error) {    select {    case msg := &lt;-rw.in:        msg.Code -= rw.offset        return msg, nil    case &lt;-rw.closed:        return Msg{}, io.EOF    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-p2pæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>p2pçš„æºç åˆä¸‹é¢å‡ ä¸ªåŒ…</p><ul><li>discover         åŒ…å«äº†<a href="download/Kademlia%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B.pdf">Kademliaåè®®</a>ã€‚æ˜¯åŸºäºUDPçš„p2pèŠ‚ç‚¹å‘ç°åè®®ã€‚</li><li>discv5        æ–°çš„èŠ‚ç‚¹å‘ç°åè®®ã€‚ è¿˜æ˜¯è¯•éªŒå±æ€§ã€‚æœ¬æ¬¡åˆ†ææ²¡æœ‰æ¶‰åŠã€‚</li><li>nat            ç½‘ç»œåœ°å€è½¬æ¢çš„éƒ¨åˆ†ä»£ç </li><li>netutil        ä¸€äº›å·¥å…·</li><li>simulations    p2pç½‘ç»œçš„æ¨¡æ‹Ÿã€‚ æœ¬æ¬¡åˆ†ææ²¡æœ‰æ¶‰åŠã€‚</li></ul><p>discoveréƒ¨åˆ†çš„æºç åˆ†æ</p><ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-database.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="å‘ç°çš„èŠ‚ç‚¹çš„æŒä¹…åŒ–å­˜å‚¨ database.go">å‘ç°çš„èŠ‚ç‚¹çš„æŒä¹…åŒ–å­˜å‚¨ database.go</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-table.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="Kademliaåè®®çš„æ ¸å¿ƒé€»è¾‘ tabel.go">Kademliaåè®®çš„æ ¸å¿ƒé€»è¾‘ tabel.go</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-udp.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="UDPåè®®çš„å¤„ç†é€»è¾‘udp.go">UDPåè®®çš„å¤„ç†é€»è¾‘udp.go</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-nat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="ç½‘ç»œåœ°å€è½¬æ¢ nat.go">ç½‘ç»œåœ°å€è½¬æ¢ nat.go</a></li></ul><p>p2p/ éƒ¨åˆ†æºç åˆ†æ</p><ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-rlpx%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8A%A0%E5%AF%86%E9%93%BE%E8%B7%AF/" title="èŠ‚ç‚¹ä¹‹é—´çš„åŠ å¯†é“¾è·¯å¤„ç†åè®® rlpx.go">èŠ‚ç‚¹ä¹‹é—´çš„åŠ å¯†é“¾è·¯å¤„ç†åè®® rlpx.go</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-dial.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="æŒ‘é€‰èŠ‚ç‚¹ç„¶åè¿›è¡Œè¿æ¥çš„å¤„ç†é€»è¾‘ dail.go">æŒ‘é€‰èŠ‚ç‚¹ç„¶åè¿›è¡Œè¿æ¥çš„å¤„ç†é€»è¾‘ dail.go</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-peer.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="èŠ‚ç‚¹å’ŒèŠ‚ç‚¹è¿æ¥çš„å¤„ç†ä»¥åŠåè®®çš„å¤„ç† peer.go">èŠ‚ç‚¹å’ŒèŠ‚ç‚¹è¿æ¥çš„å¤„ç†ä»¥åŠåè®®çš„å¤„ç† peer.go</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-server.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="p2pæœåŠ¡å™¨çš„é€»è¾‘ server.go">p2pæœåŠ¡å™¨çš„é€»è¾‘ server.go</a></li></ul><p>Kademliaåè®®è¡¥å……ææ–™ï¼š</p><p>è™šçº¿åŒ…å«çš„éƒ¨åˆ†å°±æ˜¯å„å­æ ‘ï¼Œç”±ä¸Šåˆ°ä¸‹å„å±‚çš„å‰ç¼€åˆ†åˆ«ä¸º 0ï¼Œ01ï¼Œ000ï¼Œ0010ã€‚</p><blockquote><p>æŒ‰ç…§ä¸Šæ–‡çš„ç†è§£ï¼šå¯¹äºä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéƒ½å¯ä»¥æŠŠè¿™é¢—äºŒå‰æ ‘åˆ†è§£ä¸ºä¸€ç³»åˆ—è¿ç»­çš„ï¼Œä¸åŒ…å«è‡ªå·±çš„å­æ ‘ã€‚æœ€é«˜å±‚çš„å­æ ‘ï¼Œç”±æ•´é¢—æ ‘ä¸åŒ…å«è‡ªå·±çš„æ ‘çš„å¦ä¸€åŠç»„æˆï¼› ä¸‹ä¸€å±‚å­æ ‘ç”±å‰©ä¸‹éƒ¨åˆ†ä¸åŒ…å«è‡ªå·±çš„ä¸€åŠç»„æˆï¼›ä¾æ­¤ç±»æ¨ï¼Œç›´åˆ°åˆ†å‰²å®Œæ•´é¢—æ ‘ã€‚</p></blockquote><p>è™šçº¿åŒ…å«çš„éƒ¨åˆ†å°±æ˜¯å„å­æ ‘ï¼Œç”±ä¸Šåˆ°ä¸‹å„å±‚çš„å‰ç¼€åˆ†åˆ«ä¸º 1ï¼Œ01ï¼Œ000ï¼Œ0010ã€‚</p><p>æ¯ä¸€ä¸ªè¿™æ ·çš„åˆ—è¡¨éƒ½ç§°ä¹‹ä¸ºä¸€ä¸ª K æ¡¶ï¼Œå¹¶ä¸”æ¯ä¸ª K æ¡¶å†…éƒ¨ä¿¡æ¯å­˜æ”¾ä½ç½®æ˜¯æ ¹æ®ä¸Šæ¬¡çœ‹åˆ°çš„æ—¶é—´é¡ºåºæ’åˆ—ï¼Œæœ€è¿‘ï¼ˆleast-recentlyï¼‰çœ‹åˆ°çš„æ”¾åœ¨å¤´éƒ¨ï¼Œæœ€åï¼ˆmost-recentlyï¼‰çœ‹åˆ°çš„æ”¾åœ¨å°¾éƒ¨ã€‚æ¯ä¸ªæ¡¶éƒ½æœ‰ä¸è¶…è¿‡ k ä¸ªçš„æ•°æ®é¡¹ã€‚</p><blockquote><p>æœ€è¿‘ï¼ˆleast-recentlyï¼‰ä¸æœ€åï¼ˆmost-recentlyï¼‰çš„ç¿»è¯‘ï¼Œä¼šäº§ç”Ÿæ­§ä¹‰</p></blockquote><p>æœ€è¿‘æœ€å°‘ï¼ˆleast-recentlyï¼‰è®¿é—®çš„èŠ‚ç‚¹æ”¾åœ¨é˜Ÿåˆ—å¤´ï¼Œæœ€è¿‘æœ€å¤šï¼ˆmost-recentlyï¼‰è®¿é—®çš„èŠ‚ç‚¹æ”¾åœ¨é˜Ÿåˆ—å°¾éƒ¨ã€‚ä»¥æ¨¡æ‹Ÿgnutellaç”¨æˆ·è¡Œä¸ºåˆ†æçš„ç»“æœï¼Œæœ€è¿‘æœ€å¤šè®¿é—®çš„æ´»è·ƒèŠ‚ç‚¹ï¼Œä¹Ÿæ˜¯å°†æ¥æœ€æœ‰å¯èƒ½éœ€è¦è®¿é—®çš„èŠ‚ç‚¹</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-ç›®å½•</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="ä»¥å¤ªåŠæºç åˆ†æ"><a href="#ä»¥å¤ªåŠæºç åˆ†æ" class="headerlink" title="ä»¥å¤ªåŠæºç åˆ†æ"></a>ä»¥å¤ªåŠæºç åˆ†æ</h1><p><strong>å¸Œæœ›èƒ½å¤Ÿåˆ†æä»¥å¤ªåŠçš„ä»£ç æ¥å­¦ä¹ åŒºå—é“¾æŠ€æœ¯å’ŒGOè¯­è¨€çš„ä½¿ç”¨</strong></p><p>åˆ†æ<a href="https://github.com/ethereum/go-ethereum">go-ethereum</a>çš„è¿‡ç¨‹ï¼Œæˆ‘å¸Œæœ›ä»ä¾èµ–æ¯”è¾ƒå°‘çš„åº•å±‚æŠ€æœ¯ç»„ä»¶å¼€å§‹ï¼Œæ…¢æ…¢æ·±å…¥åˆ°æ ¸å¿ƒé€»è¾‘ã€‚</p><h2 id="ç›®å½•"><a href="#ç›®å½•" class="headerlink" title="ç›®å½•"></a>ç›®å½•</h2><ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-go-ethereum%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="go-ethereumä»£ç é˜…è¯»ç¯å¢ƒæ­å»º">go-ethereumä»£ç é˜…è¯»ç¯å¢ƒæ­å»º</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%BB%84%E7%9A%AE%E4%B9%A6%E9%87%8C%E9%9D%A2%E5%87%BA%E7%8E%B0%E7%9A%84%E6%89%80%E6%9C%89%E7%9A%84%E7%AC%A6%E5%8F%B7%E7%B4%A2%E5%BC%95/" title="ä»¥å¤ªåŠé»„çš®ä¹¦ ç¬¦å·ç´¢å¼•">ä»¥å¤ªåŠé»„çš®ä¹¦ ç¬¦å·ç´¢å¼•</a></li><li><a href="/2021/04/14/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-RLP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="rlpæºç è§£æ">rlpæºç è§£æ</a></li><li><a href="/2021/05/27/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%86%E6%9E%90%E5%8C%85Trie/" title="trieæºç åˆ†æ">trieæºç åˆ†æ</a></li><li><a href="/2021/06/05/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ethdb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="ethdbæºç åˆ†æ">ethdbæºç åˆ†æ</a></li><li><a href="/2021/04/14/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-RLP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="rpcæºç åˆ†æ">rpcæºç åˆ†æ</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="p2pæºç åˆ†æ">p2pæºç åˆ†æ</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="ethåè®®æºç åˆ†æ">ethåè®®æºç åˆ†æ</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-event%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="eventæºç åˆ†æ">eventæºç åˆ†æ</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-node%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="nodeæºç åˆ†æ">nodeæºç åˆ†æ</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-accounts%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="accountsæºç åˆ†æ">accountsæºç åˆ†æ</a></li><li>coreæºç åˆ†æ<ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-chain_indexer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="åŒºå—é“¾ç´¢å¼• chain_indexeræºç åˆ†æ">åŒºå—é“¾ç´¢å¼• chain_indexeræºç åˆ†æ</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-bloombits%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="å¸ƒéš†è¿‡æ»¤å™¨ç´¢å¼•">å¸ƒéš†è¿‡æ»¤å™¨ç´¢å¼•</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-state%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="stateæºç åˆ†æ">stateæºç åˆ†æ</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-state-process%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="äº¤æ˜“æ‰§è¡Œå’Œå¤„ç†éƒ¨åˆ†æºç åˆ†æ">äº¤æ˜“æ‰§è¡Œå’Œå¤„ç†éƒ¨åˆ†æºç åˆ†æ</a></li><li>vm è™šæ‹Ÿæœºæºç åˆ†æ<ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-vm-stack-memory%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="è™šæ‹Ÿæœºå †æ ˆå’Œå†…å­˜æ•°æ®ç»“æ„åˆ†æ">è™šæ‹Ÿæœºå †æ ˆå’Œå†…å­˜æ•°æ®ç»“æ„åˆ†æ</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-vm-jumptable-instruction/" title="è™šæ‹ŸæœºæŒ‡ä»¤,è·³è½¬è¡¨,è§£é‡Šå™¨æºç åˆ†æ">è™šæ‹ŸæœºæŒ‡ä»¤,è·³è½¬è¡¨,è§£é‡Šå™¨æºç åˆ†æ</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-vm%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="è™šæ‹Ÿæœºæºç åˆ†æ">è™šæ‹Ÿæœºæºç åˆ†æ</a></li></ul></li><li>å¾…ç¡®è®¤äº¤æ˜“æ± çš„ç®¡ç†txPool<ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-txlist%E4%BA%A4%E6%98%93%E6%B1%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="äº¤æ˜“æ± æ•°æ®ç»“æ„æºç åˆ†æ">äº¤æ˜“æ± æ•°æ®ç»“æ„æºç åˆ†æ</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-txpool%E4%BA%A4%E6%98%93%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="äº¤æ˜“æ± æºç åˆ†æ">äº¤æ˜“æ± æºç åˆ†æ</a></li></ul></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-genesis%E5%88%9B%E4%B8%96%E5%8C%BA%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="åˆ›ä¸–åŒºå—çš„æºç åˆ†æ">åˆ›ä¸–åŒºå—çš„æºç åˆ†æ</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-blockchain%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="core-blockchainæºç åˆ†æ">core-blockchainæºç åˆ†æ</a></li></ul></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-miner%E6%8C%96%E7%9F%BF%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90CPU%E6%8C%96%E7%9F%BF/" title="mineræŒ–çŸ¿éƒ¨åˆ†æºç åˆ†æCPUæŒ–çŸ¿">mineræŒ–çŸ¿éƒ¨åˆ†æºç åˆ†æCPUæŒ–çŸ¿</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-pow%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/" title="powä¸€è‡´æ€§ç®—æ³•">powä¸€è‡´æ€§ç®—æ³•</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9CClique_PoA%E4%BB%8B%E7%BB%8D/" title="ä»¥å¤ªåŠæµ‹è¯•ç½‘ç»œClique_PoAä»‹ç»">ä»¥å¤ªåŠæµ‹è¯•ç½‘ç»œClique_PoAä»‹ç»</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/" title="ä»¥å¤ªåŠéšæœºæ•°ç”Ÿæˆæ–¹å¼">ä»¥å¤ªåŠéšæœºæ•°ç”Ÿæˆæ–¹å¼</a></li><li><a href="/2021/05/27/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%B0%81%E8%A3%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/" title="å°è£…çš„ä¸€äº›åŸºç¡€å·¥å…·">å°è£…çš„ä¸€äº›åŸºç¡€å·¥å…·</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-é»„çš®ä¹¦é‡Œé¢å‡ºç°çš„æ‰€æœ‰çš„ç¬¦å·ç´¢å¼•</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%BB%84%E7%9A%AE%E4%B9%A6%E9%87%8C%E9%9D%A2%E5%87%BA%E7%8E%B0%E7%9A%84%E6%89%80%E6%9C%89%E7%9A%84%E7%AC%A6%E5%8F%B7%E7%B4%A2%E5%BC%95/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%BB%84%E7%9A%AE%E4%B9%A6%E9%87%8C%E9%9D%A2%E5%87%BA%E7%8E%B0%E7%9A%84%E6%89%80%E6%9C%89%E7%9A%84%E7%AC%A6%E5%8F%B7%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/ethereum/source_analysis/arch.jpg" alt="image"></p><p><img src="/images/ethereum/source_analysis/sign_state_1.png" alt="image"></p><p><img src="/images/ethereum/source_analysis/sign_state_3.png" alt="image">æ˜¯t+1æ—¶åˆ»çš„çŠ¶æ€(account trie)ã€‚</p><p><img src="/images/ethereum/source_analysis/sign_state_4.png" alt="image">æ˜¯çŠ¶æ€è½¬æ¢å‡½æ•°ï¼Œä¹Ÿå¯ä»¥ç†è§£ä¸ºæ‰§è¡Œå¼•æ“ã€‚</p><p><img src="/images/ethereum/source_analysis/sign_state_5.png" alt="image"> æ˜¯transactionï¼Œä¸€æ¬¡äº¤æ˜“ã€‚</p><p><img src="/images/ethereum/source_analysis/sign_state_6.png" alt="image"></p><p><img src="/images/ethereum/source_analysis/sign_state_7.png" alt="image">  æ˜¯åŒºå—çº§åˆ«çš„çŠ¶æ€è½¬æ¢å‡½æ•°ã€‚</p><p><img src="/images/ethereum/source_analysis/sign_state_8.png" alt="image">  æ˜¯åŒºå—ï¼Œç”±å¾ˆå¤šäº¤æ˜“ç»„æˆã€‚</p><p><img src="/images/ethereum/source_analysis/sign_state_9.png" alt="image">  0å·ä½ç½®çš„äº¤æ˜“ã€‚</p><p><img src="/images/ethereum/source_analysis/sign_state_10.png" alt="image"> æ˜¯å—ç»ˆç»“çŠ¶æ€è½¬æ¢å‡½æ•°ï¼ˆä¸€ä¸ªå¥–åŠ±æŒ–çŸ¿è€…çš„å‡½æ•°ï¼‰ã€‚</p><p><img src="/images/ethereum/source_analysis/sign_ether.png" alt="image"> Etherçš„æ ‡è¯†ã€‚</p><p><img src="/images/ethereum/source_analysis/sign_ether_value.png" alt="image"> Ethereumä¸­æ‰€ç”¨åˆ°çš„å„ç§å•ä½ä¸Weiçš„æ¢ç®—å…³ç³»ï¼ˆä¾‹å¦‚ï¼šä¸€ä¸ªFinneyå¯¹åº”10^15ä¸ªWeiï¼‰ã€‚</p><p><img src="/images/ethereum/source_analysis/sign_machine_state.png" alt="image"> machine-state</p><h2 id="ä¸€äº›åŸºæœ¬çš„è§„åˆ™"><a href="#ä¸€äº›åŸºæœ¬çš„è§„åˆ™" class="headerlink" title="ä¸€äº›åŸºæœ¬çš„è§„åˆ™"></a>ä¸€äº›åŸºæœ¬çš„è§„åˆ™</h2><ul><li>å¯¹äºå¤§å¤šæ•°çš„å‡½æ•°æ¥è¯´ï¼Œéƒ½ç”¨å¤§å†™å­—æ¯æ¥æ ‡è¯†ã€‚</li><li>å…ƒç»„ä¸€èˆ¬ç”¨å¤§å†™å­—æ¯æ¥æ ‡è¯†</li><li>æ ‡é‡æˆ–è€…å›ºå®šå¤§å°çš„å­—èŠ‚æ•°ç»„éƒ½ç”¨å°å†™å­—æ¯æ ‡è¯†ã€‚ æ¯”å¦‚ n ä»£è¡¨äº¤æ˜“çš„nonceï¼Œ æœ‰ä¸€äº›å¯èƒ½æœ‰ä¾‹å¤–ï¼Œæ¯”å¦‚Î´ä»£è¡¨ ä¸€ä¸ªç»™å®šæŒ‡ä»¤éœ€è¦çš„å †æ ˆæ•°æ®çš„å¤šå°‘ã€‚</li><li>å˜é•¿çš„å­—èŠ‚æ•°ç»„ä¸€èˆ¬ç”¨åŠ ç²—çš„å°å†™å­—æ¯ã€‚ æ¯”å¦‚ <strong>o</strong> ä»£è¡¨ä¸€ä¸ªmessage callçš„è¾“å‡ºæ•°æ®ã€‚å¯¹äºæŸäº›é‡è¦çš„ä¹Ÿå¯èƒ½ä½¿ç”¨åŠ ç²—çš„å¤§å†™å­—æ¯</li></ul><p><img src="/images/ethereum/source_analysis/sign_set_b.png" alt="image"> å­—èŠ‚åºåˆ—<br><img src="/images/ethereum/source_analysis/sign_set_p.png" alt="image"> æ­£æ•´æ•°<br><img src="/images/ethereum/source_analysis/sign_set_b32.png" alt="image"> 32å­—èŠ‚é•¿åº¦çš„å­—èŠ‚åºåˆ—<br><img src="/images/ethereum/source_analysis/sign_set_p256.png" alt="image"> å°äº 2^256 çš„æ­£æ•´æ•°<br><strong>[ ]</strong> ç”¨äºç´¢å¼•æ•°ç»„é‡Œé¢çš„å¯¹åº”å…ƒç´ <br><img src="/images/ethereum/source_analysis/sign_stack.png" alt="image"> ä»£è¡¨æœºå™¨å †æ ˆ(machineâ€™s stack)çš„ç¬¬ä¸€ä¸ªå¯¹è±¡<br><img src="/images/ethereum/source_analysis/sign_memory.png" alt="image"> ä»£è¡¨äº†æœºå™¨å†…å­˜(machineâ€™s memory)é‡Œé¢çš„å‰32ä¸ªå…ƒç´ <br><img src="/images/ethereum/source_analysis/sign_placeholder_1.png" alt="image"> ä¸€ä¸ªå ä½ç¬¦å·ï¼Œå¯ä»¥æ˜¯ä»»æ„å­—ç¬¦ä»£è¡¨ä»»æ„å¯¹è±¡</p><p><img src="/images/ethereum/source_analysis/sign_placeholder_2.png" alt="image"> ä»£è¡¨è¿™ä¸ªå¯¹è±¡è¢«ä¿®æ”¹åçš„å€¼<br><img src="/images/ethereum/source_analysis/sign_placeholder_3.png" alt="image"> ä¸­é—´çŠ¶æ€<br><img src="/images/ethereum/source_analysis/sign_placeholder_4.png" alt="image"> ä¸­é—´çŠ¶æ€2<br><img src="/images/ethereum/source_analysis/sign_func_1.png" alt="image"> <img src="/images/ethereum/source_analysis/sign_func_2.png" alt="image"> å¦‚æœå‰é¢çš„fä»£è¡¨äº†ä¸€ä¸ªå‡½æ•°ï¼Œ é‚£ä¹ˆåé¢çš„f*ä»£è¡¨äº†ä¸€ä¸ªç›¸ä¼¼çš„å‡½æ•°ï¼Œä¸è¿‡æ˜¯å¯¹å†…éƒ¨çš„å…ƒç´ ä¾æ¬¡æ‰§è¡Œfçš„ä¸€ä¸ªå‡½æ•°ã€‚</p><p><img src="/images/ethereum/source_analysis/sign_last_item.png" alt="image">  ä»£è¡¨äº†åˆ—è¡¨é‡Œé¢çš„æœ€åä¸€ä¸ªå…ƒç´ <br><img src="/images/ethereum/source_analysis/sign_last_item_1.png" alt="image">  ä»£è¡¨äº†åˆ—è¡¨é‡Œé¢çš„æœ€åä¸€ä¸ªå…ƒç´ <br><img src="/images/ethereum/source_analysis/sign_seq_item.png" alt="image">   æ±‚xçš„é•¿åº¦</p><p><img src="/images/ethereum/source_analysis/sign_state_nonce.png" alt="image">  aä»£è¡¨æŸä¸ªåœ°å€ï¼Œä»£è¡¨æŸä¸ªè´¦å·çš„nonce<br><img src="/images/ethereum/source_analysis/sign_state_balance.png" alt="image"> banlance ä½™é¢<br><img src="/images/ethereum/source_analysis/sign_state_root.png" alt="image">   storage trie çš„ root hash<br><img src="/images/ethereum/source_analysis/sign_state_code.png" alt="image"> Codeçš„hashã€‚ å¦‚æœcodeæ˜¯b é‚£ä¹ˆKEC(b)===è¿™ä¸ªhash</p><p><img src="/images/ethereum/source_analysis/sign_l1.png" alt="image"></p><p><img src="/images/ethereum/source_analysis/sign_ls.png" alt="image">  world state collapse function<br><img src="/images/ethereum/source_analysis/sign_pa.png" alt="image"></p><p><img src="/images/ethereum/source_analysis/sign_math_any.png" alt="image">  ä»»æ„çš„ any<br><img src="/images/ethereum/source_analysis/sign_math_or.png" alt="image">   å¹¶é›† or<br><img src="/images/ethereum/source_analysis/sign_math_and.png" alt="image">  äº¤é›† and</p><p><img src="/images/ethereum/source_analysis/sign_homestead.png" alt="image"> Homestead</p><h2 id="äº¤æ˜“"><a href="#äº¤æ˜“" class="headerlink" title="äº¤æ˜“"></a>äº¤æ˜“</h2><p><img src="/images/ethereum/source_analysis/sign_t_nonce.png" alt="image"> äº¤æ˜“çš„nonce<br><img src="/images/ethereum/source_analysis/sign_t_gasprice.png" alt="image"> gasPrice<br><img src="/images/ethereum/source_analysis/sign_t_gaslimit.png" alt="image"> gasLimit<br><img src="/images/ethereum/source_analysis/sign_t_to.png" alt="image"> to<br><img src="/images/ethereum/source_analysis/sign_t_value.png" alt="image"> value</p><p><img src="/images/ethereum/source_analysis/sign_t_w.png" alt="image"><img src="/images/ethereum/source_analysis/sign_t_tr.png" alt="image"><img src="/images/ethereum/source_analysis/sign_t_ts.png" alt="image">é€šè¿‡è€…ä¸‰ä¸ªå€¼å¯ä»¥å¾—åˆ°senderçš„åœ°å€</p><p><img src="/images/ethereum/source_analysis/sign_t_ti.png" alt="image"> åˆçº¦çš„åˆå§‹åŒ–ä»£ç <br><img src="/images/ethereum/source_analysis/sign_t_data.png" alt="image"> æ–¹æ³•è°ƒç”¨çš„å…¥å‚<br><img src="/images/ethereum/source_analysis/sign_t_lt.png" alt="image"></p><h2 id="åŒºå—å¤´"><a href="#åŒºå—å¤´" class="headerlink" title="åŒºå—å¤´"></a>åŒºå—å¤´</h2><p><img src="/images/ethereum/source_analysis/sign_h_p.png" alt="image">ParentHash<br><img src="/images/ethereum/source_analysis/sign_h_o.png" alt="image">OmmersHash<br><img src="/images/ethereum/source_analysis/sign_h_c.png" alt="image">beneficiaryçŸ¿å·¥åœ°å€<br><img src="/images/ethereum/source_analysis/sign_h_r.png" alt="image">stateRoot<br><img src="/images/ethereum/source_analysis/sign_h_t.png" alt="image">transactionRoot<br><img src="/images/ethereum/source_analysis/sign_h_e.png" alt="image">receiptRoot<br><img src="/images/ethereum/source_analysis/sign_h_b.png" alt="image">logsBloom<br><img src="/images/ethereum/source_analysis/sign_h_d.png" alt="image">éš¾åº¦<br><img src="/images/ethereum/source_analysis/sign_h_i.png" alt="image">numberé«˜åº¦<br><img src="/images/ethereum/source_analysis/sign_h_l.png" alt="image">gasLimit<br><img src="/images/ethereum/source_analysis/sign_h_g.png" alt="image">gasUsed<br><img src="/images/ethereum/source_analysis/sign_h_s.png" alt="image">timestamp<br><img src="/images/ethereum/source_analysis/sign_h_x.png" alt="image">extraData<br><img src="/images/ethereum/source_analysis/sign_h_m.png" alt="image">mixHash<br><img src="/images/ethereum/source_analysis/sign_h_n.png" alt="image">nonce</p><h2 id="å›æ‰§"><a href="#å›æ‰§" class="headerlink" title="å›æ‰§"></a>å›æ‰§</h2><p><img src="/images/ethereum/source_analysis/sign_r_i.png" alt="image"> ç¬¬iä¸ªäº¤æ˜“çš„receipt</p><p><img src="/images/ethereum/source_analysis/sign_receipt.png" alt="image"><br><img src="/images/ethereum/source_analysis/sign_r_state.png" alt="image"> äº¤æ˜“æ‰§è¡Œåçš„world-state<br><img src="/images/ethereum/source_analysis/sign_r_gasused.png" alt="image">äº¤æ˜“æ‰§è¡ŒååŒºå—æ€»çš„gasä½¿ç”¨é‡<br><img src="/images/ethereum/source_analysis/sign_r_bloom.png" alt="image">æœ¬äº¤æ˜“æ‰§è¡Œäº§ç”Ÿçš„æ‰€æœ‰logçš„å¸ƒéš†è¿‡æ»¤æ•°æ®<br><img src="/images/ethereum/source_analysis/sign_r_log.png" alt="image">äº¤æ˜“äº§ç”Ÿçš„æ—¥å¿—é›†åˆ</p><p><img src="/images/ethereum/source_analysis/sign_r_logentry.png" alt="image"> Log entry Oaæ—¥å¿—äº§ç”Ÿçš„åœ°å€ï¼Œ Ot topic Od æ—¶é—´</p><h2 id="äº¤æ˜“æ‰§è¡Œ"><a href="#äº¤æ˜“æ‰§è¡Œ" class="headerlink" title="äº¤æ˜“æ‰§è¡Œ"></a>äº¤æ˜“æ‰§è¡Œ</h2><p><img src="/images/ethereum/source_analysis/sign_substate_a.png" alt="image"> substate<br><img src="/images/ethereum/source_analysis/sign_substate_as.png" alt="image"> suicide set<br><img src="/images/ethereum/source_analysis/sign_substate_al.png" alt="image"> log series<br><img src="/images/ethereum/source_analysis/sign_substate_ar.png" alt="image"> refund balance</p><p><img src="/images/ethereum/source_analysis/sign_gas_total.png" alt="image"> äº¤æ˜“è¿‡ç¨‹ä¸­ä½¿ç”¨çš„æ€»gasæ•°é‡ã€‚<br><img src="/images/ethereum/source_analysis/sign_gas_log.png" alt="image">     äº¤æ˜“äº§ç”Ÿçš„æ—¥å¿—ã€‚</p><p><img src="/images/ethereum/source_analysis/sign_i_a.png" alt="image"> æ‰§è¡Œä»£ç çš„æ‹¥æœ‰è€…<br><img src="/images/ethereum/source_analysis/sign_i_o.png" alt="image"> äº¤æ˜“çš„å‘èµ·è€…<br><img src="/images/ethereum/source_analysis/sign_i_p.png" alt="image"> gasPrice<br><img src="/images/ethereum/source_analysis/sign_i_d.png" alt="image"> inputdata<br><img src="/images/ethereum/source_analysis/sign_i_s.png" alt="image"> å¼•èµ·ä»£ç æ‰§è¡Œçš„åœ°å€ï¼Œå¦‚æœæ˜¯äº¤æ˜“é‚£ä¹ˆæ˜¯äº¤æ˜“çš„å‘èµ·äºº<br><img src="/images/ethereum/source_analysis/sign_i_v.png" alt="image"> value<br><img src="/images/ethereum/source_analysis/sign_i_b.png" alt="image"> éœ€è¦æ‰§è¡Œçš„ä»£ç <br><img src="/images/ethereum/source_analysis/sign_i_h.png" alt="image"> å½“å‰çš„åŒºå—å¤´<br><img src="/images/ethereum/source_analysis/sign_i_e.png" alt="image"> å½“å‰çš„è°ƒç”¨æ·±åº¦</p><p><img src="/images/ethereum/source_analysis/sign_exec_model.png" alt="image"> æ‰§è¡Œæ¨¡å‹ s suicide set; l æ—¥å¿—é›†åˆ <strong>o</strong> è¾“å‡º ; r refund</p><p><img src="/images/ethereum/source_analysis/sign_exec_func.png" alt="image"> æ‰§è¡Œå‡½æ•°</p><p><img src="/images/ethereum/source_analysis/sign_m_g.png" alt="image"> å½“å‰å¯ç”¨çš„gas<br><img src="/images/ethereum/source_analysis/sign_u_pc.png" alt="image"> ç¨‹åºè®¡æ•°å™¨<br><img src="/images/ethereum/source_analysis/sign_u_m.png" alt="image"> å†…å­˜å†…å®¹<br><img src="/images/ethereum/source_analysis/sign_u_i.png" alt="image"> å†…å­˜ä¸­æœ‰æ•ˆçš„wordæ•°é‡<br><img src="/images/ethereum/source_analysis/sign_u_s.png" alt="image"> å †æ ˆå†…å®¹</p><p><img src="/images/ethereum/source_analysis/sign_m_w.png" alt="image"> wä»£è¡¨å½“å‰éœ€è¦æ‰§è¡Œçš„æŒ‡ä»¤</p><p><img src="/images/ethereum/source_analysis/sign_stack_removed.png" alt="image"> æŒ‡ä»¤éœ€è¦ç§»é™¤çš„å †æ ˆå¯¹è±¡ä¸ªæ•°<br><img src="/images/ethereum/source_analysis/sign_stack_added.png" alt="image"> æŒ‡ä»¤éœ€è¦å¢åŠ çš„å †æ ˆå¯¹è±¡ä¸ªæ•°</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-core-blockchainæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-blockchain%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-blockchain%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>ä»æµ‹è¯•æ¡ˆä¾‹æ¥çœ‹,blockchainçš„ä¸»è¦åŠŸèƒ½ç‚¹æœ‰ä¸‹é¢å‡ ç‚¹.</p><ol><li>import.</li><li>GetLastBlockçš„åŠŸèƒ½.</li><li>å¦‚æœæœ‰å¤šæ¡åŒºå—é“¾,å¯ä»¥é€‰å–å…¶ä¸­éš¾åº¦æœ€å¤§çš„ä¸€æ¡ä½œä¸ºè§„èŒƒçš„åŒºå—é“¾.</li><li>BadHashes å¯ä»¥æ‰‹å·¥ç¦æ­¢æ¥å—ä¸€äº›åŒºå—çš„hashå€¼.åœ¨blocks.goé‡Œé¢.</li><li>å¦‚æœæ–°é…ç½®äº†BadHashes. é‚£ä¹ˆåŒºå—å¯åŠ¨çš„æ—¶å€™ä¼šè‡ªåŠ¨ç¦æ­¢å¹¶è¿›å…¥æœ‰æ•ˆçŠ¶æ€.</li><li>é”™è¯¯çš„nonceä¼šè¢«æ‹’ç».</li><li>æ”¯æŒFast importing.</li><li>Light vs Fast vs Full processing åœ¨å¤„ç†åŒºå—å¤´ä¸Šé¢çš„æ•ˆæœç›¸ç­‰.</li></ol><p>å¯ä»¥çœ‹åˆ°blockchainçš„ä¸»è¦åŠŸèƒ½æ˜¯ç»´æŠ¤åŒºå—é“¾çš„çŠ¶æ€, åŒ…æ‹¬åŒºå—çš„éªŒè¯,æ’å…¥å’ŒçŠ¶æ€æŸ¥è¯¢.</p><p>åè¯è§£é‡Š:</p><p>ä»€ä¹ˆæ˜¯è§„èŒƒçš„åŒºå—é“¾</p><p>å› ä¸ºåœ¨åŒºå—çš„åˆ›å»ºè¿‡ç¨‹ä¸­,å¯èƒ½åœ¨çŸ­æ—¶é—´å†…äº§ç”Ÿä¸€äº›åˆ†å‰, åœ¨æˆ‘ä»¬çš„æ•°æ®åº“é‡Œé¢è®°å½•çš„å…¶å®æ˜¯ä¸€é¢—åŒºå—æ ‘.æˆ‘ä»¬ä¼šè®¤ä¸ºå…¶ä¸­æ€»éš¾åº¦æœ€é«˜çš„ä¸€æ¡è·¯å¾„è®¤ä¸ºæ˜¯æˆ‘ä»¬çš„è§„èŒƒçš„åŒºå—é“¾. è¿™æ ·æœ‰å¾ˆå¤šåŒºå—è™½ç„¶ä¹Ÿèƒ½å½¢æˆåŒºå—é“¾,ä½†æ˜¯ä¸æ˜¯è§„èŒƒçš„åŒºå—é“¾.</p><p>æ•°æ®åº“ç»“æ„:</p><pre><code>åŒºå—çš„hashå€¼å’ŒåŒºå—å¤´çš„hashå€¼æ˜¯åŒæ ·çš„ä¹ˆã€‚æ‰€è°“çš„åŒºå—çš„Hashå€¼å…¶å®å°±æ˜¯Headerçš„åŒºå—å€¼ã€‚// key -&gt; value// + ä»£è¡¨è¿æ¥"LastHeader"  æœ€æ–°çš„åŒºå—å¤´ HeaderChainä¸­ä½¿ç”¨"LastBlock"   æœ€æ–°çš„åŒºå—å¤´ BlockChain ä¸­ä½¿ç”¨"LastFast"    æœ€æ–°çš„å¿«é€ŸåŒæ­¥çš„åŒºå—å¤´"h"+num+"n" -&gt; hash  ç”¨æ¥å­˜å‚¨è§„èŒƒçš„åŒºå—é“¾çš„é«˜åº¦å’ŒåŒºå—å¤´çš„hashå€¼"h" + num + hash -&gt; header é«˜åº¦+hashå€¼ -&gt; åŒºå—å¤´"h" + num + hash + "t" -&gt; td  é«˜åº¦+hashå€¼ -&gt; æ€»éš¾åº¦"H" + hash -&gt; num  åŒºå—ä½“hash -&gt; é«˜åº¦"b" + num + hash -&gt; block body   é«˜åº¦+hashå€¼ -&gt; åŒºå—ä½“"r" + num + hash -&gt; block receipts  é«˜åº¦ + hashå€¼ -&gt; åŒºå—æ”¶æ®"l" + hash -&gt; transaction/receipt lookup metadata</code></pre><table><thead><tr><th>key</th><th>value</th><th>è¯´æ˜</th><th>æ’å…¥</th><th>åˆ é™¤</th></tr></thead><tbody><tr><td>â€œLastHeaderâ€</td><td>hash</td><td>æœ€æ–°çš„åŒºå—å¤´ HeaderChainä¸­ä½¿ç”¨</td><td>å½“åŒºå—è¢«è®¤ä¸ºæ˜¯å½“å‰æœ€æ–°çš„ä¸€ä¸ªè§„èŒƒçš„åŒºå—é“¾å¤´</td><td>å½“æœ‰äº†æ›´æ–°çš„åŒºå—é“¾å¤´æˆ–è€…æ˜¯åˆ†å‰çš„å…„å¼ŸåŒºå—é“¾æ›¿ä»£äº†å®ƒ</td></tr><tr><td>â€œLastBlockâ€</td><td>hash</td><td>æœ€æ–°çš„åŒºå—å¤´ BlockChainä¸­ä½¿ç”¨</td><td>å½“åŒºå—è¢«è®¤ä¸ºæ˜¯å½“å‰æœ€æ–°çš„ä¸€ä¸ªè§„èŒƒçš„åŒºå—é“¾å¤´</td><td>å½“æœ‰äº†æ›´æ–°çš„åŒºå—é“¾å¤´æˆ–è€…æ˜¯åˆ†å‰çš„å…„å¼ŸåŒºå—é“¾æ›¿ä»£äº†å®ƒ</td></tr><tr><td>â€œLastFastâ€</td><td>hash</td><td>æœ€æ–°çš„åŒºå—å¤´ BlockChainä¸­ä½¿ç”¨</td><td>å½“åŒºå—è¢«è®¤ä¸ºæ˜¯å½“å‰æœ€æ–°çš„è§„èŒƒçš„åŒºå—é“¾å¤´</td><td>å½“æœ‰äº†æ›´æ–°çš„åŒºå—é“¾å¤´æˆ–è€…æ˜¯åˆ†å‰çš„å…„å¼ŸåŒºå—é“¾æ›¿ä»£äº†å®ƒ</td></tr><tr><td>â€œhâ€+num+â€nâ€</td><td>hash</td><td>ç”¨æ¥å­˜å‚¨è§„èŒƒçš„åŒºå—é“¾çš„é«˜åº¦å’ŒåŒºå—å¤´çš„hashå€¼ åœ¨HeaderChainä¸­ä½¿ç”¨</td><td>å½“åŒºå—åœ¨è§„èŒƒçš„åŒºå—é“¾ä¸­</td><td>å½“åŒºå—ä¸åœ¨è§„èŒƒçš„åŒºå—é“¾ä¸­</td></tr><tr><td>â€œhâ€ + num + hash + â€œtâ€</td><td>td</td><td>æ€»éš¾åº¦</td><td>WriteBlockAndStateå½“éªŒè¯å¹¶æ‰§è¡Œå®Œä¸€ä¸ªåŒºå—ä¹‹å(ä¸ç®¡æ˜¯ä¸æ˜¯è§„èŒƒçš„)</td><td>SetHeadæ–¹æ³•ä¼šè°ƒç”¨ã€‚è¿™ç§æ–¹æ³•åªä¼šåœ¨ä¸¤ç§æƒ…å†µä¸‹è¢«è°ƒç”¨ï¼Œ1æ˜¯å½“å‰åŒºå—é“¾åŒ…å«äº†badhashsï¼Œéœ€è¦åˆ é™¤æ‰€æœ‰ä»badhashså¼€å§‹çš„åŒºå—ï¼Œ 2.æ˜¯å½“å‰åŒºå—çš„çŠ¶æ€é”™è¯¯ï¼Œéœ€è¦Resetåˆ°genesisã€‚</td></tr><tr><td>â€œHâ€ + hash</td><td>num</td><td>åŒºå—çš„é«˜åº¦ åœ¨HeaderChainä¸­ä½¿ç”¨</td><td>WriteBlockAndStateå½“éªŒè¯å¹¶æ‰§è¡Œå®Œä¸€ä¸ªåŒºå—ä¹‹å</td><td>SetHeadä¸­è¢«è°ƒç”¨ï¼ŒåŒä¸Š</td></tr><tr><td>â€œbâ€ + num + hash</td><td>block body</td><td>åŒºå—æ•°æ®</td><td>WriteBlockAndState or InsertReceiptChain</td><td>SetHeadä¸­è¢«åˆ é™¤ï¼ŒåŒä¸Š</td></tr><tr><td>â€œrâ€ + num + hash</td><td>block receipts</td><td>åŒºå—æ”¶æ®</td><td>WriteBlockAndState or InsertReceiptChain</td><td>åŒä¸Š</td></tr><tr><td>â€œlâ€ + txHash</td><td>{hash,num,TxIndex</td><td>äº¤æ˜“hashå¯ä»¥æ‰¾åˆ°åŒºå—å’Œäº¤æ˜“</td><td>å½“åŒºå—åŠ å…¥è§„èŒƒçš„åŒºå—é“¾</td><td>å½“åŒºå—ä»è§„èŒƒçš„åŒºå—é“¾ç§»é™¤</td></tr></tbody></table><p>æ•°æ®ç»“æ„</p><pre><code>// BlockChain represents the canonical chain given a database with a genesis// block. The Blockchain manages chain imports, reverts, chain reorganisations.// BlockChain è¡¨ç¤ºäº†ä¸€ä¸ªè§„èŒƒçš„é“¾,è¿™ä¸ªé“¾é€šè¿‡ä¸€ä¸ªåŒ…å«äº†åˆ›ä¸–åŒºå—çš„æ•°æ®åº“æŒ‡å®š. BlockChainç®¡ç†äº†é“¾çš„æ’å…¥,è¿˜åŸ,é‡å»ºç­‰æ“ä½œ.// Importing blocks in to the block chain happens according to the set of rules// defined by the two stage Validator. Processing of blocks is done using the// Processor which processes the included transaction. The validation of the state// is done in the second part of the Validator. Failing results in aborting of// the import.// æ’å…¥ä¸€ä¸ªåŒºå—éœ€è¦é€šè¿‡ä¸€ç³»åˆ—æŒ‡å®šçš„è§„åˆ™æŒ‡å®šçš„ä¸¤é˜¶æ®µçš„éªŒè¯å™¨. // ä½¿ç”¨Processoræ¥å¯¹åŒºå—çš„äº¤æ˜“è¿›è¡Œå¤„ç†. çŠ¶æ€çš„éªŒè¯æ˜¯ç¬¬äºŒé˜¶æ®µçš„éªŒè¯å™¨. é”™è¯¯å°†å¯¼è‡´æ’å…¥ç»ˆæ­¢.// The BlockChain also helps in returning blocks from **any** chain included// in the database as well as blocks that represents the canonical chain. It's// important to note that GetBlock can return any block and does not need to be// included in the canonical one where as GetBlockByNumber always represents the// canonical chain.// éœ€è¦æ³¨æ„çš„æ˜¯GetBlockå¯èƒ½è¿”å›ä»»æ„ä¸åœ¨å½“å‰è§„èŒƒåŒºå—é“¾ä¸­çš„åŒºå—, // ä½†æ˜¯GetBlockByNumber æ€»æ˜¯è¿”å›å½“å‰è§„èŒƒåŒºå—é“¾ä¸­çš„åŒºå—.type BlockChain struct {    config *params.ChainConfig // chain &amp; network configuration    hc            *HeaderChain        // åªåŒ…å«äº†åŒºå—å¤´çš„åŒºå—é“¾    chainDb       ethdb.Database    // åº•å±‚æ•°æ®åº“    rmLogsFeed    event.Feed        // ä¸‹é¢æ˜¯å¾ˆå¤šæ¶ˆæ¯é€šçŸ¥çš„ç»„ä»¶    chainFeed     event.Feed    chainSideFeed event.Feed    chainHeadFeed event.Feed    logsFeed      event.Feed    scope         event.SubscriptionScope    genesisBlock  *types.Block        // åˆ›ä¸–åŒºå—    mu      sync.RWMutex // global mutex for locking chain operations    chainmu sync.RWMutex // blockchain insertion lock    procmu  sync.RWMutex // block processor lock    checkpoint       int          // checkpoint counts towards the new checkpoint    currentBlock     *types.Block // Current head of the block chain å½“å‰çš„åŒºå—å¤´    currentFastBlock *types.Block // Current head of the fast-sync chain (may be above the block chain!) å½“å‰çš„å¿«é€ŸåŒæ­¥çš„åŒºå—å¤´.    stateCache   state.Database // State database to reuse between imports (contains state cache)    bodyCache    *lru.Cache     // Cache for the most recent block bodies    bodyRLPCache *lru.Cache     // Cache for the most recent block bodies in RLP encoded format    blockCache   *lru.Cache     // Cache for the most recent entire blocks    futureBlocks *lru.Cache     // future blocks are blocks added for later processing  æš‚æ—¶è¿˜ä¸èƒ½æ’å…¥çš„åŒºå—å­˜æ”¾ä½ç½®.    quit    chan struct{} // blockchain quit channel    running int32         // running must be called atomically    // procInterrupt must be atomically called    procInterrupt int32          // interrupt signaler for block processing    wg            sync.WaitGroup // chain processing wait group for shutting down    engine    consensus.Engine    // ä¸€è‡´æ€§å¼•æ“    processor Processor // block processor interface  // åŒºå—å¤„ç†å™¨æ¥å£    validator Validator // block and state validator interface // åŒºå—å’ŒçŠ¶æ€éªŒè¯å™¨æ¥å£    vmConfig  vm.Config //è™šæ‹Ÿæœºçš„é…ç½®    badBlocks *lru.Cache // Bad block cache  é”™è¯¯åŒºå—çš„ç¼“å­˜.}</code></pre><p>æ„é€ ,NewBlockChain ä½¿ç”¨æ•°æ®åº“é‡Œé¢çš„å¯ç”¨ä¿¡æ¯æ„é€ äº†ä¸€ä¸ªåˆå§‹åŒ–å¥½çš„åŒºå—é“¾. åŒæ—¶åˆå§‹åŒ–äº†ä»¥å¤ªåŠé»˜è®¤çš„ éªŒè¯å™¨å’Œå¤„ç†å™¨ (Validator and Processor)</p><pre><code>// NewBlockChain returns a fully initialised block chain using information// available in the database. It initialises the default Ethereum Validator and// Processor.func NewBlockChain(chainDb ethdb.Database, config *params.ChainConfig, engine consensus.Engine, vmConfig vm.Config) (*BlockChain, error) {    bodyCache, _ := lru.New(bodyCacheLimit)    bodyRLPCache, _ := lru.New(bodyCacheLimit)    blockCache, _ := lru.New(blockCacheLimit)    futureBlocks, _ := lru.New(maxFutureBlocks)    badBlocks, _ := lru.New(badBlockLimit)    bc := &amp;BlockChain{        config:       config,        chainDb:      chainDb,        stateCache:   state.NewDatabase(chainDb),        quit:         make(chan struct{}),        bodyCache:    bodyCache,        bodyRLPCache: bodyRLPCache,        blockCache:   blockCache,        futureBlocks: futureBlocks,        engine:       engine,        vmConfig:     vmConfig,        badBlocks:    badBlocks,    }    bc.SetValidator(NewBlockValidator(config, bc, engine))    bc.SetProcessor(NewStateProcessor(config, bc, engine))    var err error    bc.hc, err = NewHeaderChain(chainDb, config, engine, bc.getProcInterrupt)    if err != nil {        return nil, err    }    bc.genesisBlock = bc.GetBlockByNumber(0)  // æ‹¿åˆ°åˆ›ä¸–åŒºå—    if bc.genesisBlock == nil {        return nil, ErrNoGenesis    }    if err := bc.loadLastState(); err != nil { //åŠ è½½æœ€æ–°çš„çŠ¶æ€        return nil, err    }    // Check the current state of the block hashes and make sure that we do not have any of the bad blocks in our chain    // æ£€æŸ¥å½“å‰çš„çŠ¶æ€,ç¡®è®¤æˆ‘ä»¬çš„åŒºå—é“¾ä¸Šé¢æ²¡æœ‰éæ³•çš„åŒºå—.    // BadHashesæ˜¯ä¸€äº›æ‰‹å·¥é…ç½®çš„åŒºå—hashå€¼, ç”¨æ¥ç¡¬åˆ†å‰ä½¿ç”¨çš„.    for hash := range BadHashes {        if header := bc.GetHeaderByHash(hash); header != nil {            // get the canonical block corresponding to the offending header's number            // è·å–è§„èŒƒçš„åŒºå—é“¾ä¸Šé¢åŒæ ·é«˜åº¦çš„åŒºå—å¤´,å¦‚æœè¿™ä¸ªåŒºå—å¤´ç¡®å®æ˜¯åœ¨æˆ‘ä»¬çš„è§„èŒƒçš„åŒºå—é“¾ä¸Šçš„è¯,æˆ‘ä»¬éœ€è¦å›æ»šåˆ°è¿™ä¸ªåŒºå—å¤´çš„é«˜åº¦ - 1            headerByNumber := bc.GetHeaderByNumber(header.Number.Uint64())            // make sure the headerByNumber (if present) is in our current canonical chain            if headerByNumber != nil &amp;&amp; headerByNumber.Hash() == header.Hash() {                log.Error("Found bad hash, rewinding chain", "number", header.Number, "hash", header.ParentHash)                bc.SetHead(header.Number.Uint64() - 1)                log.Error("Chain rewind was successful, resuming normal operation")            }        }    }    // Take ownership of this particular state    go bc.update()    return bc, nil}</code></pre><p>loadLastState, åŠ è½½æ•°æ®åº“é‡Œé¢çš„æœ€æ–°çš„æˆ‘ä»¬çŸ¥é“çš„åŒºå—é“¾çŠ¶æ€. è¿™ä¸ªæ–¹æ³•å‡è®¾å·²ç»è·å–åˆ°é”äº†.</p><pre><code>// loadLastState loads the last known chain state from the database. This method// assumes that the chain manager mutex is held.func (bc *BlockChain) loadLastState() error {    // Restore the last known head block    // è¿”å›æˆ‘ä»¬çŸ¥é“çš„æœ€æ–°çš„åŒºå—çš„hash    head := GetHeadBlockHash(bc.chainDb)    if head == (common.Hash{}) { // å¦‚æœè·å–åˆ°äº†ç©º.é‚£ä¹ˆè®¤ä¸ºæ•°æ®åº“å·²ç»è¢«ç ´å.é‚£ä¹ˆè®¾ç½®åŒºå—é“¾ä¸ºåˆ›ä¸–åŒºå—.        // Corrupt or empty database, init from scratch        log.Warn("Empty database, resetting chain")        return bc.Reset()    }    // Make sure the entire head block is available    // æ ¹æ®blockHash æ¥æŸ¥æ‰¾block    currentBlock := bc.GetBlockByHash(head)    if currentBlock == nil {        // Corrupt or empty database, init from scratch        log.Warn("Head block missing, resetting chain", "hash", head)        return bc.Reset()    }    // Make sure the state associated with the block is available    // ç¡®è®¤å’Œè¿™ä¸ªåŒºå—çš„world stateæ˜¯å¦æ­£ç¡®.    if _, err := state.New(currentBlock.Root(), bc.stateCache); err != nil {        // Dangling block without a state associated, init from scratch        log.Warn("Head state missing, resetting chain", "number", currentBlock.Number(), "hash", currentBlock.Hash())        return bc.Reset()    }    // Everything seems to be fine, set as the head block    bc.currentBlock = currentBlock    // Restore the last known head header    // è·å–æœ€æ–°çš„åŒºå—å¤´çš„hash    currentHeader := bc.currentBlock.Header()    if head := GetHeadHeaderHash(bc.chainDb); head != (common.Hash{}) {        if header := bc.GetHeaderByHash(head); header != nil {            currentHeader = header        }    }    // header chain è®¾ç½®ä¸ºå½“å‰çš„åŒºå—å¤´.    bc.hc.SetCurrentHeader(currentHeader)    // Restore the last known head fast block    bc.currentFastBlock = bc.currentBlock    if head := GetHeadFastBlockHash(bc.chainDb); head != (common.Hash{}) {        if block := bc.GetBlockByHash(head); block != nil {            bc.currentFastBlock = block        }    }    // Issue a status log for the user ç”¨æ¥æ‰“å°æ—¥å¿—.    headerTd := bc.GetTd(currentHeader.Hash(), currentHeader.Number.Uint64())    blockTd := bc.GetTd(bc.currentBlock.Hash(), bc.currentBlock.NumberU64())    fastTd := bc.GetTd(bc.currentFastBlock.Hash(), bc.currentFastBlock.NumberU64())    log.Info("Loaded most recent local header", "number", currentHeader.Number, "hash", currentHeader.Hash(), "td", headerTd)    log.Info("Loaded most recent local full block", "number", bc.currentBlock.Number(), "hash", bc.currentBlock.Hash(), "td", blockTd)    log.Info("Loaded most recent local fast block", "number", bc.currentFastBlock.Number(), "hash", bc.currentFastBlock.Hash(), "td", fastTd)    return nil}</code></pre><p>goroutine updateçš„å¤„ç†éå¸¸ç®€å•. å®šæ—¶å¤„ç†future blocks.</p><pre><code>func (bc *BlockChain) update() {    futureTimer := time.Tick(5 * time.Second)    for {        select {        case &lt;-futureTimer:            bc.procFutureBlocks()        case &lt;-bc.quit:            return        }    }}</code></pre><p>Reset æ–¹æ³• é‡ç½®åŒºå—é“¾. </p><pre><code>// Reset purges the entire blockchain, restoring it to its genesis state.func (bc *BlockChain) Reset() error {    return bc.ResetWithGenesisBlock(bc.genesisBlock)}// ResetWithGenesisBlock purges the entire blockchain, restoring it to the// specified genesis state.func (bc *BlockChain) ResetWithGenesisBlock(genesis *types.Block) error {    // Dump the entire block chain and purge the caches    // æŠŠæ•´ä¸ªåŒºå—é“¾è½¬å‚¨å¹¶æ¸…æ¥šç¼“å­˜    if err := bc.SetHead(0); err != nil {        return err    }    bc.mu.Lock()    defer bc.mu.Unlock()    // Prepare the genesis block and reinitialise the chain    // ä½¿ç”¨åˆ›ä¸–åŒºå—é‡æ–°åˆå§‹åŒ–åŒºå—é“¾    if err := bc.hc.WriteTd(genesis.Hash(), genesis.NumberU64(), genesis.Difficulty()); err != nil {        log.Crit("Failed to write genesis block TD", "err", err)    }    if err := WriteBlock(bc.chainDb, genesis); err != nil {        log.Crit("Failed to write genesis block", "err", err)    }    bc.genesisBlock = genesis    bc.insert(bc.genesisBlock)    bc.currentBlock = bc.genesisBlock    bc.hc.SetGenesis(bc.genesisBlock.Header())    bc.hc.SetCurrentHeader(bc.genesisBlock.Header())    bc.currentFastBlock = bc.genesisBlock    return nil}</code></pre><p>SetHeadå°†æœ¬åœ°é“¾å›å·åˆ°æ–°çš„å¤´éƒ¨ã€‚ åœ¨ç»™å®šæ–°headerä¹‹ä¸Šçš„æ‰€æœ‰å†…å®¹éƒ½å°†è¢«åˆ é™¤ï¼Œæ–°çš„headerå°†è¢«è®¾ç½®ã€‚ å¦‚æœå—ä½“ä¸¢å¤±ï¼ˆå¿«é€ŸåŒæ­¥ä¹‹åçš„éå½’æ¡£èŠ‚ç‚¹ï¼‰ï¼Œå¤´éƒ¨å¯èƒ½è¢«è¿›ä¸€æ­¥å€’å›ã€‚</p><pre><code>// SetHead rewinds the local chain to a new head. In the case of headers, everything// above the new head will be deleted and the new one set. In the case of blocks// though, the head may be further rewound if block bodies are missing (non-archive// nodes after a fast sync).func (bc *BlockChain) SetHead(head uint64) error {    log.Warn("Rewinding blockchain", "target", head)    bc.mu.Lock()    defer bc.mu.Unlock()    // Rewind the header chain, deleting all block bodies until then    delFn := func(hash common.Hash, num uint64) {        DeleteBody(bc.chainDb, hash, num)    }    bc.hc.SetHead(head, delFn)    currentHeader := bc.hc.CurrentHeader()    // Clear out any stale content from the caches    bc.bodyCache.Purge()    bc.bodyRLPCache.Purge()    bc.blockCache.Purge()    bc.futureBlocks.Purge()    // Rewind the block chain, ensuring we don't end up with a stateless head block    if bc.currentBlock != nil &amp;&amp; currentHeader.Number.Uint64() &lt; bc.currentBlock.NumberU64() {        bc.currentBlock = bc.GetBlock(currentHeader.Hash(), currentHeader.Number.Uint64())    }    if bc.currentBlock != nil {        if _, err := state.New(bc.currentBlock.Root(), bc.stateCache); err != nil {            // Rewound state missing, rolled back to before pivot, reset to genesis            bc.currentBlock = nil        }    }    // Rewind the fast block in a simpleton way to the target head    if bc.currentFastBlock != nil &amp;&amp; currentHeader.Number.Uint64() &lt; bc.currentFastBlock.NumberU64() {        bc.currentFastBlock = bc.GetBlock(currentHeader.Hash(), currentHeader.Number.Uint64())    }    // If either blocks reached nil, reset to the genesis state    if bc.currentBlock == nil {        bc.currentBlock = bc.genesisBlock    }    if bc.currentFastBlock == nil {        bc.currentFastBlock = bc.genesisBlock    }    if err := WriteHeadBlockHash(bc.chainDb, bc.currentBlock.Hash()); err != nil {        log.Crit("Failed to reset head full block", "err", err)    }    if err := WriteHeadFastBlockHash(bc.chainDb, bc.currentFastBlock.Hash()); err != nil {        log.Crit("Failed to reset head fast block", "err", err)    }    return bc.loadLastState()}</code></pre><p>InsertChain,æ’å…¥åŒºå—é“¾, æ’å…¥åŒºå—é“¾å°è¯•æŠŠç»™å®šçš„åŒºå—æ’å…¥åˆ°è§„èŒƒçš„é“¾æ¡,æˆ–è€…æ˜¯åˆ›å»ºä¸€ä¸ªåˆ†å‰. å¦‚æœå‘ç”Ÿé”™è¯¯,é‚£ä¹ˆä¼šè¿”å›é”™è¯¯å‘ç”Ÿæ—¶å€™çš„indexå’Œå…·ä½“çš„é”™è¯¯ä¿¡æ¯.</p><pre><code>// InsertChain attempts to insert the given batch of blocks in to the canonical// chain or, otherwise, create a fork. If an error is returned it will return// the index number of the failing block as well an error describing what went// wrong.//// After insertion is done, all accumulated events will be fired.// åœ¨æ’å…¥å®Œæˆä¹‹å,æ‰€æœ‰ç´¯è®¡çš„äº‹ä»¶å°†è¢«è§¦å‘.func (bc *BlockChain) InsertChain(chain types.Blocks) (int, error) {    n, events, logs, err := bc.insertChain(chain)    bc.PostChainEvents(events, logs)    return n, err}</code></pre><p>insertChainæ–¹æ³•ä¼šæ‰§è¡ŒåŒºå—é“¾æ’å…¥,å¹¶æ”¶é›†äº‹ä»¶ä¿¡æ¯. å› ä¸ºéœ€è¦ä½¿ç”¨deferæ¥å¤„ç†è§£é”,æ‰€ä»¥æŠŠè¿™ä¸ªæ–¹æ³•ä½œä¸ºä¸€ä¸ªå•ç‹¬çš„æ–¹æ³•.</p><pre><code>// insertChain will execute the actual chain insertion and event aggregation. The// only reason this method exists as a separate one is to make locking cleaner// with deferred statements.func (bc *BlockChain) insertChain(chain types.Blocks) (int, []interface{}, []*types.Log, error) {    // Do a sanity check that the provided chain is actually ordered and linked    // åšä¸€ä¸ªå¥å…¨çš„æ£€æŸ¥ï¼Œæä¾›çš„é“¾å®é™…ä¸Šæ˜¯æœ‰åºçš„å’Œç›¸äº’é“¾æ¥çš„    for i := 1; i &lt; len(chain); i++ {        if chain[i].NumberU64() != chain[i-1].NumberU64()+1 || chain[i].ParentHash() != chain[i-1].Hash() {            // Chain broke ancestry, log a messge (programming error) and skip insertion            log.Error("Non contiguous block insert", "number", chain[i].Number(), "hash", chain[i].Hash(),                "parent", chain[i].ParentHash(), "prevnumber", chain[i-1].Number(), "prevhash", chain[i-1].Hash())            return 0, nil, nil, fmt.Errorf("non contiguous insert: item %d is #%d [%xâ€¦], item %d is #%d [%xâ€¦] (parent [%xâ€¦])", i-1, chain[i-1].NumberU64(),                chain[i-1].Hash().Bytes()[:4], i, chain[i].NumberU64(), chain[i].Hash().Bytes()[:4], chain[i].ParentHash().Bytes()[:4])        }    }    // Pre-checks passed, start the full block imports    bc.wg.Add(1)    defer bc.wg.Done()    bc.chainmu.Lock()    defer bc.chainmu.Unlock()    // A queued approach to delivering events. This is generally    // faster than direct delivery and requires much less mutex    // acquiring.    var (        stats         = insertStats{startTime: mclock.Now()}        events        = make([]interface{}, 0, len(chain))        lastCanon     *types.Block        coalescedLogs []*types.Log    )    // Start the parallel header verifier    headers := make([]*types.Header, len(chain))    seals := make([]bool, len(chain))    for i, block := range chain {        headers[i] = block.Header()        seals[i] = true    }    // è°ƒç”¨ä¸€è‡´æ€§å¼•æ“æ¥éªŒè¯åŒºå—å¤´æ˜¯æœ‰æ•ˆçš„.    abort, results := bc.engine.VerifyHeaders(bc, headers, seals)    defer close(abort)    // Iterate over the blocks and insert when the verifier permits    for i, block := range chain {        // If the chain is terminating, stop processing blocks        if atomic.LoadInt32(&amp;bc.procInterrupt) == 1 {            log.Debug("Premature abort during blocks processing")            break        }        // If the header is a banned one, straight out abort        // å¦‚æœåŒºå—å¤´è¢«ç¦æ­¢äº†.         if BadHashes[block.Hash()] {            bc.reportBlock(block, nil, ErrBlacklistedHash)            return i, events, coalescedLogs, ErrBlacklistedHash        }        // Wait for the block's verification to complete        bstart := time.Now()        err := &lt;-results        if err == nil { // å¦‚æœæ²¡æœ‰é”™è¯¯. éªŒè¯body            err = bc.Validator().ValidateBody(block)        }        if err != nil {            if err == ErrKnownBlock { // å¦‚æœåŒºå—å·²ç»æ’å…¥, ç›´æ¥ç»§ç»­                stats.ignored++                continue            }            if err == consensus.ErrFutureBlock {                 // Allow up to MaxFuture second in the future blocks. If this limit                // is exceeded the chain is discarded and processed at a later time                // if given.                // å¦‚æœæ˜¯æœªæ¥çš„åŒºå—, è€Œä¸”åŒºå—çš„æ—¶é—´è·ç¦»ç°åœ¨ä¸æ˜¯å¾ˆä¹…è¿œ. é‚£ä¹ˆå­˜æ”¾èµ·æ¥.                max := big.NewInt(time.Now().Unix() + maxTimeFutureBlocks)                if block.Time().Cmp(max) &gt; 0 {                    return i, events, coalescedLogs, fmt.Errorf("future block: %v &gt; %v", block.Time(), max)                }                bc.futureBlocks.Add(block.Hash(), block)                stats.queued++                continue            }            if err == consensus.ErrUnknownAncestor &amp;&amp; bc.futureBlocks.Contains(block.ParentHash()) { å¦‚æœåŒºå—æ²¡æœ‰æ‰¾åˆ°ç¥–å…ˆ è€Œåœ¨future blocks åŒ…å«äº†è¿™ä¸ªåŒºå—çš„ç¥–å…ˆ,é‚£ä¹ˆä¹Ÿå­˜æ”¾åœ¨future                bc.futureBlocks.Add(block.Hash(), block)                stats.queued++                continue            }            bc.reportBlock(block, nil, err)            return i, events, coalescedLogs, err        }        // Create a new statedb using the parent block and report an        // error if it fails.        var parent *types.Block        if i == 0 {            parent = bc.GetBlock(block.ParentHash(), block.NumberU64()-1)        } else {            parent = chain[i-1]        }        state, err := state.New(parent.Root(), bc.stateCache)        if err != nil {            return i, events, coalescedLogs, err        }        // Process block using the parent state as reference point.        // å¤„ç†åŒºå—,ç”Ÿæˆäº¤æ˜“,æ”¶æ®,æ—¥å¿—ç­‰ä¿¡æ¯.         // å®é™…ä¸Šè°ƒç”¨äº†state_processor.go é‡Œé¢çš„ Processæ–¹æ³•.        receipts, logs, usedGas, err := bc.processor.Process(block, state, bc.vmConfig)        if err != nil {            bc.reportBlock(block, receipts, err)            return i, events, coalescedLogs, err        }        // Validate the state using the default validator        // äºŒæ¬¡éªŒè¯,éªŒè¯çŠ¶æ€æ˜¯å¦åˆæ³•        err = bc.Validator().ValidateState(block, parent, state, receipts, usedGas)        if err != nil {            bc.reportBlock(block, receipts, err)            return i, events, coalescedLogs, err        }        // Write the block to the chain and get the status                // å†™å…¥åŒºå—å’ŒçŠ¶æ€.        status, err := bc.WriteBlockAndState(block, receipts, state)        if err != nil {            return i, events, coalescedLogs, err        }        switch status {        case CanonStatTy:  // æ’å…¥äº†æ–°çš„åŒºå—.            log.Debug("Inserted new block", "number", block.Number(), "hash", block.Hash(), "uncles", len(block.Uncles()),                "txs", len(block.Transactions()), "gas", block.GasUsed(), "elapsed", common.PrettyDuration(time.Since(bstart)))            coalescedLogs = append(coalescedLogs, logs...)            blockInsertTimer.UpdateSince(bstart)            events = append(events, ChainEvent{block, block.Hash(), logs})            lastCanon = block        case SideStatTy:  // æ’å…¥äº†ä¸€ä¸ªforked åŒºå—            log.Debug("Inserted forked block", "number", block.Number(), "hash", block.Hash(), "diff", block.Difficulty(), "elapsed",                common.PrettyDuration(time.Since(bstart)), "txs", len(block.Transactions()), "gas", block.GasUsed(), "uncles", len(block.Uncles()))            blockInsertTimer.UpdateSince(bstart)            events = append(events, ChainSideEvent{block})        }        stats.processed++        stats.usedGas += usedGas.Uint64()        stats.report(chain, i)    }    // Append a single chain head event if we've progressed the chain    // å¦‚æœæˆ‘ä»¬ç”Ÿæˆäº†ä¸€ä¸ªæ–°çš„åŒºå—å¤´, è€Œä¸”æœ€æ–°çš„åŒºå—å¤´ç­‰äºlastCanon    // é‚£ä¹ˆæˆ‘ä»¬å…¬å¸ƒä¸€ä¸ªæ–°çš„ ChainHeadEvent    if lastCanon != nil &amp;&amp; bc.LastBlockHash() == lastCanon.Hash() {        events = append(events, ChainHeadEvent{lastCanon})    }    return 0, events, coalescedLogs, nil}</code></pre><p>WriteBlockAndState,æŠŠåŒºå—å†™å…¥åŒºå—é“¾. </p><pre><code>// WriteBlock writes the block to the chain.func (bc *BlockChain) WriteBlockAndState(block *types.Block, receipts []*types.Receipt, state *state.StateDB) (status WriteStatus, err error) {    bc.wg.Add(1)    defer bc.wg.Done()    // Calculate the total difficulty of the block    // è®¡ç®—å¾…æ’å…¥çš„åŒºå—çš„æ€»éš¾åº¦    ptd := bc.GetTd(block.ParentHash(), block.NumberU64()-1)    if ptd == nil {        return NonStatTy, consensus.ErrUnknownAncestor    }    // Make sure no inconsistent state is leaked during insertion    // ç¡®ä¿åœ¨æ’å…¥è¿‡ç¨‹ä¸­æ²¡æœ‰ä¸ä¸€è‡´çš„çŠ¶æ€æ³„æ¼    bc.mu.Lock()    defer bc.mu.Unlock()    // è®¡ç®—å½“å‰åŒºå—çš„åŒºå—é“¾çš„æ€»éš¾åº¦.    localTd := bc.GetTd(bc.currentBlock.Hash(), bc.currentBlock.NumberU64())    // è®¡ç®—æ–°çš„åŒºå—é“¾çš„æ€»éš¾åº¦    externTd := new(big.Int).Add(block.Difficulty(), ptd)    // Irrelevant of the canonical status, write the block itself to the database    // å’Œè§„èŒƒåŒºå—æ²¡æœ‰å…³ç³»çš„çŠ¶æ€, å†™å…¥æ•°æ®åº“.  å†™å…¥åŒºå—çš„hash é«˜åº¦å’Œå¯¹åº”çš„æ€»éš¾åº¦.    if err := bc.hc.WriteTd(block.Hash(), block.NumberU64(), externTd); err != nil {        return NonStatTy, err    }    // Write other block data using a batch.    batch := bc.chainDb.NewBatch()    if err := WriteBlock(batch, block); err != nil { // å†™å…¥åŒºå—        return NonStatTy, err    }    if _, err := state.CommitTo(batch, bc.config.IsEIP158(block.Number())); err != nil {  //Commit        return NonStatTy, err    }    if err := WriteBlockReceipts(batch, block.Hash(), block.NumberU64(), receipts); err != nil { // å†™å…¥åŒºå—æ”¶æ®        return NonStatTy, err    }    // If the total difficulty is higher than our known, add it to the canonical chain    // Second clause in the if statement reduces the vulnerability to selfish mining.    // Please refer to http://www.cs.cornell.edu/~ie53/publications/btcProcFC.pdf    // å¦‚æœæ–°çš„åŒºå—çš„æ€»éš¾åº¦é«˜äºæˆ‘ä»¬å½“å‰çš„åŒºå—, æŠŠè¿™ä¸ªåŒºå—è®¾ç½®ä¸ºè§„èŒƒçš„åŒºå—.    // ç¬¬äºŒä¸ªè¡¨è¾¾å¼ ((externTd.Cmp(localTd) == 0 &amp;&amp; mrand.Float64() &lt; 0.5))     // æ˜¯ä¸ºäº†å‡å°‘è‡ªç§æŒ–çŸ¿çš„å¯èƒ½æ€§.    if externTd.Cmp(localTd) &gt; 0 || (externTd.Cmp(localTd) == 0 &amp;&amp; mrand.Float64() &lt; 0.5) {        // Reorganise the chain if the parent is not the head block        // å¦‚æœè¿™ä¸ªåŒºå—çš„çˆ¶åŒºå—ä¸æ˜¯å½“å‰çš„åŒºå—, è¯´æ˜å­˜åœ¨ä¸€ä¸ªåˆ†å‰.éœ€è¦è°ƒç”¨reorgé‡æ–°ç»„ç»‡åŒºå—é“¾.        if block.ParentHash() != bc.currentBlock.Hash() {            if err := bc.reorg(bc.currentBlock, block); err != nil {                return NonStatTy, err            }        }        // Write the positional metadata for transaction and receipt lookups        // "l" + txHash -&gt; {blockHash,blockNum,txIndex}        // æ ¹æ®äº¤æ˜“çš„hashå€¼æ¥æ‰¾åˆ°å¯¹åº”çš„åŒºå—ä»¥åŠå¯¹åº”çš„äº¤æ˜“ã€‚        if err := WriteTxLookupEntries(batch, block); err != nil {            return NonStatTy, err        }        // Write hash preimages        // hash(Keccak-256) -&gt; å¯¹åº”çš„æ•°æ® è¿™ä¸ªåŠŸèƒ½æ˜¯ç”¨æ¥æµ‹è¯•çš„ã€‚å¦‚æœå¼€å¯äº†devæ¨¡å¼ï¼Œ        // æˆ–è€…æ˜¯ vmdebugå‚æ•°ï¼Œ å¦‚æœæ‰§è¡Œ SHA3 æŒ‡ä»¤å°±ä¼šæ·»åŠ Preimage        if err := WritePreimages(bc.chainDb, block.NumberU64(), state.Preimages()); err != nil {            return NonStatTy, err        }        status = CanonStatTy    } else {        status = SideStatTy    }    if err := batch.Write(); err != nil {        return NonStatTy, err    }    // Set new head.    if status == CanonStatTy {        bc.insert(block)    }    bc.futureBlocks.Remove(block.Hash())    return status, nil}</code></pre><p>reorgsæ–¹æ³•æ˜¯åœ¨æ–°çš„é“¾çš„æ€»éš¾åº¦å¤§äºæœ¬åœ°é“¾çš„æ€»éš¾åº¦çš„æƒ…å†µä¸‹ï¼Œéœ€è¦ç”¨æ–°çš„åŒºå—é“¾æ¥æ›¿æ¢æœ¬åœ°çš„åŒºå—é“¾ä¸ºè§„èŒƒé“¾ã€‚</p><pre><code>// reorgs takes two blocks, an old chain and a new chain and will reconstruct the blocks and inserts them// to be part of the new canonical chain and accumulates potential missing transactions and post an// event about them// reorgs æ¥å—ä¸¤ä¸ªåŒºå—ä½œä¸ºå‚æ•°ï¼Œä¸€ä¸ªæ˜¯è€çš„åŒºå—é“¾ï¼Œä¸€ä¸ªæ–°çš„åŒºå—é“¾ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šæŠŠä»–ä»¬æ’å…¥// ä»¥ä¾¿é‡æ–°æ„å»ºå‡ºä¸€æ¡è§„èŒƒçš„åŒºå—é“¾ã€‚ åŒæ—¶ä¼šç´¯è®¡æ½œåœ¨ä¼šä¸¢å¤±çš„äº¤æ˜“å¹¶æŠŠå®ƒä»¬ä½œä¸ºäº‹ä»¶å‘å¸ƒå‡ºå»ã€‚func (bc *BlockChain) reorg(oldBlock, newBlock *types.Block) error {    var (        newChain    types.Blocks        oldChain    types.Blocks        commonBlock *types.Block        deletedTxs  types.Transactions        deletedLogs []*types.Log        // collectLogs collects the logs that were generated during the        // processing of the block that corresponds with the given hash.        // These logs are later announced as deleted.        // collectLogs ä¼šæ”¶é›†æˆ‘ä»¬å·²ç»ç”Ÿæˆçš„æ—¥å¿—ä¿¡æ¯ï¼Œè¿™äº›æ—¥å¿—ç¨åä¼šè¢«å£°æ˜åˆ é™¤(å®é™…ä¸Šåœ¨æ•°æ®åº“ä¸­å¹¶æ²¡æœ‰è¢«åˆ é™¤)ã€‚        collectLogs = func(h common.Hash) {            // Coalesce logs and set 'Removed'.            receipts := GetBlockReceipts(bc.chainDb, h, bc.hc.GetBlockNumber(h))            for _, receipt := range receipts {                for _, log := range receipt.Logs {                    del := *log                    del.Removed = true                    deletedLogs = append(deletedLogs, &amp;del)                }            }        }    )    // first reduce whoever is higher bound    if oldBlock.NumberU64() &gt; newBlock.NumberU64() {        // reduce old chain å¦‚æœè€çš„é“¾æ¯”æ–°çš„é“¾é«˜ã€‚é‚£ä¹ˆéœ€è¦å‡å°‘è€çš„é“¾ï¼Œè®©å®ƒå’Œæ–°é“¾ä¸€æ ·é«˜        for ; oldBlock != nil &amp;&amp; oldBlock.NumberU64() != newBlock.NumberU64(); oldBlock = bc.GetBlock(oldBlock.ParentHash(), oldBlock.NumberU64()-1) {            oldChain = append(oldChain, oldBlock)            deletedTxs = append(deletedTxs, oldBlock.Transactions()...)            collectLogs(oldBlock.Hash())        }    } else {        // reduce new chain and append new chain blocks for inserting later on        // å¦‚æœæ–°é“¾æ¯”è€é“¾è¦é«˜ï¼Œé‚£ä¹ˆå‡å°‘æ–°é“¾ã€‚        for ; newBlock != nil &amp;&amp; newBlock.NumberU64() != oldBlock.NumberU64(); newBlock = bc.GetBlock(newBlock.ParentHash(), newBlock.NumberU64()-1) {            newChain = append(newChain, newBlock)        }    }    if oldBlock == nil {        return fmt.Errorf("Invalid old chain")    }    if newBlock == nil {        return fmt.Errorf("Invalid new chain")    }    for { //è¿™ä¸ªforå¾ªç¯é‡Œé¢éœ€è¦æ‰¾åˆ°å…±åŒçš„ç¥–å…ˆã€‚        if oldBlock.Hash() == newBlock.Hash() {            commonBlock = oldBlock            break        }        oldChain = append(oldChain, oldBlock)        newChain = append(newChain, newBlock)        deletedTxs = append(deletedTxs, oldBlock.Transactions()...)        collectLogs(oldBlock.Hash())        oldBlock, newBlock = bc.GetBlock(oldBlock.ParentHash(), oldBlock.NumberU64()-1), bc.GetBlock(newBlock.ParentHash(), newBlock.NumberU64()-1)        if oldBlock == nil {            return fmt.Errorf("Invalid old chain")        }        if newBlock == nil {            return fmt.Errorf("Invalid new chain")        }    }    // Ensure the user sees large reorgs    if len(oldChain) &gt; 0 &amp;&amp; len(newChain) &gt; 0 {        logFn := log.Debug        if len(oldChain) &gt; 63 {            logFn = log.Warn        }        logFn("Chain split detected", "number", commonBlock.Number(), "hash", commonBlock.Hash(),            "drop", len(oldChain), "dropfrom", oldChain[0].Hash(), "add", len(newChain), "addfrom", newChain[0].Hash())    } else {        log.Error("Impossible reorg, please file an issue", "oldnum", oldBlock.Number(), "oldhash", oldBlock.Hash(), "newnum", newBlock.Number(), "newhash", newBlock.Hash())    }    var addedTxs types.Transactions    // insert blocks. Order does not matter. Last block will be written in ImportChain itself which creates the new head properly    for _, block := range newChain {        // insert the block in the canonical way, re-writing history        // æ’å…¥åŒºå— æ›´æ–°è®°å½•è§„èŒƒåŒºå—é“¾çš„key        bc.insert(block)        // write lookup entries for hash based transaction/receipt searches        // å†™å…¥äº¤æ˜“çš„æŸ¥è¯¢ä¿¡æ¯ã€‚        if err := WriteTxLookupEntries(bc.chainDb, block); err != nil {            return err        }        addedTxs = append(addedTxs, block.Transactions()...)    }    // calculate the difference between deleted and added transactions    diff := types.TxDifference(deletedTxs, addedTxs)    // When transactions get deleted from the database that means the    // receipts that were created in the fork must also be deleted    // åˆ é™¤é‚£äº›éœ€è¦åˆ é™¤çš„äº¤æ˜“æŸ¥è¯¢ä¿¡æ¯ã€‚     // è¿™é‡Œå¹¶æ²¡æœ‰åˆ é™¤é‚£äº›éœ€è¦åˆ é™¤çš„åŒºå—ï¼ŒåŒºå—å¤´ï¼Œæ”¶æ®ç­‰ä¿¡æ¯ã€‚    for _, tx := range diff {        DeleteTxLookupEntry(bc.chainDb, tx.Hash())    }    if len(deletedLogs) &gt; 0 { // å‘é€æ¶ˆæ¯é€šçŸ¥        go bc.rmLogsFeed.Send(RemovedLogsEvent{deletedLogs})    }    if len(oldChain) &gt; 0 {        go func() {            for _, block := range oldChain { // å‘é€æ¶ˆæ¯é€šçŸ¥ã€‚                bc.chainSideFeed.Send(ChainSideEvent{Block: block})            }        }()    }    return nil}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-core-stateæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-state%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-state%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>core/state åŒ…ä¸»è¦ä¸ºä»¥å¤ªåŠçš„state trieæä¾›äº†ä¸€å±‚ç¼“å­˜å±‚(cache)</p><p>stateçš„ç»“æ„ä¸»è¦å¦‚ä¸‹å›¾</p><p><img src="/images/ethereum/source_analysis/state_1.png" alt="image"></p><p>è“è‰²çš„çŸ©å½¢ä»£è¡¨æœ¬æ¨¡å—ï¼Œ ç°è‰²çš„çŸ©å½¢ä»£è¡¨å¤–éƒ¨æ¨¡å—ã€‚</p><ul><li>databaseä¸»è¦æä¾›äº†trieæ ‘çš„æŠ½è±¡ï¼Œæä¾›trieæ ‘çš„ç¼“å­˜å’Œåˆçº¦ä»£ç é•¿åº¦çš„ç¼“å­˜ã€‚</li><li>journalä¸»è¦æä¾›äº†æ“ä½œæ—¥å¿—ï¼Œä»¥åŠæ“ä½œå›æ»šçš„åŠŸèƒ½ã€‚ </li><li>state_objectæ˜¯accountå¯¹è±¡çš„æŠ½è±¡ï¼Œæä¾›äº†è´¦æˆ·çš„ä¸€äº›åŠŸèƒ½ã€‚ </li><li>statedbä¸»è¦æ˜¯æä¾›äº†state trieçš„éƒ¨åˆ†åŠŸèƒ½ã€‚</li></ul><h2 id="database-go"><a href="#database-go" class="headerlink" title="database.go"></a>database.go</h2><p>database.go æä¾›äº†ä¸€ä¸ªæ•°æ®åº“çš„æŠ½è±¡ã€‚</p><p>æ•°æ®ç»“æ„</p><pre><code>// Database wraps access to tries and contract code.type Database interface {    // Accessing tries:    // OpenTrie opens the main account trie.    // OpenStorageTrie opens the storage trie of an account.    // OpenTrie æ‰“å¼€äº†ä¸»è´¦å·çš„trieæ ‘    // OpenStorageTrie æ‰“å¼€äº†ä¸€ä¸ªè´¦å·çš„storage trie    OpenTrie(root common.Hash) (Trie, error)    OpenStorageTrie(addrHash, root common.Hash) (Trie, error)    // Accessing contract code:    // è®¿é—®åˆçº¦ä»£ç     ContractCode(addrHash, codeHash common.Hash) ([]byte, error)    // è®¿é—®åˆçº¦çš„å¤§å°ã€‚ è¿™ä¸ªæ–¹æ³•å¯èƒ½ç»å¸¸è¢«è°ƒç”¨ã€‚å› ä¸ºæœ‰ç¼“å­˜ã€‚    ContractCodeSize(addrHash, codeHash common.Hash) (int, error)    // CopyTrie returns an independent copy of the given trie.    // CopyTrie è¿”å›äº†ä¸€ä¸ªæŒ‡å®štrieçš„ç‹¬ç«‹çš„copy    CopyTrie(Trie) Trie}// NewDatabase creates a backing store for state. The returned database is safe for// concurrent use and retains cached trie nodes in memory.func NewDatabase(db ethdb.Database) Database {    csc, _ := lru.New(codeSizeCacheSize)    return &amp;cachingDB{db: db, codeSizeCache: csc}}type cachingDB struct {    db            ethdb.Database    mu            sync.Mutex    pastTries     []*trie.SecureTrie  //trieæ ‘çš„ç¼“å­˜    codeSizeCache *lru.Cache          //åˆçº¦ä»£ç å¤§å°çš„ç¼“å­˜}</code></pre><p>OpenTrieï¼Œä»ç¼“å­˜é‡Œé¢æŸ¥æ‰¾ã€‚å¦‚æœæ‰¾åˆ°äº†è¿”å›ç¼“å­˜çš„trieçš„copyï¼Œ å¦åˆ™é‡æ–°æ„å»ºä¸€é¢—æ ‘è¿”å›ã€‚</p><pre><code>func (db *cachingDB) OpenTrie(root common.Hash) (Trie, error) {    db.mu.Lock()    defer db.mu.Unlock()    for i := len(db.pastTries) - 1; i &gt;= 0; i-- {        if db.pastTries[i].Hash() == root {            return cachedTrie{db.pastTries[i].Copy(), db}, nil        }    }    tr, err := trie.NewSecure(root, db.db, MaxTrieCacheGen)    if err != nil {        return nil, err    }    return cachedTrie{tr, db}, nil}func (db *cachingDB) OpenStorageTrie(addrHash, root common.Hash) (Trie, error) {    return trie.NewSecure(root, db.db, 0)}</code></pre><p>ContractCode å’Œ ContractCodeSize, ContractCodeSizeæœ‰ç¼“å­˜ã€‚</p><pre><code>func (db *cachingDB) ContractCode(addrHash, codeHash common.Hash) ([]byte, error) {    code, err := db.db.Get(codeHash[:])    if err == nil {        db.codeSizeCache.Add(codeHash, len(code))    }    return code, err}func (db *cachingDB) ContractCodeSize(addrHash, codeHash common.Hash) (int, error) {    if cached, ok := db.codeSizeCache.Get(codeHash); ok {        return cached.(int), nil    }    code, err := db.ContractCode(addrHash, codeHash)    if err == nil {        db.codeSizeCache.Add(codeHash, len(code))    }    return len(code), err}</code></pre><p>cachedTrieçš„ç»“æ„å’Œcommitæ–¹æ³•ï¼Œcommitçš„æ—¶å€™ä¼šè°ƒç”¨pushTrieæ–¹æ³•æŠŠä¹‹å‰çš„Trieæ ‘ç¼“å­˜èµ·æ¥ã€‚</p><pre><code>// cachedTrie inserts its trie into a cachingDB on commit.type cachedTrie struct {    *trie.SecureTrie    db *cachingDB}func (m cachedTrie) CommitTo(dbw trie.DatabaseWriter) (common.Hash, error) {    root, err := m.SecureTrie.CommitTo(dbw)    if err == nil {        m.db.pushTrie(m.SecureTrie)    }    return root, err}func (db *cachingDB) pushTrie(t *trie.SecureTrie) {    db.mu.Lock()    defer db.mu.Unlock()    if len(db.pastTries) &gt;= maxPastTries {        copy(db.pastTries, db.pastTries[1:])        db.pastTries[len(db.pastTries)-1] = t    } else {        db.pastTries = append(db.pastTries, t)    }}</code></pre><h2 id="journal-go"><a href="#journal-go" class="headerlink" title="journal.go"></a>journal.go</h2><p>journalä»£è¡¨äº†æ“ä½œæ—¥å¿—ï¼Œ å¹¶é’ˆå¯¹å„ç§æ“ä½œçš„æ—¥å¿—æä¾›äº†å¯¹åº”çš„å›æ»šåŠŸèƒ½ã€‚ å¯ä»¥åŸºäºè¿™ä¸ªæ—¥å¿—æ¥åšä¸€äº›äº‹åŠ¡ç±»å‹çš„æ“ä½œã€‚</p><p>ç±»å‹å®šä¹‰ï¼Œå®šä¹‰äº†journalEntryè¿™ä¸ªæ¥å£ï¼Œæä¾›äº†undoçš„åŠŸèƒ½ã€‚ journal å°±æ˜¯journalEntryçš„åˆ—è¡¨ã€‚</p><pre><code>type journalEntry interface {    undo(*StateDB)}type journal []journalEntry</code></pre><p>å„ç§ä¸åŒçš„æ—¥å¿—ç±»å‹ä»¥åŠundoæ–¹æ³•ã€‚</p><pre><code>createObjectChange struct {  //åˆ›å»ºå¯¹è±¡çš„æ—¥å¿—ã€‚ undoæ–¹æ³•å°±æ˜¯ä»StateDBä¸­åˆ é™¤åˆ›å»ºçš„å¯¹è±¡ã€‚    account *common.Address}func (ch createObjectChange) undo(s *StateDB) {    delete(s.stateObjects, *ch.account)    delete(s.stateObjectsDirty, *ch.account)}// å¯¹äºstateObjectçš„ä¿®æ”¹ï¼Œ undoæ–¹æ³•å°±æ˜¯æŠŠå€¼æ”¹ä¸ºåŸæ¥çš„å¯¹è±¡ã€‚resetObjectChange struct {    prev *stateObject}func (ch resetObjectChange) undo(s *StateDB) {    s.setStateObject(ch.prev)}// è‡ªæ€çš„æ›´æ”¹ã€‚è‡ªæ€åº”è¯¥æ˜¯åˆ é™¤è´¦å·ï¼Œä½†æ˜¯å¦‚æœæ²¡æœ‰commitçš„åŒ–ï¼Œå¯¹è±¡è¿˜æ²¡æœ‰ä»stateDBåˆ é™¤ã€‚suicideChange struct {    account     *common.Address    prev        bool // whether account had already suicided    prevbalance *big.Int}func (ch suicideChange) undo(s *StateDB) {    obj := s.getStateObject(*ch.account)    if obj != nil {        obj.suicided = ch.prev        obj.setBalance(ch.prevbalance)    }}// Changes to individual accounts.balanceChange struct {    account *common.Address    prev    *big.Int}nonceChange struct {    account *common.Address    prev    uint64}storageChange struct {    account       *common.Address    key, prevalue common.Hash}codeChange struct {    account            *common.Address    prevcode, prevhash []byte}func (ch balanceChange) undo(s *StateDB) {    s.getStateObject(*ch.account).setBalance(ch.prev)}func (ch nonceChange) undo(s *StateDB) {    s.getStateObject(*ch.account).setNonce(ch.prev)}func (ch codeChange) undo(s *StateDB) {    s.getStateObject(*ch.account).setCode(common.BytesToHash(ch.prevhash), ch.prevcode)}func (ch storageChange) undo(s *StateDB) {    s.getStateObject(*ch.account).setState(ch.key, ch.prevalue)}// æˆ‘ç†è§£æ˜¯DAOäº‹ä»¶çš„é€€æ¬¾å¤„ç†refundChange struct {    prev *big.Int}func (ch refundChange) undo(s *StateDB) {    s.refund = ch.prev}// å¢åŠ äº†æ—¥å¿—çš„ä¿®æ”¹addLogChange struct {    txhash common.Hash}func (ch addLogChange) undo(s *StateDB) {    logs := s.logs[ch.txhash]    if len(logs) == 1 {        delete(s.logs, ch.txhash)    } else {        s.logs[ch.txhash] = logs[:len(logs)-1]    }    s.logSize--}// è¿™ä¸ªæ˜¯å¢åŠ  VMçœ‹åˆ°çš„ SHA3çš„ åŸå§‹byte[], å¢åŠ SHA3 hash -&gt; byte[] çš„å¯¹åº”å…³ç³»addPreimageChange struct {    hash common.Hash}func (ch addPreimageChange) undo(s *StateDB) {    delete(s.preimages, ch.hash)}touchChange struct {    account   *common.Address    prev      bool    prevDirty bool}var ripemd = common.HexToAddress("0000000000000000000000000000000000000003")func (ch touchChange) undo(s *StateDB) {    if !ch.prev &amp;&amp; *ch.account != ripemd {        s.getStateObject(*ch.account).touched = ch.prev        if !ch.prevDirty {            delete(s.stateObjectsDirty, *ch.account)        }    }}</code></pre><h2 id="state-object-go"><a href="#state-object-go" class="headerlink" title="state_object.go"></a>state_object.go</h2><p>stateObjectè¡¨ç¤ºæ­£åœ¨ä¿®æ”¹çš„ä»¥å¤ªåŠå¸æˆ·ã€‚</p><p>æ•°æ®ç»“æ„</p><pre><code>type Storage map[common.Hash]common.Hash// stateObject represents an Ethereum account which is being modified.// stateObjectè¡¨ç¤ºæ­£åœ¨ä¿®æ”¹çš„ä»¥å¤ªåŠå¸æˆ·ã€‚// The usage pattern is as follows:// First you need to obtain a state object.// Account values can be accessed and modified through the object.// Finally, call CommitTrie to write the modified storage trie into a database.ä½¿ç”¨æ¨¡å¼å¦‚ä¸‹ï¼šé¦–å…ˆä½ éœ€è¦è·å¾—ä¸€ä¸ªstate_objectã€‚å¸æˆ·å€¼å¯ä»¥é€šè¿‡å¯¹è±¡è®¿é—®å’Œä¿®æ”¹ã€‚æœ€åï¼Œè°ƒç”¨CommitTrieå°†ä¿®æ”¹åçš„å­˜å‚¨trieå†™å…¥æ•°æ®åº“ã€‚type stateObject struct {    address  common.Address    addrHash common.Hash // hash of ethereum address of the account ä»¥å¤ªåŠè´¦å·åœ°å€çš„hashå€¼    data     Account  // è¿™ä¸ªæ˜¯å®é™…çš„ä»¥å¤ªåŠè´¦å·çš„ä¿¡æ¯    db       *StateDB //çŠ¶æ€æ•°æ®åº“    // DB error.    // State objects are used by the consensus core and VM which are    // unable to deal with database-level errors. Any error that occurs    // during a database read is memoized here and will eventually be returned    // by StateDB.Commit.    //     æ•°æ®åº“é”™è¯¯ã€‚    stateObjectä¼šè¢«å…±è¯†ç®—æ³•çš„æ ¸å¿ƒå’ŒVMä½¿ç”¨ï¼Œåœ¨è¿™äº›ä»£ç å†…éƒ¨æ— æ³•å¤„ç†æ•°æ®åº“çº§åˆ«çš„é”™è¯¯ã€‚     åœ¨æ•°æ®åº“è¯»å–æœŸé—´å‘ç”Ÿçš„ä»»ä½•é”™è¯¯éƒ½ä¼šåœ¨è¿™é‡Œè¢«å­˜å‚¨ï¼Œæœ€ç»ˆå°†ç”±StateDB.Commitè¿”å›ã€‚    dbErr error    // Write caches.  å†™ç¼“å­˜    trie Trie // storage trie, which becomes non-nil on first access ç”¨æˆ·çš„å­˜å‚¨trie ï¼Œåœ¨ç¬¬ä¸€æ¬¡è®¿é—®çš„æ—¶å€™å˜å¾—éç©º    code Code // contract bytecode, which gets set when code is loaded åˆçº¦ä»£ç ï¼Œå½“ä»£ç è¢«åŠ è½½çš„æ—¶å€™è¢«è®¾ç½®    cachedStorage Storage // Storage entry cache to avoid duplicate reads ç”¨æˆ·å­˜å‚¨å¯¹è±¡çš„ç¼“å­˜ï¼Œç”¨æ¥é¿å…é‡å¤è¯»    dirtyStorage  Storage // Storage entries that need to be flushed to disk éœ€è¦åˆ·å…¥ç£ç›˜çš„ç”¨æˆ·å­˜å‚¨å¯¹è±¡    // Cache flags.  Cache æ ‡å¿—    // When an object is marked suicided it will be delete from the trie    // during the "update" phase of the state transition.    // å½“ä¸€ä¸ªå¯¹è±¡è¢«æ ‡è®°ä¸ºè‡ªæ€æ—¶ï¼Œå®ƒå°†åœ¨çŠ¶æ€è½¬æ¢çš„â€œæ›´æ–°â€é˜¶æ®µæœŸé—´ä»æ ‘ä¸­åˆ é™¤ã€‚    dirtyCode bool // true if the code was updated å¦‚æœä»£ç è¢«æ›´æ–°ï¼Œä¼šè®¾ç½®ä¸ºtrue    suicided  bool    touched   bool    deleted   bool    onDirty   func(addr common.Address) // Callback method to mark a state object newly dirty  ç¬¬ä¸€æ¬¡è¢«è®¾ç½®ä¸ºdrityçš„æ—¶å€™ä¼šè¢«è°ƒç”¨ã€‚}// Account is the Ethereum consensus representation of accounts.// These objects are stored in the main account trie.// å¸æˆ·æ˜¯ä»¥å¤ªåŠå…±è¯†è¡¨ç¤ºçš„å¸æˆ·ã€‚ è¿™äº›å¯¹è±¡å­˜å‚¨åœ¨main account trieã€‚type Account struct {    Nonce    uint64    Balance  *big.Int    Root     common.Hash // merkle root of the storage trie    CodeHash []byte}</code></pre><p>æ„é€ å‡½æ•°</p><pre><code>// newObject creates a state object.func newObject(db *StateDB, address common.Address, data Account, onDirty func(addr common.Address)) *stateObject {    if data.Balance == nil {        data.Balance = new(big.Int)    }    if data.CodeHash == nil {        data.CodeHash = emptyCodeHash    }    return &amp;stateObject{        db:            db,        address:       address,        addrHash:      crypto.Keccak256Hash(address[:]),        data:          data,        cachedStorage: make(Storage),        dirtyStorage:  make(Storage),        onDirty:       onDirty,    }}</code></pre><p>RLPçš„ç¼–ç æ–¹å¼ï¼Œåªä¼šç¼–ç  Accountå¯¹è±¡ã€‚</p><pre><code>// EncodeRLP implements rlp.Encoder.func (c *stateObject) EncodeRLP(w io.Writer) error {    return rlp.Encode(w, c.data)}</code></pre><p>ä¸€äº›çŠ¶æ€æ”¹å˜çš„å‡½æ•°ã€‚</p><pre><code>func (self *stateObject) markSuicided() {    self.suicided = true    if self.onDirty != nil {        self.onDirty(self.Address())        self.onDirty = nil    }}func (c *stateObject) touch() {    c.db.journal = append(c.db.journal, touchChange{        account:   &amp;c.address,        prev:      c.touched,        prevDirty: c.onDirty == nil,    })    if c.onDirty != nil {        c.onDirty(c.Address())        c.onDirty = nil    }    c.touched = true}</code></pre><p>Storageçš„å¤„ç†</p><pre><code>// getTrieè¿”å›è´¦æˆ·çš„Storage Triefunc (c *stateObject) getTrie(db Database) Trie {    if c.trie == nil {        var err error        c.trie, err = db.OpenStorageTrie(c.addrHash, c.data.Root)        if err != nil {            c.trie, _ = db.OpenStorageTrie(c.addrHash, common.Hash{})            c.setError(fmt.Errorf("can't create storage trie: %v", err))        }    }    return c.trie}// GetState returns a value in account storage.// GetState è¿”å›account storage çš„ä¸€ä¸ªå€¼ï¼Œè¿™ä¸ªå€¼çš„ç±»å‹æ˜¯Hashç±»å‹ã€‚// è¯´æ˜account storageé‡Œé¢åªèƒ½å­˜å‚¨hashå€¼ï¼Ÿ// å¦‚æœç¼“å­˜é‡Œé¢å­˜åœ¨å°±ä»ç¼“å­˜é‡ŒæŸ¥æ‰¾ï¼Œå¦åˆ™ä»æ•°æ®åº“é‡Œé¢æŸ¥è¯¢ã€‚ç„¶åå­˜å‚¨åˆ°ç¼“å­˜é‡Œé¢ã€‚func (self *stateObject) GetState(db Database, key common.Hash) common.Hash {    value, exists := self.cachedStorage[key]    if exists {        return value    }    // Load from DB in case it is missing.    enc, err := self.getTrie(db).TryGet(key[:])    if err != nil {        self.setError(err)        return common.Hash{}    }    if len(enc) &gt; 0 {        _, content, _, err := rlp.Split(enc)        if err != nil {            self.setError(err)        }        value.SetBytes(content)    }    if (value != common.Hash{}) {        self.cachedStorage[key] = value    }    return value}// SetState updates a value in account storage.// å¾€ account storeage é‡Œé¢è®¾ç½®ä¸€ä¸ªå€¼ key value çš„ç±»å‹éƒ½æ˜¯Hashç±»å‹ã€‚func (self *stateObject) SetState(db Database, key, value common.Hash) {    self.db.journal = append(self.db.journal, storageChange{        account:  &amp;self.address,        key:      key,        prevalue: self.GetState(db, key),    })    self.setState(key, value)}func (self *stateObject) setState(key, value common.Hash) {    self.cachedStorage[key] = value    self.dirtyStorage[key] = value    if self.onDirty != nil {        self.onDirty(self.Address())        self.onDirty = nil    }}</code></pre><p>æäº¤ Commit</p><pre><code>// CommitTrie the storage trie of the object to dwb.// This updates the trie root.// æ­¥éª¤ï¼Œé¦–å…ˆæ‰“å¼€ï¼Œç„¶åä¿®æ”¹ï¼Œç„¶åæäº¤æˆ–è€…å›æ»šfunc (self *stateObject) CommitTrie(db Database, dbw trie.DatabaseWriter) error {    self.updateTrie(db) // updateTrieæŠŠä¿®æ”¹è¿‡çš„ç¼“å­˜å†™å…¥Trieæ ‘    if self.dbErr != nil {        return self.dbErr    }    root, err := self.trie.CommitTo(dbw)    if err == nil {        self.data.Root = root    }    return err}// updateTrie writes cached storage modifications into the object's storage trie.func (self *stateObject) updateTrie(db Database) Trie {    tr := self.getTrie(db)    for key, value := range self.dirtyStorage {        delete(self.dirtyStorage, key)        if (value == common.Hash{}) {            self.setError(tr.TryDelete(key[:]))            continue        }        // Encoding []byte cannot fail, ok to ignore the error.        v, _ := rlp.EncodeToBytes(bytes.TrimLeft(value[:], "\x00"))        self.setError(tr.TryUpdate(key[:], v))    }    return tr}// UpdateRoot sets the trie root to the current root hash of// æŠŠè´¦å·çš„rootè®¾ç½®ä¸ºå½“å‰çš„trieæ ‘çš„è·Ÿã€‚func (self *stateObject) updateRoot(db Database) {    self.updateTrie(db)    self.data.Root = self.trie.Hash()}</code></pre><p>é¢å¤–çš„ä¸€äº›åŠŸèƒ½ ï¼ŒdeepCopyæä¾›äº†state_objectçš„æ·±æ‹·è´ã€‚</p><pre><code>func (self *stateObject) deepCopy(db *StateDB, onDirty func(addr common.Address)) *stateObject {    stateObject := newObject(db, self.address, self.data, onDirty)    if self.trie != nil {        stateObject.trie = db.db.CopyTrie(self.trie)    }    stateObject.code = self.code    stateObject.dirtyStorage = self.dirtyStorage.Copy()    stateObject.cachedStorage = self.dirtyStorage.Copy()    stateObject.suicided = self.suicided    stateObject.dirtyCode = self.dirtyCode    stateObject.deleted = self.deleted    return stateObject}</code></pre><h2 id="statedb-go"><a href="#statedb-go" class="headerlink" title="statedb.go"></a>statedb.go</h2><p>stateDBç”¨æ¥å­˜å‚¨ä»¥å¤ªåŠä¸­å…³äºmerkle trieçš„æ‰€æœ‰å†…å®¹ã€‚ StateDBè´Ÿè´£ç¼“å­˜å’Œå­˜å‚¨åµŒå¥—çŠ¶æ€ã€‚ è¿™æ˜¯æ£€ç´¢åˆçº¦å’Œè´¦æˆ·çš„ä¸€èˆ¬æŸ¥è¯¢ç•Œé¢ï¼š</p><p>æ•°æ®ç»“æ„</p><pre><code>type StateDB struct {    db   Database  // åç«¯çš„æ•°æ®åº“    trie Trie       // trieæ ‘ main account trie    // This map holds 'live' objects, which will get modified while processing a state transition.    // ä¸‹é¢çš„Mapç”¨æ¥å­˜å‚¨å½“å‰æ´»åŠ¨çš„å¯¹è±¡ï¼Œè¿™äº›å¯¹è±¡åœ¨çŠ¶æ€è½¬æ¢çš„æ—¶å€™ä¼šè¢«ä¿®æ”¹ã€‚    // stateObjects ç”¨æ¥ç¼“å­˜å¯¹è±¡    // stateObjectsDirtyç”¨æ¥ç¼“å­˜è¢«ä¿®æ”¹è¿‡çš„å¯¹è±¡ã€‚    stateObjects      map[common.Address]*stateObject    stateObjectsDirty map[common.Address]struct{}    // DB error.    // State objects are used by the consensus core and VM which are    // unable to deal with database-level errors. Any error that occurs    // during a database read is memoized here and will eventually be returned    // by StateDB.Commit.    dbErr error    // The refund counter, also used by state transitioning.    // refundè®¡æ•°å™¨ã€‚ æš‚æ—¶è¿˜ä¸æ¸…æ¥šåŠŸèƒ½ã€‚    refund *big.Int    thash, bhash common.Hash  //å½“å‰çš„transaction hash å’Œblock hash     txIndex      int          // å½“å‰çš„äº¤æ˜“çš„index    logs         map[common.Hash][]*types.Log // æ—¥å¿— keyæ˜¯äº¤æ˜“çš„hashå€¼    logSize      uint    preimages map[common.Hash][]byte  // EVMè®¡ç®—çš„ SHA3-&gt;byte[]çš„æ˜ å°„å…³ç³»    // Journal of state modifications. This is the backbone of    // Snapshot and RevertToSnapshot.    // çŠ¶æ€ä¿®æ”¹æ—¥å¿—ã€‚ è¿™æ˜¯Snapshotå’ŒRevertToSnapshotçš„æ”¯æŸ±ã€‚    journal        journal    validRevisions []revision    nextRevisionId int    lock sync.Mutex}</code></pre><p>æ„é€ å‡½æ•°</p><pre><code>// ä¸€èˆ¬çš„ç”¨æ³• statedb, _ := state.New(common.Hash{}, state.NewDatabase(db))// Create a new state from a given triefunc New(root common.Hash, db Database) (*StateDB, error) {    tr, err := db.OpenTrie(root)    if err != nil {        return nil, err    }    return &amp;StateDB{        db:                db,        trie:              tr,        stateObjects:      make(map[common.Address]*stateObject),        stateObjectsDirty: make(map[common.Address]struct{}),        refund:            new(big.Int),        logs:              make(map[common.Hash][]*types.Log),        preimages:         make(map[common.Hash][]byte),    }, nil}</code></pre><h3 id="å¯¹äºLogçš„å¤„ç†"><a href="#å¯¹äºLogçš„å¤„ç†" class="headerlink" title="å¯¹äºLogçš„å¤„ç†"></a>å¯¹äºLogçš„å¤„ç†</h3><p>stateæä¾›äº†Logçš„å¤„ç†ï¼Œè¿™æ¯”è¾ƒæ„å¤–ï¼Œå› ä¸ºLogå®é™…ä¸Šæ˜¯å­˜å‚¨åœ¨åŒºå—é“¾ä¸­çš„ï¼Œå¹¶æ²¡æœ‰å­˜å‚¨åœ¨state trieä¸­, stateæä¾›Logçš„å¤„ç†ï¼Œ ä½¿ç”¨äº†åŸºäºä¸‹é¢çš„å‡ ä¸ªå‡½æ•°ã€‚  å¥‡æ€ªçš„æ˜¯æš‚æ—¶æ²¡çœ‹åˆ°å¦‚ä½•åˆ é™¤logsé‡Œé¢çš„ä¿¡æ¯ï¼Œå¦‚æœä¸åˆ é™¤çš„è¯ï¼Œåº”è¯¥ä¼šè¶Šç§¯ç´¯è¶Šå¤šã€‚ TODO logs åˆ é™¤</p><p>Prepareå‡½æ•°ï¼Œåœ¨äº¤æ˜“æ‰§è¡Œå¼€å§‹è¢«æ‰§è¡Œã€‚</p><p>AddLogå‡½æ•°ï¼Œåœ¨äº¤æ˜“æ‰§è¡Œè¿‡ç¨‹ä¸­è¢«VMæ‰§è¡Œã€‚æ·»åŠ æ—¥å¿—ã€‚åŒæ—¶æŠŠæ—¥å¿—å’Œäº¤æ˜“å…³è”èµ·æ¥ï¼Œæ·»åŠ éƒ¨åˆ†äº¤æ˜“çš„ä¿¡æ¯ã€‚</p><p>GetLogså‡½æ•°ï¼Œäº¤æ˜“å®Œæˆå–èµ°ã€‚</p><pre><code>// Prepare sets the current transaction hash and index and block hash which is// used when the EVM emits new state logs.func (self *StateDB) Prepare(thash, bhash common.Hash, ti int) {    self.thash = thash    self.bhash = bhash    self.txIndex = ti}func (self *StateDB) AddLog(log *types.Log) {    self.journal = append(self.journal, addLogChange{txhash: self.thash})    log.TxHash = self.thash    log.BlockHash = self.bhash    log.TxIndex = uint(self.txIndex)    log.Index = self.logSize    self.logs[self.thash] = append(self.logs[self.thash], log)    self.logSize++}func (self *StateDB) GetLogs(hash common.Hash) []*types.Log {    return self.logs[hash]}func (self *StateDB) Logs() []*types.Log {    var logs []*types.Log    for _, lgs := range self.logs {        logs = append(logs, lgs...)    }    return logs}</code></pre><h3 id="stateObjectå¤„ç†"><a href="#stateObjectå¤„ç†" class="headerlink" title="stateObjectå¤„ç†"></a>stateObjectå¤„ç†</h3><p>getStateObject,é¦–å…ˆä»ç¼“å­˜é‡Œé¢è·å–ï¼Œå¦‚æœæ²¡æœ‰å°±ä»trieæ ‘é‡Œé¢è·å–ï¼Œå¹¶åŠ è½½åˆ°ç¼“å­˜ã€‚</p><pre><code>// Retrieve a state object given my the address. Returns nil if not found.func (self *StateDB) getStateObject(addr common.Address) (stateObject *stateObject) {    // Prefer 'live' objects.    if obj := self.stateObjects[addr]; obj != nil {        if obj.deleted {            return nil        }        return obj    }    // Load the object from the database.    enc, err := self.trie.TryGet(addr[:])    if len(enc) == 0 {        self.setError(err)        return nil    }    var data Account    if err := rlp.DecodeBytes(enc, &amp;data); err != nil {        log.Error("Failed to decode state object", "addr", addr, "err", err)        return nil    }    // Insert into the live set.    obj := newObject(self, addr, data, self.MarkStateObjectDirty)    self.setStateObject(obj)    return obj}</code></pre><p>MarkStateObjectDirtyï¼Œ è®¾ç½®ä¸€ä¸ªstateObjectä¸ºDirtyã€‚ ç›´æ¥å¾€stateObjectDirtyå¯¹åº”çš„åœ°å€æ’å…¥ä¸€ä¸ªç©ºç»“æ„ä½“ã€‚</p><pre><code>// MarkStateObjectDirty adds the specified object to the dirty map to avoid costly// state object cache iteration to find a handful of modified ones.func (self *StateDB) MarkStateObjectDirty(addr common.Address) {    self.stateObjectsDirty[addr] = struct{}{}}</code></pre><h3 id="å¿«ç…§å’Œå›æ»šåŠŸèƒ½"><a href="#å¿«ç…§å’Œå›æ»šåŠŸèƒ½" class="headerlink" title="å¿«ç…§å’Œå›æ»šåŠŸèƒ½"></a>å¿«ç…§å’Œå›æ»šåŠŸèƒ½</h3><p>Snapshotå¯ä»¥åˆ›å»ºä¸€ä¸ªå¿«ç…§ï¼Œ ç„¶åé€šè¿‡    RevertToSnapshotå¯ä»¥å›æ»šåˆ°å“ªä¸ªçŠ¶æ€ï¼Œè¿™ä¸ªåŠŸèƒ½æ˜¯é€šè¿‡journalæ¥åšåˆ°çš„ã€‚ æ¯ä¸€æ­¥çš„ä¿®æ”¹éƒ½ä¼šå¾€journalé‡Œé¢æ·»åŠ ä¸€ä¸ªundoæ—¥å¿—ã€‚ å¦‚æœéœ€è¦å›æ»šåªéœ€è¦æ‰§è¡Œundoæ—¥å¿—å°±è¡Œäº†ã€‚</p><pre><code>// Snapshot returns an identifier for the current revision of the state.func (self *StateDB) Snapshot() int {    id := self.nextRevisionId    self.nextRevisionId++    self.validRevisions = append(self.validRevisions, revision{id, len(self.journal)})    return id}// RevertToSnapshot reverts all state changes made since the given revision.func (self *StateDB) RevertToSnapshot(revid int) {    // Find the snapshot in the stack of valid snapshots.    idx := sort.Search(len(self.validRevisions), func(i int) bool {        return self.validRevisions[i].id &gt;= revid    })    if idx == len(self.validRevisions) || self.validRevisions[idx].id != revid {        panic(fmt.Errorf("revision id %v cannot be reverted", revid))    }    snapshot := self.validRevisions[idx].journalIndex    // Replay the journal to undo changes.    for i := len(self.journal) - 1; i &gt;= snapshot; i-- {        self.journal[i].undo(self)    }    self.journal = self.journal[:snapshot]    // Remove invalidated snapshots from the stack.    self.validRevisions = self.validRevisions[:idx]}</code></pre><h3 id="è·å–ä¸­é—´çŠ¶æ€çš„-root-hashå€¼"><a href="#è·å–ä¸­é—´çŠ¶æ€çš„-root-hashå€¼" class="headerlink" title="è·å–ä¸­é—´çŠ¶æ€çš„ root hashå€¼"></a>è·å–ä¸­é—´çŠ¶æ€çš„ root hashå€¼</h3><p>IntermediateRoot ç”¨æ¥è®¡ç®—å½“å‰çš„state trieçš„rootçš„hashå€¼ã€‚è¿™ä¸ªæ–¹æ³•ä¼šåœ¨äº¤æ˜“æ‰§è¡Œçš„è¿‡ç¨‹ä¸­è¢«è°ƒç”¨ã€‚ä¼šè¢«å­˜å…¥ transaction receipt</p><p>Finaliseæ–¹æ³•ä¼šè°ƒç”¨updateæ–¹æ³•æŠŠå­˜æ”¾åœ¨cacheå±‚çš„ä¿®æ”¹å†™å…¥åˆ°trieæ•°æ®åº“é‡Œé¢ã€‚ ä½†æ˜¯è¿™ä¸ªæ—¶å€™è¿˜æ²¡æœ‰å†™å…¥åº•å±‚çš„æ•°æ®åº“ã€‚ è¿˜æ²¡æœ‰è°ƒç”¨commitï¼Œæ•°æ®è¿˜åœ¨å†…å­˜é‡Œé¢ï¼Œè¿˜æ²¡æœ‰è½åœ°æˆæ–‡ä»¶ã€‚</p><pre><code>// Finalise finalises the state by removing the self destructed objects// and clears the journal as well as the refunds.func (s *StateDB) Finalise(deleteEmptyObjects bool) {    for addr := range s.stateObjectsDirty {        stateObject := s.stateObjects[addr]        if stateObject.suicided || (deleteEmptyObjects &amp;&amp; stateObject.empty()) {            s.deleteStateObject(stateObject)        } else {            stateObject.updateRoot(s.db)            s.updateStateObject(stateObject)        }    }    // Invalidate journal because reverting across transactions is not allowed.    s.clearJournalAndRefund()}// IntermediateRoot computes the current root hash of the state trie.// It is called in between transactions to get the root hash that// goes into transaction receipts.func (s *StateDB) IntermediateRoot(deleteEmptyObjects bool) common.Hash {    s.Finalise(deleteEmptyObjects)    return s.trie.Hash()}</code></pre><h3 id="commitæ–¹æ³•"><a href="#commitæ–¹æ³•" class="headerlink" title="commitæ–¹æ³•"></a>commitæ–¹æ³•</h3><p>CommitToç”¨æ¥æäº¤æ›´æ”¹ã€‚</p><pre><code>// CommitTo writes the state to the given database.func (s *StateDB) CommitTo(dbw trie.DatabaseWriter, deleteEmptyObjects bool) (root common.Hash, err error) {    defer s.clearJournalAndRefund()    // Commit objects to the trie.    for addr, stateObject := range s.stateObjects {        _, isDirty := s.stateObjectsDirty[addr]        switch {        case stateObject.suicided || (isDirty &amp;&amp; deleteEmptyObjects &amp;&amp; stateObject.empty()):            // If the object has been removed, don't bother syncing it            // and just mark it for deletion in the trie.            s.deleteStateObject(stateObject)        case isDirty:            // Write any contract code associated with the state object            if stateObject.code != nil &amp;&amp; stateObject.dirtyCode {                if err := dbw.Put(stateObject.CodeHash(), stateObject.code); err != nil {                    return common.Hash{}, err                }                stateObject.dirtyCode = false            }            // Write any storage changes in the state object to its storage trie.            if err := stateObject.CommitTrie(s.db, dbw); err != nil {                return common.Hash{}, err            }            // Update the object in the main account trie.            s.updateStateObject(stateObject)        }        delete(s.stateObjectsDirty, addr)    }    // Write trie changes.    root, err = s.trie.CommitTo(dbw)    log.Debug("Trie cache stats after commit", "misses", trie.CacheMisses(), "unloads", trie.CacheUnloads())    return root, err}</code></pre><h3 id="æ€»ç»“"><a href="#æ€»ç»“" class="headerlink" title="æ€»ç»“"></a>æ€»ç»“</h3><p>stateåŒ…æä¾›äº†ç”¨æˆ·å’Œåˆçº¦çš„çŠ¶æ€ç®¡ç†çš„åŠŸèƒ½ã€‚ ç®¡ç†äº†çŠ¶æ€å’Œåˆçº¦çš„å„ç§çŠ¶æ€è½¬æ¢ã€‚ cacheï¼Œ trieï¼Œ æ•°æ®åº“ã€‚  æ—¥å¿—å’Œå›æ»šåŠŸèƒ½ã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-core-txlistäº¤æ˜“æ± çš„ä¸€äº›æ•°æ®ç»“æ„æºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-txlist%E4%BA%A4%E6%98%93%E6%B1%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-txlist%E4%BA%A4%E6%98%93%E6%B1%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="nonceHeap"><a href="#nonceHeap" class="headerlink" title="nonceHeap"></a>nonceHeap</h2><p>nonceHeapå®ç°äº†ä¸€ä¸ªheap.Interfaceçš„æ•°æ®ç»“æ„ï¼Œç”¨æ¥å®ç°äº†ä¸€ä¸ªå †çš„æ•°æ®ç»“æ„ã€‚ åœ¨heap.Interfaceçš„æ–‡æ¡£ä»‹ç»ä¸­ï¼Œé»˜è®¤å®ç°çš„æ˜¯æœ€å°å †ã€‚</p><p>å¦‚æœhæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œåªè¦æ•°ç»„ä¸­çš„æ•°æ®æ»¡è¶³ä¸‹é¢çš„è¦æ±‚ã€‚é‚£ä¹ˆå°±è®¤ä¸ºhæ˜¯ä¸€ä¸ªæœ€å°å †ã€‚</p><pre><code>!h.Less(j, i) for 0 &lt;= i &lt; h.Len() and 2*i+1 &lt;= j &lt;= 2*i+2 and j &lt; h.Len()// æŠŠæ•°ç»„çœ‹æˆæ˜¯ä¸€é¢—æ»¡çš„äºŒå‰æ ‘ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ ‘æ ¹ï¼Œç¬¬äºŒå’Œç¬¬ä¸‰ä¸ªå…ƒç´ æ˜¯æ ‘æ ¹çš„ä¸¤ä¸ªæ ‘æï¼Œ// è¿™æ ·ä¾æ¬¡æ¨ä¸‹å» é‚£ä¹ˆå¦‚æœæ ‘æ ¹æ˜¯  i é‚£ä¹ˆå®ƒçš„ä¸¤ä¸ªæ ‘æå°±æ˜¯ 2*i+2 å’Œ 2*i + 2ã€‚// æœ€å°å †çš„å®šä¹‰æ˜¯ ä»»æ„çš„æ ‘æ ¹ä¸èƒ½æ¯”å®ƒçš„ä¸¤ä¸ªæ ‘æå¤§ã€‚ ä¹Ÿå°±æ˜¯ä¸Šé¢çš„ä»£ç æè¿°çš„å®šä¹‰ã€‚heap.Interfaceçš„å®šä¹‰æˆ‘ä»¬åªéœ€è¦å®šä¹‰æ»¡è¶³ä¸‹é¢æ¥å£çš„æ•°æ®ç»“æ„ï¼Œå°±èƒ½å¤Ÿä½¿ç”¨heapçš„ä¸€äº›æ–¹æ³•æ¥å®ç°ä¸ºå †ç»“æ„ã€‚type Interface interface {    sort.Interface    Push(x interface{}) // add x as element Len() æŠŠxå¢åŠ åˆ°æœ€å    Pop() interface{}   //  remove and return element Len() - 1. ç§»é™¤å¹¶è¿”å›æœ€åçš„ä¸€ä¸ªå…ƒç´ }</code></pre><p>nonceHeapçš„ä»£ç åˆ†æã€‚</p><pre><code>// nonceHeap is a heap.Interface implementation over 64bit unsigned integers for// retrieving sorted transactions from the possibly gapped future queue.type nonceHeap []uint64func (h nonceHeap) Len() int           { return len(h) }func (h nonceHeap) Less(i, j int) bool { return h[i] &lt; h[j] }func (h nonceHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }func (h *nonceHeap) Push(x interface{}) {    *h = append(*h, x.(uint64))}func (h *nonceHeap) Pop() interface{} {    old := *h    n := len(old)    x := old[n-1]    *h = old[0 : n-1]    return x}</code></pre><h2 id="txSortedMap"><a href="#txSortedMap" class="headerlink" title="txSortedMap"></a>txSortedMap</h2><p>txSortedMap,å­˜å‚¨çš„æ˜¯åŒä¸€ä¸ªè´¦å·ä¸‹é¢çš„æ‰€æœ‰çš„äº¤æ˜“ã€‚</p><p>ç»“æ„</p><pre><code>// txSortedMap is a nonce-&gt;transaction hash map with a heap based index to allow// iterating over the contents in a nonce-incrementing way.// txSortedMapæ˜¯ä¸€ä¸ªå…·æœ‰åŸºäºå †çš„ç´¢å¼•çš„nonce-&gt;äº¤æ˜“ çš„hashmapï¼Œ// å…è®¸ä»¥nonceé€’å¢çš„æ–¹å¼è¿­ä»£å†…å®¹ã€‚type Transactions []*Transaction type txSortedMap struct {    items map[uint64]*types.Transaction // Hash map storing the transaction data    index *nonceHeap                    // Heap of nonces of all the stored transactions (non-strict mode)    cache types.Transactions            // Cache of the transactions already sorted ç”¨æ¥ç¼“å­˜å·²ç»æ’å¥½åºçš„äº¤æ˜“ã€‚}</code></pre><p>Put å’Œ Get, Getç”¨äºè·å–æŒ‡å®šnonceçš„äº¤æ˜“ï¼Œ Putç”¨æ¥æŠŠäº¤æ˜“æ’å…¥åˆ°mapä¸­ã€‚</p><pre><code>// Get retrieves the current transactions associated with the given nonce.func (m *txSortedMap) Get(nonce uint64) *types.Transaction {    return m.items[nonce]}// Put inserts a new transaction into the map, also updating the map's nonce// index. If a transaction already exists with the same nonce, it's overwritten.// æŠŠä¸€ä¸ªæ–°çš„äº‹åŠ¡æ’å…¥åˆ°mapä¸­ï¼ŒåŒæ—¶æ›´æ–°mapçš„nonceç´¢å¼•ã€‚ å¦‚æœä¸€ä¸ªäº‹åŠ¡å·²ç»å­˜åœ¨ï¼Œå°±æŠŠå®ƒè¦†ç›–ã€‚ åŒæ—¶ä»»ä½•ç¼“å­˜çš„æ•°æ®ä¼šè¢«åˆ é™¤ã€‚func (m *txSortedMap) Put(tx *types.Transaction) {    nonce := tx.Nonce()    if m.items[nonce] == nil {        heap.Push(m.index, nonce)    }    m.items[nonce], m.cache = tx, nil}</code></pre><p>Forwardç”¨äºåˆ é™¤æ‰€æœ‰nonceå°äºthresholdçš„äº¤æ˜“ã€‚ ç„¶åè¿”å›æ‰€æœ‰è¢«ç§»é™¤çš„äº¤æ˜“ã€‚</p><pre><code>// Forward removes all transactions from the map with a nonce lower than the// provided threshold. Every removed transaction is returned for any post-removal// maintenance.func (m *txSortedMap) Forward(threshold uint64) types.Transactions {    var removed types.Transactions    // Pop off heap items until the threshold is reached    for m.index.Len() &gt; 0 &amp;&amp; (*m.index)[0] &lt; threshold {        nonce := heap.Pop(m.index).(uint64)        removed = append(removed, m.items[nonce])        delete(m.items, nonce)    }    // If we had a cached order, shift the front    // cacheæ˜¯æ’å¥½åºçš„äº¤æ˜“ã€‚     if m.cache != nil {        m.cache = m.cache[len(removed):]    }    return removed}</code></pre><p>Filter, åˆ é™¤æ‰€æœ‰ä»¤filterå‡½æ•°è°ƒç”¨è¿”å›trueçš„äº¤æ˜“ï¼Œå¹¶è¿”å›é‚£äº›äº¤æ˜“ã€‚</p><pre><code>// Filter iterates over the list of transactions and removes all of them for which// the specified function evaluates to true.func (m *txSortedMap) Filter(filter func(*types.Transaction) bool) types.Transactions {    var removed types.Transactions    // Collect all the transactions to filter out    for nonce, tx := range m.items {        if filter(tx) {            removed = append(removed, tx)            delete(m.items, nonce)        }    }    // If transactions were removed, the heap and cache are ruined    // å¦‚æœäº‹åŠ¡è¢«åˆ é™¤ï¼Œå †å’Œç¼“å­˜è¢«æ¯å    if len(removed) &gt; 0 {        *m.index = make([]uint64, 0, len(m.items))        for nonce := range m.items {            *m.index = append(*m.index, nonce)        }        // éœ€è¦é‡å»ºå †        heap.Init(m.index)        // è®¾ç½®cacheä¸ºnil        m.cache = nil    }    return removed}</code></pre><p>Cap å¯¹itemsé‡Œé¢çš„æ•°é‡æœ‰é™åˆ¶ï¼Œè¿”å›è¶…è¿‡é™åˆ¶çš„æ‰€æœ‰äº¤æ˜“ã€‚</p><pre><code>// Cap places a hard limit on the number of items, returning all transactions// exceeding that limit.// Cap å¯¹itemsé‡Œé¢çš„æ•°é‡æœ‰é™åˆ¶ï¼Œè¿”å›è¶…è¿‡é™åˆ¶çš„æ‰€æœ‰äº¤æ˜“ã€‚func (m *txSortedMap) Cap(threshold int) types.Transactions {    // Short circuit if the number of items is under the limit    if len(m.items) &lt;= threshold {        return nil    }    // Otherwise gather and drop the highest nonce'd transactions    var drops types.Transactions    sort.Sort(*m.index) //ä»å°åˆ°å¤§æ’åº ä»å°¾éƒ¨åˆ é™¤ã€‚    for size := len(m.items); size &gt; threshold; size-- {        drops = append(drops, m.items[(*m.index)[size-1]])        delete(m.items, (*m.index)[size-1])    }    *m.index = (*m.index)[:threshold]    // é‡å»ºå †    heap.Init(m.index)    // If we had a cache, shift the back    if m.cache != nil {        m.cache = m.cache[:len(m.cache)-len(drops)]    }    return drops}</code></pre><p>Remove</p><pre><code>// Remove deletes a transaction from the maintained map, returning whether the// transaction was found.// func (m *txSortedMap) Remove(nonce uint64) bool {    // Short circuit if no transaction is present    _, ok := m.items[nonce]    if !ok {        return false    }    // Otherwise delete the transaction and fix the heap index    for i := 0; i &lt; m.index.Len(); i++ {        if (*m.index)[i] == nonce {            heap.Remove(m.index, i)            break        }    }    delete(m.items, nonce)    m.cache = nil    return true}</code></pre><p>Readyå‡½æ•°    </p><pre><code>// Ready retrieves a sequentially increasing list of transactions starting at the// provided nonce that is ready for processing. The returned transactions will be// removed from the list.// Ready è¿”å›ä¸€ä¸ªä»æŒ‡å®šnonceå¼€å§‹ï¼Œè¿ç»­çš„äº¤æ˜“ã€‚ è¿”å›çš„äº¤æ˜“ä¼šè¢«åˆ é™¤ã€‚// Note, all transactions with nonces lower than start will also be returned to// prevent getting into and invalid state. This is not something that should ever// happen but better to be self correcting than failing!// æ³¨æ„ï¼Œè¯·æ³¨æ„ï¼Œæ‰€æœ‰å…·æœ‰ä½äºstartçš„nonceçš„äº¤æ˜“ä¹Ÿå°†è¢«è¿”å›ï¼Œä»¥é˜²æ­¢è¿›å…¥å’Œæ— æ•ˆçŠ¶æ€ã€‚ // è¿™ä¸æ˜¯åº”è¯¥å‘ç”Ÿçš„äº‹æƒ…ï¼Œè€Œæ˜¯è‡ªæˆ‘çº æ­£è€Œä¸æ˜¯å¤±è´¥ï¼func (m *txSortedMap) Ready(start uint64) types.Transactions {    // Short circuit if no transactions are available    if m.index.Len() == 0 || (*m.index)[0] &gt; start {        return nil    }    // Otherwise start accumulating incremental transactions    var ready types.Transactions    // ä»æœ€å°çš„å¼€å§‹ï¼Œä¸€ä¸ªä¸€ä¸ªçš„å¢åŠ ï¼Œ    for next := (*m.index)[0]; m.index.Len() &gt; 0 &amp;&amp; (*m.index)[0] == next; next++ {        ready = append(ready, m.items[next])        delete(m.items, next)        heap.Pop(m.index)    }    m.cache = nil    return ready}</code></pre><p>Flatten,è¿”å›ä¸€ä¸ªåŸºäºnonceæ’åºçš„äº¤æ˜“åˆ—è¡¨ã€‚å¹¶ç¼“å­˜åˆ°cacheå­—æ®µé‡Œé¢ï¼Œä»¥ä¾¿åœ¨æ²¡æœ‰ä¿®æ”¹çš„æƒ…å†µä¸‹åå¤ä½¿ç”¨ã€‚</p><pre><code>// Len returns the length of the transaction map.func (m *txSortedMap) Len() int {    return len(m.items)}// Flatten creates a nonce-sorted slice of transactions based on the loosely// sorted internal representation. The result of the sorting is cached in case// it's requested again before any modifications are made to the contents.func (m *txSortedMap) Flatten() types.Transactions {    // If the sorting was not cached yet, create and cache it    if m.cache == nil {        m.cache = make(types.Transactions, 0, len(m.items))        for _, tx := range m.items {            m.cache = append(m.cache, tx)        }        sort.Sort(types.TxByNonce(m.cache))    }    // Copy the cache to prevent accidental modifications    txs := make(types.Transactions, len(m.cache))    copy(txs, m.cache)    return txs}</code></pre><h2 id="txList"><a href="#txList" class="headerlink" title="txList"></a>txList</h2><p>txList æ˜¯å±äºåŒä¸€ä¸ªè´¦å·çš„äº¤æ˜“åˆ—è¡¨ï¼Œ æŒ‰ç…§nonceæ’åºã€‚å¯ä»¥ç”¨æ¥å­˜å‚¨è¿ç»­çš„å¯æ‰§è¡Œçš„äº¤æ˜“ã€‚å¯¹äºéè¿ç»­çš„äº¤æ˜“,æœ‰ä¸€äº›å°çš„ä¸åŒçš„è¡Œä¸ºã€‚</p><p>ç»“æ„</p><pre><code>// txList is a "list" of transactions belonging to an account, sorted by account// nonce. The same type can be used both for storing contiguous transactions for// the executable/pending queue; and for storing gapped transactions for the non-// executable/future queue, with minor behavioral changes.type txList struct {    strict bool         // Whether nonces are strictly continuous or not noncesæ˜¯ä¸¥æ ¼è¿ç»­çš„è¿˜æ˜¯éè¿ç»­çš„    txs    *txSortedMap // Heap indexed sorted hash map of the transactions åŸºäºå †ç´¢å¼•çš„äº¤æ˜“çš„hashmap    costcap *big.Int // Price of the highest costing transaction (reset only if exceeds balance)  æ‰€æœ‰äº¤æ˜“é‡Œé¢ï¼ŒGasPrice * GasLimitæœ€é«˜çš„å€¼    gascap  *big.Int // Gas limit of the highest spending transaction (reset only if exceeds block limit) æ‰€æœ‰äº¤æ˜“é‡Œé¢ï¼Œ GasPriceæœ€é«˜çš„å€¼}</code></pre><p>Overlaps è¿”å›ç»™å®šçš„äº¤æ˜“æ˜¯å¦æœ‰å…·æœ‰ç›¸åŒnonceçš„äº¤æ˜“å­˜åœ¨ã€‚</p><pre><code>// Overlaps returns whether the transaction specified has the same nonce as one// already contained within the list.// func (l *txList) Overlaps(tx *types.Transaction) bool {    return l.txs.Get(tx.Nonce()) != nil}</code></pre><p>Add æ‰§è¡Œè¿™æ ·çš„æ“ä½œï¼Œå¦‚æœæ–°çš„äº¤æ˜“æ¯”è€çš„äº¤æ˜“çš„GasPriceå€¼è¦é«˜å‡ºä¸€å®šçš„æ¯”å€¼priceBumpï¼Œé‚£ä¹ˆä¼šæ›¿æ¢è€çš„äº¤æ˜“ã€‚</p><pre><code>// Add tries to insert a new transaction into the list, returning whether the// transaction was accepted, and if yes, any previous transaction it replaced.// Add å°è¯•æ’å…¥ä¸€ä¸ªæ–°çš„äº¤æ˜“ï¼Œè¿”å›äº¤æ˜“æ˜¯å¦è¢«æ¥æ”¶ï¼Œå¦‚æœè¢«æ¥æ”¶ï¼Œé‚£ä¹ˆä»»æ„ä¹‹å‰çš„äº¤æ˜“ä¼šè¢«æ›¿æ¢ã€‚// If the new transaction is accepted into the list, the lists' cost and gas// thresholds are also potentially updated.// å¦‚æœæ–°çš„äº¤æ˜“è¢«æ¥æ”¶ï¼Œé‚£ä¹ˆæ€»çš„costå’Œgasé™åˆ¶ä¼šè¢«æ›´æ–°ã€‚func (l *txList) Add(tx *types.Transaction, priceBump uint64) (bool, *types.Transaction) {    // If there's an older better transaction, abort    // å¦‚æœå­˜åœ¨è€çš„äº¤æ˜“ã€‚ è€Œä¸”æ–°çš„äº¤æ˜“çš„ä»·æ ¼æ¯”è€çš„é«˜å‡ºä¸€å®šçš„æ•°é‡ã€‚é‚£ä¹ˆæ›¿æ¢ã€‚    old := l.txs.Get(tx.Nonce())    if old != nil {        threshold := new(big.Int).Div(new(big.Int).Mul(old.GasPrice(), big.NewInt(100+int64(priceBump))), big.NewInt(100))        if threshold.Cmp(tx.GasPrice()) &gt;= 0 {            return false, nil        }    }    // Otherwise overwrite the old transaction with the current one    l.txs.Put(tx)    if cost := tx.Cost(); l.costcap.Cmp(cost) &lt; 0 {        l.costcap = cost    }    if gas := tx.Gas(); l.gascap.Cmp(gas) &lt; 0 {        l.gascap = gas    }    return true, old}</code></pre><p>Forward åˆ é™¤nonceå°äºæŸä¸ªå€¼çš„æ‰€æœ‰äº¤æ˜“ã€‚</p><pre><code>// Forward removes all transactions from the list with a nonce lower than the// provided threshold. Every removed transaction is returned for any post-removal// maintenance.func (l *txList) Forward(threshold uint64) types.Transactions {    return l.txs.Forward(threshold)}</code></pre><p>Filter,</p><pre><code>// Filter removes all transactions from the list with a cost or gas limit higher// than the provided thresholds. Every removed transaction is returned for any// post-removal maintenance. Strict-mode invalidated transactions are also// returned.// Filter ç§»é™¤æ‰€æœ‰æ¯”æä¾›çš„costæˆ–è€…gasLimitçš„å€¼æ›´é«˜çš„äº¤æ˜“ã€‚ è¢«ç§»é™¤çš„äº¤æ˜“ä¼šè¿”å›ä»¥ä¾¿è¿›ä¸€æ­¥å¤„ç†ã€‚ åœ¨ä¸¥æ ¼æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰æ— æ•ˆçš„äº¤æ˜“åŒæ ·è¢«è¿”å›ã€‚// // This method uses the cached costcap and gascap to quickly decide if there's even// a point in calculating all the costs or if the balance covers all. If the threshold// is lower than the costgas cap, the caps will be reset to a new high after removing// the newly invalidated transactions.// è¿™ä¸ªæ–¹æ³•ä¼šä½¿ç”¨ç¼“å­˜çš„costcapå’Œgascapä»¥ä¾¿å¿«é€Ÿçš„å†³å®šæ˜¯å¦éœ€è¦éå†æ‰€æœ‰çš„äº¤æ˜“ã€‚å¦‚æœé™åˆ¶å°äºç¼“å­˜çš„costcapå’Œgascapï¼Œé‚£ä¹ˆåœ¨ç§»é™¤ä¸åˆæ³•çš„äº¤æ˜“ä¹‹åä¼šæ›´æ–°costcapå’Œgascapçš„å€¼ã€‚func (l *txList) Filter(costLimit, gasLimit *big.Int) (types.Transactions, types.Transactions) {    // If all transactions are below the threshold, short circuit    // å¦‚æœæ‰€æœ‰çš„äº¤æ˜“éƒ½å°äºé™åˆ¶ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›ã€‚    if l.costcap.Cmp(costLimit) &lt;= 0 &amp;&amp; l.gascap.Cmp(gasLimit) &lt;= 0 {        return nil, nil    }    l.costcap = new(big.Int).Set(costLimit) // Lower the caps to the thresholds    l.gascap = new(big.Int).Set(gasLimit)    // Filter out all the transactions above the account's funds    removed := l.txs.Filter(func(tx *types.Transaction) bool { return tx.Cost().Cmp(costLimit) &gt; 0 || tx.Gas().Cmp(gasLimit) &gt; 0 })    // If the list was strict, filter anything above the lowest nonce    var invalids types.Transactions    if l.strict &amp;&amp; len(removed) &gt; 0 {        // æ‰€æœ‰çš„nonceå¤§äº æœ€å°çš„è¢«ç§»é™¤çš„nonceçš„äº¤æ˜“éƒ½è¢«ä»»åŠ¡æ˜¯æ— æ•ˆçš„ã€‚        // åœ¨ä¸¥æ ¼æ¨¡å¼ä¸‹ï¼Œè¿™ç§äº¤æ˜“ä¹Ÿè¢«ç§»é™¤ã€‚        lowest := uint64(math.MaxUint64)        for _, tx := range removed {            if nonce := tx.Nonce(); lowest &gt; nonce {                lowest = nonce            }        }        invalids = l.txs.Filter(func(tx *types.Transaction) bool { return tx.Nonce() &gt; lowest })    }    return removed, invalids}</code></pre><p>Capå‡½æ•°ç”¨æ¥è¿”å›è¶…è¿‡æ•°é‡çš„äº¤æ˜“ã€‚ å¦‚æœäº¤æ˜“çš„æ•°é‡è¶…è¿‡threshold,é‚£ä¹ˆæŠŠä¹‹åçš„äº¤æ˜“ç§»é™¤å¹¶è¿”å›ã€‚</p><pre><code>// Cap places a hard limit on the number of items, returning all transactions// exceeding that limit.func (l *txList) Cap(threshold int) types.Transactions {    return l.txs.Cap(threshold)}</code></pre><p>Remove,åˆ é™¤ç»™å®šNonceçš„äº¤æ˜“ï¼Œå¦‚æœåœ¨ä¸¥æ ¼æ¨¡å¼ä¸‹ï¼Œè¿˜åˆ é™¤æ‰€æœ‰nonceå¤§äºç»™å®šNonceçš„äº¤æ˜“ï¼Œå¹¶è¿”å›ã€‚</p><pre><code>// Remove deletes a transaction from the maintained list, returning whether the// transaction was found, and also returning any transaction invalidated due to// the deletion (strict mode only).func (l *txList) Remove(tx *types.Transaction) (bool, types.Transactions) {    // Remove the transaction from the set    nonce := tx.Nonce()    if removed := l.txs.Remove(nonce); !removed {        return false, nil    }    // In strict mode, filter out non-executable transactions    if l.strict {        return true, l.txs.Filter(func(tx *types.Transaction) bool { return tx.Nonce() &gt; nonce })    }    return true, nil}</code></pre><p>Readyï¼Œ len, Empty, Flatten ç›´æ¥è°ƒç”¨äº†txSortedMapçš„å¯¹åº”æ–¹æ³•ã€‚</p><pre><code>// Ready retrieves a sequentially increasing list of transactions starting at the// provided nonce that is ready for processing. The returned transactions will be// removed from the list.//// Note, all transactions with nonces lower than start will also be returned to// prevent getting into and invalid state. This is not something that should ever// happen but better to be self correcting than failing!func (l *txList) Ready(start uint64) types.Transactions {    return l.txs.Ready(start)}// Len returns the length of the transaction list.func (l *txList) Len() int {    return l.txs.Len()}// Empty returns whether the list of transactions is empty or not.func (l *txList) Empty() bool {    return l.Len() == 0}// Flatten creates a nonce-sorted slice of transactions based on the loosely// sorted internal representation. The result of the sorting is cached in case// it's requested again before any modifications are made to the contents.func (l *txList) Flatten() types.Transactions {    return l.txs.Flatten()}</code></pre><h2 id="priceHeap"><a href="#priceHeap" class="headerlink" title="priceHeap"></a>priceHeap</h2><p>priceHeapæ˜¯ä¸€ä¸ªæœ€å°å †ï¼Œ æŒ‰ç…§ä»·æ ¼çš„å¤§å°æ¥å»ºå †ã€‚</p><pre><code>// priceHeap is a heap.Interface implementation over transactions for retrieving// price-sorted transactions to discard when the pool fills up.type priceHeap []*types.Transactionfunc (h priceHeap) Len() int           { return len(h) }func (h priceHeap) Less(i, j int) bool { return h[i].GasPrice().Cmp(h[j].GasPrice()) &lt; 0 }func (h priceHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }func (h *priceHeap) Push(x interface{}) {    *h = append(*h, x.(*types.Transaction))}func (h *priceHeap) Pop() interface{} {    old := *h    n := len(old)    x := old[n-1]    *h = old[0 : n-1]    return x}</code></pre><h2 id="txPricedList"><a href="#txPricedList" class="headerlink" title="txPricedList"></a>txPricedList</h2><p>æ•°æ®ç»“æ„å’Œæ„å»º,txPricedList æ˜¯åŸºäºä»·æ ¼æ’åºçš„å †ï¼Œå…è®¸æŒ‰ç…§ä»·æ ¼é€’å¢çš„æ–¹å¼å¤„ç†äº¤æ˜“ã€‚</p><pre><code>// txPricedList is a price-sorted heap to allow operating on transactions pool// contents in a price-incrementing way.type txPricedList struct {    all    *map[common.Hash]*types.Transaction // Pointer to the map of all transactions è¿™æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘äº†æ‰€æœ‰äº¤æ˜“çš„map    items  *priceHeap                          // Heap of prices of all the stored transactions    stales int                                 // Number of stale price points to (re-heap trigger)}// newTxPricedList creates a new price-sorted transaction heap.func newTxPricedList(all *map[common.Hash]*types.Transaction) *txPricedList {    return &amp;txPricedList{        all:   all,        items: new(priceHeap),    }}</code></pre><p>Put</p><pre><code>// Put inserts a new transaction into the heap.func (l *txPricedList) Put(tx *types.Transaction) {    heap.Push(l.items, tx)}</code></pre><p>Removed</p><pre><code>// Removed notifies the prices transaction list that an old transaction dropped// from the pool. The list will just keep a counter of stale objects and update// the heap if a large enough ratio of transactions go stale.// Removed ç”¨æ¥é€šçŸ¥txPricedListæœ‰ä¸€ä¸ªè€çš„äº¤æ˜“è¢«åˆ é™¤. txPricedListä½¿ç”¨ä¸€ä¸ªè®¡æ•°å™¨æ¥å†³å®šä½•æ—¶æ›´æ–°å †ä¿¡æ¯.func (l *txPricedList) Removed() {    // Bump the stale counter, but exit if still too low (&lt; 25%)    l.stales++    if l.stales &lt;= len(*l.items)/4 {        return    }    // Seems we've reached a critical number of stale transactions, reheap    reheap := make(priceHeap, 0, len(*l.all))    l.stales, l.items = 0, &amp;reheap    for _, tx := range *l.all {        *l.items = append(*l.items, tx)    }    heap.Init(l.items)}</code></pre><p>Cap ç”¨æ¥æ‰¾åˆ°æ‰€æœ‰ä½äºç»™å®šä»·æ ¼é˜ˆå€¼çš„äº¤æ˜“. æŠŠä»–ä»¬ä»priceListåˆ é™¤å¹¶è¿”å›.</p><pre><code>// Cap finds all the transactions below the given price threshold, drops them// from the priced list and returs them for further removal from the entire pool.func (l *txPricedList) Cap(threshold *big.Int, local *accountSet) types.Transactions {    drop := make(types.Transactions, 0, 128) // Remote underpriced transactions to drop    save := make(types.Transactions, 0, 64)  // Local underpriced transactions to keep    for len(*l.items) &gt; 0 {        // Discard stale transactions if found during cleanup        tx := heap.Pop(l.items).(*types.Transaction)        if _, ok := (*l.all)[tx.Hash()]; !ok {            // å¦‚æœå‘ç°ä¸€ä¸ªå·²ç»åˆ é™¤çš„,é‚£ä¹ˆæ›´æ–°statesè®¡æ•°å™¨            l.stales--            continue        }        // Stop the discards if we've reached the threshold        if tx.GasPrice().Cmp(threshold) &gt;= 0 {            // å¦‚æœä»·æ ¼ä¸å°äºé˜ˆå€¼, é‚£ä¹ˆé€€å‡º            save = append(save, tx)            break        }        // Non stale transaction found, discard unless local        if local.containsTx(tx) {  //æœ¬åœ°çš„äº¤æ˜“ä¸ä¼šåˆ é™¤            save = append(save, tx)        } else {            drop = append(drop, tx)        }    }    for _, tx := range save {        heap.Push(l.items, tx)    }    return drop}</code></pre><p>Underpriced, æ£€æŸ¥ txæ˜¯å¦æ¯” å½“å‰txPricedListé‡Œé¢æœ€ä¾¿å®œçš„äº¤æ˜“è¿˜è¦ä¾¿å®œæˆ–è€…æ˜¯åŒæ ·ä¾¿å®œ.</p><pre><code>// Underpriced checks whether a transaction is cheaper than (or as cheap as) the// lowest priced transaction currently being tracked.func (l *txPricedList) Underpriced(tx *types.Transaction, local *accountSet) bool {    // Local transactions cannot be underpriced    if local.containsTx(tx) {        return false    }    // Discard stale price points if found at the heap start    for len(*l.items) &gt; 0 {        head := []*types.Transaction(*l.items)[0]        if _, ok := (*l.all)[head.Hash()]; !ok {            l.stales--            heap.Pop(l.items)            continue        }        break    }    // Check if the transaction is underpriced or not    if len(*l.items) == 0 {        log.Error("Pricing query for empty pool") // This cannot happen, print to catch programming errors        return false    }    cheapest := []*types.Transaction(*l.items)[0]    return cheapest.GasPrice().Cmp(tx.GasPrice()) &gt;= 0}</code></pre><p>Discard,æŸ¥æ‰¾ä¸€å®šæ•°é‡çš„æœ€ä¾¿å®œçš„äº¤æ˜“,æŠŠä»–ä»¬ä»å½“å‰çš„åˆ—è¡¨åˆ é™¤å¹¶è¿”å›.</p><pre><code>// Discard finds a number of most underpriced transactions, removes them from the// priced list and returns them for further removal from the entire pool.func (l *txPricedList) Discard(count int, local *accountSet) types.Transactions {    drop := make(types.Transactions, 0, count) // Remote underpriced transactions to drop    save := make(types.Transactions, 0, 64)    // Local underpriced transactions to keep    for len(*l.items) &gt; 0 &amp;&amp; count &gt; 0 {        // Discard stale transactions if found during cleanup        tx := heap.Pop(l.items).(*types.Transaction)        if _, ok := (*l.all)[tx.Hash()]; !ok {            l.stales--            continue        }        // Non stale transaction found, discard unless local        if local.containsTx(tx) {            save = append(save, tx)        } else {            drop = append(drop, tx)            count--        }    }    for _, tx := range save {        heap.Push(l.items, tx)    }    return drop}</code></pre><h2 id="accountSet"><a href="#accountSet" class="headerlink" title="accountSet"></a>accountSet</h2><p>accountSet å°±æ˜¯ä¸€ä¸ªè´¦å·çš„é›†åˆå’Œä¸€ä¸ªå¤„ç†ç­¾åçš„å¯¹è±¡.</p><pre><code>// accountSet is simply a set of addresses to check for existence, and a signer// capable of deriving addresses from transactions.type accountSet struct {    accounts map[common.Address]struct{}    signer   types.Signer}// newAccountSet creates a new address set with an associated signer for sender// derivations.func newAccountSet(signer types.Signer) *accountSet {    return &amp;accountSet{        accounts: make(map[common.Address]struct{}),        signer:   signer,    }}// contains checks if a given address is contained within the set.func (as *accountSet) contains(addr common.Address) bool {    _, exist := as.accounts[addr]    return exist}// containsTx checks if the sender of a given tx is within the set. If the sender// cannot be derived, this method returns false.// containsTxæ£€æŸ¥ç»™å®štxçš„å‘é€è€…æ˜¯å¦åœ¨é›†åˆå†…ã€‚ å¦‚æœå‘ä»¶äººæ— æ³•è¢«è®¡ç®—å‡ºï¼Œåˆ™æ­¤æ–¹æ³•è¿”å›falseã€‚func (as *accountSet) containsTx(tx *types.Transaction) bool {    if addr, err := types.Sender(as.signer, tx); err == nil {        return as.contains(addr)    }    return false}// add inserts a new address into the set to track.func (as *accountSet) add(addr common.Address) {    as.accounts[addr] = struct{}{}}</code></pre><h2 id="txJournal"><a href="#txJournal" class="headerlink" title="txJournal"></a>txJournal</h2><p>txJournalæ˜¯äº¤æ˜“çš„ä¸€ä¸ªå¾ªç¯æ—¥å¿—ï¼Œå…¶ç›®çš„æ˜¯å­˜å‚¨æœ¬åœ°åˆ›å»ºçš„äº‹åŠ¡ï¼Œä»¥å…è®¸æœªæ‰§è¡Œçš„äº‹åŠ¡åœ¨èŠ‚ç‚¹é‡æ–°å¯åŠ¨åç»§ç»­è¿è¡Œã€‚<br>ç»“æ„</p><pre><code>// txJournal is a rotating log of transactions with the aim of storing locally// created transactions to allow non-executed ones to survive node restarts.type txJournal struct {    path   string         // Filesystem path to store the transactions at ç”¨æ¥å­˜å‚¨äº¤æ˜“çš„æ–‡ä»¶ç³»ç»Ÿè·¯å¾„.    writer io.WriteCloser // Output stream to write new transactions into ç”¨æ¥å†™å…¥æ–°äº¤æ˜“çš„è¾“å‡ºæµ.}</code></pre><p>newTxJournal,ç”¨æ¥åˆ›å»ºæ–°çš„äº¤æ˜“æ—¥å¿—.</p><pre><code>// newTxJournal creates a new transaction journal tofunc newTxJournal(path string) *txJournal {    return &amp;txJournal{        path: path,    }}</code></pre><p>loadæ–¹æ³•ä»ç£ç›˜è§£æäº¤æ˜“,ç„¶åè°ƒç”¨addå›è°ƒæ–¹æ³•.    </p><pre><code>// load parses a transaction journal dump from disk, loading its contents into// the specified pool.func (journal *txJournal) load(add func(*types.Transaction) error) error {    // Skip the parsing if the journal file doens't exist at all    if _, err := os.Stat(journal.path); os.IsNotExist(err) {        return nil    }    // Open the journal for loading any past transactions    input, err := os.Open(journal.path)    if err != nil {        return err    }    defer input.Close()    // Inject all transactions from the journal into the pool    stream := rlp.NewStream(input, 0)    total, dropped := 0, 0    var failure error    for {        // Parse the next transaction and terminate on error        tx := new(types.Transaction)        if err = stream.Decode(tx); err != nil {            if err != io.EOF {                failure = err            }            break        }        // Import the transaction and bump the appropriate progress counters        total++        if err = add(tx); err != nil {            log.Debug("Failed to add journaled transaction", "err", err)            dropped++            continue        }    }    log.Info("Loaded local transaction journal", "transactions", total, "dropped", dropped)    return failure}</code></pre><p>insertæ–¹æ³•,è°ƒç”¨rlp.Encodeå†™å…¥writer</p><pre><code>// insert adds the specified transaction to the local disk journal.func (journal *txJournal) insert(tx *types.Transaction) error {    if journal.writer == nil {        return errNoActiveJournal    }    if err := rlp.Encode(journal.writer, tx); err != nil {        return err    }    return nil}</code></pre><p>rotateæ–¹æ³•åŸºäºå½“å‰çš„äº¤æ˜“æ± é‡æ–°ç”Ÿæˆäº¤æ˜“,</p><pre><code>// rotate regenerates the transaction journal based on the current contents of// the transaction pool.func (journal *txJournal) rotate(all map[common.Address]types.Transactions) error {    // Close the current journal (if any is open)    if journal.writer != nil {        if err := journal.writer.Close(); err != nil {            return err        }        journal.writer = nil    }    // Generate a new journal with the contents of the current pool    replacement, err := os.OpenFile(journal.path+".new", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)    if err != nil {        return err    }    journaled := 0    for _, txs := range all {        for _, tx := range txs {            if err = rlp.Encode(replacement, tx); err != nil {                replacement.Close()                return err            }        }        journaled += len(txs)    }    replacement.Close()    // Replace the live journal with the newly generated one    if err = os.Rename(journal.path+".new", journal.path); err != nil {        return err    }    sink, err := os.OpenFile(journal.path, os.O_WRONLY|os.O_APPEND, 0755)    if err != nil {        return err    }    journal.writer = sink    log.Info("Regenerated local transaction journal", "transactions", journaled, "accounts", len(all))    return nil}</code></pre><p>close</p><pre><code>// close flushes the transaction journal contents to disk and closes the file.func (journal *txJournal) close() error {    var err error    if journal.writer != nil {        err = journal.writer.Close()        journal.writer = nil    }    return err}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-core-vmæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-vm%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-vm%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="contract-go"><a href="#contract-go" class="headerlink" title="contract.go"></a>contract.go</h2><p>contract ä»£è¡¨äº†ä»¥å¤ªåŠ state databaseé‡Œé¢çš„ä¸€ä¸ªåˆçº¦ã€‚åŒ…å«äº†åˆçº¦ä»£ç ï¼Œè°ƒç”¨å‚æ•°ã€‚</p><p>ç»“æ„</p><pre><code>// ContractRef is a reference to the contract's backing objecttype ContractRef interface {    Address() common.Address}// AccountRef implements ContractRef.//// Account references are used during EVM initialisation and// it's primary use is to fetch addresses. Removing this object// proves difficult because of the cached jump destinations which// are fetched from the parent contract (i.e. the caller), which// is a ContractRef.type AccountRef common.Address// Address casts AccountRef to a Addressfunc (ar AccountRef) Address() common.Address { return (common.Address)(ar) }// Contract represents an ethereum contract in the state database. It contains// the the contract code, calling arguments. Contract implements ContractReftype Contract struct {    // CallerAddress is the result of the caller which initialised this    // contract. However when the "call method" is delegated this value    // needs to be initialised to that of the caller's caller.    // CallerAddressæ˜¯åˆå§‹åŒ–è¿™ä¸ªåˆçº¦çš„äººã€‚ å¦‚æœæ˜¯delegateï¼Œè¿™ä¸ªå€¼è¢«è®¾ç½®ä¸ºè°ƒç”¨è€…çš„è°ƒç”¨è€…ã€‚    CallerAddress common.Address    caller        ContractRef    self          ContractRef    jumpdests destinations // result of JUMPDEST analysis.  JUMPDESTæŒ‡ä»¤çš„åˆ†æ    Code     []byte  //ä»£ç     CodeHash common.Hash  //ä»£ç çš„HASH    CodeAddr *common.Address //ä»£ç åœ°å€    Input    []byte     // å…¥å‚    Gas   uint64          // åˆçº¦è¿˜æœ‰å¤šå°‘Gas    value *big.Int          Args []byte  //å¥½åƒæ²¡æœ‰ä½¿ç”¨    DelegateCall bool  }</code></pre><p>æ„é€ </p><pre><code>// NewContract returns a new contract environment for the execution of EVM.func NewContract(caller ContractRef, object ContractRef, value *big.Int, gas uint64) *Contract {    c := &amp;Contract{CallerAddress: caller.Address(), caller: caller, self: object, Args: nil}    if parent, ok := caller.(*Contract); ok {        // Reuse JUMPDEST analysis from parent context if available.        // å¦‚æœ caller æ˜¯ä¸€ä¸ªåˆçº¦ï¼Œè¯´æ˜æ˜¯åˆçº¦è°ƒç”¨äº†æˆ‘ä»¬ã€‚ jumpdestsè®¾ç½®ä¸ºcallerçš„jumpdests        c.jumpdests = parent.jumpdests    } else {        c.jumpdests = make(destinations)    }    // Gas should be a pointer so it can safely be reduced through the run    // This pointer will be off the state transition    c.Gas = gas    // ensures a value is set    c.value = value    return c}</code></pre><p>AsDelegateå°†åˆçº¦è®¾ç½®ä¸ºå§”æ‰˜è°ƒç”¨å¹¶è¿”å›å½“å‰åˆåŒï¼ˆç”¨äºé“¾å¼è°ƒç”¨ï¼‰</p><pre><code>// AsDelegate sets the contract to be a delegate call and returns the current// contract (for chaining calls)func (c *Contract) AsDelegate() *Contract {    c.DelegateCall = true    // NOTE: caller must, at all times be a contract. It should never happen    // that caller is something other than a Contract.    parent := c.caller.(*Contract)    c.CallerAddress = parent.CallerAddress    c.value = parent.value    return c}    </code></pre><p>GetOp  ç”¨æ¥è·å–ä¸‹ä¸€è·³æŒ‡ä»¤</p><pre><code>// GetOp returns the n'th element in the contract's byte arrayfunc (c *Contract) GetOp(n uint64) OpCode {    return OpCode(c.GetByte(n))}// GetByte returns the n'th byte in the contract's byte arrayfunc (c *Contract) GetByte(n uint64) byte {    if n &lt; uint64(len(c.Code)) {        return c.Code[n]    }    return 0}// Caller returns the caller of the contract.//// Caller will recursively call caller when the contract is a delegate// call, including that of caller's caller.func (c *Contract) Caller() common.Address {    return c.CallerAddress}</code></pre><p>UseGasä½¿ç”¨Gasã€‚ </p><pre><code>// UseGas attempts the use gas and subtracts it and returns true on successfunc (c *Contract) UseGas(gas uint64) (ok bool) {    if c.Gas &lt; gas {        return false    }    c.Gas -= gas    return true}// Address returns the contracts addressfunc (c *Contract) Address() common.Address {    return c.self.Address()}// Value returns the contracts value (sent to it from it's caller)func (c *Contract) Value() *big.Int {    return c.value}</code></pre><p>SetCode    ï¼ŒSetCallCode è®¾ç½®ä»£ç ã€‚</p><pre><code>// SetCode sets the code to the contractfunc (self *Contract) SetCode(hash common.Hash, code []byte) {    self.Code = code    self.CodeHash = hash}// SetCallCode sets the code of the contract and address of the backing data// objectfunc (self *Contract) SetCallCode(addr *common.Address, hash common.Hash, code []byte) {    self.Code = code    self.CodeHash = hash    self.CodeAddr = addr}</code></pre><h2 id="evm-go"><a href="#evm-go" class="headerlink" title="evm.go"></a>evm.go</h2><p>ç»“æ„</p><pre><code>// Context provides the EVM with auxiliary information. Once provided// it shouldn't be modified.// ä¸Šä¸‹æ–‡ä¸ºEVMæä¾›è¾…åŠ©ä¿¡æ¯ã€‚ ä¸€æ—¦æä¾›ï¼Œä¸åº”è¯¥ä¿®æ”¹ã€‚type Context struct {    // CanTransfer returns whether the account contains    // sufficient ether to transfer the value    // CanTransfer å‡½æ•°è¿”å›è´¦æˆ·æ˜¯å¦æœ‰è¶³å¤Ÿçš„etherç”¨æ¥è½¬è´¦    CanTransfer CanTransferFunc    // Transfer transfers ether from one account to the other    // Transfer ç”¨æ¥ä»ä¸€ä¸ªè´¦æˆ·ç»™å¦ä¸€ä¸ªè´¦æˆ·è½¬è´¦    Transfer TransferFunc    // GetHash returns the hash corresponding to n    // GetHashç”¨æ¥è¿”å›å…¥å‚nå¯¹åº”çš„hashå€¼    GetHash GetHashFunc    // Message information    // ç”¨æ¥æä¾›Originçš„ä¿¡æ¯ senderçš„åœ°å€    Origin   common.Address // Provides information for ORIGIN    // ç”¨æ¥æä¾›GasPriceä¿¡æ¯    GasPrice *big.Int       // Provides information for GASPRICE    // Block information    Coinbase    common.Address // Provides information for COINBASE    GasLimit    *big.Int       // Provides information for GASLIMIT    BlockNumber *big.Int       // Provides information for NUMBER    Time        *big.Int       // Provides information for TIME    Difficulty  *big.Int       // Provides information for DIFFICULTY}// EVM is the Ethereum Virtual Machine base object and provides// the necessary tools to run a contract on the given state with// the provided context. It should be noted that any error// generated through any of the calls should be considered a// revert-state-and-consume-all-gas operation, no checks on// specific errors should ever be performed. The interpreter makes// sure that any errors generated are to be considered faulty code.// EVMæ˜¯ä»¥å¤ªåŠè™šæ‹ŸæœºåŸºç¡€å¯¹è±¡ï¼Œå¹¶æä¾›å¿…è¦çš„å·¥å…·ï¼Œä»¥ä½¿ç”¨æä¾›çš„ä¸Šä¸‹æ–‡è¿è¡Œç»™å®šçŠ¶æ€çš„åˆçº¦ã€‚// åº”è¯¥æŒ‡å‡ºçš„æ˜¯ï¼Œä»»ä½•è°ƒç”¨äº§ç”Ÿçš„ä»»ä½•é”™è¯¯éƒ½åº”è¯¥è¢«è®¤ä¸ºæ˜¯ä¸€ç§å›æ»šä¿®æ”¹çŠ¶æ€å’Œæ¶ˆè€—æ‰€æœ‰GASæ“ä½œï¼Œ// ä¸åº”è¯¥æ‰§è¡Œå¯¹å…·ä½“é”™è¯¯çš„æ£€æŸ¥ã€‚ è§£é‡Šå™¨ç¡®ä¿ç”Ÿæˆçš„ä»»ä½•é”™è¯¯éƒ½è¢«è®¤ä¸ºæ˜¯é”™è¯¯çš„ä»£ç ã€‚// The EVM should never be reused and is not thread safe.type EVM struct {    // Context provides auxiliary blockchain related information    Context    // StateDB gives access to the underlying state    StateDB StateDB    // Depth is the current call stack    // å½“å‰çš„è°ƒç”¨å †æ ˆ    depth int    // chainConfig contains information about the current chain    // åŒ…å«äº†å½“å‰çš„åŒºå—é“¾çš„ä¿¡æ¯    chainConfig *params.ChainConfig    // chain rules contains the chain rules for the current epoch    chainRules params.Rules    // virtual machine configuration options used to initialise the    // evm.    vmConfig Config    // global (to this context) ethereum virtual machine    // used throughout the execution of the tx.    interpreter *Interpreter    // abort is used to abort the EVM calling operations    // NOTE: must be set atomically    abort int32}</code></pre><p>æ„é€ å‡½æ•°</p><pre><code>// NewEVM retutrns a new EVM . The returned EVM is not thread safe and should// only ever be used *once*.func NewEVM(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config) *EVM {    evm := &amp;EVM{        Context:     ctx,        StateDB:     statedb,        vmConfig:    vmConfig,        chainConfig: chainConfig,        chainRules:  chainConfig.Rules(ctx.BlockNumber),    }    evm.interpreter = NewInterpreter(evm, vmConfig)    return evm}// Cancel cancels any running EVM operation. This may be called concurrently and// it's safe to be called multiple times.func (evm *EVM) Cancel() {    atomic.StoreInt32(&amp;evm.abort, 1)}</code></pre><p>åˆçº¦åˆ›å»º Create ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„åˆçº¦ã€‚</p><pre><code>// Create creates a new contract using code as deployment code.func (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {    // Depth check execution. Fail if we're trying to execute above the    // limit.    if evm.depth &gt; int(params.CallCreateDepth) {        return nil, common.Address{}, gas, ErrDepth    }    if !evm.CanTransfer(evm.StateDB, caller.Address(), value) {        return nil, common.Address{}, gas, ErrInsufficientBalance    }    // Ensure there's no existing contract already at the designated address    // ç¡®ä¿ç‰¹å®šçš„åœ°å€æ²¡æœ‰åˆçº¦å­˜åœ¨    nonce := evm.StateDB.GetNonce(caller.Address())    evm.StateDB.SetNonce(caller.Address(), nonce+1)    contractAddr = crypto.CreateAddress(caller.Address(), nonce)    contractHash := evm.StateDB.GetCodeHash(contractAddr)    if evm.StateDB.GetNonce(contractAddr) != 0 || (contractHash != (common.Hash{}) &amp;&amp; contractHash != emptyCodeHash) { //å¦‚æœå·²ç»å­˜åœ¨        return nil, common.Address{}, 0, ErrContractAddressCollision    }    // Create a new account on the state    snapshot := evm.StateDB.Snapshot()  //åˆ›å»ºä¸€ä¸ªStateDBçš„å¿«ç…§ï¼Œä»¥ä¾¿å›æ»š    evm.StateDB.CreateAccount(contractAddr) //åˆ›å»ºè´¦æˆ·    if evm.ChainConfig().IsEIP158(evm.BlockNumber) {        evm.StateDB.SetNonce(contractAddr, 1) //è®¾ç½®nonce    }    evm.Transfer(evm.StateDB, caller.Address(), contractAddr, value)  //è½¬è´¦    // initialise a new contract and set the code that is to be used by the    // E The contract is a scoped evmironment for this execution context    // only.    contract := NewContract(caller, AccountRef(contractAddr), value, gas)    contract.SetCallCode(&amp;contractAddr, crypto.Keccak256Hash(code), code)    if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 {        return nil, contractAddr, gas, nil    }    ret, err = run(evm, snapshot, contract, nil) //æ‰§è¡Œåˆçº¦çš„åˆå§‹åŒ–ä»£ç     // check whether the max code size has been exceeded    // æ£€æŸ¥åˆå§‹åŒ–ç”Ÿæˆçš„ä»£ç çš„é•¿åº¦ä¸è¶…è¿‡é™åˆ¶    maxCodeSizeExceeded := evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; len(ret) &gt; params.MaxCodeSize    // if the contract creation ran successfully and no errors were returned    // calculate the gas required to store the code. If the code could not    // be stored due to not enough gas set an error and let it be handled    // by the error checking condition below.    //å¦‚æœåˆåŒåˆ›å»ºæˆåŠŸå¹¶ä¸”æ²¡æœ‰é”™è¯¯è¿”å›ï¼Œåˆ™è®¡ç®—å­˜å‚¨ä»£ç æ‰€éœ€çš„GASã€‚ å¦‚æœç”±äºæ²¡æœ‰è¶³å¤Ÿçš„GASè€Œå¯¼è‡´ä»£ç ä¸èƒ½è¢«å­˜å‚¨è®¾ç½®é”™è¯¯ï¼Œå¹¶é€šè¿‡ä¸‹é¢çš„é”™è¯¯æ£€æŸ¥æ¡ä»¶æ¥å¤„ç†ã€‚    if err == nil &amp;&amp; !maxCodeSizeExceeded {        createDataGas := uint64(len(ret)) * params.CreateDataGas        if contract.UseGas(createDataGas) {            evm.StateDB.SetCode(contractAddr, ret)        } else {            err = ErrCodeStoreOutOfGas        }    }    // When an error was returned by the EVM or when setting the creation code    // above we revert to the snapshot and consume any gas remaining. Additionally    // when we're in homestead this also counts for code storage gas errors.    // å½“é”™è¯¯è¿”å›æˆ‘ä»¬å›æ»šä¿®æ”¹ï¼Œ    if maxCodeSizeExceeded || (err != nil &amp;&amp; (evm.ChainConfig().IsHomestead(evm.BlockNumber) || err != ErrCodeStoreOutOfGas)) {        evm.StateDB.RevertToSnapshot(snapshot)        if err != errExecutionReverted {            contract.UseGas(contract.Gas)        }    }    // Assign err if contract code size exceeds the max while the err is still empty.    if maxCodeSizeExceeded &amp;&amp; err == nil {        err = errMaxCodeSizeExceeded    }    return ret, contractAddr, contract.Gas, err}</code></pre><p>Callæ–¹æ³•, æ— è®ºæˆ‘ä»¬è½¬è´¦æˆ–è€…æ˜¯æ‰§è¡Œåˆçº¦ä»£ç éƒ½ä¼šè°ƒç”¨åˆ°è¿™é‡Œï¼Œ åŒæ—¶åˆçº¦é‡Œé¢çš„callæŒ‡ä»¤ä¹Ÿä¼šæ‰§è¡Œåˆ°è¿™é‡Œã€‚</p><pre><code>// Call executes the contract associated with the addr with the given input as// parameters. It also handles any necessary value transfer required and takes// the necessary steps to create accounts and reverses the state in case of an// execution error or failed value transfer.// Call æ‰§è¡Œä¸ç»™å®šçš„inputä½œä¸ºå‚æ•°ä¸addrç›¸å…³è”çš„åˆçº¦ã€‚ // å®ƒè¿˜å¤„ç†æ‰€éœ€çš„ä»»ä½•å¿…è¦çš„è½¬è´¦æ“ä½œï¼Œå¹¶é‡‡å–å¿…è¦çš„æ­¥éª¤æ¥åˆ›å»ºå¸æˆ·// å¹¶åœ¨ä»»æ„é”™è¯¯çš„æƒ…å†µä¸‹å›æ»šæ‰€åšçš„æ“ä½œã€‚func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {    if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 {        return nil, gas, nil    }    // Fail if we're trying to execute above the call depth limit    //  è°ƒç”¨æ·±åº¦æœ€å¤š1024    if evm.depth &gt; int(params.CallCreateDepth) {        return nil, gas, ErrDepth    }    // Fail if we're trying to transfer more than the available balance    // æŸ¥çœ‹æˆ‘ä»¬çš„è´¦æˆ·æ˜¯å¦æœ‰è¶³å¤Ÿçš„é‡‘é’±ã€‚    if !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {        return nil, gas, ErrInsufficientBalance    }    var (        to       = AccountRef(addr)        snapshot = evm.StateDB.Snapshot()    )    if !evm.StateDB.Exist(addr) { // æŸ¥çœ‹æŒ‡å®šåœ°å€æ˜¯å¦å­˜åœ¨        // å¦‚æœåœ°å€ä¸å­˜åœ¨ï¼ŒæŸ¥çœ‹æ˜¯å¦æ˜¯ native goçš„åˆçº¦ï¼Œ native goçš„åˆçº¦åœ¨        // contracts.go æ–‡ä»¶é‡Œé¢        precompiles := PrecompiledContractsHomestead        if evm.ChainConfig().IsByzantium(evm.BlockNumber) {            precompiles = PrecompiledContractsByzantium        }        if precompiles[addr] == nil &amp;&amp; evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; value.Sign() == 0 {            // å¦‚æœä¸æ˜¯æŒ‡å®šçš„åˆçº¦åœ°å€ï¼Œ å¹¶ä¸”valueçš„å€¼ä¸º0é‚£ä¹ˆè¿”å›æ­£å¸¸ï¼Œè€Œä¸”è¿™æ¬¡è°ƒç”¨æ²¡æœ‰æ¶ˆè€—Gas            return nil, gas, nil        }        // è´Ÿè´£åœ¨æœ¬åœ°çŠ¶æ€åˆ›å»ºaddr        evm.StateDB.CreateAccount(addr)    }    // æ‰§è¡Œè½¬è´¦    evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)    // initialise a new contract and set the code that is to be used by the    // E The contract is a scoped environment for this execution context    // only.    contract := NewContract(caller, to, value, gas)    contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))    ret, err = run(evm, snapshot, contract, input)    // When an error was returned by the EVM or when setting the creation code    // above we revert to the snapshot and consume any gas remaining. Additionally    // when we're in homestead this also counts for code storage gas errors.    if err != nil {        evm.StateDB.RevertToSnapshot(snapshot)        if err != errExecutionReverted {             // å¦‚æœæ˜¯ç”±revertæŒ‡ä»¤è§¦å‘çš„é”™è¯¯ï¼Œå› ä¸ºICOä¸€èˆ¬è®¾ç½®äº†äººæ•°é™åˆ¶æˆ–è€…èµ„é‡‘é™åˆ¶            // åœ¨å¤§å®¶æŠ¢è´­çš„æ—¶å€™å¾ˆå¯èƒ½ä¼šè§¦å‘è¿™äº›é™åˆ¶æ¡ä»¶ï¼Œå¯¼è‡´è¢«æŠ½èµ°ä¸å°‘é’±ã€‚è¿™ä¸ªæ—¶å€™            // åˆä¸èƒ½è®¾ç½®æ¯”è¾ƒä½çš„GasPriceå’ŒGasLimitã€‚å› ä¸ºè¦é€Ÿåº¦å¿«ã€‚            // é‚£ä¹ˆä¸ä¼šä½¿ç”¨å‰©ä¸‹çš„å…¨éƒ¨Gasï¼Œè€Œæ˜¯åªä¼šä½¿ç”¨ä»£ç æ‰§è¡Œçš„Gas            // ä¸ç„¶ä¼šè¢«æŠ½èµ° GasLimit *GasPriceçš„é’±ï¼Œé‚£å¯ä¸å°‘ã€‚            contract.UseGas(contract.Gas)        }    }    return ret, contract.Gas, err}</code></pre><p>å‰©ä¸‹çš„ä¸‰ä¸ªå‡½æ•° CallCode, DelegateCall, å’Œ StaticCallï¼Œè¿™ä¸‰ä¸ªå‡½æ•°ä¸èƒ½ç”±å¤–éƒ¨è°ƒç”¨ï¼Œåªèƒ½ç”±Opcodeè§¦å‘ã€‚</p><p>CallCode</p><pre><code>// CallCode differs from Call in the sense that it executes the given address'// code with the caller as context.// CallCodeä¸Callä¸åŒçš„åœ°æ–¹åœ¨äºå®ƒä½¿ç”¨callerçš„contextæ¥æ‰§è¡Œç»™å®šåœ°å€çš„ä»£ç ã€‚func (evm *EVM) CallCode(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {    if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 {        return nil, gas, nil    }    // Fail if we're trying to execute above the call depth limit    if evm.depth &gt; int(params.CallCreateDepth) {        return nil, gas, ErrDepth    }    // Fail if we're trying to transfer more than the available balance    if !evm.CanTransfer(evm.StateDB, caller.Address(), value) {        return nil, gas, ErrInsufficientBalance    }    var (        snapshot = evm.StateDB.Snapshot()        to       = AccountRef(caller.Address())  //è¿™é‡Œæ˜¯æœ€ä¸åŒçš„åœ°æ–¹ toçš„åœ°å€è¢«ä¿®æ”¹ä¸ºcallerçš„åœ°å€äº† è€Œä¸”æ²¡æœ‰è½¬è´¦çš„è¡Œä¸º    )    // initialise a new contract and set the code that is to be used by the    // E The contract is a scoped evmironment for this execution context    // only.    contract := NewContract(caller, to, value, gas)    contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))    ret, err = run(evm, snapshot, contract, input)    if err != nil {        evm.StateDB.RevertToSnapshot(snapshot)        if err != errExecutionReverted {            contract.UseGas(contract.Gas)        }    }    return ret, contract.Gas, err}</code></pre><p>DelegateCall</p><pre><code>// DelegateCall differs from CallCode in the sense that it executes the given address'// code with the caller as context and the caller is set to the caller of the caller.// DelegateCall å’Œ CallCodeä¸åŒçš„åœ°æ–¹åœ¨äº callerè¢«è®¾ç½®ä¸º callerçš„callerfunc (evm *EVM) DelegateCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {    if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 {        return nil, gas, nil    }    // Fail if we're trying to execute above the call depth limit    if evm.depth &gt; int(params.CallCreateDepth) {        return nil, gas, ErrDepth    }    var (        snapshot = evm.StateDB.Snapshot()        to       = AccountRef(caller.Address())     )    // Initialise a new contract and make initialise the delegate values    // æ ‡è¯†ä¸ºAsDelete()    contract := NewContract(caller, to, nil, gas).AsDelegate()     contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))    ret, err = run(evm, snapshot, contract, input)    if err != nil {        evm.StateDB.RevertToSnapshot(snapshot)        if err != errExecutionReverted {            contract.UseGas(contract.Gas)        }    }    return ret, contract.Gas, err}// StaticCall executes the contract associated with the addr with the given input// as parameters while disallowing any modifications to the state during the call.// Opcodes that attempt to perform such modifications will result in exceptions// instead of performing the modifications.// StaticCallä¸å…è®¸æ‰§è¡Œä»»ä½•ä¿®æ”¹çŠ¶æ€çš„æ“ä½œï¼Œfunc (evm *EVM) StaticCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {    if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 {        return nil, gas, nil    }    // Fail if we're trying to execute above the call depth limit    if evm.depth &gt; int(params.CallCreateDepth) {        return nil, gas, ErrDepth    }    // Make sure the readonly is only set if we aren't in readonly yet    // this makes also sure that the readonly flag isn't removed for    // child calls.    if !evm.interpreter.readOnly {        evm.interpreter.readOnly = true        defer func() { evm.interpreter.readOnly = false }()    }    var (        to       = AccountRef(addr)        snapshot = evm.StateDB.Snapshot()    )    // Initialise a new contract and set the code that is to be used by the    // EVM. The contract is a scoped environment for this execution context    // only.    contract := NewContract(caller, to, new(big.Int), gas)    contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))    // When an error was returned by the EVM or when setting the creation code    // above we revert to the snapshot and consume any gas remaining. Additionally    // when we're in Homestead this also counts for code storage gas errors.    ret, err = run(evm, snapshot, contract, input)    if err != nil {        evm.StateDB.RevertToSnapshot(snapshot)        if err != errExecutionReverted {            contract.UseGas(contract.Gas)        }    }    return ret, contract.Gas, err}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-eth-bloombitså’Œfilteræºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-bloombits%E5%92%8Cfilter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-bloombits%E5%92%8Cfilter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="ä»¥å¤ªåŠçš„å¸ƒéš†è¿‡æ»¤å™¨"><a href="#ä»¥å¤ªåŠçš„å¸ƒéš†è¿‡æ»¤å™¨" class="headerlink" title="ä»¥å¤ªåŠçš„å¸ƒéš†è¿‡æ»¤å™¨"></a>ä»¥å¤ªåŠçš„å¸ƒéš†è¿‡æ»¤å™¨</h2><p>ä»¥å¤ªåŠçš„åŒºå—å¤´ä¸­åŒ…å«äº†ä¸€ä¸ªå«åšlogsBloomçš„åŒºåŸŸã€‚ è¿™ä¸ªåŒºåŸŸå­˜å‚¨äº†å½“å‰åŒºå—ä¸­æ‰€æœ‰çš„æ”¶æ®çš„æ—¥å¿—çš„å¸ƒéš†è¿‡æ»¤å™¨ï¼Œä¸€å…±æ˜¯2048ä¸ªbitã€‚ä¹Ÿå°±æ˜¯256ä¸ªå­—èŠ‚ã€‚</p><p>è€Œæˆ‘ä»¬çš„ä¸€ä¸ªäº¤æ˜“çš„æ”¶æ®åŒ…å«äº†å¾ˆå¤šçš„æ—¥å¿—è®°å½•ã€‚ æ¯ä¸ªæ—¥å¿—è®°å½•åŒ…å«äº† åˆçº¦çš„åœ°å€ï¼Œ å¤šä¸ªTopicã€‚ è€Œåœ¨æˆ‘ä»¬çš„æ”¶æ®ä¸­ä¹Ÿå­˜åœ¨ä¸€ä¸ªå¸ƒéš†è¿‡æ»¤å™¨ï¼Œè¿™ä¸ªå¸ƒéš†è¿‡æ»¤å™¨è®°å½•äº†æ‰€æœ‰çš„æ—¥å¿—è®°å½•çš„ä¿¡æ¯ã€‚</p><p><img src="/images/ethereum/source_analysis/bloom_1.png" alt="image"></p><p>å¦‚æœæˆ‘ä»¬çœ‹é»„çš®ä¹¦é‡Œé¢å¯¹æ—¥å¿—è®°å½•çš„å½¢å¼åŒ–å®šä¹‰ã€‚</p><p>Oä»£è¡¨æˆ‘ä»¬çš„æ—¥å¿—è®°å½•ï¼ŒOaä»£è¡¨loggerçš„åœ°å€ï¼ŒOto,Ot1ä»£è¡¨æ—¥å¿—çš„Topicsï¼Œ Odä»£è¡¨æ—¶é—´ã€‚</p><p><img src="/images/ethereum/source_analysis/bloom_2.png" alt="image"></p><p>Oaæ˜¯20ä¸ªå­—èŠ‚ï¼ŒOtæ˜¯32ä¸ªå­—èŠ‚ï¼ŒOdæ˜¯å¾ˆå¤šå­—èŠ‚</p><p><img src="/images/ethereum/source_analysis/bloom_3.png" alt="image"></p><p>æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå¸ƒéš†è¿‡æ»¤å™¨å‡½æ•°Mï¼Œç”¨æ¥æŠŠä¸€ä¸ªæ—¥å¿—å¯¹è±¡è½¬æ¢æˆ256å­—èŠ‚çš„hash</p><p><img src="/images/ethereum/source_analysis/bloom_4.png" alt="image"></p><p>M3:2045æ˜¯ä¸€ä¸ªç‰¹åˆ«çš„å‡½æ•°ï¼Œç”¨æ¥è®¾ç½®2048ä¸ªbitä½ä¸­çš„ä¸‰ä½ä¸º1ã€‚ å…·ä½“çš„æ–¹æ³•è¯·å‚è€ƒä¸‹é¢çš„å…¬å¼ã€‚</p><p><img src="/images/ethereum/source_analysis/bloom_5.png" alt="image"></p><p>å¯¹äºä»»æ„çš„è¾“å…¥å€¼ï¼Œé¦–å…ˆæ±‚ä»–çš„KECè¾“å‡ºï¼Œ ç„¶åé€šè¿‡å–KECè¾“å‡ºçš„ [0,1] [2,3],[4,5] è¿™å‡ ä½çš„å€¼ å¯¹2048å–æ¨¡ï¼Œ å¾—åˆ°ä¸‰ä¸ªå€¼ï¼Œ è¿™ä¸‰ä¸ªå€¼å°±æ˜¯è¾“å‡ºçš„2048ä¸­éœ€è¦ç½®ä½çš„ä¸‹æ ‡ã€‚ ä¹Ÿå°±æ˜¯è¯´å¯¹äºä»»ä½•ä¸€ä¸ªè¾“å…¥ï¼Œå¦‚æœå®ƒå¯¹åº”çš„ä¸‰ä¸ªä¸‹æ ‡çš„å€¼ä¸éƒ½ä¸º1ï¼Œé‚£ä¹ˆå®ƒè‚¯å®šä¸åœ¨è¿™ä¸ªåŒºå—ä¸­ã€‚ å½“å¦‚å¦‚æœå¯¹åº”çš„ä¸‰ä½éƒ½ä¸º1ï¼Œä¹Ÿä¸èƒ½è¯´æ˜ä¸€å®šåœ¨è¿™ä¸ªåŒºå—ä¸­ã€‚ è¿™å°±æ˜¯å¸ƒéš†è¿‡æ»¤å™¨çš„ç‰¹æ€§ã€‚</p><p>æ”¶æ®ä¸­çš„å¸ƒéš†è¿‡æ»¤å™¨å°±æ˜¯æ‰€æœ‰çš„æ—¥å¿—çš„å¸ƒéš†è¿‡æ»¤å™¨è¾“å‡ºçš„å¹¶é›†ã€‚</p><p>åŒæ—¶åŒºå—å¤´ä¸­çš„logBloomï¼Œå°±æ˜¯æ‰€æœ‰çš„æ”¶æ®çš„å¸ƒéš†è¿‡æ»¤å™¨çš„å¹¶é›†ã€‚</p><h2 id="ChainIndexer-å’Œ-BloomIndexer"><a href="#ChainIndexer-å’Œ-BloomIndexer" class="headerlink" title="ChainIndexer å’Œ BloomIndexer"></a>ChainIndexer å’Œ BloomIndexer</h2><p>æœ€å¼€å§‹çœ‹åˆ°ChainIndexerï¼Œä¸æ˜¯å¾ˆæ˜ç™½æ˜¯ä»€ä¹ˆåŠŸèƒ½ã€‚ å…¶å®ä»åå­—ä¸­å¯ä»¥çœ‹åˆ°ï¼Œæ˜¯Chainçš„ç´¢å¼•ã€‚ åœ¨ ethä¸­æˆ‘ä»¬æœ‰çœ‹åˆ°BloomIndexer,è¿™ä¸ªå°±æ˜¯å¸ƒéš†è¿‡æ»¤å™¨çš„ç´¢å¼•ã€‚</p><p>åœ¨æˆ‘ä»¬çš„åè®®ä¸­æä¾›äº†æŸ¥æ‰¾æŒ‡å®šLogçš„åŠŸèƒ½ã€‚ </p><p>ç”¨æˆ·å¯ä»¥é€šè¿‡ä¼ é€’ä¸‹é¢çš„å‚æ•°æ¥æŸ¥æ‰¾æŒ‡å®šçš„Log,å¼€å§‹çš„åŒºå—å·ï¼Œç»“æŸçš„åŒºå—å·ï¼Œ æ ¹æ®åˆçº¦ AddressesæŒ‡å®šçš„åœ°å€è¿‡æ»¤ï¼Œæ ¹æ®æŒ‡å®šçš„Topicsæ¥è¿‡æ»¤ã€‚</p><pre><code>// FilterCriteria represents a request to create a new filter.type FilterCriteria struct {    FromBlock *big.Int    ToBlock   *big.Int    Addresses []common.Address    Topics    [][]common.Hash}</code></pre><p>å¦‚æœå¼€å§‹å’Œç»“æŸä¹‹é—´é—´éš”å¾ˆå¤§ï¼Œé‚£ä¹ˆå¦‚æœç›´æ¥ä¾æ¬¡æ£€ç´¢æ¯ä¸ªåŒºå—å¤´çš„logBloomåŒºåŸŸæ˜¯æ¯”è¾ƒä½æ•ˆçš„ã€‚ å› ä¸ºæ¯ä¸ªåŒºå—å¤´éƒ½æ˜¯åˆ†å¼€å­˜å‚¨çš„ï¼Œ å¯èƒ½éœ€è¦éå¸¸å¤šçš„ç£ç›˜éšæœºè®¿é—®ã€‚</p><p>æ‰€ä»¥ä»¥å¤ªåŠåè®®åœ¨æœ¬åœ°ç»´æŠ¤äº†ä¸€å¥—ç´¢å¼•ï¼Œç”¨æ¥åŠ é€Ÿè¿™ä¸ªè¿‡ç¨‹ã€‚ </p><p>å¤§è‡´åŸç†æ˜¯ã€‚ æ¯4096ä¸ªåŒºå—ç§°ä¸ºä¸€ä¸ªSectionï¼Œä¸€ä¸ªSectioné‡Œé¢çš„logBloomä¼šå­˜å‚¨åœ¨ä¸€èµ·ã€‚å¯¹äºæ¯ä¸ªSection, ç”¨ä¸€ä¸ªäºŒç»´æ•°æ®ï¼ŒA[2048][4096]æ¥å­˜å‚¨ã€‚ ç¬¬ä¸€ç»´2048ä»£è¡¨äº†bloomè¿‡æ»¤å™¨çš„é•¿åº¦2048ä¸ªå­—èŠ‚ã€‚ ç¬¬äºŒç»´4096ä»£è¡¨äº†ä¸€ä¸ªSectioné‡Œé¢çš„æ‰€æœ‰åŒºå—ï¼Œæ¯ä¸€ä¸ªä½ç½®æŒ‰ç…§é¡ºåºä»£è¡¨äº†å…¶ä¸­çš„ä¸€ä¸ªåŒºå—ã€‚</p><ul><li>A[0][0]=blockchain[section*4096+0].logBloom[0],</li><li>A[0][1]=blockchain[section*4096+1].logBloom[0],</li><li>A[0][4096]=blockchain[section*4096+1].logBloom[0],</li><li>A[1][0]=blockchain[section*4096+0].logBloom[1],</li><li>A[1][1024]=blockchain[section*4096+1024].logBloom[1],</li><li>A[2047][1]=blockchain[section*4096+1].logBloom[2047],</li></ul><p>å¦‚æœSectionå¡«å……å®Œæ¯•ï¼Œé‚£ä¹ˆä¼šå†™æˆ2048ä¸ªKVã€‚<br><img src="/images/ethereum/source_analysis/bloom_6.png" alt="image"></p><h2 id="bloombit-go-ä»£ç åˆ†æ"><a href="#bloombit-go-ä»£ç åˆ†æ" class="headerlink" title="bloombit.go ä»£ç åˆ†æ"></a>bloombit.go ä»£ç åˆ†æ</h2><p>è¿™ä¸ªä»£ç ç›¸å¯¹ä¸æ˜¯å¾ˆç‹¬ç«‹ï¼Œå¦‚æœå•ç‹¬çœ‹è¿™ä¸ªä»£ç ï¼Œæœ‰ç‚¹æ‘¸ä¸ç€å¤´è„‘çš„æ„Ÿè§‰ï¼Œ å› ä¸ºå®ƒåªæ˜¯å®ç°äº†ä¸€äº›æ¥å£ï¼Œå…·ä½“çš„å¤„ç†é€»è¾‘å¹¶ä¸åœ¨è¿™é‡Œï¼Œè€Œæ˜¯åœ¨coreé‡Œé¢ã€‚ ä¸è¿‡è¿™é‡Œæˆ‘å…ˆç»“åˆä¹‹å‰è®²åˆ°çš„ä¿¡æ¯åˆ†æä¸€ä¸‹ã€‚ åç»­æ›´è¯¦ç»†çš„é€»è¾‘åœ¨åˆ†æcoreçš„ä»£ç çš„æ—¶å€™å†è¯¦ç»†åˆ†æã€‚</p><p>æœåŠ¡çº¿ç¨‹startBloomHandlers,è¿™ä¸ªæ–¹æ³•æ˜¯ä¸ºäº†å“åº”å…·ä½“çš„æŸ¥è¯¢è¯·æ±‚ï¼Œ ç»™å®šæŒ‡å®šçš„Sectionå’Œbitæ¥ä»levelDBé‡Œé¢æŸ¥è¯¢ç„¶åè¿”å›å‡ºå»ã€‚ å•ç‹¬çœ‹è¿™é‡Œæœ‰ç‚¹æ‘¸ä¸ç€å¤´è„‘ã€‚ è¿™ä¸ªæ–¹æ³•çš„è°ƒç”¨æ¯”è¾ƒå¤æ‚ã€‚ æ¶‰åŠåˆ°coreé‡Œé¢çš„å¾ˆå¤šé€»è¾‘ã€‚ è¿™é‡Œå…ˆä¸ç»†è¯´äº†ã€‚ ç›´åˆ°æœ‰è¿™ä¸ªæ–¹æ³•å°±è¡Œäº†ã€‚</p><pre><code>type Retrieval struct {    Bit      uint            //Bitçš„å–å€¼ 0-2047 ä»£è¡¨äº†æƒ³è¦è·å–å“ªä¸€ä½çš„å€¼    Sections []uint64        // é‚£äº›Section    Bitsets  [][]byte        // è¿”å›å€¼ æŸ¥è¯¢å‡ºæ¥çš„ç»“æœã€‚}// startBloomHandlers starts a batch of goroutines to accept bloom bit database// retrievals from possibly a range of filters and serving the data to satisfy.func (eth *Ethereum) startBloomHandlers() {    for i := 0; i &lt; bloomServiceThreads; i++ {        go func() {            for {                select {                case &lt;-eth.shutdownChan:                    return                case request := &lt;-eth.bloomRequests: // requestæ˜¯ä¸€ä¸ªé€šé“                    task := &lt;-request //ä»é€šé“é‡Œé¢è·å–ä¸€ä¸ªtask                    task.Bitsets = make([][]byte, len(task.Sections))                    for i, section := range task.Sections {                        head := core.GetCanonicalHash(eth.chainDb, (section+1)*params.BloomBitsBlocks-1)                        blob, err := bitutil.DecompressBytes(core.GetBloomBits(eth.chainDb, task.Bit, section, head), int(params.BloomBitsBlocks)/8)                        if err != nil {                            panic(err)                        }                        task.Bitsets[i] = blob                    }                    request &lt;- task //é€šè¿‡requesté€šé“è¿”å›ç»“æœ                }            }        }()    }}</code></pre><h3 id="æ•°æ®ç»“æ„"><a href="#æ•°æ®ç»“æ„" class="headerlink" title="æ•°æ®ç»“æ„"></a>æ•°æ®ç»“æ„</h3><p>BloomIndexerå¯¹è±¡ä¸»è¦ç”¨æˆ·æ„å»ºç´¢å¼•çš„è¿‡ç¨‹ï¼Œæ˜¯core.ChainIndexerçš„ä¸€ä¸ªæ¥å£å®ç°ï¼Œæ‰€ä»¥åªå®ç°äº†ä¸€äº›å¿…é¡»çš„æ¥å£ã€‚å¯¹äºåˆ›å»ºç´¢å¼•çš„é€»è¾‘è¿˜åœ¨core.ChainIndexeré‡Œé¢ã€‚</p><pre><code>// BloomIndexer implements a core.ChainIndexer, building up a rotated bloom bits index// for the Ethereum header bloom filters, permitting blazing fast filtering.type BloomIndexer struct {    size uint64 // section size to generate bloombits for    db  ethdb.Database       // database instance to write index data and metadata into    gen *bloombits.Generator // generator to rotate the bloom bits crating the bloom index    section uint64      // Section is the section number being processed currently  å½“å‰çš„section    head    common.Hash // Head is the hash of the last header processed}// NewBloomIndexer returns a chain indexer that generates bloom bits data for the// canonical chain for fast logs filtering.func NewBloomIndexer(db ethdb.Database, size uint64) *core.ChainIndexer {    backend := &amp;BloomIndexer{        db:   db,        size: size,    }    table := ethdb.NewTable(db, string(core.BloomBitsIndexPrefix))    return core.NewChainIndexer(db, table, backend, size, bloomConfirms, bloomThrottling, "bloombits")}</code></pre><p>Resetå®ç°äº†ChainIndexerBackendçš„æ–¹æ³•ï¼Œå¯åŠ¨ä¸€ä¸ªæ–°çš„section</p><pre><code>// Reset implements core.ChainIndexerBackend, starting a new bloombits index// section.func (b *BloomIndexer) Reset(section uint64) {    gen, err := bloombits.NewGenerator(uint(b.size))    if err != nil {        panic(err)    }    b.gen, b.section, b.head = gen, section, common.Hash{}}</code></pre><p>Processå®ç°äº†ChainIndexerBackendï¼Œ å¢åŠ ä¸€ä¸ªæ–°çš„åŒºå—å¤´åˆ°index</p><pre><code>// Process implements core.ChainIndexerBackend, adding a new header's bloom into// the index.func (b *BloomIndexer) Process(header *types.Header) {    b.gen.AddBloom(uint(header.Number.Uint64()-b.section*b.size), header.Bloom)    b.head = header.Hash()}</code></pre><p>Commitæ–¹æ³•å®ç°äº†ChainIndexerBackendï¼ŒæŒä¹…åŒ–å¹¶å†™å…¥æ•°æ®åº“ã€‚</p><pre><code>// Commit implements core.ChainIndexerBackend, finalizing the bloom section and// writing it out into the database.func (b *BloomIndexer) Commit() error {    batch := b.db.NewBatch()    for i := 0; i &lt; types.BloomBitLength; i++ {        bits, err := b.gen.Bitset(uint(i))        if err != nil {            return err        }        core.WriteBloomBits(batch, uint(i), b.section, b.head, bitutil.CompressBytes(bits))    }    return batch.Write()}</code></pre><h2 id="filter-api-go-æºç åˆ†æ"><a href="#filter-api-go-æºç åˆ†æ" class="headerlink" title="filter/api.go æºç åˆ†æ"></a>filter/api.go æºç åˆ†æ</h2><p>eth/filter åŒ… åŒ…å«äº†ç»™ç”¨æˆ·æä¾›è¿‡æ»¤çš„åŠŸèƒ½ï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡è°ƒç”¨å¯¹äº¤æ˜“æˆ–è€…åŒºå—è¿›è¡Œè¿‡æ»¤ï¼Œç„¶åæŒç»­çš„è·å–ç»“æœï¼Œå¦‚æœ5åˆ†é’Ÿæ²¡æœ‰æ“ä½œï¼Œè¿™ä¸ªè¿‡æ»¤å™¨ä¼šè¢«åˆ é™¤ã€‚</p><p>è¿‡æ»¤å™¨çš„ç»“æ„ã€‚</p><pre><code>var (    deadline = 5 * time.Minute // consider a filter inactive if it has not been polled for within deadline)// filter is a helper struct that holds meta information over the filter type// and associated subscription in the event system.type filter struct {    typ      Type            // è¿‡æ»¤å™¨çš„ç±»å‹ï¼Œ è¿‡æ»¤ä»€ä¹ˆç±»å‹çš„æ•°æ®    deadline *time.Timer // filter is inactiv when deadline triggers å½“è®¡æ—¶å™¨å“èµ·çš„æ—¶å€™ï¼Œä¼šè§¦å‘å®šæ—¶å™¨ã€‚    hashes   []common.Hash //è¿‡æ»¤å‡ºæ¥çš„hashç»“æœ    crit     FilterCriteria    //è¿‡æ»¤æ¡ä»¶    logs     []*types.Log    //è¿‡æ»¤å‡ºæ¥çš„Logä¿¡æ¯    s        *Subscription // associated subscription in event system äº‹ä»¶ç³»ç»Ÿä¸­çš„è®¢é˜…å™¨ã€‚}</code></pre><p>æ„é€ æ–¹æ³•</p><pre><code>// PublicFilterAPI offers support to create and manage filters. This will allow external clients to retrieve various// information related to the Ethereum protocol such als blocks, transactions and logs.// PublicFilterAPIç”¨æ¥åˆ›å»ºå’Œç®¡ç†è¿‡æ»¤å™¨ã€‚ å…è®¸å¤–éƒ¨çš„å®¢æˆ·ç«¯è·å–ä»¥å¤ªåŠåè®®çš„ä¸€äº›ä¿¡æ¯ï¼Œæ¯”å¦‚åŒºå—ä¿¡æ¯ï¼Œäº¤æ˜“ä¿¡æ¯å’Œæ—¥å¿—ä¿¡æ¯ã€‚type PublicFilterAPI struct {    backend   Backend    mux       *event.TypeMux    quit      chan struct{}    chainDb   ethdb.Database    events    *EventSystem    filtersMu sync.Mutex    filters   map[rpc.ID]*filter}// NewPublicFilterAPI returns a new PublicFilterAPI instance.func NewPublicFilterAPI(backend Backend, lightMode bool) *PublicFilterAPI {    api := &amp;PublicFilterAPI{        backend: backend,        mux:     backend.EventMux(),        chainDb: backend.ChainDb(),        events:  NewEventSystem(backend.EventMux(), backend, lightMode),        filters: make(map[rpc.ID]*filter),    }    go api.timeoutLoop()    return api}</code></pre><h3 id="è¶…æ—¶æ£€æŸ¥"><a href="#è¶…æ—¶æ£€æŸ¥" class="headerlink" title="è¶…æ—¶æ£€æŸ¥"></a>è¶…æ—¶æ£€æŸ¥</h3><pre><code>// timeoutLoop runs every 5 minutes and deletes filters that have not been recently used.// Tt is started when the api is created.// æ¯éš”5åˆ†é’Ÿæ£€æŸ¥ä¸€ä¸‹ã€‚ å¦‚æœè¿‡æœŸçš„è¿‡æ»¤å™¨ï¼Œåˆ é™¤ã€‚func (api *PublicFilterAPI) timeoutLoop() {    ticker := time.NewTicker(5 * time.Minute)    for {        &lt;-ticker.C        api.filtersMu.Lock()        for id, f := range api.filters {            select {            case &lt;-f.deadline.C:                f.s.Unsubscribe()                delete(api.filters, id)            default:                continue            }        }        api.filtersMu.Unlock()    }}</code></pre><p>NewPendingTransactionFilter,ç”¨æ¥åˆ›å»ºä¸€ä¸ªPendingTransactionFilterã€‚  è¿™ç§æ–¹å¼æ˜¯ç”¨æ¥ç»™é‚£ç§æ— æ³•åˆ›å»ºé•¿è¿æ¥çš„é€šé“ä½¿ç”¨çš„(æ¯”å¦‚HTTP), å¦‚æœå¯¹äºå¯ä»¥å»ºç«‹é•¿é“¾æ¥çš„é€šé“(æ¯”å¦‚WebSocket)å¯ä»¥ä½¿ç”¨rpcæä¾›çš„å‘é€è®¢é˜…æ¨¡å¼æ¥å¤„ç†ï¼Œå°±ä¸ç”¨æŒç»­çš„è½®è¯¢äº†</p><pre><code>// NewPendingTransactionFilter creates a filter that fetches pending transaction hashes// as transactions enter the pending state.//// It is part of the filter package because this filter can be used throug the// `eth_getFilterChanges` polling method that is also used for log filters.//// https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_newpendingtransactionfilterfunc (api *PublicFilterAPI) NewPendingTransactionFilter() rpc.ID {    var (        pendingTxs   = make(chan common.Hash)        // åœ¨äº‹ä»¶ç³»ç»Ÿè®¢é˜…è¿™ç§æ¶ˆæ¯        pendingTxSub = api.events.SubscribePendingTxEvents(pendingTxs)    )    api.filtersMu.Lock()    api.filters[pendingTxSub.ID] = &amp;filter{typ: PendingTransactionsSubscription, deadline: time.NewTimer(deadline), hashes: make([]common.Hash, 0), s: pendingTxSub}    api.filtersMu.Unlock()    go func() {        for {            select {            case ph := &lt;-pendingTxs: // æ¥æ”¶åˆ°pendingTxsï¼Œå­˜å‚¨åœ¨è¿‡æ»¤å™¨çš„hasheså®¹å™¨é‡Œé¢ã€‚                api.filtersMu.Lock()                if f, found := api.filters[pendingTxSub.ID]; found {                    f.hashes = append(f.hashes, ph)                }                api.filtersMu.Unlock()            case &lt;-pendingTxSub.Err():                api.filtersMu.Lock()                delete(api.filters, pendingTxSub.ID)                api.filtersMu.Unlock()                return            }        }    }()    return pendingTxSub.ID}</code></pre><p>è½®è¯¢: GetFilterChanges</p><pre><code>// GetFilterChanges returns the logs for the filter with the given id since// last time it was called. This can be used for polling.// GetFilterChanges ç”¨æ¥è¿”å›ä»ä¸Šæ¬¡è°ƒç”¨åˆ°ç°åœ¨çš„æ‰€æœ‰çš„æŒ‡å®šidçš„æ‰€æœ‰è¿‡æ»¤ä¿¡æ¯ã€‚è¿™ä¸ªå¯ä»¥ç”¨æ¥è½®è¯¢ã€‚// For pending transaction and block filters the result is []common.Hash.// (pending)Log filters return []Log.// å¯¹äºpending transactionå’Œblockçš„è¿‡æ»¤å™¨ï¼Œè¿”å›ç»“æœç±»å‹æ˜¯[]common.Hash. å¯¹äºpending Log è¿‡æ»¤å™¨ï¼Œè¿”å›çš„æ˜¯ []Log// https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getfilterchangesfunc (api *PublicFilterAPI) GetFilterChanges(id rpc.ID) (interface{}, error) {    api.filtersMu.Lock()    defer api.filtersMu.Unlock()    if f, found := api.filters[id]; found {        if !f.deadline.Stop() { // å¦‚æœå®šæ—¶å™¨å·²ç»è§¦å‘ï¼Œä½†æ˜¯filterè¿˜æ²¡æœ‰ç§»é™¤ï¼Œé‚£ä¹ˆæˆ‘ä»¬å…ˆæ¥æ”¶å®šæ—¶å™¨çš„å€¼ï¼Œç„¶åé‡ç½®å®šæ—¶å™¨            // timer expired but filter is not yet removed in timeout loop            // receive timer value and reset timer            &lt;-f.deadline.C        }        f.deadline.Reset(deadline)        switch f.typ {        case PendingTransactionsSubscription, BlocksSubscription:            hashes := f.hashes            f.hashes = nil            return returnHashes(hashes), nil        case LogsSubscription:            logs := f.logs            f.logs = nil            return returnLogs(logs), nil        }    }    return []interface{}{}, fmt.Errorf("filter not found")}</code></pre><p>å¯¹äºå¯ä»¥å»ºç«‹é•¿è¿æ¥çš„é€šé“ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨rpcçš„å‘é€è®¢é˜…æ¨¡å¼ï¼Œ è¿™æ ·å®¢æˆ·ç«¯å°±å¯ä»¥ç›´æ¥æ¥æ”¶åˆ°è¿‡æ»¤ä¿¡æ¯ï¼Œä¸ç”¨è°ƒç”¨è½®è¯¢çš„æ–¹å¼äº†ã€‚ å¯ä»¥çœ‹åˆ°è¿™ç§æ¨¡å¼ä¸‹é¢å¹¶æ²¡æœ‰æ·»åŠ åˆ°filtersè¿™ä¸ªå®¹å™¨ï¼Œä¹Ÿæ²¡æœ‰è¶…æ—¶ç®¡ç†äº†ã€‚ä¹Ÿå°±æ˜¯è¯´æ”¯æŒä¸¤ç§æ¨¡å¼ã€‚</p><pre><code>// NewPendingTransactions creates a subscription that is triggered each time a transaction// enters the transaction pool and was signed from one of the transactions this nodes manages.func (api *PublicFilterAPI) NewPendingTransactions(ctx context.Context) (*rpc.Subscription, error) {    notifier, supported := rpc.NotifierFromContext(ctx)    if !supported {        return &amp;rpc.Subscription{}, rpc.ErrNotificationsUnsupported    }    rpcSub := notifier.CreateSubscription()    go func() {        txHashes := make(chan common.Hash)        pendingTxSub := api.events.SubscribePendingTxEvents(txHashes)        for {            select {            case h := &lt;-txHashes:                notifier.Notify(rpcSub.ID, h)            case &lt;-rpcSub.Err():                pendingTxSub.Unsubscribe()                return            case &lt;-notifier.Closed():                pendingTxSub.Unsubscribe()                return            }        }    }()    return rpcSub, nil}</code></pre><p>æ—¥å¿—è¿‡æ»¤åŠŸèƒ½ï¼Œæ ¹æ®FilterCriteriaæŒ‡å®šçš„å‚æ•°ï¼Œæ¥å¯¹æ—¥å¿—è¿›è¡Œè¿‡æ»¤ï¼Œå¼€å§‹åŒºå—ï¼Œç»“æŸåŒºå—ï¼Œåœ°å€å’ŒTopicsï¼Œè¿™é‡Œé¢å¼•å…¥äº†ä¸€ä¸ªæ–°çš„å¯¹è±¡filter</p><pre><code>// FilterCriteria represents a request to create a new filter.type FilterCriteria struct {    FromBlock *big.Int    ToBlock   *big.Int    Addresses []common.Address    Topics    [][]common.Hash}    // GetLogs returns logs matching the given argument that are stored within the state.//// https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getlogsfunc (api *PublicFilterAPI) GetLogs(ctx context.Context, crit FilterCriteria) ([]*types.Log, error) {    // Convert the RPC block numbers into internal representations    if crit.FromBlock == nil {        crit.FromBlock = big.NewInt(rpc.LatestBlockNumber.Int64())    }    if crit.ToBlock == nil {        crit.ToBlock = big.NewInt(rpc.LatestBlockNumber.Int64())    }    // Create and run the filter to get all the logs    // åˆ›å»ºäº†ä¸€ä¸ªFilterå¯¹è±¡ ç„¶åè°ƒç”¨filter.Logs    filter := New(api.backend, crit.FromBlock.Int64(), crit.ToBlock.Int64(), crit.Addresses, crit.Topics)    logs, err := filter.Logs(ctx)    if err != nil {        return nil, err    }    return returnLogs(logs), err}</code></pre><h2 id="filter-go"><a href="#filter-go" class="headerlink" title="filter.go"></a>filter.go</h2><p>fiter.goé‡Œé¢å®šä¹‰äº†ä¸€ä¸ªFilterå¯¹è±¡ã€‚è¿™ä¸ªå¯¹è±¡ä¸»è¦ç”¨æ¥æ ¹æ® åŒºå—çš„BloomIndexerå’Œå¸ƒéš†è¿‡æ»¤å™¨ç­‰æ¥æ‰§è¡Œæ—¥å¿—çš„è¿‡æ»¤åŠŸèƒ½ã€‚</p><h3 id="æ•°æ®ç»“æ„-1"><a href="#æ•°æ®ç»“æ„-1" class="headerlink" title="æ•°æ®ç»“æ„"></a>æ•°æ®ç»“æ„</h3><pre><code>// åç«¯ï¼Œ è¿™ä¸ªåç«¯å…¶å®æ˜¯åœ¨coreé‡Œé¢å®ç°çš„ã€‚ å¸ƒéš†è¿‡æ»¤å™¨çš„ä¸»è¦ç®—æ³•åœ¨coreé‡Œé¢å®ç°äº†ã€‚type Backend interface {    ChainDb() ethdb.Database    EventMux() *event.TypeMux    HeaderByNumber(ctx context.Context, blockNr rpc.BlockNumber) (*types.Header, error)    GetReceipts(ctx context.Context, blockHash common.Hash) (types.Receipts, error)    SubscribeTxPreEvent(chan&lt;- core.TxPreEvent) event.Subscription    SubscribeChainEvent(ch chan&lt;- core.ChainEvent) event.Subscription    SubscribeRemovedLogsEvent(ch chan&lt;- core.RemovedLogsEvent) event.Subscription    SubscribeLogsEvent(ch chan&lt;- []*types.Log) event.Subscription    BloomStatus() (uint64, uint64)    ServiceFilter(ctx context.Context, session *bloombits.MatcherSession)}// Filter can be used to retrieve and filter logs.type Filter struct {    backend Backend                // åç«¯    db         ethdb.Database    // æ•°æ®åº“    begin, end int64            // å¼€å§‹ç»“æŸåŒºå—    addresses  []common.Address    // ç­›é€‰åœ°å€    topics     [][]common.Hash    // ç­›é€‰ä¸»é¢˜    matcher *bloombits.Matcher    // å¸ƒéš†è¿‡æ»¤å™¨çš„åŒ¹é…å™¨}</code></pre><p>æ„é€ å‡½æ•°æŠŠaddresså’Œtopicéƒ½åŠ å…¥åˆ°filterså®¹å™¨ã€‚ç„¶åæ„å»ºäº†ä¸€ä¸ªbloombits.NewMatcher(size, filters)ã€‚è¿™ä¸ªå‡½æ•°åœ¨coreé‡Œé¢å®ç°ï¼Œ æš‚æ—¶ä¸ä¼šè®²è§£ã€‚</p><pre><code>// New creates a new filter which uses a bloom filter on blocks to figure out whether// a particular block is interesting or not.func New(backend Backend, begin, end int64, addresses []common.Address, topics [][]common.Hash) *Filter {    // Flatten the address and topic filter clauses into a single bloombits filter    // system. Since the bloombits are not positional, nil topics are permitted,    // which get flattened into a nil byte slice.    var filters [][][]byte    if len(addresses) &gt; 0 {        filter := make([][]byte, len(addresses))        for i, address := range addresses {            filter[i] = address.Bytes()        }        filters = append(filters, filter)    }    for _, topicList := range topics {        filter := make([][]byte, len(topicList))        for i, topic := range topicList {            filter[i] = topic.Bytes()        }        filters = append(filters, filter)    }    // Assemble and return the filter    size, _ := backend.BloomStatus()    return &amp;Filter{        backend:   backend,        begin:     begin,        end:       end,        addresses: addresses,        topics:    topics,        db:        backend.ChainDb(),        matcher:   bloombits.NewMatcher(size, filters),    }}</code></pre><p>Logs æ‰§è¡Œè¿‡æ»¤</p><pre><code>// Logs searches the blockchain for matching log entries, returning all from the// first block that contains matches, updating the start of the filter accordingly.func (f *Filter) Logs(ctx context.Context) ([]*types.Log, error) {    // Figure out the limits of the filter range    header, _ := f.backend.HeaderByNumber(ctx, rpc.LatestBlockNumber)    if header == nil {        return nil, nil    }    head := header.Number.Uint64()    if f.begin == -1 {        f.begin = int64(head)    }    end := uint64(f.end)    if f.end == -1 {        end = head    }    // Gather all indexed logs, and finish with non indexed ones    var (        logs []*types.Log        err  error    )    size, sections := f.backend.BloomStatus()    // indexed æ˜¯æŒ‡åˆ›å»ºäº†ç´¢å¼•çš„åŒºå—çš„æœ€å¤§å€¼ã€‚ å¦‚æœè¿‡æ»¤çš„èŒƒå›´è½åœ¨äº†åˆ›å»ºäº†ç´¢å¼•çš„éƒ¨åˆ†ã€‚    // é‚£ä¹ˆæ‰§è¡Œç´¢å¼•æœç´¢ã€‚    if indexed := sections * size; indexed &gt; uint64(f.begin) {        if indexed &gt; end {            logs, err = f.indexedLogs(ctx, end)        } else {            logs, err = f.indexedLogs(ctx, indexed-1)        }        if err != nil {            return logs, err        }    }    // å¯¹äºå‰©ä¸‹çš„éƒ¨åˆ†æ‰§è¡Œéç´¢å¼•çš„æœç´¢ã€‚    rest, err := f.unindexedLogs(ctx, end)    logs = append(logs, rest...)    return logs, err}</code></pre><p>ç´¢å¼•æœç´¢</p><pre><code>// indexedLogs returns the logs matching the filter criteria based on the bloom// bits indexed available locally or via the network.func (f *Filter) indexedLogs(ctx context.Context, end uint64) ([]*types.Log, error) {    // Create a matcher session and request servicing from the backend    matches := make(chan uint64, 64)    // å¯åŠ¨matcher    session, err := f.matcher.Start(uint64(f.begin), end, matches)    if err != nil {        return nil, err    }    defer session.Close(time.Second)    // è¿›è¡Œè¿‡æ»¤æœåŠ¡ã€‚ è¿™äº›éƒ½åœ¨coreé‡Œé¢ã€‚åç»­åˆ†æcoreçš„ä»£ç ä¼šè¿›è¡Œåˆ†æã€‚        f.backend.ServiceFilter(ctx, session)    // Iterate over the matches until exhausted or context closed    var logs []*types.Log    for {        select {        case number, ok := &lt;-matches:            // Abort if all matches have been fulfilled            if !ok {  // æ²¡æœ‰æ¥æ”¶åˆ°å€¼å¹¶ä¸”channelå·²ç»è¢«å…³é—­                f.begin = int64(end) + 1  //æ›´æ–°beginã€‚ä»¥ä¾¿äºä¸‹é¢çš„éç´¢å¼•æœç´¢                return logs, nil            }            // Retrieve the suggested block and pull any truly matching logs            header, err := f.backend.HeaderByNumber(ctx, rpc.BlockNumber(number))            if header == nil || err != nil {                return logs, err            }            found, err := f.checkMatches(ctx, header) //æŸ¥æ‰¾åŒ¹é…çš„å€¼            if err != nil {                return logs, err            }            logs = append(logs, found...)        case &lt;-ctx.Done():            return logs, ctx.Err()        }    }}</code></pre><p>checkMatches,æ‹¿åˆ°æ‰€æœ‰çš„æ”¶æ®ï¼Œå¹¶ä»æ”¶æ®ä¸­æ‹¿åˆ°æ‰€æœ‰çš„æ—¥å¿—ã€‚ æ‰§è¡ŒfilterLogsæ–¹æ³•ã€‚</p><pre><code>// checkMatches checks if the receipts belonging to the given header contain any log events that// match the filter criteria. This function is called when the bloom filter signals a potential match.func (f *Filter) checkMatches(ctx context.Context, header *types.Header) (logs []*types.Log, err error) {    // Get the logs of the block    receipts, err := f.backend.GetReceipts(ctx, header.Hash())    if err != nil {        return nil, err    }    var unfiltered []*types.Log    for _, receipt := range receipts {        unfiltered = append(unfiltered, ([]*types.Log)(receipt.Logs)...)    }    logs = filterLogs(unfiltered, nil, nil, f.addresses, f.topics)    if len(logs) &gt; 0 {        return logs, nil    }    return nil, nil}</code></pre><p>filterLogs,è¿™ä¸ªæ–¹æ³•ä»ç»™å®šçš„logsé‡Œé¢æ‰¾åˆ°èƒ½å¤ŸåŒ¹é…ä¸Šçš„ã€‚å¹¶è¿”å›ã€‚</p><pre><code>// filterLogs creates a slice of logs matching the given criteria.func filterLogs(logs []*types.Log, fromBlock, toBlock *big.Int, addresses []common.Address, topics [][]common.Hash) []*types.Log {    var ret []*types.LogLogs:    for _, log := range logs {        if fromBlock != nil &amp;&amp; fromBlock.Int64() &gt;= 0 &amp;&amp; fromBlock.Uint64() &gt; log.BlockNumber {            continue        }        if toBlock != nil &amp;&amp; toBlock.Int64() &gt;= 0 &amp;&amp; toBlock.Uint64() &lt; log.BlockNumber {            continue        }        if len(addresses) &gt; 0 &amp;&amp; !includes(addresses, log.Address) {            continue        }        // If the to filtered topics is greater than the amount of topics in logs, skip.        if len(topics) &gt; len(log.Topics) {            continue Logs        }        for i, topics := range topics {            match := len(topics) == 0 // empty rule set == wildcard            for _, topic := range topics {                if log.Topics[i] == topic {                    match = true                    break                }            }            if !match {                continue Logs            }        }        ret = append(ret, log)    }    return ret}</code></pre><p>unindexedLogs,éç´¢å¼•æŸ¥è¯¢ï¼Œå¾ªç¯éå†æ‰€æœ‰çš„åŒºå—ã€‚ é¦–å…ˆç”¨åŒºå—é‡Œé¢çš„header.Bloomæ¥çœ‹æ˜¯å¦æœ‰å¯èƒ½å­˜åœ¨ï¼Œå¦‚æœæœ‰å¯èƒ½å­˜åœ¨ï¼Œ å†ä½¿ç”¨checkMatchesæ¥æ£€ç´¢æ‰€æœ‰çš„åŒ¹é…ã€‚</p><pre><code>// indexedLogs returns the logs matching the filter criteria based on raw block// iteration and bloom matching.func (f *Filter) unindexedLogs(ctx context.Context, end uint64) ([]*types.Log, error) {    var logs []*types.Log    for ; f.begin &lt;= int64(end); f.begin++ {        header, err := f.backend.HeaderByNumber(ctx, rpc.BlockNumber(f.begin))        if header == nil || err != nil {            return logs, err        }        if bloomFilter(header.Bloom, f.addresses, f.topics) {            found, err := f.checkMatches(ctx, header)            if err != nil {                return logs, err            }            logs = append(logs, found...)        }    }    return logs, nil}</code></pre><h2 id="æ€»ç»“"><a href="#æ€»ç»“" class="headerlink" title="æ€»ç»“"></a>æ€»ç»“</h2><p>filteræºç åŒ…ä¸»è¦å®ç°äº†ä¸¤ä¸ªåŠŸèƒ½ï¼Œ </p><ul><li>æä¾›äº† å‘å¸ƒè®¢é˜…æ¨¡å¼çš„filter RPCã€‚ç”¨æ¥ç»™rpcå®¢æˆ·ç«¯æä¾›å®æ—¶çš„äº¤æ˜“ï¼ŒåŒºå—ï¼Œæ—¥å¿—ç­‰çš„è¿‡æ»¤</li><li>æä¾›äº† åŸºäºbloomIndexerçš„æ—¥å¿—è¿‡æ»¤æ¨¡å¼ï¼Œè¿™ç§æ¨¡å¼ä¸‹ï¼Œå¯ä»¥å¿«é€Ÿçš„å¯¹å¤§é‡åŒºå—æ‰§è¡Œå¸ƒéš†è¿‡æ»¤æ“ä½œã€‚ è¿˜æä¾›äº†å†å²çš„æ—¥å¿—çš„è¿‡æ»¤æ“ä½œã€‚ </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-eth-downloader-queue.goæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-downloader-queue.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-downloader-queue.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>queueç»™downloaderæä¾›äº†è°ƒåº¦åŠŸèƒ½å’Œé™æµçš„åŠŸèƒ½ã€‚ é€šè¿‡è°ƒç”¨Schedule/ScheduleSkeletonæ¥ç”³è¯·å¯¹ä»»åŠ¡è¿›è¡Œè°ƒåº¦ï¼Œç„¶åè°ƒç”¨ReserveXXXæ–¹æ³•æ¥é¢†å–è°ƒåº¦å®Œæˆçš„ä»»åŠ¡ï¼Œå¹¶åœ¨downloaderé‡Œé¢çš„çº¿ç¨‹æ¥æ‰§è¡Œï¼Œè°ƒç”¨DeliverXXXæ–¹æ³•æŠŠä¸‹è½½å®Œçš„æ•°æ®ç»™queueã€‚ æœ€åé€šè¿‡WaitResultsæ¥è·å–å·²ç»å®Œæˆçš„ä»»åŠ¡ã€‚ä¸­é—´è¿˜æœ‰ä¸€äº›å¯¹ä»»åŠ¡çš„é¢å¤–æ§åˆ¶ï¼ŒExpireXXXç”¨æ¥æ§åˆ¶ä»»åŠ¡æ˜¯å¦è¶…æ—¶ï¼Œ CancelXXXç”¨æ¥å–æ¶ˆä»»åŠ¡ã€‚</p><h2 id="Scheduleæ–¹æ³•"><a href="#Scheduleæ–¹æ³•" class="headerlink" title="Scheduleæ–¹æ³•"></a>Scheduleæ–¹æ³•</h2><p>Scheduleè°ƒç”¨ç”³è¯·å¯¹ä¸€äº›åŒºå—å¤´è¿›è¡Œä¸‹è½½è°ƒåº¦ã€‚å¯ä»¥çœ‹åˆ°åšäº†ä¸€äº›åˆæ³•æ€§æ£€æŸ¥ä¹‹åï¼ŒæŠŠä»»åŠ¡æ’å…¥äº†blockTaskPoolï¼ŒreceiptTaskPoolï¼ŒreceiptTaskQueueï¼ŒreceiptTaskPoolã€‚<br>TaskPoolæ˜¯Mapï¼Œç”¨æ¥è®°å½•headerçš„hashæ˜¯å¦å­˜åœ¨ã€‚ TaskQueueæ˜¯ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œä¼˜å…ˆçº§æ˜¯åŒºå—çš„é«˜åº¦çš„è´Ÿæ•°ï¼Œ è¿™æ ·åŒºå—é«˜åº¦è¶Šå°çš„ä¼˜å…ˆçº§è¶Šé«˜ï¼Œå°±å®ç°äº†é¦–å…ˆè°ƒåº¦å°çš„ä»»åŠ¡çš„åŠŸèƒ½ã€‚</p><pre><code>// Schedule adds a set of headers for the download queue for scheduling, returning// the new headers encountered.// fromè¡¨ç¤ºheadersé‡Œé¢ç¬¬ä¸€ä¸ªå…ƒç´ çš„åŒºå—é«˜åº¦ã€‚ è¿”å›å€¼è¿”å›äº†æ‰€æœ‰è¢«æ¥æ”¶çš„headerfunc (q *queue) Schedule(headers []*types.Header, from uint64) []*types.Header {    q.lock.Lock()    defer q.lock.Unlock()    // Insert all the headers prioritised by the contained block number    inserts := make([]*types.Header, 0, len(headers))    for _, header := range headers {        // Make sure chain order is honoured and preserved throughout        hash := header.Hash()        if header.Number == nil || header.Number.Uint64() != from {            log.Warn("Header broke chain ordering", "number", header.Number, "hash", hash, "expected", from)            break        }        //headerHeadå­˜å‚¨äº†æœ€åä¸€ä¸ªæ’å…¥çš„åŒºå—å¤´ï¼Œ æ£€æŸ¥å½“å‰åŒºå—æ˜¯å¦æ­£ç¡®çš„é“¾æ¥ã€‚        if q.headerHead != (common.Hash{}) &amp;&amp; q.headerHead != header.ParentHash {            log.Warn("Header broke chain ancestry", "number", header.Number, "hash", hash)            break        }        // Make sure no duplicate requests are executed        // æ£€æŸ¥é‡å¤ï¼Œè¿™é‡Œç›´æ¥continueäº†ï¼Œé‚£ä¸æ˜¯fromå¯¹ä¸ä¸Šäº†ã€‚        if _, ok := q.blockTaskPool[hash]; ok {            log.Warn("Header  already scheduled for block fetch", "number", header.Number, "hash", hash)            continue        }        if _, ok := q.receiptTaskPool[hash]; ok {            log.Warn("Header already scheduled for receipt fetch", "number", header.Number, "hash", hash)            continue        }        // Queue the header for content retrieval        q.blockTaskPool[hash] = header        q.blockTaskQueue.Push(header, -float32(header.Number.Uint64()))        if q.mode == FastSync &amp;&amp; header.Number.Uint64() &lt;= q.fastSyncPivot {            // Fast phase of the fast sync, retrieve receipts too            // å¦‚æœæ˜¯å¿«é€ŸåŒæ­¥æ¨¡å¼ï¼Œè€Œä¸”åŒºå—é«˜åº¦ä¹Ÿå°äºpivot point. é‚£ä¹ˆè¿˜è¦è·å–receipt            q.receiptTaskPool[hash] = header            q.receiptTaskQueue.Push(header, -float32(header.Number.Uint64()))        }        inserts = append(inserts, header)        q.headerHead = hash        from++    }    return inserts}</code></pre><h2 id="ReserveXXX"><a href="#ReserveXXX" class="headerlink" title="ReserveXXX"></a>ReserveXXX</h2><p>ReserveXXXæ–¹æ³•ç”¨æ¥ä»queueé‡Œé¢é¢†å–ä¸€äº›ä»»åŠ¡æ¥æ‰§è¡Œã€‚downloaderé‡Œé¢çš„goroutineä¼šè°ƒç”¨è¿™ä¸ªæ–¹æ³•æ¥é¢†å–ä¸€äº›ä»»åŠ¡æ¥æ‰§è¡Œã€‚ è¿™ä¸ªæ–¹æ³•ç›´æ¥è°ƒç”¨äº†reserveHeadersæ–¹æ³•ã€‚ æ‰€æœ‰çš„ReserveXXXæ–¹æ³•éƒ½ä¼šè°ƒç”¨reserveHeadersæ–¹æ³•ï¼Œé™¤äº†ä¼ å…¥çš„å‚æ•°æœ‰ä¸€äº›åŒºåˆ«ã€‚</p><pre><code>// ReserveBodies reserves a set of body fetches for the given peer, skipping any// previously failed downloads. Beside the next batch of needed fetches, it also// returns a flag whether empty blocks were queued requiring processing.func (q *queue) ReserveBodies(p *peerConnection, count int) (*fetchRequest, bool, error) {    isNoop := func(header *types.Header) bool {        return header.TxHash == types.EmptyRootHash &amp;&amp; header.UncleHash == types.EmptyUncleHash    }    q.lock.Lock()    defer q.lock.Unlock()    return q.reserveHeaders(p, count, q.blockTaskPool, q.blockTaskQueue, q.blockPendPool, q.blockDonePool, isNoop)}</code></pre><p>reserveHeaders</p><pre><code>// reserveHeaders reserves a set of data download operations for a given peer,// skipping any previously failed ones. This method is a generic version used// by the individual special reservation functions.// reserveHeadersä¸ºæŒ‡å®šçš„peerä¿ç•™ä¸€äº›ä¸‹è½½æ“ä½œï¼Œè·³è¿‡ä¹‹å‰çš„ä»»æ„é”™è¯¯ã€‚ è¿™ä¸ªæ–¹æ³•å•ç‹¬è¢«æŒ‡å®šçš„ä¿ç•™æ–¹æ³•è°ƒç”¨ã€‚// Note, this method expects the queue lock to be already held for writing. The// reason the lock is not obtained in here is because the parameters already need// to access the queue, so they already need a lock anyway.// è¿™ä¸ªæ–¹æ³•è°ƒç”¨çš„æ—¶å€™ï¼Œå‡è®¾å·²ç»è·å–åˆ°é”ï¼Œè¿™ä¸ªæ–¹æ³•é‡Œé¢æ²¡æœ‰é”çš„åŸå› æ˜¯å‚æ•°å·²ç»ä¼ å…¥åˆ°å‡½æ•°é‡Œé¢äº†ï¼Œæ‰€ä»¥è°ƒç”¨çš„æ—¶å€™å°±éœ€è¦è·å–é”ã€‚func (q *queue) reserveHeaders(p *peerConnection, count int, taskPool map[common.Hash]*types.Header, taskQueue *prque.Prque,    pendPool map[string]*fetchRequest, donePool map[common.Hash]struct{}, isNoop func(*types.Header) bool) (*fetchRequest, bool, error) {    // Short circuit if the pool has been depleted, or if the peer's already    // downloading something (sanity check not to corrupt state)    if taskQueue.Empty() {        return nil, false, nil    }    // å¦‚æœè¿™ä¸ªpeerè¿˜æœ‰ä¸‹è½½ä»»åŠ¡æ²¡æœ‰å®Œæˆã€‚    if _, ok := pendPool[p.id]; ok {        return nil, false, nil    }    // Calculate an upper limit on the items we might fetch (i.e. throttling)    // è®¡ç®—æˆ‘ä»¬éœ€è¦è·å–çš„ä¸Šé™ã€‚    space := len(q.resultCache) - len(donePool)    // è¿˜éœ€è¦å‡å»æ­£åœ¨ä¸‹è½½çš„æ•°é‡ã€‚    for _, request := range pendPool {        space -= len(request.Headers)    }    // Retrieve a batch of tasks, skipping previously failed ones    send := make([]*types.Header, 0, count)    skip := make([]*types.Header, 0)    progress := false    for proc := 0; proc &lt; space &amp;&amp; len(send) &lt; count &amp;&amp; !taskQueue.Empty(); proc++ {        header := taskQueue.PopItem().(*types.Header)        // If we're the first to request this task, initialise the result container        index := int(header.Number.Int64() - int64(q.resultOffset))        // index æ˜¯ç»“æœåº”è¯¥å­˜å‚¨åœ¨resultCacheçš„å“ªä¸€éƒ¨åˆ†ã€‚        if index &gt;= len(q.resultCache) || index &lt; 0 {            common.Report("index allocation went beyond available resultCache space")            return nil, false, errInvalidChain        }        if q.resultCache[index] == nil { // ç¬¬ä¸€æ¬¡è°ƒåº¦ æœ‰å¯èƒ½å¤šæ¬¡è°ƒåº¦ã€‚ é‚£è¿™é‡Œå¯èƒ½å°±æ˜¯éç©ºçš„ã€‚            components := 1            if q.mode == FastSync &amp;&amp; header.Number.Uint64() &lt;= q.fastSyncPivot {                // å¦‚æœæ˜¯å¿«é€ŸåŒæ­¥ï¼Œé‚£ä¹ˆéœ€è¦ä¸‹è½½çš„ç»„ä»¶è¿˜æœ‰ æ”¶æ®receipt                components = 2            }            q.resultCache[index] = &amp;fetchResult{                Pending: components,                Header:  header,            }        }        // If this fetch task is a noop, skip this fetch operation        if isNoop(header) {            // å¦‚æœheaderçš„åŒºå—ä¸­æ²¡æœ‰åŒ…å«äº¤æ˜“ï¼Œé‚£ä¹ˆä¸éœ€è¦è·å–åŒºå—å¤´            donePool[header.Hash()] = struct{}{}            delete(taskPool, header.Hash())            space, proc = space-1, proc-1            q.resultCache[index].Pending--            progress = true            continue        }        // Otherwise unless the peer is known not to have the data, add to the retrieve list        // Lacksä»£è¡¨èŠ‚ç‚¹ä¹‹å‰æ˜ç¡®è¡¨ç¤ºè¿‡æ²¡æœ‰è¿™ä¸ªhashçš„æ•°æ®ã€‚        if p.Lacks(header.Hash()) {            skip = append(skip, header)        } else {            send = append(send, header)        }    }    // Merge all the skipped headers back    for _, header := range skip {        taskQueue.Push(header, -float32(header.Number.Uint64()))    }    if progress {        // Wake WaitResults, resultCache was modified        // é€šçŸ¥WaitResultsï¼Œ resultCacheæœ‰æ”¹å˜        q.active.Signal()    }    // Assemble and return the block download request    if len(send) == 0 {        return nil, progress, nil    }    request := &amp;fetchRequest{        Peer:    p,        Headers: send,        Time:    time.Now(),    }    pendPool[p.id] = request    return request, progress, nil}</code></pre><p>ReserveReceipts å¯ä»¥çœ‹åˆ°å’ŒReserveBodyså·®ä¸å¤šã€‚ä¸è¿‡æ˜¯é˜Ÿåˆ—æ¢äº†è€Œå·²ã€‚</p><pre><code>// ReserveReceipts reserves a set of receipt fetches for the given peer, skipping// any previously failed downloads. Beside the next batch of needed fetches, it// also returns a flag whether empty receipts were queued requiring importing.func (q *queue) ReserveReceipts(p *peerConnection, count int) (*fetchRequest, bool, error) {    isNoop := func(header *types.Header) bool {        return header.ReceiptHash == types.EmptyRootHash    }    q.lock.Lock()    defer q.lock.Unlock()    return q.reserveHeaders(p, count, q.receiptTaskPool, q.receiptTaskQueue, q.receiptPendPool, q.receiptDonePool, isNoop)}</code></pre><h2 id="DeliverXXX"><a href="#DeliverXXX" class="headerlink" title="DeliverXXX"></a>DeliverXXX</h2><p>Deliveræ–¹æ³•åœ¨æ•°æ®ä¸‹è½½å®Œä¹‹åä¼šè¢«è°ƒç”¨ã€‚</p><pre><code>// DeliverBodies injects a block body retrieval response into the results queue.// The method returns the number of blocks bodies accepted from the delivery and// also wakes any threads waiting for data delivery.// DeliverBodiesæŠŠä¸€ä¸ª è¯·æ±‚åŒºå—ä½“çš„è¿”å›å€¼æ’å…¥åˆ°resultsé˜Ÿåˆ—// è¿™ä¸ªæ–¹æ³•è¿”å›è¢«deliveryçš„åŒºå—ä½“æ•°é‡ï¼ŒåŒæ—¶ä¼šå”¤é†’ç­‰å¾…æ•°æ®çš„çº¿ç¨‹func (q *queue) DeliverBodies(id string, txLists [][]*types.Transaction, uncleLists [][]*types.Header) (int, error) {    q.lock.Lock()    defer q.lock.Unlock()    reconstruct := func(header *types.Header, index int, result *fetchResult) error {        if types.DeriveSha(types.Transactions(txLists[index])) != header.TxHash || types.CalcUncleHash(uncleLists[index]) != header.UncleHash {            return errInvalidBody        }        result.Transactions = txLists[index]        result.Uncles = uncleLists[index]        return nil    }    return q.deliver(id, q.blockTaskPool, q.blockTaskQueue, q.blockPendPool, q.blockDonePool, bodyReqTimer, len(txLists), reconstruct)}</code></pre><p>deliveræ–¹æ³•</p><pre><code>func (q *queue) deliver(id string, taskPool map[common.Hash]*types.Header, taskQueue *prque.Prque,    pendPool map[string]*fetchRequest, donePool map[common.Hash]struct{}, reqTimer metrics.Timer,    results int, reconstruct func(header *types.Header, index int, result *fetchResult) error) (int, error) {    // Short circuit if the data was never requested    // æ£€æŸ¥ æ•°æ®æ˜¯å¦ä»æ¥æ²¡æœ‰è¯·æ±‚è¿‡ã€‚    request := pendPool[id]    if request == nil {        return 0, errNoFetchesPending    }    reqTimer.UpdateSince(request.Time)    delete(pendPool, id)    // If no data items were retrieved, mark them as unavailable for the origin peer    if results == 0 {        //å¦‚æœç»“æœä¸ºç©ºã€‚ é‚£ä¹ˆæ ‡è¯†è¿™ä¸ªpeeræ²¡æœ‰è¿™äº›æ•°æ®ã€‚        for _, header := range request.Headers {            request.Peer.MarkLacking(header.Hash())        }    }    // Assemble each of the results with their headers and retrieved data parts    var (        accepted int        failure  error        useful   bool    )    for i, header := range request.Headers {        // Short circuit assembly if no more fetch results are found        if i &gt;= results {            break        }        // Reconstruct the next result if contents match up        index := int(header.Number.Int64() - int64(q.resultOffset))        if index &gt;= len(q.resultCache) || index &lt; 0 || q.resultCache[index] == nil {            failure = errInvalidChain            break        }        // è°ƒç”¨ä¼ å…¥çš„å‡½æ•°å¯¹æ•°æ®è¿›è¡Œæ„å»º        if err := reconstruct(header, i, q.resultCache[index]); err != nil {            failure = err            break        }        donePool[header.Hash()] = struct{}{}        q.resultCache[index].Pending--        useful = true        accepted++        // Clean up a successful fetch        // ä»taskPoolåˆ é™¤ã€‚åŠ å…¥donePool        request.Headers[i] = nil        delete(taskPool, header.Hash())    }    // Return all failed or missing fetches to the queue    // æ‰€æœ‰æ²¡æœ‰æˆåŠŸçš„è¯·æ±‚åŠ å…¥taskQueue    for _, header := range request.Headers {        if header != nil {            taskQueue.Push(header, -float32(header.Number.Uint64()))        }    }    // Wake up WaitResults    // å¦‚æœç»“æœæœ‰å˜æ›´ï¼Œé€šçŸ¥WaitResultsçº¿ç¨‹å¯åŠ¨ã€‚    if accepted &gt; 0 {        q.active.Signal()    }    // If none of the data was good, it's a stale delivery    switch {    case failure == nil || failure == errInvalidChain:        return accepted, failure    case useful:        return accepted, fmt.Errorf("partial failure: %v", failure)    default:        return accepted, errStaleDelivery    }}</code></pre><h2 id="ExpireXXX-and-CancelXXX"><a href="#ExpireXXX-and-CancelXXX" class="headerlink" title="ExpireXXX and CancelXXX"></a>ExpireXXX and CancelXXX</h2><h3 id="ExpireXXX"><a href="#ExpireXXX" class="headerlink" title="ExpireXXX"></a>ExpireXXX</h3><p>ExpireBodieså‡½æ•°è·å–äº†é”ï¼Œç„¶åç›´æ¥è°ƒç”¨äº†expireå‡½æ•°ã€‚ </p><pre><code>// ExpireBodies checks for in flight block body requests that exceeded a timeout// allowance, canceling them and returning the responsible peers for penalisation.func (q *queue) ExpireBodies(timeout time.Duration) map[string]int {    q.lock.Lock()    defer q.lock.Unlock()    return q.expire(timeout, q.blockPendPool, q.blockTaskQueue, bodyTimeoutMeter)}</code></pre><p>expireå‡½æ•°ï¼Œ</p><pre><code>// expire is the generic check that move expired tasks from a pending pool back// into a task pool, returning all entities caught with expired tasks.// expireæ˜¯é€šç”¨æ£€æŸ¥ï¼Œå°†è¿‡æœŸä»»åŠ¡ä»å¾…å¤„ç†æ± ç§»å›ä»»åŠ¡æ± ï¼Œè¿”å›æ‰€æœ‰æ•è·å·²åˆ°æœŸä»»åŠ¡çš„å®ä½“ã€‚func (q *queue) expire(timeout time.Duration, pendPool map[string]*fetchRequest, taskQueue *prque.Prque, timeoutMeter metrics.Meter) map[string]int {    // Iterate over the expired requests and return each to the queue    expiries := make(map[string]int)    for id, request := range pendPool {        if time.Since(request.Time) &gt; timeout {            // Update the metrics with the timeout            timeoutMeter.Mark(1)            // Return any non satisfied requests to the pool            if request.From &gt; 0 {                taskQueue.Push(request.From, -float32(request.From))            }            for hash, index := range request.Hashes {                taskQueue.Push(hash, float32(index))            }            for _, header := range request.Headers {                taskQueue.Push(header, -float32(header.Number.Uint64()))            }            // Add the peer to the expiry report along the the number of failed requests            expirations := len(request.Hashes)            if expirations &lt; len(request.Headers) {                expirations = len(request.Headers)            }            expiries[id] = expirations        }    }    // Remove the expired requests from the pending pool    for id := range expiries {        delete(pendPool, id)    }    return expiries}</code></pre><h3 id="CancelXXX"><a href="#CancelXXX" class="headerlink" title="CancelXXX"></a>CancelXXX</h3><p>Cancleå‡½æ•°å–æ¶ˆå·²ç»åˆ†é…çš„ä»»åŠ¡ï¼Œ æŠŠä»»åŠ¡é‡æ–°åŠ å…¥åˆ°ä»»åŠ¡æ± ã€‚</p><pre><code>// CancelBodies aborts a body fetch request, returning all pending headers to the// task queue.func (q *queue) CancelBodies(request *fetchRequest) {    q.cancel(request, q.blockTaskQueue, q.blockPendPool)}// Cancel aborts a fetch request, returning all pending hashes to the task queue.func (q *queue) cancel(request *fetchRequest, taskQueue *prque.Prque, pendPool map[string]*fetchRequest) {    q.lock.Lock()    defer q.lock.Unlock()    if request.From &gt; 0 {        taskQueue.Push(request.From, -float32(request.From))    }    for hash, index := range request.Hashes {        taskQueue.Push(hash, float32(index))    }    for _, header := range request.Headers {        taskQueue.Push(header, -float32(header.Number.Uint64()))    }    delete(pendPool, request.Peer.id)}</code></pre><h2 id="ScheduleSkeleton"><a href="#ScheduleSkeleton" class="headerlink" title="ScheduleSkeleton"></a>ScheduleSkeleton</h2><p>Scheduleæ–¹æ³•ä¼ å…¥çš„æ˜¯å·²ç»fetchå¥½çš„headerã€‚Schedule(headers []*types.Header, from uint64)ã€‚è€ŒScheduleSkeletonå‡½æ•°çš„å‚æ•°æ˜¯ä¸€ä¸ªéª¨æ¶ï¼Œ ç„¶åè¯·æ±‚å¯¹éª¨æ¶è¿›è¡Œå¡«å……ã€‚æ‰€è°“çš„éª¨æ¶æ˜¯æŒ‡æˆ‘é¦–å…ˆæ¯éš”192ä¸ªåŒºå—è¯·æ±‚ä¸€ä¸ªåŒºå—å¤´ï¼Œç„¶åæŠŠè¿”å›çš„headerä¼ å…¥ScheduleSkeletonã€‚ åœ¨Scheduleå‡½æ•°ä¸­åªéœ€è¦queueè°ƒåº¦åŒºå—ä½“å’Œå›æ‰§çš„ä¸‹è½½ï¼Œè€Œåœ¨ScheduleSkeletonå‡½æ•°ä¸­ï¼Œè¿˜éœ€è¦è°ƒåº¦é‚£äº›ç¼ºå¤±çš„åŒºå—å¤´çš„ä¸‹è½½ã€‚</p><pre><code>// ScheduleSkeleton adds a batch of header retrieval tasks to the queue to fill// up an already retrieved header skeleton.func (q *queue) ScheduleSkeleton(from uint64, skeleton []*types.Header) {    q.lock.Lock()    defer q.lock.Unlock()    // No skeleton retrieval can be in progress, fail hard if so (huge implementation bug)    if q.headerResults != nil {        panic("skeleton assembly already in progress")    }    // Shedule all the header retrieval tasks for the skeleton assembly    // å› ä¸ºè¿™ä¸ªæ–¹æ³•åœ¨skeletonä¸ºfalseçš„æ—¶å€™ä¸ä¼šè°ƒç”¨ã€‚ æ‰€ä»¥ä¸€äº›åˆå§‹åŒ–å·¥ä½œæ”¾åœ¨è¿™é‡Œæ‰§è¡Œã€‚    q.headerTaskPool = make(map[uint64]*types.Header)    q.headerTaskQueue = prque.New()    q.headerPeerMiss = make(map[string]map[uint64]struct{}) // Reset availability to correct invalid chains    q.headerResults = make([]*types.Header, len(skeleton)*MaxHeaderFetch)    q.headerProced = 0    q.headerOffset = from    q.headerContCh = make(chan bool, 1)    for i, header := range skeleton {        index := from + uint64(i*MaxHeaderFetch)        // æ¯éš”MaxHeaderFetchè¿™ä¹ˆè¿œæœ‰ä¸€ä¸ªheader        q.headerTaskPool[index] = header        q.headerTaskQueue.Push(index, -float32(index))    }}</code></pre><h3 id="ReserveHeaders"><a href="#ReserveHeaders" class="headerlink" title="ReserveHeaders"></a>ReserveHeaders</h3><p>è¿™ä¸ªæ–¹æ³•åªskeletonçš„æ¨¡å¼ä¸‹æ‰ä¼šè¢«è°ƒç”¨ã€‚ ç”¨æ¥ç»™peerä¿ç•™fetch åŒºå—å¤´çš„ä»»åŠ¡ã€‚</p><pre><code>// ReserveHeaders reserves a set of headers for the given peer, skipping any// previously failed batches.func (q *queue) ReserveHeaders(p *peerConnection, count int) *fetchRequest {    q.lock.Lock()    defer q.lock.Unlock()    // Short circuit if the peer's already downloading something (sanity check to    // not corrupt state)    if _, ok := q.headerPendPool[p.id]; ok {        return nil    }    // Retrieve a batch of hashes, skipping previously failed ones    // ä»é˜Ÿåˆ—ä¸­è·å–ä¸€ä¸ªï¼Œè·³è¿‡ä¹‹å‰å¤±è´¥è¿‡çš„èŠ‚ç‚¹ã€‚    send, skip := uint64(0), []uint64{}    for send == 0 &amp;&amp; !q.headerTaskQueue.Empty() {        from, _ := q.headerTaskQueue.Pop()        if q.headerPeerMiss[p.id] != nil {            if _, ok := q.headerPeerMiss[p.id][from.(uint64)]; ok {                skip = append(skip, from.(uint64))                continue            }        }        send = from.(uint64)    }    // Merge all the skipped batches back    for _, from := range skip {        q.headerTaskQueue.Push(from, -float32(from))    }    // Assemble and return the block download request    if send == 0 {        return nil    }    request := &amp;fetchRequest{        Peer: p,        From: send,        Time: time.Now(),    }    q.headerPendPool[p.id] = request    return request}</code></pre><h3 id="DeliverHeaders"><a href="#DeliverHeaders" class="headerlink" title="DeliverHeaders"></a>DeliverHeaders</h3><pre><code>// DeliverHeaders injects a header retrieval response into the header results// cache. This method either accepts all headers it received, or none of them// if they do not map correctly to the skeleton.// è¿™ä¸ªæ–¹æ³•å¯¹äºæ‰€æœ‰çš„åŒºå—å¤´ï¼Œè¦ä¹ˆå…¨éƒ¨æ¥æ”¶ï¼Œè¦ä¹ˆå…¨éƒ¨æ‹’ç»(å¦‚æœä¸èƒ½æ˜ å°„åˆ°ä¸€ä¸ªskeletonä¸Šé¢)// If the headers are accepted, the method makes an attempt to deliver the set// of ready headers to the processor to keep the pipeline full. However it will// not block to prevent stalling other pending deliveries.// å¦‚æœåŒºå—å¤´è¢«æ¥æ”¶ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šè¯•å›¾æŠŠä»–ä»¬æŠ•é€’åˆ°headerProcChç®¡é“ä¸Šé¢ã€‚ ä¸è¿‡è¿™ä¸ªæ–¹æ³•ä¸ä¼šé˜»å¡å¼çš„æŠ•é€’ã€‚è€Œæ˜¯å°è¯•æŠ•é€’ï¼Œå¦‚æœä¸èƒ½æŠ•é€’å°±è¿”å›ã€‚func (q *queue) DeliverHeaders(id string, headers []*types.Header, headerProcCh chan []*types.Header) (int, error) {    q.lock.Lock()    defer q.lock.Unlock()    // Short circuit if the data was never requested    request := q.headerPendPool[id]    if request == nil {        return 0, errNoFetchesPending    }    headerReqTimer.UpdateSince(request.Time)    delete(q.headerPendPool, id)    // Ensure headers can be mapped onto the skeleton chain    target := q.headerTaskPool[request.From].Hash()    accepted := len(headers) == MaxHeaderFetch    if accepted { //é¦–å…ˆé•¿åº¦éœ€è¦åŒ¹é…ï¼Œ ç„¶åæ£€æŸ¥åŒºå—å·å’Œæœ€åä¸€å—åŒºå—çš„Hashå€¼æ˜¯å¦èƒ½å¤Ÿå¯¹åº”ä¸Šã€‚        if headers[0].Number.Uint64() != request.From {            log.Trace("First header broke chain ordering", "peer", id, "number", headers[0].Number, "hash", headers[0].Hash(), request.From)            accepted = false        } else if headers[len(headers)-1].Hash() != target {            log.Trace("Last header broke skeleton structure ", "peer", id, "number", headers[len(headers)-1].Number, "hash", headers[len(headers)-1].Hash(), "expected", target)            accepted = false        }    }    if accepted {// ä¾æ¬¡æ£€æŸ¥æ¯ä¸€å—åŒºå—çš„åŒºå—å·ï¼Œ ä»¥åŠé“¾æ¥æ˜¯å¦æ­£ç¡®ã€‚        for i, header := range headers[1:] {            hash := header.Hash()            if want := request.From + 1 + uint64(i); header.Number.Uint64() != want {                log.Warn("Header broke chain ordering", "peer", id, "number", header.Number, "hash", hash, "expected", want)                accepted = false                break            }            if headers[i].Hash() != header.ParentHash {                log.Warn("Header broke chain ancestry", "peer", id, "number", header.Number, "hash", hash)                accepted = false                break            }        }    }    // If the batch of headers wasn't accepted, mark as unavailable    if !accepted { // å¦‚æœä¸è¢«æ¥æ”¶ï¼Œé‚£ä¹ˆæ ‡è®°è¿™ä¸ªpeeråœ¨è¿™ä¸ªä»»åŠ¡ä¸Šçš„å¤±è´¥ã€‚ä¸‹æ¬¡è¯·æ±‚å°±ä¸ä¼šæŠ•é€’ç»™è¿™ä¸ªpeer        log.Trace("Skeleton filling not accepted", "peer", id, "from", request.From)        miss := q.headerPeerMiss[id]        if miss == nil {            q.headerPeerMiss[id] = make(map[uint64]struct{})            miss = q.headerPeerMiss[id]        }        miss[request.From] = struct{}{}        q.headerTaskQueue.Push(request.From, -float32(request.From))        return 0, errors.New("delivery not accepted")    }    // Clean up a successful fetch and try to deliver any sub-results    copy(q.headerResults[request.From-q.headerOffset:], headers)    delete(q.headerTaskPool, request.From)    ready := 0    for q.headerProced+ready &lt; len(q.headerResults) &amp;&amp; q.headerResults[q.headerProced+ready] != nil {//è®¡ç®—è¿™æ¬¡åˆ°æ¥çš„headerå¯ä»¥è®©headerResultsæœ‰å¤šå°‘æ•°æ®å¯ä»¥æŠ•é€’äº†ã€‚        ready += MaxHeaderFetch    }    if ready &gt; 0 {        // Headers are ready for delivery, gather them and push forward (non blocking)        process := make([]*types.Header, ready)        copy(process, q.headerResults[q.headerProced:q.headerProced+ready])        // å°è¯•æŠ•é€’        select {        case headerProcCh &lt;- process:            log.Trace("Pre-scheduled new headers", "peer", id, "count", len(process), "from", process[0].Number)            q.headerProced += len(process)        default:        }    }    // Check for termination and return    if len(q.headerTaskPool) == 0 {        // è¿™ä¸ªé€šé“æ¯”è¾ƒé‡è¦ï¼Œ å¦‚æœè¿™ä¸ªé€šé“æ¥æ”¶åˆ°æ•°æ®ï¼Œè¯´æ˜æ‰€æœ‰çš„headerä»»åŠ¡å·²ç»å®Œæˆã€‚        q.headerContCh &lt;- false    }    return len(headers), nil}</code></pre><p>RetrieveHeadersï¼ŒScheduleSkeletonå‡½æ•°åœ¨ä¸Šæ¬¡è°ƒåº¦è¿˜æ²¡æœ‰åšå®Œçš„æƒ…å†µä¸‹æ˜¯ä¸ä¼šè°ƒç”¨çš„ã€‚ æ‰€ä»¥ä¸Šæ¬¡è°ƒç”¨å®Œæˆä¹‹åï¼Œä¼šä½¿ç”¨è¿™ä¸ªæ–¹æ³•æ¥è·å–ç»“æœï¼Œé‡ç½®çŠ¶æ€ã€‚</p><pre><code>// RetrieveHeaders retrieves the header chain assemble based on the scheduled// skeleton.func (q *queue) RetrieveHeaders() ([]*types.Header, int) {    q.lock.Lock()    defer q.lock.Unlock()    headers, proced := q.headerResults, q.headerProced    q.headerResults, q.headerProced = nil, 0    return headers, proced}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-eth-fetcheræºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-fetcher%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-fetcher%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>fetcheråŒ…å«åŸºäºå—é€šçŸ¥çš„åŒæ­¥ã€‚å½“æˆ‘ä»¬æ¥æ”¶åˆ°NewBlockHashesMsgæ¶ˆæ¯å¾—æ—¶å€™ï¼Œæˆ‘ä»¬åªæ”¶åˆ°äº†å¾ˆå¤šBlockçš„hashå€¼ã€‚ éœ€è¦é€šè¿‡hashå€¼æ¥åŒæ­¥åŒºå—ï¼Œç„¶åæ›´æ–°æœ¬åœ°åŒºå—é“¾ã€‚ fetcherå°±æä¾›äº†è¿™æ ·çš„åŠŸèƒ½ã€‚</p><p>æ•°æ®ç»“æ„</p><pre><code>// announce is the hash notification of the availability of a new block in the// network.// announce æ˜¯ä¸€ä¸ªhashé€šçŸ¥ï¼Œè¡¨ç¤ºç½‘ç»œä¸Šæœ‰åˆé€‚çš„æ–°åŒºå—å‡ºç°ã€‚type announce struct {    hash   common.Hash   // Hash of the block being announced //æ–°åŒºå—çš„hashå€¼    number uint64        // Number of the block being announced (0 = unknown | old protocol) åŒºå—çš„é«˜åº¦å€¼ï¼Œ    header *types.Header // Header of the block partially reassembled (new protocol)    é‡æ–°ç»„è£…çš„åŒºå—å¤´    time   time.Time     // Timestamp of the announcement    origin string // Identifier of the peer originating the notification    fetchHeader headerRequesterFn // Fetcher function to retrieve the header of an announced block  è·å–åŒºå—å¤´çš„å‡½æ•°æŒ‡é’ˆï¼Œ é‡Œé¢åŒ…å«äº†peerçš„ä¿¡æ¯ã€‚å°±æ˜¯è¯´æ‰¾è°è¦è¿™ä¸ªåŒºå—å¤´    fetchBodies bodyRequesterFn   // Fetcher function to retrieve the body of an announced block è·å–åŒºå—ä½“çš„å‡½æ•°æŒ‡é’ˆ}// headerFilterTask represents a batch of headers needing fetcher filtering.type headerFilterTask struct {    peer    string          // The source peer of block headers    headers []*types.Header // Collection of headers to filter    time    time.Time       // Arrival time of the headers}// headerFilterTask represents a batch of block bodies (transactions and uncles)// needing fetcher filtering.type bodyFilterTask struct {    peer         string                 // The source peer of block bodies    transactions [][]*types.Transaction // Collection of transactions per block bodies    uncles       [][]*types.Header      // Collection of uncles per block bodies    time         time.Time              // Arrival time of the blocks' contents}// inject represents a schedules import operation. // å½“èŠ‚ç‚¹æ”¶åˆ°NewBlockMsgçš„æ¶ˆæ¯æ—¶å€™ï¼Œä¼šæ’å…¥ä¸€ä¸ªåŒºå—type inject struct {    origin string    block  *types.Block}// Fetcher is responsible for accumulating block announcements from various peers// and scheduling them for retrieval.type Fetcher struct {    // Various event channels    notify chan *announce    //announceçš„é€šé“ï¼Œ    inject chan *inject        //injectçš„é€šé“    blockFilter  chan chan []*types.Block     //é€šé“çš„é€šé“ï¼Ÿ    headerFilter chan chan *headerFilterTask    bodyFilter   chan chan *bodyFilterTask    done chan common.Hash    quit chan struct{}    // Announce states    announces  map[string]int              // Per peer announce counts to prevent memory exhaustion keyæ˜¯peerçš„åå­—ï¼Œ valueæ˜¯announceçš„countï¼Œ ä¸ºäº†é¿å…å†…å­˜å ç”¨å¤ªå¤§ã€‚    announced  map[common.Hash][]*announce // Announced blocks, scheduled for fetching ç­‰å¾…è°ƒåº¦fetchingçš„announce    fetching   map[common.Hash]*announce   // Announced blocks, currently fetching æ­£åœ¨fetchingçš„announce    fetched    map[common.Hash][]*announce // Blocks with headers fetched, scheduled for body retrieval // å·²ç»è·å–åŒºå—å¤´çš„ï¼Œç­‰å¾…è·å–åŒºå—body    completing map[common.Hash]*announce   // Blocks with headers, currently body-completing  //å¤´å’Œä½“éƒ½å·²ç»è·å–å®Œæˆçš„announce    // Block cache    queue  *prque.Prque            // Queue containing the import operations (block number sorted) //åŒ…å«äº†importæ“ä½œçš„é˜Ÿåˆ—(æŒ‰ç…§åŒºå—å·æ’åˆ—)    queues map[string]int          // Per peer block counts to prevent memory exhaustion keyæ˜¯peerï¼Œvalueæ˜¯blockæ•°é‡ã€‚ é¿å…å†…å­˜æ¶ˆè€—å¤ªå¤šã€‚    queued map[common.Hash]*inject // Set of already queued blocks (to dedup imports)  å·²ç»æ”¾å…¥é˜Ÿåˆ—çš„åŒºå—ã€‚ ä¸ºäº†å»é‡ã€‚    // Callbacks  ä¾èµ–äº†ä¸€äº›å›è°ƒå‡½æ•°ã€‚    getBlock       blockRetrievalFn   // Retrieves a block from the local chain    verifyHeader   headerVerifierFn   // Checks if a block's headers have a valid proof of work    broadcastBlock blockBroadcasterFn // Broadcasts a block to connected peers    chainHeight    chainHeightFn      // Retrieves the current chain's height    insertChain    chainInsertFn      // Injects a batch of blocks into the chain    dropPeer       peerDropFn         // Drops a peer for misbehaving    // Testing hooks  ä»…ä¾›æµ‹è¯•ä½¿ç”¨ã€‚    announceChangeHook func(common.Hash, bool) // Method to call upon adding or deleting a hash from the announce list    queueChangeHook    func(common.Hash, bool) // Method to call upon adding or deleting a block from the import queue    fetchingHook       func([]common.Hash)     // Method to call upon starting a block (eth/61) or header (eth/62) fetch    completingHook     func([]common.Hash)     // Method to call upon starting a block body fetch (eth/62)    importedHook       func(*types.Block)      // Method to call upon successful block import (both eth/61 and eth/62)}</code></pre><p>å¯åŠ¨fetcherï¼Œ ç›´æ¥å¯åŠ¨äº†ä¸€ä¸ªgoroutineæ¥å¤„ç†ã€‚ è¿™ä¸ªå‡½æ•°æœ‰ç‚¹é•¿ã€‚ åç»­å†åˆ†æã€‚</p><pre><code>// Start boots up the announcement based synchroniser, accepting and processing// hash notifications and block fetches until termination requested.func (f *Fetcher) Start() {    go f.loop()}</code></pre><p>loopå‡½æ•°å‡½æ•°å¤ªé•¿ã€‚ æˆ‘å…ˆå¸–ä¸€ä¸ªçœç•¥ç‰ˆæœ¬çš„å‡ºæ¥ã€‚fetcheré€šè¿‡å››ä¸ªmap(announced,fetching,fetched,completing )è®°å½•äº†announceçš„çŠ¶æ€(ç­‰å¾…fetch,æ­£åœ¨fetch,fetchå®Œå¤´ç­‰å¾…fetch body, fetchå®Œæˆ)ã€‚ loopå…¶å®é€šè¿‡å®šæ—¶å™¨å’Œå„ç§æ¶ˆæ¯æ¥å¯¹å„ç§mapé‡Œé¢çš„announceè¿›è¡ŒçŠ¶æ€è½¬æ¢ã€‚</p><pre><code>// Loop is the main fetcher loop, checking and processing various notification// events.func (f *Fetcher) loop() {    // Iterate the block fetching until a quit is requested    fetchTimer := time.NewTimer(0)  //fetchçš„å®šæ—¶å™¨ã€‚    completeTimer := time.NewTimer(0) // compelteçš„å®šæ—¶å™¨ã€‚    for {        // Clean up any expired block fetches        // å¦‚æœfetchingçš„æ—¶é—´è¶…è¿‡5ç§’ï¼Œé‚£ä¹ˆæ”¾å¼ƒæ‰è¿™ä¸ªfetching        for hash, announce := range f.fetching {            if time.Since(announce.time) &gt; fetchTimeout {                f.forgetHash(hash)            }        }        // Import any queued blocks that could potentially fit        // è¿™ä¸ªfetcher.queueé‡Œé¢ç¼“å­˜äº†å·²ç»å®Œæˆfetchçš„blockç­‰å¾…æŒ‰ç…§é¡ºåºæ’å…¥åˆ°æœ¬åœ°çš„åŒºå—é“¾ä¸­        //fetcher.queueæ˜¯ä¸€ä¸ªä¼˜å…ˆçº§é˜Ÿåˆ—ã€‚ ä¼˜å…ˆçº§åˆ«å°±æ˜¯ä»–ä»¬çš„åŒºå—å·çš„è´Ÿæ•°ï¼Œè¿™æ ·åŒºå—æ•°å°çš„æ’åœ¨æœ€å‰é¢ã€‚        height := f.chainHeight()        for !f.queue.Empty() { //             op := f.queue.PopItem().(*inject)            if f.queueChangeHook != nil {                f.queueChangeHook(op.block.Hash(), false)            }            // If too high up the chain or phase, continue later            number := op.block.NumberU64()            if number &gt; height+1 { //å½“å‰çš„åŒºå—çš„é«˜åº¦å¤ªé«˜ï¼Œè¿˜ä¸èƒ½import                f.queue.Push(op, -float32(op.block.NumberU64()))                if f.queueChangeHook != nil {                    f.queueChangeHook(op.block.Hash(), true)                }                break            }            // Otherwise if fresh and still unknown, try and import            hash := op.block.Hash()            if number+maxUncleDist &lt; height || f.getBlock(hash) != nil {                // åŒºå—çš„é«˜åº¦å¤ªä½ ä½äºå½“å‰çš„height-maxUncleDist                // æˆ–è€…åŒºå—å·²ç»è¢«importäº†                f.forgetBlock(hash)                continue            }            // æ’å…¥åŒºå—            f.insert(op.origin, op.block)        }        // Wait for an outside event to occur        select {        case &lt;-f.quit:            // Fetcher terminating, abort all operations            return        case notification := &lt;-f.notify: //åœ¨æ¥æ”¶åˆ°NewBlockHashesMsgçš„æ—¶å€™ï¼Œå¯¹äºæœ¬åœ°åŒºå—é“¾è¿˜æ²¡æœ‰çš„åŒºå—çš„hashå€¼ä¼šè°ƒç”¨fetcherçš„Notifyæ–¹æ³•å‘é€åˆ°notifyé€šé“ã€‚            ...        case op := &lt;-f.inject: // åœ¨æ¥æ”¶åˆ°NewBlockMsgçš„æ—¶å€™ä¼šè°ƒç”¨fetcherçš„Enqueueæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šæŠŠå½“å‰æ¥æ”¶åˆ°çš„åŒºå—å‘é€åˆ°injecté€šé“ã€‚            ...            f.enqueue(op.origin, op.block)        case hash := &lt;-f.done: //å½“å®Œæˆä¸€ä¸ªåŒºå—çš„importçš„æ—¶å€™ä¼šå‘é€è¯¥åŒºå—çš„hashå€¼åˆ°doneé€šé“ã€‚            ...        case &lt;-fetchTimer.C: // fetchTimerå®šæ—¶å™¨ï¼Œå®šæœŸå¯¹éœ€è¦fetchçš„åŒºå—å¤´è¿›è¡Œfetch            ...        case &lt;-completeTimer.C: // completeTimerå®šæ—¶å™¨å®šæœŸå¯¹éœ€è¦fetchçš„åŒºå—ä½“è¿›è¡Œfetch            ...        case filter := &lt;-f.headerFilter: //å½“æ¥æ”¶åˆ°BlockHeadersMsgçš„æ¶ˆæ¯çš„æ—¶å€™(æ¥æ”¶åˆ°ä¸€äº›åŒºå—å¤´),ä¼šæŠŠè¿™äº›æ¶ˆæ¯æŠ•é€’åˆ°headerFilteré˜Ÿåˆ—ã€‚ è¿™è¾¹ä¼šæŠŠå±äºfetcherè¯·æ±‚çš„æ•°æ®ç•™ä¸‹ï¼Œå…¶ä»–çš„ä¼šè¿”å›å‡ºæ¥ï¼Œç»™å…¶ä»–ç³»ç»Ÿä½¿ç”¨ã€‚            ...        case filter := &lt;-f.bodyFilter: //å½“æ¥æ”¶åˆ°BlockBodiesMsgæ¶ˆæ¯çš„æ—¶å€™ï¼Œä¼šæŠŠè¿™äº›æ¶ˆæ¯æŠ•é€’ç»™bodyFilteré˜Ÿåˆ—ã€‚è¿™è¾¹ä¼šæŠŠå±äºfetcherè¯·æ±‚çš„æ•°æ®ç•™ä¸‹ï¼Œå…¶ä»–çš„ä¼šè¿”å›å‡ºæ¥ï¼Œç»™å…¶ä»–ç³»ç»Ÿä½¿ç”¨ã€‚            ...        }    }}</code></pre><h3 id="åŒºå—å¤´çš„è¿‡æ»¤æµç¨‹"><a href="#åŒºå—å¤´çš„è¿‡æ»¤æµç¨‹" class="headerlink" title="åŒºå—å¤´çš„è¿‡æ»¤æµç¨‹"></a>åŒºå—å¤´çš„è¿‡æ»¤æµç¨‹</h3><h4 id="FilterHeadersè¯·æ±‚"><a href="#FilterHeadersè¯·æ±‚" class="headerlink" title="FilterHeadersè¯·æ±‚"></a>FilterHeadersè¯·æ±‚</h4><p>FilterHeadersæ–¹æ³•åœ¨æ¥æ”¶åˆ°BlockHeadersMsgçš„æ—¶å€™è¢«è°ƒç”¨ã€‚è¿™ä¸ªæ–¹æ³•é¦–å…ˆæŠ•é€’äº†ä¸€ä¸ªchannel filteråˆ°headerFilterã€‚ ç„¶åå¾€filteræŠ•é€’äº†ä¸€ä¸ªheaderFilterTaskçš„ä»»åŠ¡ã€‚ç„¶åé˜»å¡ç­‰å¾…filteré˜Ÿåˆ—è¿”å›æ¶ˆæ¯ã€‚</p><pre><code>// FilterHeaders extracts all the headers that were explicitly requested by the fetcher,// returning those that should be handled differently.func (f *Fetcher) FilterHeaders(peer string, headers []*types.Header, time time.Time) []*types.Header {    log.Trace("Filtering headers", "peer", peer, "headers", len(headers))    // Send the filter channel to the fetcher    filter := make(chan *headerFilterTask)    select {    case f.headerFilter &lt;- filter:    case &lt;-f.quit:        return nil    }    // Request the filtering of the header list    select {    case filter &lt;- &amp;headerFilterTask{peer: peer, headers: headers, time: time}:    case &lt;-f.quit:        return nil    }    // Retrieve the headers remaining after filtering    select {    case task := &lt;-filter:        return task.headers    case &lt;-f.quit:        return nil    }}</code></pre><h4 id="headerFilterçš„å¤„ç†"><a href="#headerFilterçš„å¤„ç†" class="headerlink" title="headerFilterçš„å¤„ç†"></a>headerFilterçš„å¤„ç†</h4><p>è¿™ä¸ªå¤„ç†åœ¨loop()çš„goroutineä¸­ã€‚</p><pre><code>case filter := &lt;-f.headerFilter:            // Headers arrived from a remote peer. Extract those that were explicitly            // requested by the fetcher, and return everything else so it's delivered            // to other parts of the system.            var task *headerFilterTask            select {            case task = &lt;-filter:            case &lt;-f.quit:                return            }            headerFilterInMeter.Mark(int64(len(task.headers)))            // Split the batch of headers into unknown ones (to return to the caller),            // known incomplete ones (requiring body retrievals) and completed blocks.            unknown, incomplete, complete := []*types.Header{}, []*announce{}, []*types.Block{}            for _, header := range task.headers {                hash := header.Hash()                // Filter fetcher-requested headers from other synchronisation algorithms                // æ ¹æ®æƒ…å†µçœ‹è¿™ä¸ªæ˜¯å¦æ˜¯æˆ‘ä»¬çš„è¯·æ±‚è¿”å›çš„ä¿¡æ¯ã€‚                if announce := f.fetching[hash]; announce != nil &amp;&amp; announce.origin == task.peer &amp;&amp; f.fetched[hash] == nil &amp;&amp; f.completing[hash] == nil &amp;&amp; f.queued[hash] == nil {                    // If the delivered header does not match the promised number, drop the announcer                    // å¦‚æœè¿”å›çš„headerçš„åŒºå—é«˜åº¦å’Œæˆ‘ä»¬è¯·æ±‚çš„ä¸åŒï¼Œé‚£ä¹ˆåˆ é™¤æ‰è¿”å›è¿™ä¸ªheaderçš„peerã€‚ å¹¶ä¸”å¿˜è®°æ‰è¿™ä¸ªhash(ä»¥ä¾¿äºé‡æ–°è·å–åŒºå—ä¿¡æ¯)                    if header.Number.Uint64() != announce.number {                        log.Trace("Invalid block number fetched", "peer", announce.origin, "hash", header.Hash(), "announced", announce.number, "provided", header.Number)                        f.dropPeer(announce.origin)                        f.forgetHash(hash)                        continue                    }                    // Only keep if not imported by other means                    if f.getBlock(hash) == nil {                        announce.header = header                        announce.time = task.time                        // If the block is empty (header only), short circuit into the final import queue                        // æ ¹æ®åŒºå—å¤´æŸ¥çœ‹ï¼Œå¦‚æœè¿™ä¸ªåŒºå—ä¸åŒ…å«ä»»ä½•äº¤æ˜“æˆ–è€…æ˜¯UncleåŒºå—ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±ä¸ç”¨è·å–åŒºå—çš„bodyäº†ã€‚ é‚£ä¹ˆç›´æ¥æ’å…¥å®Œæˆåˆ—è¡¨ã€‚                        if header.TxHash == types.DeriveSha(types.Transactions{}) &amp;&amp; header.UncleHash == types.CalcUncleHash([]*types.Header{}) {                            log.Trace("Block empty, skipping body retrieval", "peer", announce.origin, "number", header.Number, "hash", header.Hash())                            block := types.NewBlockWithHeader(header)                            block.ReceivedAt = task.time                            complete = append(complete, block)                            f.completing[hash] = announce                            continue                        }                        // Otherwise add to the list of blocks needing completion                        // å¦åˆ™ï¼Œæ’å…¥åˆ°æœªå®Œæˆåˆ—è¡¨ç­‰å¾…fetch blockbody                        incomplete = append(incomplete, announce)                    } else {                        log.Trace("Block already imported, discarding header", "peer", announce.origin, "number", header.Number, "hash", header.Hash())                        f.forgetHash(hash)                    }                } else {                    // Fetcher doesn't know about it, add to the return list                    // Fetcherå¹¶ä¸çŸ¥é“è¿™ä¸ªheaderã€‚ å¢åŠ åˆ°è¿”å›åˆ—è¡¨ç­‰å¾…è¿”å›ã€‚                    unknown = append(unknown, header)                }            }            headerFilterOutMeter.Mark(int64(len(unknown)))            select {            // æŠŠè¿”å›ç»“æœè¿”å›ã€‚            case filter &lt;- &amp;headerFilterTask{headers: unknown, time: task.time}:            case &lt;-f.quit:                return            }            // Schedule the retrieved headers for body completion            for _, announce := range incomplete {                hash := announce.header.Hash()                if _, ok := f.completing[hash]; ok { //å¦‚æœå·²ç»åœ¨å…¶ä»–çš„åœ°æ–¹å®Œæˆ                    continue                }                // æ”¾åˆ°ç­‰å¾…è·å–bodyçš„mapç­‰å¾…å¤„ç†ã€‚                f.fetched[hash] = append(f.fetched[hash], announce)                if len(f.fetched) == 1 { //å¦‚æœfetched mapåªæœ‰åˆšåˆšåŠ å…¥çš„ä¸€ä¸ªå…ƒç´ ã€‚ é‚£ä¹ˆé‡ç½®è®¡æ—¶å™¨ã€‚                    f.rescheduleComplete(completeTimer)                }            }            // Schedule the header-only blocks for import            // è¿™äº›åªæœ‰headerçš„åŒºå—æ”¾å…¥queueç­‰å¾…import            for _, block := range complete {                if announce := f.completing[block.Hash()]; announce != nil {                    f.enqueue(announce.origin, block)                }            }</code></pre><h4 id="bodyFilterçš„å¤„ç†"><a href="#bodyFilterçš„å¤„ç†" class="headerlink" title="bodyFilterçš„å¤„ç†"></a>bodyFilterçš„å¤„ç†</h4><p>å’Œä¸Šé¢çš„å¤„ç†ç±»ä¼¼ã€‚</p><pre><code>    case filter := &lt;-f.bodyFilter:        // Block bodies arrived, extract any explicitly requested blocks, return the rest        var task *bodyFilterTask        select {        case task = &lt;-filter:        case &lt;-f.quit:            return        }        bodyFilterInMeter.Mark(int64(len(task.transactions)))        blocks := []*types.Block{}        for i := 0; i &lt; len(task.transactions) &amp;&amp; i &lt; len(task.uncles); i++ {            // Match up a body to any possible completion request            matched := false            for hash, announce := range f.completing {                if f.queued[hash] == nil {                    txnHash := types.DeriveSha(types.Transactions(task.transactions[i]))                    uncleHash := types.CalcUncleHash(task.uncles[i])                    if txnHash == announce.header.TxHash &amp;&amp; uncleHash == announce.header.UncleHash &amp;&amp; announce.origin == task.peer {                        // Mark the body matched, reassemble if still unknown                        matched = true                                                if f.getBlock(hash) == nil {                            block := types.NewBlockWithHeader(announce.header).WithBody(task.transactions[i], task.uncles[i])                            block.ReceivedAt = task.time                            blocks = append(blocks, block)                        } else {                            f.forgetHash(hash)                        }                    }                }            }            if matched {                task.transactions = append(task.transactions[:i], task.transactions[i+1:]...)                task.uncles = append(task.uncles[:i], task.uncles[i+1:]...)                i--                continue            }        }        bodyFilterOutMeter.Mark(int64(len(task.transactions)))        select {        case filter &lt;- task:        case &lt;-f.quit:            return        }        // Schedule the retrieved blocks for ordered import        for _, block := range blocks {            if announce := f.completing[block.Hash()]; announce != nil {                f.enqueue(announce.origin, block)            }        }</code></pre><h4 id="notificationçš„å¤„ç†"><a href="#notificationçš„å¤„ç†" class="headerlink" title="notificationçš„å¤„ç†"></a>notificationçš„å¤„ç†</h4><p>åœ¨æ¥æ”¶åˆ°NewBlockHashesMsgçš„æ—¶å€™ï¼Œå¯¹äºæœ¬åœ°åŒºå—é“¾è¿˜æ²¡æœ‰çš„åŒºå—çš„hashå€¼ä¼šè°ƒç”¨fetcherçš„Notifyæ–¹æ³•å‘é€åˆ°notifyé€šé“ã€‚</p><pre><code>// Notify announces the fetcher of the potential availability of a new block in// the network.func (f *Fetcher) Notify(peer string, hash common.Hash, number uint64, time time.Time,    headerFetcher headerRequesterFn, bodyFetcher bodyRequesterFn) error {    block := &amp;announce{        hash:        hash,        number:      number,        time:        time,        origin:      peer,        fetchHeader: headerFetcher,        fetchBodies: bodyFetcher,    }    select {    case f.notify &lt;- block:        return nil    case &lt;-f.quit:        return errTerminated    }}</code></pre><p>åœ¨loopä¸­çš„å¤„ç†ï¼Œä¸»è¦æ˜¯æ£€æŸ¥ä¸€ä¸‹ç„¶ååŠ å…¥äº†announcedè¿™ä¸ªå®¹å™¨ç­‰å¾…å®šæ—¶å¤„ç†ã€‚</p><pre><code>case notification := &lt;-f.notify:        // A block was announced, make sure the peer isn't DOSing us        propAnnounceInMeter.Mark(1)        count := f.announces[notification.origin] + 1        if count &gt; hashLimit {  //hashLimit 256 ä¸€ä¸ªè¿œç«¯æœ€å¤šåªå­˜åœ¨256ä¸ªannounces            log.Debug("Peer exceeded outstanding announces", "peer", notification.origin, "limit", hashLimit)            propAnnounceDOSMeter.Mark(1)            break        }        // If we have a valid block number, check that it's potentially useful        // æŸ¥çœ‹æ˜¯æ½œåœ¨æ˜¯å¦æœ‰ç”¨ã€‚ æ ¹æ®è¿™ä¸ªåŒºå—å·å’Œæœ¬åœ°åŒºå—é“¾çš„è·ç¦»ï¼Œ å¤ªå¤§å’Œå¤ªå°å¯¹äºæˆ‘ä»¬éƒ½æ²¡æœ‰æ„ä¹‰ã€‚        if notification.number &gt; 0 {            if dist := int64(notification.number) - int64(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist {                log.Debug("Peer discarded announcement", "peer", notification.origin, "number", notification.number, "hash", notification.hash, "distance", dist)                propAnnounceDropMeter.Mark(1)                break            }        }        // All is well, schedule the announce if block's not yet downloading        // æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦å·²ç»å­˜åœ¨äº†ã€‚        if _, ok := f.fetching[notification.hash]; ok {            break        }        if _, ok := f.completing[notification.hash]; ok {            break        }        f.announces[notification.origin] = count        f.announced[notification.hash] = append(f.announced[notification.hash], notification)        if f.announceChangeHook != nil &amp;&amp; len(f.announced[notification.hash]) == 1 {            f.announceChangeHook(notification.hash, true)        }        if len(f.announced) == 1 {            f.rescheduleFetch(fetchTimer)        }</code></pre><h4 id="Enqueueå¤„ç†"><a href="#Enqueueå¤„ç†" class="headerlink" title="Enqueueå¤„ç†"></a>Enqueueå¤„ç†</h4><p>åœ¨æ¥æ”¶åˆ°NewBlockMsgçš„æ—¶å€™ä¼šè°ƒç”¨fetcherçš„Enqueueæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šæŠŠå½“å‰æ¥æ”¶åˆ°çš„åŒºå—å‘é€åˆ°injecté€šé“ã€‚ å¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•ç”Ÿæˆäº†ä¸€ä¸ªinjectå¯¹è±¡ç„¶åå‘é€åˆ°injecté€šé“</p><pre><code>// Enqueue tries to fill gaps the the fetcher's future import queue.func (f *Fetcher) Enqueue(peer string, block *types.Block) error {    op := &amp;inject{        origin: peer,        block:  block,    }    select {    case f.inject &lt;- op:        return nil    case &lt;-f.quit:        return errTerminated    }}</code></pre><p>injecté€šé“å¤„ç†éå¸¸ç®€å•ï¼Œç›´æ¥åŠ å…¥åˆ°é˜Ÿåˆ—ç­‰å¾…import</p><pre><code>case op := &lt;-f.inject:        // A direct block insertion was requested, try and fill any pending gaps        propBroadcastInMeter.Mark(1)        f.enqueue(op.origin, op.block)</code></pre><p>enqueue</p><pre><code>// enqueue schedules a new future import operation, if the block to be imported// has not yet been seen.func (f *Fetcher) enqueue(peer string, block *types.Block) {    hash := block.Hash()    // Ensure the peer isn't DOSing us    count := f.queues[peer] + 1    if count &gt; blockLimit { blockLimit 64 å¦‚æœç¼“å­˜çš„å¯¹æ–¹çš„blockå¤ªå¤šã€‚        log.Debug("Discarded propagated block, exceeded allowance", "peer", peer, "number", block.Number(), "hash", hash, "limit", blockLimit)        propBroadcastDOSMeter.Mark(1)        f.forgetHash(hash)        return    }    // Discard any past or too distant blocks    // è·ç¦»æˆ‘ä»¬çš„åŒºå—é“¾å¤ªè¿œã€‚    if dist := int64(block.NumberU64()) - int64(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist {         log.Debug("Discarded propagated block, too far away", "peer", peer, "number", block.Number(), "hash", hash, "distance", dist)        propBroadcastDropMeter.Mark(1)        f.forgetHash(hash)        return    }    // Schedule the block for future importing    // æ’å…¥åˆ°é˜Ÿåˆ—ã€‚    if _, ok := f.queued[hash]; !ok {        op := &amp;inject{            origin: peer,            block:  block,        }        f.queues[peer] = count        f.queued[hash] = op        f.queue.Push(op, -float32(block.NumberU64()))        if f.queueChangeHook != nil {            f.queueChangeHook(op.block.Hash(), true)        }        log.Debug("Queued propagated block", "peer", peer, "number", block.Number(), "hash", hash, "queued", f.queue.Size())    }}</code></pre><h4 id="å®šæ—¶å™¨çš„å¤„ç†"><a href="#å®šæ—¶å™¨çš„å¤„ç†" class="headerlink" title="å®šæ—¶å™¨çš„å¤„ç†"></a>å®šæ—¶å™¨çš„å¤„ç†</h4><p>ä¸€å…±å­˜åœ¨ä¸¤ä¸ªå®šæ—¶å™¨ã€‚fetchTimerå’ŒcompleteTimerï¼Œåˆ†åˆ«è´Ÿè´£è·å–åŒºå—å¤´å’Œè·å–åŒºå—bodyã€‚</p><p>çŠ¶æ€è½¬æ¢ announced  â€“fetchTimer(fetch header)â€”&gt; fetching  â€“(headerFilter)â€“&gt; fetched â€“completeTimer(fetch body)â€“&gt;completing â€“(bodyFilter)â€“&gt; enqueue â€“task.doneâ€“&gt; forgetHash</p><p>å‘ç°ä¸€ä¸ªé—®é¢˜ã€‚ completingçš„å®¹å™¨æœ‰å¯èƒ½æ³„éœ²ã€‚å¦‚æœå‘é€äº†ä¸€ä¸ªhashçš„bodyè¯·æ±‚ã€‚ ä½†æ˜¯è¯·æ±‚å¤±è´¥ï¼Œå¯¹æ–¹å¹¶æ²¡æœ‰è¿”å›ã€‚ è¿™ä¸ªæ—¶å€™completingå®¹å™¨æ²¡æœ‰æ¸…ç†ã€‚ æ˜¯å¦æœ‰å¯èƒ½å¯¼è‡´é—®é¢˜ã€‚</p><pre><code>    case &lt;-fetchTimer.C:        // At least one block's timer ran out, check for needing retrieval        request := make(map[string][]common.Hash)        for hash, announces := range f.announced {            // TODO è¿™é‡Œçš„æ—¶é—´é™åˆ¶æ˜¯ä»€ä¹ˆæ„æ€            // æœ€æ—©æ”¶åˆ°çš„announceï¼Œå¹¶ç»è¿‡arriveTimeout-gatherSlackè¿™ä¹ˆé•¿çš„æ—¶é—´ã€‚            if time.Since(announces[0].time) &gt; arriveTimeout-gatherSlack {                // Pick a random peer to retrieve from, reset all others                // announcesä»£è¡¨äº†åŒä¸€ä¸ªåŒºå—çš„æ¥è‡ªå¤šä¸ªpeerçš„å¤šä¸ªannounce                announce := announces[rand.Intn(len(announces))]                f.forgetHash(hash)                // If the block still didn't arrive, queue for fetching                if f.getBlock(hash) == nil {                    request[announce.origin] = append(request[announce.origin], hash)                    f.fetching[hash] = announce                }            }        }        // Send out all block header requests        // å‘é€æ‰€æœ‰çš„è¯·æ±‚ã€‚        for peer, hashes := range request {            log.Trace("Fetching scheduled headers", "peer", peer, "list", hashes)            // Create a closure of the fetch and schedule in on a new thread            fetchHeader, hashes := f.fetching[hashes[0]].fetchHeader, hashes            go func() {                if f.fetchingHook != nil {                    f.fetchingHook(hashes)                }                for _, hash := range hashes {                    headerFetchMeter.Mark(1)                    fetchHeader(hash) // Suboptimal, but protocol doesn't allow batch header retrievals                }            }()        }        // Schedule the next fetch if blocks are still pending        f.rescheduleFetch(fetchTimer)    case &lt;-completeTimer.C:        // At least one header's timer ran out, retrieve everything        request := make(map[string][]common.Hash)        for hash, announces := range f.fetched {            // Pick a random peer to retrieve from, reset all others            announce := announces[rand.Intn(len(announces))]            f.forgetHash(hash)            // If the block still didn't arrive, queue for completion            if f.getBlock(hash) == nil {                request[announce.origin] = append(request[announce.origin], hash)                f.completing[hash] = announce            }        }        // Send out all block body requests        for peer, hashes := range request {            log.Trace("Fetching scheduled bodies", "peer", peer, "list", hashes)            // Create a closure of the fetch and schedule in on a new thread            if f.completingHook != nil {                f.completingHook(hashes)            }            bodyFetchMeter.Mark(int64(len(hashes)))            go f.completing[hashes[0]].fetchBodies(hashes)        }        // Schedule the next fetch if blocks are still pending        f.rescheduleComplete(completeTimer)</code></pre><h4 id="å…¶ä»–çš„ä¸€äº›æ–¹æ³•"><a href="#å…¶ä»–çš„ä¸€äº›æ–¹æ³•" class="headerlink" title="å…¶ä»–çš„ä¸€äº›æ–¹æ³•"></a>å…¶ä»–çš„ä¸€äº›æ–¹æ³•</h4><p>fetcher insertæ–¹æ³•ã€‚ è¿™ä¸ªæ–¹æ³•æŠŠç»™å®šçš„åŒºå—æ’å…¥æœ¬åœ°çš„åŒºå—é“¾ã€‚</p><pre><code>// insert spawns a new goroutine to run a block insertion into the chain. If the// block's number is at the same height as the current import phase, if updates// the phase states accordingly.func (f *Fetcher) insert(peer string, block *types.Block) {    hash := block.Hash()    // Run the import on a new thread    log.Debug("Importing propagated block", "peer", peer, "number", block.Number(), "hash", hash)    go func() {        defer func() { f.done &lt;- hash }()        // If the parent's unknown, abort insertion        parent := f.getBlock(block.ParentHash())        if parent == nil {            log.Debug("Unknown parent of propagated block", "peer", peer, "number", block.Number(), "hash", hash, "parent", block.ParentHash())            return        }        // Quickly validate the header and propagate the block if it passes        // å¦‚æœåŒºå—å¤´é€šè¿‡éªŒè¯ï¼Œé‚£ä¹ˆé©¬ä¸Šå¯¹åŒºå—è¿›è¡Œå¹¿æ’­ã€‚ NewBlockMsg        switch err := f.verifyHeader(block.Header()); err {        case nil:            // All ok, quickly propagate to our peers            propBroadcastOutTimer.UpdateSince(block.ReceivedAt)            go f.broadcastBlock(block, true)        case consensus.ErrFutureBlock:            // Weird future block, don't fail, but neither propagate        default:            // Something went very wrong, drop the peer            log.Debug("Propagated block verification failed", "peer", peer, "number", block.Number(), "hash", hash, "err", err)            f.dropPeer(peer)            return        }        // Run the actual import and log any issues        if _, err := f.insertChain(types.Blocks{block}); err != nil {            log.Debug("Propagated block import failed", "peer", peer, "number", block.Number(), "hash", hash, "err", err)            return        }        // If import succeeded, broadcast the block        // å¦‚æœæ’å…¥æˆåŠŸï¼Œ é‚£ä¹ˆå¹¿æ’­åŒºå—ï¼Œ ç¬¬äºŒä¸ªå‚æ•°ä¸ºfalseã€‚é‚£ä¹ˆåªä¼šå¯¹åŒºå—çš„hashè¿›è¡Œå¹¿æ’­ã€‚NewBlockHashesMsg        propAnnounceOutTimer.UpdateSince(block.ReceivedAt)        go f.broadcastBlock(block, false)        // Invoke the testing hook if needed        if f.importedHook != nil {            f.importedHook(block)        }    }()}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-p2p-rlpxèŠ‚ç‚¹ä¹‹é—´çš„åŠ å¯†é“¾è·¯</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-rlpx%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8A%A0%E5%AF%86%E9%93%BE%E8%B7%AF/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-rlpx%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8A%A0%E5%AF%86%E9%93%BE%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>RLPx Encryption(RLPxåŠ å¯†)</p><p>ä¹‹å‰ä»‹ç»çš„discoverèŠ‚ç‚¹å‘ç°åè®®ï¼Œ å› ä¸ºæ‰¿è½½çš„æ•°æ®ä¸æ˜¯å¾ˆé‡è¦ï¼ŒåŸºæœ¬æ˜¯æ˜æ–‡ä¼ è¾“çš„ã€‚ </p><p>æ¯ä¸€ä¸ªèŠ‚ç‚¹ä¼šå¼€å¯ä¸¤ä¸ªåŒæ ·çš„ç«¯å£ï¼Œä¸€ä¸ªæ˜¯UDPç«¯å£ï¼Œç”¨æ¥èŠ‚ç‚¹å‘ç°ï¼Œä¸€ä¸ªæ˜¯TCPç«¯å£ï¼Œç”¨æ¥æ‰¿è½½ä¸šåŠ¡æ•°æ®ã€‚ UDPçš„ç«¯å£å’ŒTCPçš„ç«¯å£çš„ç«¯å£å·æ˜¯åŒæ ·çš„ã€‚ è¿™æ ·åªè¦é€šè¿‡UDPå‘ç°äº†ç«¯å£ï¼Œå°±ç­‰äºå¯ä»¥ç”¨TCPæ¥è¿æ¥åˆ°å¯¹åº”çš„ç«¯å£ã€‚</p><p>RLPxåè®®å°±å®šä¹‰äº†TCPé“¾æ¥çš„åŠ å¯†è¿‡ç¨‹ã€‚</p><p>RLPxä½¿ç”¨äº†(Perfect Forward Secrecy), ç®€å•æ¥è¯´ã€‚ é“¾æ¥çš„ä¸¤æ–¹ç”Ÿæˆç”Ÿæˆéšæœºçš„ç§é’¥ï¼Œé€šè¿‡éšæœºçš„ç§é’¥å¾—åˆ°å…¬é’¥ã€‚ ç„¶ååŒæ–¹äº¤æ¢å„è‡ªçš„å…¬é’¥ï¼Œ è¿™æ ·åŒæ–¹éƒ½å¯ä»¥é€šè¿‡è‡ªå·±éšæœºçš„ç§é’¥å’Œå¯¹æ–¹çš„å…¬é’¥æ¥ç”Ÿæˆä¸€ä¸ªåŒæ ·çš„å…±äº«å¯†é’¥(shared-secret)ã€‚åç»­çš„é€šè®¯ä½¿ç”¨è¿™ä¸ªå…±äº«å¯†é’¥ä½œä¸ºå¯¹ç§°åŠ å¯†ç®—æ³•çš„å¯†é’¥ã€‚ è¿™æ ·æ¥è¯´ã€‚å¦‚æœæœ‰ä¸€å¤©ä¸€æ–¹çš„ç§é’¥è¢«æ³„éœ²ï¼Œä¹Ÿåªä¼šå½±å“æ³„éœ²ä¹‹åçš„æ¶ˆæ¯çš„å®‰å…¨æ€§ï¼Œ å¯¹äºä¹‹å‰çš„é€šè®¯æ˜¯å®‰å…¨çš„(å› ä¸ºé€šè®¯çš„å¯†é’¥æ˜¯éšæœºç”Ÿæˆçš„ï¼Œç”¨å®Œåå°±æ¶ˆå¤±äº†)ã€‚</p><h2 id="å‰å‘å®‰å…¨æ€§-å¼•ç”¨è‡ªç»´åŸºç™¾ç§‘"><a href="#å‰å‘å®‰å…¨æ€§-å¼•ç”¨è‡ªç»´åŸºç™¾ç§‘" class="headerlink" title="å‰å‘å®‰å…¨æ€§(å¼•ç”¨è‡ªç»´åŸºç™¾ç§‘)"></a>å‰å‘å®‰å…¨æ€§(å¼•ç”¨è‡ªç»´åŸºç™¾ç§‘)</h2><p>å‰å‘å®‰å…¨æˆ–å‰å‘ä¿å¯†ï¼ˆè‹±è¯­ï¼šForward Secrecyï¼Œç¼©å†™ï¼šFSï¼‰ï¼Œæœ‰æ—¶ä¹Ÿè¢«ç§°ä¸ºå®Œç¾å‰å‘å®‰å…¨[1]ï¼ˆè‹±è¯­ï¼šPerfect Forward Secrecyï¼Œç¼©å†™ï¼šPFSï¼‰ï¼Œæ˜¯å¯†ç å­¦ä¸­é€šè®¯åè®®çš„å®‰å…¨å±æ€§ï¼ŒæŒ‡çš„æ˜¯é•¿æœŸä½¿ç”¨çš„ä¸»å¯†é’¥æ³„æ¼ä¸ä¼šå¯¼è‡´è¿‡å»çš„ä¼šè¯å¯†é’¥æ³„æ¼ã€‚[2]å‰å‘å®‰å…¨èƒ½å¤Ÿä¿æŠ¤è¿‡å»è¿›è¡Œçš„é€šè®¯ä¸å—å¯†ç æˆ–å¯†é’¥åœ¨æœªæ¥æš´éœ²çš„å¨èƒã€‚[3]å¦‚æœç³»ç»Ÿå…·æœ‰å‰å‘å®‰å…¨æ€§ï¼Œå°±å¯ä»¥ä¿è¯ä¸‡ä¸€å¯†ç æˆ–å¯†é’¥åœ¨æŸä¸ªæ—¶åˆ»ä¸æ…æ³„éœ²ï¼Œè¿‡å»å·²ç»è¿›è¡Œçš„é€šè®¯ä¾ç„¶æ˜¯å®‰å…¨ï¼Œä¸ä¼šå—åˆ°ä»»ä½•å½±å“ï¼Œå³ä½¿ç³»ç»Ÿé­åˆ°ä¸»åŠ¨æ”»å‡»ä¹Ÿæ˜¯å¦‚æ­¤ã€‚</p><h3 id="è¿ªè²-èµ«å°”æ›¼å¯†é’¥äº¤æ¢"><a href="#è¿ªè²-èµ«å°”æ›¼å¯†é’¥äº¤æ¢" class="headerlink" title="è¿ªè²-èµ«å°”æ›¼å¯†é’¥äº¤æ¢"></a>è¿ªè²-èµ«å°”æ›¼å¯†é’¥äº¤æ¢</h3><p>è¿ªè²-èµ«å°”æ›¼å¯†é’¥äº¤æ¢ï¼ˆè‹±è¯­ï¼šDiffieâ€“Hellman key exchangeï¼Œç¼©å†™ä¸ºD-Hï¼‰ æ˜¯ä¸€ç§å®‰å…¨åè®®ã€‚å®ƒå¯ä»¥è®©åŒæ–¹åœ¨å®Œå…¨æ²¡æœ‰å¯¹æ–¹ä»»ä½•é¢„å…ˆä¿¡æ¯çš„æ¡ä»¶ä¸‹é€šè¿‡ä¸å®‰å…¨ä¿¡é“åˆ›å»ºèµ·ä¸€ä¸ªå¯†é’¥ã€‚è¿™ä¸ªå¯†é’¥å¯ä»¥åœ¨åç»­çš„é€šè®¯ä¸­ä½œä¸ºå¯¹ç§°å¯†é’¥æ¥åŠ å¯†é€šè®¯å†…å®¹ã€‚å…¬é’¥äº¤æ¢çš„æ¦‚å¿µæœ€æ—©ç”±ç‘å¤«Â·å¢¨å…‹ï¼ˆRalph C. Merkleï¼‰æå‡ºï¼Œè€Œè¿™ä¸ªå¯†é’¥äº¤æ¢æ–¹æ³•ï¼Œç”±æƒ ç‰¹è²å°”å¾·Â·è¿ªè²ï¼ˆBailey Whitfield Diffieï¼‰å’Œé©¬ä¸Â·èµ«å°”æ›¼ï¼ˆMartin Edward Hellmanï¼‰åœ¨1976å¹´é¦–æ¬¡å‘è¡¨ã€‚é©¬ä¸Â·èµ«å°”æ›¼æ›¾ä¸»å¼ è¿™ä¸ªå¯†é’¥äº¤æ¢æ–¹æ³•ï¼Œåº”è¢«ç§°ä¸ºè¿ªè²-èµ«å°”æ›¼-å¢¨å…‹å¯†é’¥äº¤æ¢ï¼ˆè‹±è¯­ï¼šDiffieâ€“Hellmanâ€“Merkle key exchangeï¼‰ã€‚</p><ul><li>è¿ªè²ï¼èµ«å°”æ›¼å¯†é’¥äº¤æ¢çš„åŒä¹‰è¯åŒ…æ‹¬:</li><li>è¿ªè²ï¼èµ«å°”æ›¼å¯†é’¥åå•†</li><li>è¿ªè²ï¼èµ«å°”æ›¼å¯†é’¥åˆ›å»º</li><li>æŒ‡æ•°å¯†é’¥äº¤æ¢</li><li>è¿ªè²ï¼èµ«å°”æ›¼åè®®</li></ul><p>è™½ç„¶è¿ªè²ï¼èµ«å°”æ›¼å¯†é’¥äº¤æ¢æœ¬èº«æ˜¯ä¸€ä¸ªåŒ¿åï¼ˆæ— è®¤è¯ï¼‰çš„å¯†é’¥äº¤æ¢åè®®ï¼Œå®ƒå´æ˜¯å¾ˆå¤šè®¤è¯åè®®çš„åŸºç¡€ï¼Œå¹¶ä¸”è¢«ç”¨æ¥æä¾›ä¼ è¾“å±‚å®‰å…¨åè®®çš„çŸ­æš‚æ¨¡å¼ä¸­çš„å®Œå¤‡çš„å‰å‘å®‰å…¨æ€§ã€‚</p><h4 id="æè¿°"><a href="#æè¿°" class="headerlink" title="æè¿°"></a>æè¿°</h4><p>è¿ªè²ï¼èµ«å°”æ›¼é€šè¿‡å…¬å…±ä¿¡é“äº¤æ¢ä¸€ä¸ªä¿¡æ¯ï¼Œå°±å¯ä»¥åˆ›å»ºä¸€ä¸ªå¯ä»¥ç”¨äºåœ¨å…¬å…±ä¿¡é“ä¸Šå®‰å…¨é€šä¿¡çš„å…±äº«ç§˜å¯†ï¼ˆshared secretï¼‰ã€‚<br>ä»¥ä¸‹è§£é‡Šå®ƒçš„è¿‡ç¨‹ï¼ˆåŒ…æ‹¬ç®—æ³•çš„æ•°å­¦éƒ¨åˆ†ï¼‰ï¼š<br><img src="/images/ethereum/source_analysis/rlpx_1.png" alt="image"></p><p>æœ€ç®€å•ï¼Œæœ€æ—©æå‡ºçš„è¿™ä¸ªåè®®ä½¿ç”¨ä¸€ä¸ªè´¨æ•°pçš„æ•´æ•°æ¨¡nä¹˜æ³•ç¾¤ä»¥åŠå…¶åŸæ ¹gã€‚ä¸‹é¢å±•ç¤ºè¿™ä¸ªç®—æ³•ï¼Œç»¿è‰²è¡¨ç¤ºéç§˜å¯†ä¿¡æ¯, çº¢è‰²ç²—ä½“è¡¨ç¤ºç§˜å¯†ä¿¡æ¯ï¼š<br><img src="/images/ethereum/source_analysis/rlpx_2.png" alt="image"><br><img src="/images/ethereum/source_analysis/rlpx_3.png" alt="image"></p><h2 id="p2p-rlpx-goæºç è§£è¯»"><a href="#p2p-rlpx-goæºç è§£è¯»" class="headerlink" title="p2p/rlpx.goæºç è§£è¯»"></a>p2p/rlpx.goæºç è§£è¯»</h2><p>è¿™ä¸ªæ–‡ä»¶å®ç°äº†RLPxçš„é“¾è·¯åè®®ã€‚</p><p>é“¾æ¥è”ç³»çš„å¤§è‡´æµç¨‹å¦‚ä¸‹ï¼š</p><ol><li>doEncHandshake() é€šè¿‡è¿™ä¸ªæ–¹æ³•æ¥å®Œæˆäº¤æ¢å¯†é’¥ï¼Œåˆ›å»ºåŠ å¯†ä¿¡é“çš„æµç¨‹ã€‚å¦‚æœå¤±è´¥ï¼Œé‚£ä¹ˆé“¾æ¥å…³é—­ã€‚</li><li>doProtoHandshake() è¿™ä¸ªæ–¹æ³•æ¥è¿›è¡Œåè®®ç‰¹æ€§ä¹‹é—´çš„åå•†ï¼Œæ¯”å¦‚åŒæ–¹çš„åè®®ç‰ˆæœ¬ï¼Œæ˜¯å¦æ”¯æŒSnappyåŠ å¯†æ–¹å¼ç­‰æ“ä½œã€‚</li></ol><p>é“¾æ¥ç»è¿‡è¿™ä¸¤æ¬¡å¤„ç†ä¹‹åï¼Œå°±ç®—å»ºç«‹èµ·æ¥äº†ã€‚å› ä¸ºTCPæ˜¯æµå¼çš„åè®®ã€‚æ‰€æœ‰RLPxåè®®å®šä¹‰äº†åˆ†å¸§çš„æ–¹å¼ã€‚æ‰€æœ‰çš„æ•°æ®éƒ½å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªæ¥ä¸€ä¸ªçš„rlpxFrameã€‚ rlpxçš„è¯»å†™éƒ½æ˜¯é€šè¿‡rlpxFrameRWå¯¹è±¡æ¥è¿›è¡Œå¤„ç†ã€‚</p><h3 id="doEncHandshake"><a href="#doEncHandshake" class="headerlink" title="doEncHandshake"></a>doEncHandshake</h3><p>é“¾æ¥çš„å‘èµ·è€…è¢«ç§°ä¸ºinitiatorã€‚é“¾æ¥çš„è¢«åŠ¨æ¥å—è€…è¢«æˆä¸ºreceiverã€‚ è¿™ä¸¤ç§æ¨¡å¼ä¸‹å¤„ç†çš„æµç¨‹æ˜¯ä¸åŒçš„ã€‚å®Œæˆæ¡æ‰‹åã€‚ ç”Ÿæˆäº†ä¸€ä¸ªsec.å¯ä»¥ç†è§£ä¸ºæ‹¿åˆ°äº†å¯¹ç§°åŠ å¯†çš„å¯†é’¥ã€‚ ç„¶ååˆ›å»ºäº†ä¸€ä¸ªnewRLPXFrameRWå¸§è¯»å†™å™¨ã€‚å®ŒæˆåŠ å¯†ä¿¡é“çš„åˆ›å»ºè¿‡ç¨‹ã€‚</p><pre><code>func (t *rlpx) doEncHandshake(prv *ecdsa.PrivateKey, dial *discover.Node) (discover.NodeID, error) {    var (        sec secrets        err error    )    if dial == nil {        sec, err = receiverEncHandshake(t.fd, prv, nil)    } else {        sec, err = initiatorEncHandshake(t.fd, prv, dial.ID, nil)    }    if err != nil {        return discover.NodeID{}, err    }    t.wmu.Lock()    t.rw = newRLPXFrameRW(t.fd, sec)    t.wmu.Unlock()    return sec.RemoteID, nil}</code></pre><p>initiatorEncHandshake é¦–å…ˆçœ‹çœ‹é“¾æ¥çš„å‘èµ·è€…çš„æ“ä½œã€‚é¦–å…ˆé€šè¿‡makeAuthMsgåˆ›å»ºäº†authMsgã€‚ ç„¶åé€šè¿‡ç½‘ç»œå‘é€ç»™å¯¹ç«¯ã€‚ç„¶åé€šè¿‡readHandshakeMsgè¯»å–å¯¹ç«¯çš„å›åº”ã€‚ æœ€åè°ƒç”¨secretsåˆ›å»ºäº†å…±äº«ç§˜å¯†ã€‚</p><pre><code>// initiatorEncHandshake negotiates a session token on conn.// it should be called on the dialing side of the connection.//// prv is the local client's private key.func initiatorEncHandshake(conn io.ReadWriter, prv *ecdsa.PrivateKey, remoteID discover.NodeID, token []byte) (s secrets, err error) {    h := &amp;encHandshake{initiator: true, remoteID: remoteID}    authMsg, err := h.makeAuthMsg(prv, token)    if err != nil {        return s, err    }    authPacket, err := sealEIP8(authMsg, h)    if err != nil {        return s, err    }    if _, err = conn.Write(authPacket); err != nil {        return s, err    }    authRespMsg := new(authRespV4)    authRespPacket, err := readHandshakeMsg(authRespMsg, encAuthRespLen, prv, conn)    if err != nil {        return s, err    }    if err := h.handleAuthResp(authRespMsg); err != nil {        return s, err    }    return h.secrets(authPacket, authRespPacket)}</code></pre><p>makeAuthMsgã€‚è¿™ä¸ªæ–¹æ³•åˆ›å»ºäº†initiatorçš„handshake messageã€‚ é¦–å…ˆå¯¹ç«¯çš„å…¬é’¥å¯ä»¥é€šè¿‡å¯¹ç«¯çš„IDæ¥è·å–ã€‚æ‰€ä»¥å¯¹ç«¯çš„å…¬é’¥å¯¹äºå‘èµ·è¿æ¥çš„äººæ¥è¯´æ˜¯çŸ¥é“çš„ã€‚ ä½†æ˜¯å¯¹äºè¢«è¿æ¥çš„äººæ¥è¯´ï¼Œå¯¹ç«¯çš„å…¬é’¥åº”è¯¥æ˜¯ä¸çŸ¥é“çš„ã€‚</p><pre><code>// makeAuthMsg creates the initiator handshake message.func (h *encHandshake) makeAuthMsg(prv *ecdsa.PrivateKey, token []byte) (*authMsgV4, error) {    rpub, err := h.remoteID.Pubkey()    if err != nil {        return nil, fmt.Errorf("bad remoteID: %v", err)    }    h.remotePub = ecies.ImportECDSAPublic(rpub)    // Generate random initiator nonce.    // ç”Ÿæˆä¸€ä¸ªéšæœºçš„åˆå§‹å€¼ï¼Œ æ˜¯ä¸ºäº†é¿å…é‡æ”¾æ”»å‡»ä¹ˆï¼Ÿ è¿˜æ˜¯ä¸ºäº†é¿å…é€šè¿‡å¤šæ¬¡è¿æ¥çŒœæµ‹å¯†é’¥ï¼Ÿ    h.initNonce = make([]byte, shaLen)    if _, err := rand.Read(h.initNonce); err != nil {        return nil, err    }    // Generate random keypair to for ECDH.    //ç”Ÿæˆä¸€ä¸ªéšæœºçš„ç§é’¥    h.randomPrivKey, err = ecies.GenerateKey(rand.Reader, crypto.S256(), nil)    if err != nil {        return nil, err    }    // Sign known message: static-shared-secret ^ nonce    // è¿™ä¸ªåœ°æ–¹åº”è¯¥æ˜¯ç›´æ¥ä½¿ç”¨äº†é™æ€çš„å…±äº«ç§˜å¯†ã€‚ ä½¿ç”¨è‡ªå·±çš„ç§é’¥å’Œå¯¹æ–¹çš„å…¬é’¥ç”Ÿæˆçš„ä¸€ä¸ªå…±äº«ç§˜å¯†ã€‚    token, err = h.staticSharedSecret(prv)    if err != nil {        return nil, err    }    //è¿™é‡Œæˆ‘ç†è§£ç”¨å…±äº«ç§˜å¯†æ¥åŠ å¯†è¿™ä¸ªinitNonceã€‚     signed := xor(token, h.initNonce)    // ä½¿ç”¨éšæœºçš„ç§é’¥æ¥åŠ å¯†è¿™ä¸ªä¿¡æ¯ã€‚    signature, err := crypto.Sign(signed, h.randomPrivKey.ExportECDSA())    if err != nil {        return nil, err    }    msg := new(authMsgV4)    copy(msg.Signature[:], signature)    //è¿™é‡ŒæŠŠå‘èµ·è€…çš„å…¬é’¥å‘ŠçŸ¥å¯¹æ–¹ã€‚ è¿™æ ·å¯¹æ–¹ä½¿ç”¨è‡ªå·±çš„ç§é’¥å’Œè¿™ä¸ªå…¬é’¥å¯ä»¥ç”Ÿæˆé™æ€çš„å…±äº«ç§˜å¯†ã€‚    copy(msg.InitiatorPubkey[:], crypto.FromECDSAPub(&amp;prv.PublicKey)[1:])    copy(msg.Nonce[:], h.initNonce)    msg.Version = 4    return msg, nil}// staticSharedSecret returns the static shared secret, the result// of key agreement between the local and remote static node key.func (h *encHandshake) staticSharedSecret(prv *ecdsa.PrivateKey) ([]byte, error) {    return ecies.ImportECDSA(prv).GenerateShared(h.remotePub, sskLen, sskLen)}</code></pre><p>sealEIP8æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯ä¸€ä¸ªç»„åŒ…æ–¹æ³•ï¼Œå¯¹msgè¿›è¡Œrlpçš„ç¼–ç ã€‚ å¡«å……ä¸€äº›æ•°æ®ã€‚ ç„¶åä½¿ç”¨å¯¹æ–¹çš„å…¬é’¥æŠŠæ•°æ®è¿›è¡ŒåŠ å¯†ã€‚ è¿™æ„å‘³ç€åªæœ‰å¯¹æ–¹çš„ç§é’¥æ‰èƒ½è§£å¯†è¿™æ®µä¿¡æ¯ã€‚</p><pre><code>func sealEIP8(msg interface{}, h *encHandshake) ([]byte, error) {    buf := new(bytes.Buffer)    if err := rlp.Encode(buf, msg); err != nil {        return nil, err    }    // pad with random amount of data. the amount needs to be at least 100 bytes to make    // the message distinguishable from pre-EIP-8 handshakes.    pad := padSpace[:mrand.Intn(len(padSpace)-100)+100]    buf.Write(pad)    prefix := make([]byte, 2)    binary.BigEndian.PutUint16(prefix, uint16(buf.Len()+eciesOverhead))    enc, err := ecies.Encrypt(rand.Reader, h.remotePub, buf.Bytes(), nil, prefix)    return append(prefix, enc...), err}</code></pre><p>readHandshakeMsgè¿™ä¸ªæ–¹æ³•ä¼šä»ä¸¤ä¸ªåœ°æ–¹è°ƒç”¨ã€‚ ä¸€ä¸ªæ˜¯åœ¨initiatorEncHandshakeã€‚ä¸€ä¸ªå°±æ˜¯åœ¨receiverEncHandshakeã€‚ è¿™ä¸ªæ–¹æ³•æ¯”è¾ƒç®€å•ã€‚ é¦–å…ˆç”¨ä¸€ç§æ ¼å¼å°è¯•è§£ç ã€‚å¦‚æœä¸è¡Œå°±æ¢å¦å¤–ä¸€ç§ã€‚åº”è¯¥æ˜¯ä¸€ç§å…¼å®¹æ€§çš„è®¾ç½®ã€‚ åŸºæœ¬ä¸Šå°±æ˜¯ä½¿ç”¨è‡ªå·±çš„ç§é’¥è¿›è¡Œè§£ç ç„¶åè°ƒç”¨rlpè§£ç æˆç»“æ„ä½“ã€‚ ç»“æ„ä½“çš„æè¿°å°±æ˜¯ä¸‹é¢çš„authRespV4,é‡Œé¢æœ€é‡è¦çš„å°±æ˜¯å¯¹ç«¯çš„éšæœºå…¬é’¥ã€‚ åŒæ–¹é€šè¿‡è‡ªå·±çš„ç§é’¥å’Œå¯¹ç«¯çš„éšæœºå…¬é’¥å¯ä»¥å¾—åˆ°ä¸€æ ·çš„å…±äº«ç§˜å¯†ã€‚ è€Œè¿™ä¸ªå…±äº«ç§˜å¯†æ˜¯ç¬¬ä¸‰æ–¹æ‹¿ä¸åˆ°çš„ã€‚</p><pre><code>// RLPx v4 handshake response (defined in EIP-8).type authRespV4 struct {    RandomPubkey [pubLen]byte    Nonce        [shaLen]byte    Version      uint    // Ignore additional fields (forward-compatibility)    Rest []rlp.RawValue `rlp:"tail"`}func readHandshakeMsg(msg plainDecoder, plainSize int, prv *ecdsa.PrivateKey, r io.Reader) ([]byte, error) {    buf := make([]byte, plainSize)    if _, err := io.ReadFull(r, buf); err != nil {        return buf, err    }    // Attempt decoding pre-EIP-8 "plain" format.    key := ecies.ImportECDSA(prv)    if dec, err := key.Decrypt(rand.Reader, buf, nil, nil); err == nil {        msg.decodePlain(dec)        return buf, nil    }    // Could be EIP-8 format, try that.    prefix := buf[:2]    size := binary.BigEndian.Uint16(prefix)    if size &lt; uint16(plainSize) {        return buf, fmt.Errorf("size underflow, need at least %d bytes", plainSize)    }    buf = append(buf, make([]byte, size-uint16(plainSize)+2)...)    if _, err := io.ReadFull(r, buf[plainSize:]); err != nil {        return buf, err    }    dec, err := key.Decrypt(rand.Reader, buf[2:], nil, prefix)    if err != nil {        return buf, err    }    // Can't use rlp.DecodeBytes here because it rejects    // trailing data (forward-compatibility).    s := rlp.NewStream(bytes.NewReader(dec), 0)    return buf, s.Decode(msg)}</code></pre><p>handleAuthRespè¿™ä¸ªæ–¹æ³•éå¸¸ç®€å•ã€‚</p><pre><code>func (h *encHandshake) handleAuthResp(msg *authRespV4) (err error) {    h.respNonce = msg.Nonce[:]    h.remoteRandomPub, err = importPublicKey(msg.RandomPubkey[:])    return err}</code></pre><p>æœ€åæ˜¯secretså‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯åœ¨handshakeå®Œæˆä¹‹åè°ƒç”¨ã€‚å®ƒé€šè¿‡è‡ªå·±çš„éšæœºç§é’¥å’Œå¯¹ç«¯çš„å…¬é’¥æ¥ç”Ÿæˆä¸€ä¸ªå…±äº«ç§˜å¯†,è¿™ä¸ªå…±äº«ç§˜å¯†æ˜¯ç¬æ—¶çš„(åªåœ¨å½“å‰è¿™ä¸ªé“¾æ¥ä¸­å­˜åœ¨)ã€‚æ‰€ä»¥å½“æœ‰ä¸€å¤©ç§é’¥è¢«ç ´è§£ã€‚ ä¹‹å‰çš„æ¶ˆæ¯è¿˜æ˜¯å®‰å…¨çš„ã€‚</p><pre><code>// secrets is called after the handshake is completed.// It extracts the connection secrets from the handshake values.func (h *encHandshake) secrets(auth, authResp []byte) (secrets, error) {    ecdheSecret, err := h.randomPrivKey.GenerateShared(h.remoteRandomPub, sskLen, sskLen)    if err != nil {        return secrets{}, err    }    // derive base secrets from ephemeral key agreement    sharedSecret := crypto.Keccak256(ecdheSecret, crypto.Keccak256(h.respNonce, h.initNonce))    aesSecret := crypto.Keccak256(ecdheSecret, sharedSecret)    // å®é™…ä¸Šè¿™ä¸ªMACä¿æŠ¤äº†ecdheSecretè¿™ä¸ªå…±äº«ç§˜å¯†ã€‚respNonceå’ŒinitNonceè¿™ä¸‰ä¸ªå€¼    s := secrets{        RemoteID: h.remoteID,        AES:      aesSecret,        MAC:      crypto.Keccak256(ecdheSecret, aesSecret),    }    // setup sha3 instances for the MACs    mac1 := sha3.NewKeccak256()    mac1.Write(xor(s.MAC, h.respNonce))    mac1.Write(auth)    mac2 := sha3.NewKeccak256()    mac2.Write(xor(s.MAC, h.initNonce))    mac2.Write(authResp)    //æ”¶åˆ°çš„æ¯ä¸ªåŒ…éƒ½ä¼šæ£€æŸ¥å…¶MACå€¼æ˜¯å¦æ»¡è¶³è®¡ç®—çš„ç»“æœã€‚å¦‚æœä¸æ»¡è¶³è¯´æ˜æœ‰é—®é¢˜ã€‚    if h.initiator {        s.EgressMAC, s.IngressMAC = mac1, mac2    } else {        s.EgressMAC, s.IngressMAC = mac2, mac1    }    return s, nil}</code></pre><p>receiverEncHandshakeå‡½æ•°å’ŒinitiatorEncHandshakeçš„å†…å®¹å¤§è‡´ç›¸åŒã€‚ ä½†æ˜¯é¡ºåºæœ‰äº›ä¸ä¸€æ ·ã€‚</p><pre><code>// receiverEncHandshake negotiates a session token on conn.// it should be called on the listening side of the connection.//// prv is the local client's private key.// token is the token from a previous session with this node.func receiverEncHandshake(conn io.ReadWriter, prv *ecdsa.PrivateKey, token []byte) (s secrets, err error) {    authMsg := new(authMsgV4)    authPacket, err := readHandshakeMsg(authMsg, encAuthMsgLen, prv, conn)    if err != nil {        return s, err    }    h := new(encHandshake)    if err := h.handleAuthMsg(authMsg, prv); err != nil {        return s, err    }    authRespMsg, err := h.makeAuthResp()    if err != nil {        return s, err    }    var authRespPacket []byte    if authMsg.gotPlain {        authRespPacket, err = authRespMsg.sealPlain(h)    } else {        authRespPacket, err = sealEIP8(authRespMsg, h)    }    if err != nil {        return s, err    }    if _, err = conn.Write(authRespPacket); err != nil {        return s, err    }    return h.secrets(authPacket, authRespPacket)}</code></pre><h3 id="doProtocolHandshake"><a href="#doProtocolHandshake" class="headerlink" title="doProtocolHandshake"></a>doProtocolHandshake</h3><p>è¿™ä¸ªæ–¹æ³•æ¯”è¾ƒç®€å•ï¼Œ åŠ å¯†ä¿¡é“å·²ç»åˆ›å»ºå®Œæ¯•ã€‚ æˆ‘ä»¬çœ‹åˆ°è¿™é‡Œåªæ˜¯çº¦å®šäº†æ˜¯å¦ä½¿ç”¨SnappyåŠ å¯†ç„¶åå°±é€€å‡ºäº†ã€‚</p><pre><code>// doEncHandshake runs the protocol handshake using authenticated// messages. the protocol handshake is the first authenticated message// and also verifies whether the encryption handshake 'worked' and the// remote side actually provided the right public key.func (t *rlpx) doProtoHandshake(our *protoHandshake) (their *protoHandshake, err error) {    // Writing our handshake happens concurrently, we prefer    // returning the handshake read error. If the remote side    // disconnects us early with a valid reason, we should return it    // as the error so it can be tracked elsewhere.    werr := make(chan error, 1)    go func() { werr &lt;- Send(t.rw, handshakeMsg, our) }()    if their, err = readProtocolHandshake(t.rw, our); err != nil {        &lt;-werr // make sure the write terminates too        return nil, err    }    if err := &lt;-werr; err != nil {        return nil, fmt.Errorf("write error: %v", err)    }    // If the protocol version supports Snappy encoding, upgrade immediately    t.rw.snappy = their.Version &gt;= snappyProtocolVersion    return their, nil}</code></pre><h3 id="rlpxFrameRW-æ•°æ®åˆ†å¸§"><a href="#rlpxFrameRW-æ•°æ®åˆ†å¸§" class="headerlink" title="rlpxFrameRW æ•°æ®åˆ†å¸§"></a>rlpxFrameRW æ•°æ®åˆ†å¸§</h3><p>æ•°æ®åˆ†å¸§ä¸»è¦é€šè¿‡rlpxFrameRWç±»æ¥å®Œæˆçš„ã€‚</p><pre><code>// rlpxFrameRW implements a simplified version of RLPx framing.// chunked messages are not supported and all headers are equal to// zeroHeader.//// rlpxFrameRW is not safe for concurrent use from multiple goroutines.type rlpxFrameRW struct {    conn io.ReadWriter    enc  cipher.Stream    dec  cipher.Stream    macCipher  cipher.Block    egressMAC  hash.Hash    ingressMAC hash.Hash    snappy bool}</code></pre><p>æˆ‘ä»¬åœ¨å®Œæˆä¸¤æ¬¡æ¡æ‰‹ä¹‹åã€‚è°ƒç”¨newRLPXFrameRWæ–¹æ³•åˆ›å»ºäº†è¿™ä¸ªå¯¹è±¡ã€‚</p><pre><code>t.rw = newRLPXFrameRW(t.fd, sec)</code></pre><p>ç„¶åæä¾›ReadMsgå’ŒWriteMsgæ–¹æ³•ã€‚è¿™ä¸¤ä¸ªæ–¹æ³•ç›´æ¥è°ƒç”¨äº†rlpxFrameRWçš„ReadMsgå’ŒWriteMsg</p><pre><code>func (t *rlpx) ReadMsg() (Msg, error) {    t.rmu.Lock()    defer t.rmu.Unlock()    t.fd.SetReadDeadline(time.Now().Add(frameReadTimeout))    return t.rw.ReadMsg()}func (t *rlpx) WriteMsg(msg Msg) error {    t.wmu.Lock()    defer t.wmu.Unlock()    t.fd.SetWriteDeadline(time.Now().Add(frameWriteTimeout))    return t.rw.WriteMsg(msg)}</code></pre><p>WriteMsg</p><pre><code>func (rw *rlpxFrameRW) WriteMsg(msg Msg) error {    ptype, _ := rlp.EncodeToBytes(msg.Code)    // if snappy is enabled, compress message now    if rw.snappy {        if msg.Size &gt; maxUint24 {            return errPlainMessageTooLarge        }        payload, _ := ioutil.ReadAll(msg.Payload)        payload = snappy.Encode(nil, payload)        msg.Payload = bytes.NewReader(payload)        msg.Size = uint32(len(payload))    }    // write header    headbuf := make([]byte, 32)    fsize := uint32(len(ptype)) + msg.Size    if fsize &gt; maxUint24 {        return errors.New("message size overflows uint24")    }    putInt24(fsize, headbuf) // TODO: check overflow    copy(headbuf[3:], zeroHeader)    rw.enc.XORKeyStream(headbuf[:16], headbuf[:16]) // first half is now encrypted    // write header MAC    copy(headbuf[16:], updateMAC(rw.egressMAC, rw.macCipher, headbuf[:16]))    if _, err := rw.conn.Write(headbuf); err != nil {        return err    }    // write encrypted frame, updating the egress MAC hash with    // the data written to conn.    tee := cipher.StreamWriter{S: rw.enc, W: io.MultiWriter(rw.conn, rw.egressMAC)}    if _, err := tee.Write(ptype); err != nil {        return err    }    if _, err := io.Copy(tee, msg.Payload); err != nil {        return err    }    if padding := fsize % 16; padding &gt; 0 {        if _, err := tee.Write(zero16[:16-padding]); err != nil {            return err        }    }    // write frame MAC. egress MAC hash is up to date because    // frame content was written to it as well.    fmacseed := rw.egressMAC.Sum(nil)    mac := updateMAC(rw.egressMAC, rw.macCipher, fmacseed)    _, err := rw.conn.Write(mac)    return err}</code></pre><p>ReadMsg</p><pre><code>func (rw *rlpxFrameRW) ReadMsg() (msg Msg, err error) {    // read the header    headbuf := make([]byte, 32)    if _, err := io.ReadFull(rw.conn, headbuf); err != nil {        return msg, err    }    // verify header mac    shouldMAC := updateMAC(rw.ingressMAC, rw.macCipher, headbuf[:16])    if !hmac.Equal(shouldMAC, headbuf[16:]) {        return msg, errors.New("bad header MAC")    }    rw.dec.XORKeyStream(headbuf[:16], headbuf[:16]) // first half is now decrypted    fsize := readInt24(headbuf)    // ignore protocol type for now    // read the frame content    var rsize = fsize // frame size rounded up to 16 byte boundary    if padding := fsize % 16; padding &gt; 0 {        rsize += 16 - padding    }    framebuf := make([]byte, rsize)    if _, err := io.ReadFull(rw.conn, framebuf); err != nil {        return msg, err    }    // read and validate frame MAC. we can re-use headbuf for that.    rw.ingressMAC.Write(framebuf)    fmacseed := rw.ingressMAC.Sum(nil)    if _, err := io.ReadFull(rw.conn, headbuf[:16]); err != nil {        return msg, err    }    shouldMAC = updateMAC(rw.ingressMAC, rw.macCipher, fmacseed)    if !hmac.Equal(shouldMAC, headbuf[:16]) {        return msg, errors.New("bad frame MAC")    }    // decrypt frame content    rw.dec.XORKeyStream(framebuf, framebuf)    // decode message code    content := bytes.NewReader(framebuf[:fsize])    if err := rlp.Decode(content, &amp;msg.Code); err != nil {        return msg, err    }    msg.Size = uint32(content.Len())    msg.Payload = content    // if snappy is enabled, verify and decompress message    if rw.snappy {        payload, err := ioutil.ReadAll(msg.Payload)        if err != nil {            return msg, err        }        size, err := snappy.DecodedLen(payload)        if err != nil {            return msg, err        }        if size &gt; int(maxUint24) {            return msg, errPlainMessageTooLarge        }        payload, err = snappy.Decode(nil, payload)        if err != nil {            return msg, err        }        msg.Size, msg.Payload = uint32(size), bytes.NewReader(payload)    }    return msg, nil}</code></pre><p>å¸§ç»“æ„</p><pre><code>  normal = not chunked  chunked-0 = First frame of a multi-frame packet  chunked-n = Subsequent frames for multi-frame packet  || is concatenate  ^ is xorSingle-frame packet:header || header-mac || frame || frame-macMulti-frame packet:header || header-mac || frame-0 ||[ header || header-mac || frame-n || ... || ]header || header-mac || frame-last || frame-macheader: frame-size || header-data || paddingframe-size: 3-byte integer size of frame, big endian encoded (excludes padding)header-data:    normal: rlp.list(protocol-type[, context-id])    chunked-0: rlp.list(protocol-type, context-id, total-packet-size)    chunked-n: rlp.list(protocol-type, context-id)    values:        protocol-type: &lt; 2**16        context-id: &lt; 2**16 (optional for normal frames)        total-packet-size: &lt; 2**32padding: zero-fill to 16-byte boundaryheader-mac: right128 of egress-mac.update(aes(mac-secret,egress-mac) ^ header-ciphertext).digestframe:    normal: rlp(packet-type) [|| rlp(packet-data)] || padding    chunked-0: rlp(packet-type) || rlp(packet-data...)    chunked-n: rlp(...packet-data) || paddingpadding: zero-fill to 16-byte boundary (only necessary for last frame)frame-mac: right128 of egress-mac.update(aes(mac-secret,egress-mac) ^ right128(egress-mac.update(frame-ciphertext).digest))egress-mac: h256, continuously updated with egress-bytes*ingress-mac: h256, continuously updated with ingress-bytes*</code></pre><p>å› ä¸ºåŠ å¯†è§£å¯†ç®—æ³•æˆ‘ä¹Ÿä¸æ˜¯å¾ˆç†Ÿï¼Œæ‰€ä»¥è¿™é‡Œçš„åˆ†æè¿˜ä¸æ˜¯å¾ˆå½»åº•ã€‚ æš‚æ—¶åªæ˜¯åˆ†æäº†å¤§è‡´çš„æµç¨‹ã€‚è¿˜æœ‰å¾ˆå¤šç»†èŠ‚æ²¡æœ‰ç¡®è®¤ã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-p2p-server.goæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-server.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-server.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>serveræ˜¯p2pçš„æœ€ä¸»è¦çš„éƒ¨åˆ†ã€‚é›†åˆäº†æ‰€æœ‰ä¹‹å‰çš„ç»„ä»¶ã€‚</p><p>é¦–å…ˆçœ‹çœ‹Serverçš„ç»“æ„</p><pre><code>// Server manages all peer connections.type Server struct {    // Config fields may not be modified while the server is running.    Config    // Hooks for testing. These are useful because we can inhibit    // the whole protocol stack.    newTransport func(net.Conn) transport    newPeerHook  func(*Peer)    lock    sync.Mutex // protects running    running bool    ntab         discoverTable    listener     net.Listener    ourHandshake *protoHandshake    lastLookup   time.Time    DiscV5       *discv5.Network    // These are for Peers, PeerCount (and nothing else).    peerOp     chan peerOpFunc    peerOpDone chan struct{}    quit          chan struct{}    addstatic     chan *discover.Node    removestatic  chan *discover.Node    posthandshake chan *conn    addpeer       chan *conn    delpeer       chan peerDrop    loopWG        sync.WaitGroup // loop, listenLoop    peerFeed      event.Feed}// conn wraps a network connection with information gathered// during the two handshakes.type conn struct {    fd net.Conn    transport    flags connFlag    cont  chan error      // The run loop uses cont to signal errors to SetupConn.    id    discover.NodeID // valid after the encryption handshake    caps  []Cap           // valid after the protocol handshake    name  string          // valid after the protocol handshake}type transport interface {    // The two handshakes.    doEncHandshake(prv *ecdsa.PrivateKey, dialDest *discover.Node) (discover.NodeID, error)    doProtoHandshake(our *protoHandshake) (*protoHandshake, error)    // The MsgReadWriter can only be used after the encryption    // handshake has completed. The code uses conn.id to track this    // by setting it to a non-nil value after the encryption handshake.    MsgReadWriter    // transports must provide Close because we use MsgPipe in some of    // the tests. Closing the actual network connection doesn't do    // anything in those tests because NsgPipe doesn't use it.    close(err error)}</code></pre><p>å¹¶ä¸å­˜åœ¨ä¸€ä¸ªnewServerçš„æ–¹æ³•ã€‚ åˆå§‹åŒ–çš„å·¥ä½œæ”¾åœ¨Start()æ–¹æ³•ä¸­ã€‚</p><pre><code>// Start starts running the server.// Servers can not be re-used after stopping.func (srv *Server) Start() (err error) {    srv.lock.Lock()    defer srv.lock.Unlock()    if srv.running { //é¿å…å¤šæ¬¡å¯åŠ¨ã€‚ srv.lockä¸ºäº†é¿å…å¤šçº¿ç¨‹é‡å¤å¯åŠ¨        return errors.New("server already running")    }    srv.running = true    log.Info("Starting P2P networking")    // static fields    if srv.PrivateKey == nil {        return fmt.Errorf("Server.PrivateKey must be set to a non-nil key")    }    if srv.newTransport == nil {        //è¿™é‡Œæ³¨æ„çš„æ˜¯Transportä½¿ç”¨äº†newRLPX ä½¿ç”¨äº†rlpx.goä¸­çš„ç½‘ç»œåè®®ã€‚        srv.newTransport = newRLPX    }    if srv.Dialer == nil { //ä½¿ç”¨äº†TCLPDialer        srv.Dialer = TCPDialer{&amp;net.Dialer{Timeout: defaultDialTimeout}}    }    srv.quit = make(chan struct{})    srv.addpeer = make(chan *conn)    srv.delpeer = make(chan peerDrop)    srv.posthandshake = make(chan *conn)    srv.addstatic = make(chan *discover.Node)    srv.removestatic = make(chan *discover.Node)    srv.peerOp = make(chan peerOpFunc)    srv.peerOpDone = make(chan struct{})    // node table    if !srv.NoDiscovery {  //å¯åŠ¨discoverç½‘ç»œã€‚ å¼€å¯UDPçš„ç›‘å¬ã€‚        ntab, err := discover.ListenUDP(srv.PrivateKey, srv.ListenAddr, srv.NAT, srv.NodeDatabase, srv.NetRestrict)        if err != nil {            return err        }        //è®¾ç½®æœ€å¼€å§‹çš„å¯åŠ¨èŠ‚ç‚¹ã€‚å½“æ‰¾ä¸åˆ°å…¶ä»–çš„èŠ‚ç‚¹çš„æ—¶å€™ã€‚ é‚£ä¹ˆå°±è¿æ¥è¿™äº›å¯åŠ¨èŠ‚ç‚¹ã€‚è¿™äº›èŠ‚ç‚¹çš„ä¿¡æ¯æ˜¯å†™æ­»åœ¨é…ç½®æ–‡ä»¶é‡Œé¢çš„ã€‚        if err := ntab.SetFallbackNodes(srv.BootstrapNodes); err != nil {            return err        }        srv.ntab = ntab    }    if srv.DiscoveryV5 {//è¿™æ˜¯æ–°çš„èŠ‚ç‚¹å‘ç°åè®®ã€‚ æš‚æ—¶è¿˜æ²¡æœ‰ä½¿ç”¨ã€‚  è¿™é‡Œæš‚æ—¶æ²¡æœ‰åˆ†æã€‚        ntab, err := discv5.ListenUDP(srv.PrivateKey, srv.DiscoveryV5Addr, srv.NAT, "", srv.NetRestrict) //srv.NodeDatabase)        if err != nil {            return err        }        if err := ntab.SetFallbackNodes(srv.BootstrapNodesV5); err != nil {            return err        }        srv.DiscV5 = ntab    }    dynPeers := (srv.MaxPeers + 1) / 2    if srv.NoDiscovery {        dynPeers = 0    }        //åˆ›å»ºdialerstateã€‚     dialer := newDialState(srv.StaticNodes, srv.BootstrapNodes, srv.ntab, dynPeers, srv.NetRestrict)    // handshake    //æˆ‘ä»¬è‡ªå·±çš„åè®®çš„handShake     srv.ourHandshake = &amp;protoHandshake{Version: baseProtocolVersion, Name: srv.Name, ID: discover.PubkeyID(&amp;srv.PrivateKey.PublicKey)}    for _, p := range srv.Protocols {//å¢åŠ æ‰€æœ‰çš„åè®®çš„Caps        srv.ourHandshake.Caps = append(srv.ourHandshake.Caps, p.cap())    }    // listen/dial    if srv.ListenAddr != "" {        //å¼€å§‹ç›‘å¬TCPç«¯å£        if err := srv.startListening(); err != nil {            return err        }    }    if srv.NoDial &amp;&amp; srv.ListenAddr == "" {        log.Warn("P2P server will be useless, neither dialing nor listening")    }    srv.loopWG.Add(1)    //å¯åŠ¨goroutine æ¥å¤„ç†ç¨‹åºã€‚    go srv.run(dialer)    srv.running = true    return nil}</code></pre><p>å¯åŠ¨ç›‘å¬ã€‚ å¯ä»¥çœ‹åˆ°æ˜¯TCPåè®®ã€‚ è¿™é‡Œçš„ç›‘å¬ç«¯å£å’ŒUDPçš„ç«¯å£æ˜¯ä¸€æ ·çš„ã€‚ é»˜è®¤éƒ½æ˜¯30303</p><pre><code>func (srv *Server) startListening() error {    // Launch the TCP listener.    listener, err := net.Listen("tcp", srv.ListenAddr)    if err != nil {        return err    }    laddr := listener.Addr().(*net.TCPAddr)    srv.ListenAddr = laddr.String()    srv.listener = listener    srv.loopWG.Add(1)    go srv.listenLoop()    // Map the TCP listening port if NAT is configured.    if !laddr.IP.IsLoopback() &amp;&amp; srv.NAT != nil {        srv.loopWG.Add(1)        go func() {            nat.Map(srv.NAT, srv.quit, "tcp", laddr.Port, laddr.Port, "ethereum p2p")            srv.loopWG.Done()        }()    }    return nil}</code></pre><p>listenLoop()ã€‚ è¿™æ˜¯ä¸€ä¸ªæ­»å¾ªç¯çš„goroutineã€‚ ä¼šç›‘å¬ç«¯å£å¹¶æ¥æ”¶å¤–éƒ¨çš„è¯·æ±‚ã€‚</p><pre><code>// listenLoop runs in its own goroutine and accepts// inbound connections.func (srv *Server) listenLoop() {    defer srv.loopWG.Done()    log.Info("RLPx listener up", "self", srv.makeSelf(srv.listener, srv.ntab))    // This channel acts as a semaphore limiting    // active inbound connections that are lingering pre-handshake.    // If all slots are taken, no further connections are accepted.    tokens := maxAcceptConns    if srv.MaxPendingPeers &gt; 0 {        tokens = srv.MaxPendingPeers    }    //åˆ›å»ºmaxAcceptConnsä¸ªæ§½ä½ã€‚ æˆ‘ä»¬åªåŒæ—¶å¤„ç†è¿™ä¹ˆå¤šè¿æ¥ã€‚ å¤šäº†ä¹Ÿä¸è¦ã€‚    slots := make(chan struct{}, tokens)    //æŠŠæ§½ä½å¡«æ»¡ã€‚    for i := 0; i &lt; tokens; i++ {        slots &lt;- struct{}{}    }    for {        // Wait for a handshake slot before accepting.        &lt;-slots        var (            fd  net.Conn            err error        )        for {            fd, err = srv.listener.Accept()            if tempErr, ok := err.(tempError); ok &amp;&amp; tempErr.Temporary() {                log.Debug("Temporary read error", "err", err)                continue            } else if err != nil {                log.Debug("Read error", "err", err)                return            }            break        }        // Reject connections that do not match NetRestrict.        // ç™½åå•ã€‚ å¦‚æœä¸åœ¨ç™½åå•é‡Œé¢ã€‚é‚£ä¹ˆå…³é—­è¿æ¥ã€‚        if srv.NetRestrict != nil {            if tcp, ok := fd.RemoteAddr().(*net.TCPAddr); ok &amp;&amp; !srv.NetRestrict.Contains(tcp.IP) {                log.Debug("Rejected conn (not whitelisted in NetRestrict)", "addr", fd.RemoteAddr())                fd.Close()                slots &lt;- struct{}{}                continue            }        }        fd = newMeteredConn(fd, true)        log.Trace("Accepted connection", "addr", fd.RemoteAddr())        // Spawn the handler. It will give the slot back when the connection        // has been established.        go func() {            //çœ‹æ¥åªè¦è¿æ¥å»ºç«‹å®Œæˆä¹‹åã€‚ æ§½ä½å°±ä¼šå½’è¿˜ã€‚ SetupConnè¿™ä¸ªå‡½æ•°æˆ‘ä»¬è®°å¾—å†dialTask.Doé‡Œé¢ä¹Ÿæœ‰è°ƒç”¨ï¼Œ è¿™ä¸ªå‡½æ•°ä¸»è¦æ˜¯æ‰§è¡Œè¿æ¥çš„å‡ æ¬¡æ¡æ‰‹ã€‚            srv.SetupConn(fd, inboundConn, nil)            slots &lt;- struct{}{}        }()    }}</code></pre><p>SetupConn,è¿™ä¸ªå‡½æ•°æ‰§è¡Œæ¡æ‰‹åè®®ï¼Œå¹¶å°è¯•æŠŠè¿æ¥åˆ›å»ºä½ä¸€ä¸ªpeerå¯¹è±¡ã€‚</p><pre><code>// SetupConn runs the handshakes and attempts to add the connection// as a peer. It returns when the connection has been added as a peer// or the handshakes have failed.func (srv *Server) SetupConn(fd net.Conn, flags connFlag, dialDest *discover.Node) {    // Prevent leftover pending conns from entering the handshake.    srv.lock.Lock()    running := srv.running    srv.lock.Unlock()    //åˆ›å»ºäº†ä¸€ä¸ªconnå¯¹è±¡ã€‚ newTransportæŒ‡é’ˆå®é™…ä¸ŠæŒ‡å‘çš„newRLPxæ–¹æ³•ã€‚ å®é™…ä¸Šæ˜¯æŠŠfdç”¨rlpxåè®®åŒ…è£…äº†ä¸€ä¸‹ã€‚    c := &amp;conn{fd: fd, transport: srv.newTransport(fd), flags: flags, cont: make(chan error)}    if !running {        c.close(errServerStopped)        return    }    // Run the encryption handshake.    var err error    //è¿™é‡Œå®é™…ä¸Šæ‰§è¡Œçš„æ˜¯rlpx.goé‡Œé¢çš„doEncHandshake.å› ä¸ºtransportæ˜¯connçš„ä¸€ä¸ªåŒ¿åå­—æ®µã€‚ åŒ¿åå­—æ®µçš„æ–¹æ³•ä¼šç›´æ¥ä½œä¸ºconnçš„ä¸€ä¸ªæ–¹æ³•ã€‚    if c.id, err = c.doEncHandshake(srv.PrivateKey, dialDest); err != nil {        log.Trace("Failed RLPx handshake", "addr", c.fd.RemoteAddr(), "conn", c.flags, "err", err)        c.close(err)        return    }    clog := log.New("id", c.id, "addr", c.fd.RemoteAddr(), "conn", c.flags)    // For dialed connections, check that the remote public key matches.    // å¦‚æœè¿æ¥æ¡æ‰‹çš„IDå’Œå¯¹åº”çš„IDä¸åŒ¹é…    if dialDest != nil &amp;&amp; c.id != dialDest.ID {        c.close(DiscUnexpectedIdentity)        clog.Trace("Dialed identity mismatch", "want", c, dialDest.ID)        return    }    // è¿™ä¸ªcheckpointå…¶å®å°±æ˜¯æŠŠç¬¬ä¸€ä¸ªå‚æ•°å‘é€ç»™ç¬¬äºŒä¸ªå‚æ•°æŒ‡å®šçš„é˜Ÿåˆ—ã€‚ç„¶åä»c.coutæ¥æ”¶è¿”å›ä¿¡æ¯ã€‚ æ˜¯ä¸€ä¸ªåŒæ­¥çš„æ–¹æ³•ã€‚    //è‡³äºè¿™é‡Œï¼Œåç»­çš„æ“ä½œåªæ˜¯æ£€æŸ¥äº†ä¸€ä¸‹è¿æ¥æ˜¯å¦åˆæ³•å°±è¿”å›äº†ã€‚    if err := srv.checkpoint(c, srv.posthandshake); err != nil {        clog.Trace("Rejected peer before protocol handshake", "err", err)        c.close(err)        return    }    // Run the protocol handshake    phs, err := c.doProtoHandshake(srv.ourHandshake)    if err != nil {        clog.Trace("Failed proto handshake", "err", err)        c.close(err)        return    }    if phs.ID != c.id {        clog.Trace("Wrong devp2p handshake identity", "err", phs.ID)        c.close(DiscUnexpectedIdentity)        return    }    c.caps, c.name = phs.Caps, phs.Name    // è¿™é‡Œä¸¤æ¬¡æ¡æ‰‹éƒ½å·²ç»å®Œæˆäº†ã€‚ æŠŠcå‘é€ç»™addpeeré˜Ÿåˆ—ã€‚ åå°å¤„ç†è¿™ä¸ªé˜Ÿåˆ—çš„æ—¶å€™ï¼Œä¼šå¤„ç†è¿™ä¸ªè¿æ¥    if err := srv.checkpoint(c, srv.addpeer); err != nil {        clog.Trace("Rejected peer", "err", err)        c.close(err)        return    }    // If the checks completed successfully, runPeer has now been    // launched by run.}</code></pre><p>ä¸Šé¢è¯´åˆ°çš„æµç¨‹æ˜¯listenLoopçš„æµç¨‹ï¼ŒlistenLoopä¸»è¦æ˜¯ç”¨æ¥æ¥æ”¶å¤–éƒ¨ä¸»åŠ¨è¿æ¥è€…çš„ã€‚ è¿˜æœ‰éƒ¨åˆ†æƒ…å†µæ˜¯èŠ‚ç‚¹éœ€è¦ä¸»åŠ¨å‘èµ·è¿æ¥æ¥è¿æ¥å¤–éƒ¨èŠ‚ç‚¹çš„æµç¨‹ã€‚  ä»¥åŠå¤„ç†åˆšæ‰ä¸Šé¢çš„checkpointé˜Ÿåˆ—ä¿¡æ¯çš„æµç¨‹ã€‚è¿™éƒ¨åˆ†ä»£ç éƒ½åœ¨server.runè¿™ä¸ªgoroutineé‡Œé¢ã€‚</p><pre><code>func (srv *Server) run(dialstate dialer) {    defer srv.loopWG.Done()    var (        peers        = make(map[discover.NodeID]*Peer)        trusted      = make(map[discover.NodeID]bool, len(srv.TrustedNodes))        taskdone     = make(chan task, maxActiveDialTasks)        runningTasks []task        queuedTasks  []task // tasks that can't run yet    )    // Put trusted nodes into a map to speed up checks.    // Trusted peers are loaded on startup and cannot be    // modified while the server is running.    // è¢«ä¿¡ä»»çš„èŠ‚ç‚¹åˆè¿™æ ·ä¸€ä¸ªç‰¹æ€§ï¼Œ å¦‚æœè¿æ¥å¤ªå¤šï¼Œé‚£ä¹ˆå…¶ä»–èŠ‚ç‚¹ä¼šè¢«æ‹’ç»æ‰ã€‚ä½†æ˜¯è¢«ä¿¡ä»»çš„èŠ‚ç‚¹ä¼šè¢«æ¥æ”¶ã€‚    for _, n := range srv.TrustedNodes {        trusted[n.ID] = true    }    // removes t from runningTasks    // å®šä¹‰äº†ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥ä»runningTasksé˜Ÿåˆ—åˆ é™¤æŸä¸ªTask    delTask := func(t task) {        for i := range runningTasks {            if runningTasks[i] == t {                runningTasks = append(runningTasks[:i], runningTasks[i+1:]...)                break            }        }    }    // starts until max number of active tasks is satisfied    // åŒæ—¶å¼€å§‹è¿æ¥çš„èŠ‚ç‚¹æ•°é‡æ˜¯16ä¸ªã€‚ éå† runningTasksé˜Ÿåˆ—ï¼Œå¹¶å¯åŠ¨è¿™äº›ä»»åŠ¡ã€‚    startTasks := func(ts []task) (rest []task) {        i := 0        for ; len(runningTasks) &lt; maxActiveDialTasks &amp;&amp; i &lt; len(ts); i++ {            t := ts[i]            log.Trace("New dial task", "task", t)            go func() { t.Do(srv); taskdone &lt;- t }()            runningTasks = append(runningTasks, t)        }        return ts[i:]    }    scheduleTasks := func() {        // Start from queue first.        // é¦–å…ˆè°ƒç”¨startTaskså¯åŠ¨ä¸€éƒ¨åˆ†ï¼ŒæŠŠå‰©ä¸‹çš„è¿”å›ç»™queuedTasks.        queuedTasks = append(queuedTasks[:0], startTasks(queuedTasks)...)        // Query dialer for new tasks and start as many as possible now.        // è°ƒç”¨newTasksæ¥ç”Ÿæˆä»»åŠ¡ï¼Œå¹¶å°è¯•ç”¨startTaskså¯åŠ¨ã€‚å¹¶æŠŠæš‚æ—¶æ— æ³•å¯åŠ¨çš„æ”¾å…¥queuedTasksé˜Ÿåˆ—        if len(runningTasks) &lt; maxActiveDialTasks {            nt := dialstate.newTasks(len(runningTasks)+len(queuedTasks), peers, time.Now())            queuedTasks = append(queuedTasks, startTasks(nt)...)        }    }running:    for {        //è°ƒç”¨ dialstate.newTasksæ¥ç”Ÿæˆæ–°ä»»åŠ¡ã€‚ å¹¶è°ƒç”¨startTaskså¯åŠ¨æ–°ä»»åŠ¡ã€‚        //å¦‚æœ dialTaskå·²ç»å…¨éƒ¨å¯åŠ¨ï¼Œé‚£ä¹ˆä¼šç”Ÿæˆä¸€ä¸ªç¡çœ è¶…æ—¶ä»»åŠ¡ã€‚        scheduleTasks()        select {        case &lt;-srv.quit:            // The server was stopped. Run the cleanup logic.            break running        case n := &lt;-srv.addstatic:            // This channel is used by AddPeer to add to the            // ephemeral static peer list. Add it to the dialer,            // it will keep the node connected.            log.Debug("Adding static node", "node", n)            dialstate.addStatic(n)        case n := &lt;-srv.removestatic:            // This channel is used by RemovePeer to send a            // disconnect request to a peer and begin the            // stop keeping the node connected            log.Debug("Removing static node", "node", n)            dialstate.removeStatic(n)            if p, ok := peers[n.ID]; ok {                p.Disconnect(DiscRequested)            }        case op := &lt;-srv.peerOp:            // This channel is used by Peers and PeerCount.            op(peers)            srv.peerOpDone &lt;- struct{}{}        case t := &lt;-taskdone:            // A task got done. Tell dialstate about it so it            // can update its state and remove it from the active            // tasks list.            log.Trace("Dial task done", "task", t)            dialstate.taskDone(t, time.Now())            delTask(t)        case c := &lt;-srv.posthandshake:            // A connection has passed the encryption handshake so            // the remote identity is known (but hasn't been verified yet).            // è®°å¾—ä¹‹å‰è°ƒç”¨checkpointæ–¹æ³•ï¼Œä¼šæŠŠè¿æ¥å‘é€ç»™è¿™ä¸ªchannelã€‚            if trusted[c.id] {                // Ensure that the trusted flag is set before checking against MaxPeers.                c.flags |= trustedConn            }            // TODO: track in-progress inbound node IDs (pre-Peer) to avoid dialing them.            select {            case c.cont &lt;- srv.encHandshakeChecks(peers, c):            case &lt;-srv.quit:                break running            }        case c := &lt;-srv.addpeer:            // At this point the connection is past the protocol handshake.            // Its capabilities are known and the remote identity is verified.            // ä¸¤æ¬¡æ¡æ‰‹ä¹‹åä¼šè°ƒç”¨checkpointæŠŠè¿æ¥å‘é€åˆ°addpeerè¿™ä¸ªchannelã€‚            // ç„¶åé€šè¿‡newPeeråˆ›å»ºäº†Peerå¯¹è±¡ã€‚             // å¯åŠ¨ä¸€ä¸ªgoroutine å¯åŠ¨peerå¯¹è±¡ã€‚ è°ƒç”¨äº†peer.runæ–¹æ³•ã€‚            err := srv.protoHandshakeChecks(peers, c)            if err == nil {                // The handshakes are done and it passed all checks.                p := newPeer(c, srv.Protocols)                // If message events are enabled, pass the peerFeed                // to the peer                if srv.EnableMsgEvents {                    p.events = &amp;srv.peerFeed                }                name := truncateName(c.name)                log.Debug("Adding p2p peer", "id", c.id, "name", name, "addr", c.fd.RemoteAddr(), "peers", len(peers)+1)                peers[c.id] = p                go srv.runPeer(p)            }            // The dialer logic relies on the assumption that            // dial tasks complete after the peer has been added or            // discarded. Unblock the task last.            select {            case c.cont &lt;- err:            case &lt;-srv.quit:                break running            }        case pd := &lt;-srv.delpeer:            // A peer disconnected.            d := common.PrettyDuration(mclock.Now() - pd.created)            pd.log.Debug("Removing p2p peer", "duration", d, "peers", len(peers)-1, "req", pd.requested, "err", pd.err)            delete(peers, pd.ID())        }    }    log.Trace("P2P networking is spinning down")    // Terminate discovery. If there is a running lookup it will terminate soon.    if srv.ntab != nil {        srv.ntab.Close()    }    if srv.DiscV5 != nil {        srv.DiscV5.Close()    }    // Disconnect all peers.    for _, p := range peers {        p.Disconnect(DiscQuitting)    }    // Wait for peers to shut down. Pending connections and tasks are    // not handled here and will terminate soon-ish because srv.quit    // is closed.    for len(peers) &gt; 0 {        p := &lt;-srv.delpeer        p.log.Trace("&lt;-delpeer (spindown)", "remainingTasks", len(runningTasks))        delete(peers, p.ID())    }}</code></pre><p>runPeeræ–¹æ³•</p><pre><code>// runPeer runs in its own goroutine for each peer.// it waits until the Peer logic returns and removes// the peer.func (srv *Server) runPeer(p *Peer) {    if srv.newPeerHook != nil {        srv.newPeerHook(p)    }    // broadcast peer add    srv.peerFeed.Send(&amp;PeerEvent{        Type: PeerEventTypeAdd,        Peer: p.ID(),    })    // run the protocol    remoteRequested, err := p.run()    // broadcast peer drop    srv.peerFeed.Send(&amp;PeerEvent{        Type:  PeerEventTypeDrop,        Peer:  p.ID(),        Error: err.Error(),    })    // Note: run waits for existing peers to be sent on srv.delpeer    // before returning, so this send should not select on srv.quit.    srv.delpeer &lt;- peerDrop{p, err, remoteRequested}}</code></pre><p>æ€»ç»“ï¼š</p><p>serverå¯¹è±¡ä¸»è¦å®Œæˆçš„å·¥ä½œæŠŠä¹‹å‰ä»‹ç»çš„æ‰€æœ‰ç»„ä»¶ç»„åˆåœ¨ä¸€èµ·ã€‚ ä½¿ç”¨rlpx.goæ¥å¤„ç†åŠ å¯†é“¾è·¯ã€‚ ä½¿ç”¨discoveræ¥å¤„ç†èŠ‚ç‚¹å‘ç°å’ŒæŸ¥æ‰¾ã€‚  ä½¿ç”¨dialæ¥ç”Ÿæˆå’Œè¿æ¥éœ€è¦è¿æ¥çš„èŠ‚ç‚¹ã€‚ ä½¿ç”¨peerå¯¹è±¡æ¥å¤„ç†æ¯ä¸ªè¿æ¥ã€‚</p><p>serverå¯åŠ¨äº†ä¸€ä¸ªlistenLoopæ¥ç›‘å¬å’Œæ¥æ”¶æ–°çš„è¿æ¥ã€‚ å¯åŠ¨ä¸€ä¸ªrunçš„goroutineæ¥è°ƒç”¨dialstateç”Ÿæˆæ–°çš„dialä»»åŠ¡å¹¶è¿›è¡Œè¿æ¥ã€‚ goroutineä¹‹é—´ä½¿ç”¨channelæ¥è¿›è¡Œé€šè®¯å’Œé…åˆã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-p2p-table.goæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-table.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-table.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>table.goä¸»è¦å®ç°äº†p2pçš„Kademliaåè®®ã€‚</p><h3 id="Kademliaåè®®ç®€ä»‹-å»ºè®®é˜…è¯»referencesé‡Œé¢çš„pdfæ–‡æ¡£"><a href="#Kademliaåè®®ç®€ä»‹-å»ºè®®é˜…è¯»referencesé‡Œé¢çš„pdfæ–‡æ¡£" class="headerlink" title="Kademliaåè®®ç®€ä»‹(å»ºè®®é˜…è¯»referencesé‡Œé¢çš„pdfæ–‡æ¡£)"></a>Kademliaåè®®ç®€ä»‹(å»ºè®®é˜…è¯»referencesé‡Œé¢çš„pdfæ–‡æ¡£)</h3><p>Kademliaåè®®ï¼ˆä»¥ä¸‹ç®€ç§°Kadï¼‰ æ˜¯ç¾å›½çº½çº¦å¤§å­¦çš„PetarP. Maymounkovå’ŒDavid Mazieres.<br>åœ¨2002å¹´å‘å¸ƒçš„ä¸€é¡¹ç ”ç©¶ç»“æœã€ŠKademlia: A peerto -peer information system based on<br>the XOR metricã€‹ã€‚<br>ç®€å•çš„è¯´ï¼Œ Kad æ˜¯ä¸€ç§åˆ†å¸ƒå¼å“ˆå¸Œè¡¨ï¼ˆ DHTï¼‰ æŠ€æœ¯ï¼Œ ä¸è¿‡å’Œå…¶ä»– DHT å®ç°æŠ€æœ¯æ¯”è¾ƒï¼Œå¦‚<br>Chordã€ CANã€ Pastry ç­‰ï¼Œ Kad é€šè¿‡ç‹¬ç‰¹çš„ä»¥å¼‚æˆ–ç®—æ³•ï¼ˆ XORï¼‰ä¸ºè·ç¦»åº¦é‡åŸºç¡€ï¼Œå»ºç«‹äº†ä¸€ç§<br>å…¨æ–°çš„ DHT æ‹“æ‰‘ç»“æ„ï¼Œç›¸æ¯”äºå…¶ä»–ç®—æ³•ï¼Œå¤§å¤§æé«˜äº†è·¯ç”±æŸ¥è¯¢é€Ÿåº¦ã€‚</p><h3 id="tableçš„ç»“æ„å’Œå­—æ®µ"><a href="#tableçš„ç»“æ„å’Œå­—æ®µ" class="headerlink" title="tableçš„ç»“æ„å’Œå­—æ®µ"></a>tableçš„ç»“æ„å’Œå­—æ®µ</h3><pre><code>const (    alpha      = 3  // Kademlia concurrency factor    bucketSize = 16 // Kademlia bucket size    hashBits   = len(common.Hash{}) * 8    nBuckets   = hashBits + 1 // Number of buckets    maxBondingPingPongs = 16    maxFindnodeFailures = 5    autoRefreshInterval = 1 * time.Hour    seedCount           = 30    seedMaxAge          = 5 * 24 * time.Hour)type Table struct {    mutex   sync.Mutex        // protects buckets, their content, and nursery    buckets [nBuckets]*bucket // index of known nodes by distance    nursery []*Node           // bootstrap nodes    db      *nodeDB           // database of known nodes    refreshReq chan chan struct{}    closeReq   chan struct{}    closed     chan struct{}    bondmu    sync.Mutex    bonding   map[NodeID]*bondproc    bondslots chan struct{} // limits total number of active bonding processes    nodeAddedHook func(*Node) // for testing    net  transport    self *Node // metadata of the local node}</code></pre><h3 id="åˆå§‹åŒ–"><a href="#åˆå§‹åŒ–" class="headerlink" title="åˆå§‹åŒ–"></a>åˆå§‹åŒ–</h3><pre><code>func newTable(t transport, ourID NodeID, ourAddr *net.UDPAddr, nodeDBPath string) (*Table, error) {    // If no node database was given, use an in-memory one    //è¿™ä¸ªåœ¨ä¹‹å‰çš„database.goé‡Œé¢æœ‰ä»‹ç»ã€‚ æ‰“å¼€leveldbã€‚å¦‚æœpathä¸ºç©ºã€‚é‚£ä¹ˆæ‰“å¼€ä¸€ä¸ªåŸºäºå†…å­˜çš„db    db, err := newNodeDB(nodeDBPath, Version, ourID)    if err != nil {        return nil, err    }    tab := &amp;Table{        net:        t,        db:         db,        self:       NewNode(ourID, ourAddr.IP, uint16(ourAddr.Port), uint16(ourAddr.Port)),        bonding:    make(map[NodeID]*bondproc),        bondslots:  make(chan struct{}, maxBondingPingPongs),        refreshReq: make(chan chan struct{}),        closeReq:   make(chan struct{}),        closed:     make(chan struct{}),    }    for i := 0; i &lt; cap(tab.bondslots); i++ {        tab.bondslots &lt;- struct{}{}    }    for i := range tab.buckets {        tab.buckets[i] = new(bucket)    }    go tab.refreshLoop()    return tab, nil}</code></pre><p>ä¸Šé¢çš„åˆå§‹åŒ–å¯åŠ¨äº†ä¸€ä¸ªgoroutine refreshLoop()ï¼Œè¿™ä¸ªå‡½æ•°ä¸»è¦å®Œæˆä»¥ä¸‹çš„å·¥ä½œã€‚</p><ol><li>æ¯ä¸€ä¸ªå°æ—¶è¿›è¡Œä¸€æ¬¡åˆ·æ–°å·¥ä½œ(autoRefreshInterval)</li><li>å¦‚æœæ¥æ”¶åˆ°refreshReqè¯·æ±‚ã€‚é‚£ä¹ˆè¿›è¡Œåˆ·æ–°å·¥ä½œã€‚</li><li>å¦‚æœæ¥æ”¶åˆ°å…³é—­æ¶ˆæ¯ã€‚é‚£ä¹ˆè¿›è¡Œå…³é—­ã€‚</li></ol><p>æ‰€ä»¥å‡½æ•°ä¸»è¦çš„å·¥ä½œå°±æ˜¯å¯åŠ¨åˆ·æ–°å·¥ä½œã€‚doRefresh</p><pre><code>// refreshLoop schedules doRefresh runs and coordinates shutdown.func (tab *Table) refreshLoop() {    var (        timer   = time.NewTicker(autoRefreshInterval)        waiting []chan struct{} // accumulates waiting callers while doRefresh runs        done    chan struct{}   // where doRefresh reports completion    )loop:    for {        select {        case &lt;-timer.C:            if done == nil {                done = make(chan struct{})                go tab.doRefresh(done)            }        case req := &lt;-tab.refreshReq:            waiting = append(waiting, req)            if done == nil {                done = make(chan struct{})                go tab.doRefresh(done)            }        case &lt;-done:            for _, ch := range waiting {                close(ch)            }            waiting = nil            done = nil        case &lt;-tab.closeReq:            break loop        }    }    if tab.net != nil {        tab.net.close()    }    if done != nil {        &lt;-done    }    for _, ch := range waiting {        close(ch)    }    tab.db.close()    close(tab.closed)}</code></pre><p>doRefreshå‡½æ•°</p><pre><code>// doRefresh performs a lookup for a random target to keep buckets// full. seed nodes are inserted if the table is empty (initial// bootstrap or discarded faulty peers).// doRefresh éšæœºæŸ¥æ‰¾ä¸€ä¸ªç›®æ ‡ï¼Œä»¥ä¾¿ä¿æŒbucketsæ˜¯æ»¡çš„ã€‚å¦‚æœtableæ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆç§å­èŠ‚ç‚¹ä¼šæ’å…¥ã€‚ ï¼ˆæ¯”å¦‚æœ€å¼€å§‹çš„å¯åŠ¨æˆ–è€…æ˜¯åˆ é™¤é”™è¯¯çš„èŠ‚ç‚¹ä¹‹åï¼‰func (tab *Table) doRefresh(done chan struct{}) {    defer close(done)    // The Kademlia paper specifies that the bucket refresh should    // perform a lookup in the least recently used bucket. We cannot    // adhere to this because the findnode target is a 512bit value    // (not hash-sized) and it is not easily possible to generate a    // sha3 preimage that falls into a chosen bucket.    // We perform a lookup with a random target instead.    //è¿™é‡Œæš‚æ—¶æ²¡çœ‹æ‡‚    var target NodeID    rand.Read(target[:])    result := tab.lookup(target, false) //lookupæ˜¯æŸ¥æ‰¾è·ç¦»targetæœ€è¿‘çš„kä¸ªèŠ‚ç‚¹    if len(result) &gt; 0 {  //å¦‚æœç»“æœä¸ä¸º0 è¯´æ˜è¡¨ä¸æ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›ã€‚        return    }    // The table is empty. Load nodes from the database and insert    // them. This should yield a few previously seen nodes that are    // (hopefully) still alive.    //querySeedså‡½æ•°åœ¨database.goç« èŠ‚æœ‰ä»‹ç»ï¼Œä»æ•°æ®åº“é‡Œé¢éšæœºçš„æŸ¥æ‰¾å¯ç”¨çš„ç§å­èŠ‚ç‚¹ã€‚    //åœ¨æœ€å¼€å§‹å¯åŠ¨çš„æ—¶å€™æ•°æ®åº“æ˜¯ç©ºç™½çš„ã€‚ä¹Ÿå°±æ˜¯æœ€å¼€å§‹çš„æ—¶å€™è¿™ä¸ªseedsè¿”å›çš„æ˜¯ç©ºçš„ã€‚    seeds := tab.db.querySeeds(seedCount, seedMaxAge)    //è°ƒç”¨bondallå‡½æ•°ã€‚ä¼šå°è¯•è”ç³»è¿™äº›èŠ‚ç‚¹ï¼Œå¹¶æ’å…¥åˆ°è¡¨ä¸­ã€‚    //tab.nurseryæ˜¯åœ¨å‘½ä»¤è¡Œä¸­æŒ‡å®šçš„ç§å­èŠ‚ç‚¹ã€‚    //æœ€å¼€å§‹å¯åŠ¨çš„æ—¶å€™ã€‚ tab.nurseryçš„å€¼æ˜¯å†…ç½®åœ¨ä»£ç é‡Œé¢çš„ã€‚ è¿™é‡Œæ˜¯æœ‰å€¼çš„ã€‚    //C:\GOPATH\src\github.com\ethereum\go-ethereum\mobile\params.go    //è¿™é‡Œé¢å†™æ­»äº†å€¼ã€‚ è¿™ä¸ªå€¼æ˜¯é€šè¿‡SetFallbackNodesæ–¹æ³•å†™å…¥çš„ã€‚ è¿™ä¸ªæ–¹æ³•åç»­ä¼šåˆ†æã€‚    //è¿™é‡Œä¼šè¿›è¡ŒåŒå‘çš„pingpongäº¤æµã€‚ ç„¶åæŠŠç»“æœå­˜å‚¨åœ¨æ•°æ®åº“ã€‚    seeds = tab.bondall(append(seeds, tab.nursery...))    if len(seeds) == 0 { //æ²¡æœ‰ç§å­èŠ‚ç‚¹è¢«å‘ç°ï¼Œ å¯èƒ½éœ€è¦ç­‰å¾…ä¸‹ä¸€æ¬¡åˆ·æ–°ã€‚        log.Debug("No discv4 seed nodes found")    }    for _, n := range seeds {        age := log.Lazy{Fn: func() time.Duration { return time.Since(tab.db.lastPong(n.ID)) }}        log.Trace("Found seed node in database", "id", n.ID, "addr", n.addr(), "age", age)    }    tab.mutex.Lock()    //è¿™ä¸ªæ–¹æ³•æŠŠæ‰€æœ‰ç»è¿‡bondçš„seedåŠ å…¥åˆ°bucket(å‰ææ˜¯bucketæœªæ»¡)    tab.stuff(seeds)     tab.mutex.Unlock()    // Finally, do a self lookup to fill up the buckets.    tab.lookup(tab.self.ID, false) // æœ‰äº†ç§å­èŠ‚ç‚¹ã€‚é‚£ä¹ˆæŸ¥æ‰¾è‡ªå·±æ¥å¡«å……bucketsã€‚}</code></pre><p>bondallæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å°±æ˜¯å¤šçº¿ç¨‹çš„è°ƒç”¨bondæ–¹æ³•ã€‚ </p><pre><code>// bondall bonds with all given nodes concurrently and returns// those nodes for which bonding has probably succeeded.func (tab *Table) bondall(nodes []*Node) (result []*Node) {    rc := make(chan *Node, len(nodes))    for i := range nodes {        go func(n *Node) {            nn, _ := tab.bond(false, n.ID, n.addr(), uint16(n.TCP))            rc &lt;- nn        }(nodes[i])    }    for range nodes {        if n := &lt;-rc; n != nil {            result = append(result, n)        }    }    return result}</code></pre><p>bondæ–¹æ³•ã€‚è®°å¾—åœ¨udp.goä¸­ã€‚å½“æˆ‘ä»¬æ”¶åˆ°ä¸€ä¸ªpingæ–¹æ³•çš„æ—¶å€™ï¼Œä¹Ÿæœ‰å¯èƒ½ä¼šè°ƒç”¨è¿™ä¸ªæ–¹æ³•</p><pre><code>// bond ensures the local node has a bond with the given remote node.// It also attempts to insert the node into the table if bonding succeeds.// The caller must not hold tab.mutex.// bondç¡®ä¿æœ¬åœ°èŠ‚ç‚¹ä¸ç»™å®šçš„è¿œç¨‹èŠ‚ç‚¹å…·æœ‰ç»‘å®šã€‚(è¿œç«¯çš„IDå’Œè¿œç«¯çš„IP)ã€‚// å¦‚æœç»‘å®šæˆåŠŸï¼Œå®ƒä¹Ÿä¼šå°è¯•å°†èŠ‚ç‚¹æ’å…¥è¡¨ä¸­ã€‚è°ƒç”¨è€…å¿…é¡»æŒæœ‰tab.mutexé”// A bond is must be established before sending findnode requests.// Both sides must have completed a ping/pong exchange for a bond to// exist. The total number of active bonding processes is limited in// order to restrain network use.// å‘é€findnodeè¯·æ±‚ä¹‹å‰å¿…é¡»å»ºç«‹ä¸€ä¸ªç»‘å®šã€‚    åŒæ–¹ä¸ºäº†å®Œæˆä¸€ä¸ªbondå¿…é¡»å®ŒæˆåŒå‘çš„ping/pongè¿‡ç¨‹ã€‚// ä¸ºäº†èŠ‚çº¦ç½‘è·¯èµ„æºã€‚ åŒæ—¶å­˜åœ¨çš„bondingå¤„ç†æµç¨‹çš„æ€»æ•°é‡æ˜¯å—é™çš„ã€‚    // bond is meant to operate idempotently in that bonding with a remote// node which still remembers a previously established bond will work.// The remote node will simply not send a ping back, causing waitping// to time out.// bond æ˜¯å¹‚ç­‰çš„æ“ä½œï¼Œè·Ÿä¸€ä¸ªä»»ç„¶è®°å¾—ä¹‹å‰çš„bondçš„è¿œç¨‹èŠ‚ç‚¹è¿›è¡Œbondä¹Ÿå¯ä»¥å®Œæˆã€‚ è¿œç¨‹èŠ‚ç‚¹ä¼šç®€å•çš„ä¸ä¼šå‘é€pingã€‚ ç­‰å¾…waitpingè¶…æ—¶ã€‚// If pinged is true, the remote node has just pinged us and one half// of the process can be skipped.//    å¦‚æœpingedæ˜¯trueã€‚ é‚£ä¹ˆè¿œç«¯èŠ‚ç‚¹å·²ç»ç»™æˆ‘ä»¬å‘é€äº†pingæ¶ˆæ¯ã€‚è¿™æ ·ä¸€åŠçš„æµç¨‹å¯ä»¥è·³è¿‡ã€‚func (tab *Table) bond(pinged bool, id NodeID, addr *net.UDPAddr, tcpPort uint16) (*Node, error) {    if id == tab.self.ID {        return nil, errors.New("is self")    }    // Retrieve a previously known node and any recent findnode failures    node, fails := tab.db.node(id), 0    if node != nil {        fails = tab.db.findFails(id)    }    // If the node is unknown (non-bonded) or failed (remotely unknown), bond from scratch    var result error    age := time.Since(tab.db.lastPong(id))    if node == nil || fails &gt; 0 || age &gt; nodeDBNodeExpiration {        //å¦‚æœæ•°æ®åº“æ²¡æœ‰è¿™ä¸ªèŠ‚ç‚¹ã€‚ æˆ–è€…é”™è¯¯æ•°é‡å¤§äº0æˆ–è€…èŠ‚ç‚¹è¶…æ—¶ã€‚        log.Trace("Starting bonding ping/pong", "id", id, "known", node != nil, "failcount", fails, "age", age)        tab.bondmu.Lock()        w := tab.bonding[id]        if w != nil {            // Wait for an existing bonding process to complete.            tab.bondmu.Unlock()            &lt;-w.done        } else {            // Register a new bonding process.            w = &amp;bondproc{done: make(chan struct{})}            tab.bonding[id] = w            tab.bondmu.Unlock()            // Do the ping/pong. The result goes into w.            tab.pingpong(w, pinged, id, addr, tcpPort)            // Unregister the process after it's done.            tab.bondmu.Lock()            delete(tab.bonding, id)            tab.bondmu.Unlock()        }        // Retrieve the bonding results        result = w.err        if result == nil {            node = w.n        }    }    if node != nil {        // Add the node to the table even if the bonding ping/pong        // fails. It will be relaced quickly if it continues to be        // unresponsive.        //è¿™ä¸ªæ–¹æ³•æ¯”è¾ƒé‡è¦ã€‚ å¦‚æœå¯¹åº”çš„bucketæœ‰ç©ºé—´ï¼Œä¼šç›´æ¥æ’å…¥bucketsã€‚å¦‚æœbucketsæ»¡äº†ã€‚ ä¼šç”¨pingæ“ä½œæ¥æµ‹è¯•bucketsä¸­çš„èŠ‚ç‚¹è¯•å›¾è…¾å‡ºç©ºé—´ã€‚        tab.add(node)        tab.db.updateFindFails(id, 0)    }    return node, result}</code></pre><p>pingpongæ–¹æ³•</p><pre><code>func (tab *Table) pingpong(w *bondproc, pinged bool, id NodeID, addr *net.UDPAddr, tcpPort uint16) {    // Request a bonding slot to limit network usage    &lt;-tab.bondslots    defer func() { tab.bondslots &lt;- struct{}{} }()    // Ping the remote side and wait for a pong.    // Pingè¿œç¨‹èŠ‚ç‚¹ã€‚å¹¶ç­‰å¾…ä¸€ä¸ªpongæ¶ˆæ¯    if w.err = tab.ping(id, addr); w.err != nil {        close(w.done)        return    }    //è¿™ä¸ªåœ¨udpæ”¶åˆ°ä¸€ä¸ªpingæ¶ˆæ¯çš„æ—¶å€™è¢«è®¾ç½®ä¸ºçœŸã€‚è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å·²ç»æ”¶åˆ°å¯¹æ–¹çš„pingæ¶ˆæ¯äº†ã€‚    //é‚£ä¹ˆæˆ‘ä»¬å°±ä¸åŒç­‰å¾…pingæ¶ˆæ¯äº†ã€‚ å¦åˆ™éœ€è¦ç­‰å¾…å¯¹æ–¹å‘é€è¿‡æ¥çš„pingæ¶ˆæ¯(æˆ‘ä»¬ä¸»åŠ¨å‘èµ·pingæ¶ˆæ¯)ã€‚    if !pinged {        // Give the remote node a chance to ping us before we start        // sending findnode requests. If they still remember us,        // waitping will simply time out.        tab.net.waitping(id)    }    // Bonding succeeded, update the node database.    // å®Œæˆbondè¿‡ç¨‹ã€‚ æŠŠèŠ‚ç‚¹æ’å…¥æ•°æ®åº“ã€‚ æ•°æ®åº“æ“ä½œåœ¨è¿™é‡Œå®Œæˆã€‚ bucketçš„æ“ä½œåœ¨tab.addé‡Œé¢å®Œæˆã€‚ bucketsæ˜¯å†…å­˜çš„æ“ä½œã€‚ æ•°æ®åº“æ˜¯æŒä¹…åŒ–çš„seedsèŠ‚ç‚¹ã€‚ç”¨æ¥åŠ é€Ÿå¯åŠ¨è¿‡ç¨‹çš„ã€‚    w.n = NewNode(id, addr.IP, uint16(addr.Port), tcpPort)    tab.db.updateNode(w.n)    close(w.done)}</code></pre><p>tab.addæ–¹æ³•</p><pre><code>// add attempts to add the given node its corresponding bucket. If the// bucket has space available, adding the node succeeds immediately.// Otherwise, the node is added if the least recently active node in// the bucket does not respond to a ping packet.// addè¯•å›¾æŠŠç»™å®šçš„èŠ‚ç‚¹æ’å…¥å¯¹åº”çš„bucketã€‚ å¦‚æœbucketæœ‰ç©ºé—´ï¼Œé‚£ä¹ˆç›´æ¥æ’å…¥ã€‚ å¦åˆ™ï¼Œå¦‚æœbucketä¸­æœ€è¿‘æ´»åŠ¨çš„èŠ‚ç‚¹æ²¡æœ‰å“åº”pingæ“ä½œï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä½¿ç”¨è¿™ä¸ªèŠ‚ç‚¹æ›¿æ¢å®ƒã€‚// The caller must not hold tab.mutex.func (tab *Table) add(new *Node) {    b := tab.buckets[logdist(tab.self.sha, new.sha)]    tab.mutex.Lock()    defer tab.mutex.Unlock()    if b.bump(new) { //å¦‚æœèŠ‚ç‚¹å­˜åœ¨ã€‚é‚£ä¹ˆæ›´æ–°å®ƒçš„å€¼ã€‚ç„¶åé€€å‡ºã€‚        return    }    var oldest *Node    if len(b.entries) == bucketSize {        oldest = b.entries[bucketSize-1]        if oldest.contested {            // The node is already being replaced, don't attempt            // to replace it.            // å¦‚æœåˆ«çš„goroutineæ­£åœ¨å¯¹è¿™ä¸ªèŠ‚ç‚¹è¿›è¡Œæµ‹è¯•ã€‚ é‚£ä¹ˆå–æ¶ˆæ›¿æ¢ï¼Œ ç›´æ¥é€€å‡ºã€‚            // å› ä¸ºpingçš„æ—¶é—´æ¯”è¾ƒé•¿ã€‚æ‰€ä»¥è¿™æ®µæ—¶é—´æ˜¯æ²¡æœ‰åŠ é”çš„ã€‚ ç”¨äº†contestedè¿™ä¸ªçŠ¶æ€æ¥æ ‡è¯†è¿™ç§æƒ…å†µã€‚             return        }        oldest.contested = true        // Let go of the mutex so other goroutines can access        // the table while we ping the least recently active node.        tab.mutex.Unlock()        err := tab.ping(oldest.ID, oldest.addr())        tab.mutex.Lock()        oldest.contested = false        if err == nil {            // The node responded, don't replace it.            return        }    }    added := b.replace(new, oldest)    if added &amp;&amp; tab.nodeAddedHook != nil {        tab.nodeAddedHook(new)    }}</code></pre><p>stuffæ–¹æ³•æ¯”è¾ƒç®€å•ã€‚  æ‰¾åˆ°å¯¹åº”èŠ‚ç‚¹åº”è¯¥æ’å…¥çš„bucketã€‚ å¦‚æœè¿™ä¸ªbucketæ²¡æœ‰æ»¡ï¼Œé‚£ä¹ˆå°±æ’å…¥è¿™ä¸ªbucketã€‚å¦åˆ™ä»€ä¹ˆä¹Ÿä¸åšã€‚ éœ€è¦è¯´ä¸€ä¸‹çš„æ˜¯logdist()è¿™ä¸ªæ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•å¯¹ä¸¤ä¸ªå€¼è¿›è¡ŒæŒ‰ç…§ä½ç½®å¼‚æˆ–ï¼Œç„¶åè¿”å›æœ€é«˜ä½çš„ä¸‹æ ‡ã€‚  æ¯”å¦‚   logdist(101,010) = 3   logdist(100, 100) = 0 logdist(100,110) = 2</p><pre><code>// stuff adds nodes the table to the end of their corresponding bucket// if the bucket is not full. The caller must hold tab.mutex.func (tab *Table) stuff(nodes []*Node) {outer:    for _, n := range nodes {        if n.ID == tab.self.ID {            continue // don't add self        }        bucket := tab.buckets[logdist(tab.self.sha, n.sha)]        for i := range bucket.entries {            if bucket.entries[i].ID == n.ID {                continue outer // already in bucket            }        }        if len(bucket.entries) &lt; bucketSize {            bucket.entries = append(bucket.entries, n)            if tab.nodeAddedHook != nil {                tab.nodeAddedHook(n)            }        }    }}</code></pre><p>åœ¨çœ‹çœ‹ä¹‹å‰çš„Lookupå‡½æ•°ã€‚ è¿™ä¸ªå‡½æ•°ç”¨æ¥æŸ¥è¯¢ä¸€ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„ä¿¡æ¯ã€‚  è¿™ä¸ªå‡½æ•°é¦–å…ˆä»æœ¬åœ°æ‹¿åˆ°è·ç¦»è¿™ä¸ªèŠ‚ç‚¹æœ€è¿‘çš„æ‰€æœ‰16ä¸ªèŠ‚ç‚¹ã€‚ ç„¶åç»™æ‰€æœ‰çš„èŠ‚ç‚¹å‘é€findnodeçš„è¯·æ±‚ã€‚ ç„¶åå¯¹è¿”å›çš„ç•Œå®šè¿›è¡Œbondallå¤„ç†ã€‚ ç„¶åè¿”å›æ‰€æœ‰çš„èŠ‚ç‚¹ã€‚</p><pre><code>func (tab *Table) lookup(targetID NodeID, refreshIfEmpty bool) []*Node {    var (        target         = crypto.Keccak256Hash(targetID[:])        asked          = make(map[NodeID]bool)        seen           = make(map[NodeID]bool)        reply          = make(chan []*Node, alpha)        pendingQueries = 0        result         *nodesByDistance    )    // don't query further if we hit ourself.    // unlikely to happen often in practice.    asked[tab.self.ID] = true    ä¸ä¼šè¯¢é—®æˆ‘ä»¬è‡ªå·±    for {        tab.mutex.Lock()        // generate initial result set        result = tab.closest(target, bucketSize)        //æ±‚å–å’Œtargetæœ€è¿‘çš„16ä¸ªèŠ‚ç‚¹        tab.mutex.Unlock()        if len(result.entries) &gt; 0 || !refreshIfEmpty {            break        }        // The result set is empty, all nodes were dropped, refresh.        // We actually wait for the refresh to complete here. The very        // first query will hit this case and run the bootstrapping        // logic.        &lt;-tab.refresh()        refreshIfEmpty = false    }    for {        // ask the alpha closest nodes that we haven't asked yet        // è¿™é‡Œä¼šå¹¶å‘çš„æŸ¥è¯¢ï¼Œæ¯æ¬¡3ä¸ªgoroutineå¹¶å‘(é€šè¿‡pendingQuerieså‚æ•°è¿›è¡Œæ§åˆ¶)        // æ¯æ¬¡è¿­ä»£ä¼šæŸ¥è¯¢resultä¸­å’Œtargetè·ç¦»æœ€è¿‘çš„ä¸‰ä¸ªèŠ‚ç‚¹ã€‚        for i := 0; i &lt; len(result.entries) &amp;&amp; pendingQueries &lt; alpha; i++ {            n := result.entries[i]            if !asked[n.ID] { //å¦‚æœæ²¡æœ‰æŸ¥è¯¢è¿‡ //å› ä¸ºè¿™ä¸ªresult.entriesä¼šè¢«é‡å¤å¾ªç¯å¾ˆå¤šæ¬¡ã€‚ æ‰€ä»¥ç”¨è¿™ä¸ªå˜é‡æ§åˆ¶é‚£äº›å·²ç»å¤„ç†è¿‡äº†ã€‚                asked[n.ID] = true                pendingQueries++                go func() {                    // Find potential neighbors to bond with                    r, err := tab.net.findnode(n.ID, n.addr(), targetID)                    if err != nil {                        // Bump the failure counter to detect and evacuate non-bonded entries                        fails := tab.db.findFails(n.ID) + 1                        tab.db.updateFindFails(n.ID, fails)                        log.Trace("Bumping findnode failure counter", "id", n.ID, "failcount", fails)                        if fails &gt;= maxFindnodeFailures {                            log.Trace("Too many findnode failures, dropping", "id", n.ID, "failcount", fails)                            tab.delete(n)                        }                    }                    reply &lt;- tab.bondall(r)                }()            }        }        if pendingQueries == 0 {            // we have asked all closest nodes, stop the search            break        }        // wait for the next reply        for _, n := range &lt;-reply {            if n != nil &amp;&amp; !seen[n.ID] { //å› ä¸ºä¸åŒçš„è¿œæ–¹èŠ‚ç‚¹å¯èƒ½è¿”å›ç›¸åŒçš„èŠ‚ç‚¹ã€‚æ‰€æœ‰ç”¨seen[]æ¥åšæ’é‡ã€‚                seen[n.ID] = true                //è¿™ä¸ªåœ°æ–¹éœ€è¦æ³¨æ„çš„æ˜¯, æŸ¥æ‰¾å‡ºæ¥çš„ç»“æœåˆä¼šåŠ å…¥resultè¿™ä¸ªé˜Ÿåˆ—ã€‚ä¹Ÿå°±æ˜¯è¯´è¿™æ˜¯ä¸€ä¸ªå¾ªç¯æŸ¥æ‰¾çš„è¿‡ç¨‹ï¼Œ åªè¦resulté‡Œé¢ä¸æ–­åŠ å…¥æ–°çš„èŠ‚ç‚¹ã€‚è¿™ä¸ªå¾ªç¯å°±ä¸ä¼šç»ˆæ­¢ã€‚                result.push(n, bucketSize)            }        }        pendingQueries--    }    return result.entries}// closest returns the n nodes in the table that are closest to the// given id. The caller must hold tab.mutex.func (tab *Table) closest(target common.Hash, nresults int) *nodesByDistance {    // This is a very wasteful way to find the closest nodes but    // obviously correct. I believe that tree-based buckets would make    // this easier to implement efficiently.    close := &amp;nodesByDistance{target: target}    for _, b := range tab.buckets {        for _, n := range b.entries {            close.push(n, nresults)        }    }    return close}</code></pre><p>result.pushæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šæ ¹æ® æ‰€æœ‰çš„èŠ‚ç‚¹å¯¹äºtargetçš„è·ç¦»è¿›è¡Œæ’åºã€‚ æŒ‰ç…§ä»è¿‘åˆ°è¿œçš„æ–¹å¼å†³å®šæ–°èŠ‚ç‚¹çš„æ’å…¥é¡ºåºã€‚(é˜Ÿåˆ—ä¸­æœ€å¤§ä¼šåŒ…å«16ä¸ªå…ƒç´ )ã€‚ è¿™æ ·ä¼šå¯¼è‡´é˜Ÿåˆ—é‡Œé¢çš„å…ƒç´ å’Œtargetçš„è·ç¦»è¶Šæ¥è¶Šè¿‘ã€‚è·ç¦»ç›¸å¯¹è¿œçš„ä¼šè¢«è¸¢å‡ºé˜Ÿåˆ—ã€‚</p><pre><code>// nodesByDistance is a list of nodes, ordered by// distance to target.type nodesByDistance struct {    entries []*Node    target  common.Hash}// push adds the given node to the list, keeping the total size below maxElems.func (h *nodesByDistance) push(n *Node, maxElems int) {    ix := sort.Search(len(h.entries), func(i int) bool {        return distcmp(h.target, h.entries[i].sha, n.sha) &gt; 0    })    if len(h.entries) &lt; maxElems {        h.entries = append(h.entries, n)    }    if ix == len(h.entries) {        // farther away than all nodes we already have.        // if there was room for it, the node is now the last element.    } else {        // slide existing entries down to make room        // this will overwrite the entry we just appended.        copy(h.entries[ix+1:], h.entries[ix:])        h.entries[ix] = n    }}</code></pre><h3 id="table-go-å¯¼å‡ºçš„ä¸€äº›æ–¹æ³•"><a href="#table-go-å¯¼å‡ºçš„ä¸€äº›æ–¹æ³•" class="headerlink" title="table.go å¯¼å‡ºçš„ä¸€äº›æ–¹æ³•"></a>table.go å¯¼å‡ºçš„ä¸€äº›æ–¹æ³•</h3><p>Resolveæ–¹æ³•å’ŒLookupæ–¹æ³•</p><pre><code>// Resolve searches for a specific node with the given ID.// It returns nil if the node could not be found.//Resolveæ–¹æ³•ç”¨æ¥è·å–ä¸€ä¸ªæŒ‡å®šIDçš„èŠ‚ç‚¹ã€‚ å¦‚æœèŠ‚ç‚¹åœ¨æœ¬åœ°ã€‚é‚£ä¹ˆè¿”å›æœ¬åœ°èŠ‚ç‚¹ã€‚ å¦åˆ™æ‰§è¡Œ//Lookupåœ¨ç½‘ç»œä¸ŠæŸ¥è¯¢ä¸€æ¬¡ã€‚ å¦‚æœæŸ¥è¯¢åˆ°èŠ‚ç‚¹ã€‚é‚£ä¹ˆè¿”å›ã€‚å¦åˆ™è¿”å›nilfunc (tab *Table) Resolve(targetID NodeID) *Node {    // If the node is present in the local table, no    // network interaction is required.    hash := crypto.Keccak256Hash(targetID[:])    tab.mutex.Lock()    cl := tab.closest(hash, 1)    tab.mutex.Unlock()    if len(cl.entries) &gt; 0 &amp;&amp; cl.entries[0].ID == targetID {        return cl.entries[0]    }    // Otherwise, do a network lookup.    result := tab.Lookup(targetID)    for _, n := range result {        if n.ID == targetID {            return n        }    }    return nil}// Lookup performs a network search for nodes close// to the given target. It approaches the target by querying// nodes that are closer to it on each iteration.// The given target does not need to be an actual node// identifier.func (tab *Table) Lookup(targetID NodeID) []*Node {    return tab.lookup(targetID, true)}</code></pre><p>SetFallbackNodesæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•è®¾ç½®åˆå§‹åŒ–çš„è”ç³»èŠ‚ç‚¹ã€‚ åœ¨tableæ˜¯ç©ºè€Œä¸”æ•°æ®åº“é‡Œé¢ä¹Ÿæ²¡æœ‰å·²çŸ¥çš„èŠ‚ç‚¹ï¼Œè¿™äº›èŠ‚ç‚¹å¯ä»¥å¸®åŠ©è¿æ¥ä¸Šç½‘ç»œï¼Œ</p><pre><code>// SetFallbackNodes sets the initial points of contact. These nodes// are used to connect to the network if the table is empty and there// are no known nodes in the database.func (tab *Table) SetFallbackNodes(nodes []*Node) error {    for _, n := range nodes {        if err := n.validateComplete(); err != nil {            return fmt.Errorf("bad bootstrap/fallback node %q (%v)", n, err)        }    }    tab.mutex.Lock()    tab.nursery = make([]*Node, 0, len(nodes))    for _, n := range nodes {        cpy := *n        // Recompute cpy.sha because the node might not have been        // created by NewNode or ParseNode.        cpy.sha = crypto.Keccak256Hash(n.ID[:])        tab.nursery = append(tab.nursery, &amp;cpy)    }    tab.mutex.Unlock()    tab.refresh()    return nil}</code></pre><h3 id="æ€»ç»“"><a href="#æ€»ç»“" class="headerlink" title="æ€»ç»“"></a>æ€»ç»“</h3><p>è¿™æ ·ï¼Œ p2pç½‘ç»œçš„Kademliaåè®®å°±å®Œç»“äº†ã€‚ åŸºæœ¬ä¸Šæ˜¯æŒ‰ç…§è®ºæ–‡è¿›è¡Œå®ç°ã€‚ udpè¿›è¡Œç½‘ç»œé€šä¿¡ã€‚æ•°æ®åº“å­˜å‚¨é“¾æ¥è¿‡çš„èŠ‚ç‚¹ã€‚ tableå®ç°äº†Kademliaçš„æ ¸å¿ƒã€‚ æ ¹æ®å¼‚æˆ–è·ç¦»æ¥è¿›è¡ŒèŠ‚ç‚¹çš„æŸ¥æ‰¾ã€‚ èŠ‚ç‚¹çš„å‘ç°å’Œæ›´æ–°ç­‰æµç¨‹ã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-p2p-udp.goæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-udp.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p-udp.go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>p2pçš„ç½‘ç»œå‘ç°åè®®ä½¿ç”¨äº†Kademlia protocol æ¥å¤„ç†ç½‘ç»œçš„èŠ‚ç‚¹å‘ç°ã€‚èŠ‚ç‚¹æŸ¥æ‰¾å’ŒèŠ‚ç‚¹æ›´æ–°ã€‚Kademlia protocolä½¿ç”¨äº†UDPåè®®æ¥è¿›è¡Œç½‘ç»œé€šä¿¡ã€‚</p><p>é˜…è¯»è¿™éƒ¨åˆ†çš„ä»£ç å»ºè®®å…ˆçœ‹çœ‹referencesé‡Œé¢çš„Kademliaåè®®ç®€ä»‹æ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯Kademliaåè®®ã€‚</p><p>é¦–å…ˆçœ‹çœ‹æ•°æ®ç»“æ„ã€‚ ç½‘ç»œä¼ è¾“äº†4ç§æ•°æ®åŒ…(UDPåè®®æ˜¯åŸºäºæŠ¥æ–‡çš„åè®®ã€‚ä¼ è¾“çš„æ˜¯ä¸€ä¸ªä¸€ä¸ªæ•°æ®åŒ…)ï¼Œåˆ†åˆ«æ˜¯ping,pong,findnodeå’Œneighborsã€‚ ä¸‹é¢åˆ†åˆ«å®šä¹‰äº†4ç§æŠ¥æ–‡çš„æ ¼å¼ã€‚ </p><pre><code>// RPC packet typesconst (    pingPacket = iota + 1 // zero is 'reserved'    pongPacket    findnodePacket    neighborsPacket)// RPC request structurestype (    ping struct {        Version    uint             //åè®®ç‰ˆæœ¬        From, To   rpcEndpoint        //æºIPåœ°å€ ç›®çš„IPåœ°å€        Expiration uint64            //è¶…æ—¶æ—¶é—´        // Ignore additional fields (for forward compatibility).        //å¯ä»¥å¿½ç•¥çš„å­—æ®µã€‚ ä¸ºäº†å‘å‰å…¼å®¹        Rest []rlp.RawValue `rlp:"tail"`    }    // pong is the reply to ping.    // pingåŒ…çš„å›åº”    pong struct {        // This field should mirror the UDP envelope address        // of the ping packet, which provides a way to discover the        // the external address (after NAT).        // ç›®çš„IPåœ°å€        To rpcEndpoint        // è¯´æ˜è¿™ä¸ªpongåŒ…æ˜¯å›åº”é‚£ä¸ªpingåŒ…çš„ã€‚ åŒ…å«äº†pingåŒ…çš„hashå€¼        ReplyTok   []byte // This contains the hash of the ping packet.        //åŒ…è¶…æ—¶çš„ç»å¯¹æ—¶é—´ã€‚ å¦‚æœæ”¶åˆ°åŒ…çš„æ—¶å€™è¶…è¿‡äº†è¿™ä¸ªæ—¶é—´ï¼Œé‚£ä¹ˆåŒ…è¢«è®¤ä¸ºæ˜¯è¶…æ—¶çš„ã€‚        Expiration uint64 // Absolute timestamp at which the packet becomes invalid.        // Ignore additional fields (for forward compatibility).        Rest []rlp.RawValue `rlp:"tail"`    }    // findnode æ˜¯ç”¨æ¥æŸ¥è¯¢è·ç¦»targetæ¯”è¾ƒè¿‘çš„èŠ‚ç‚¹    // findnode is a query for nodes close to the given target.    findnode struct {        // ç›®çš„èŠ‚ç‚¹        Target     NodeID // doesn't need to be an actual public key        Expiration uint64        // Ignore additional fields (for forward compatibility).        Rest []rlp.RawValue `rlp:"tail"`    }    // reply to findnode    // findnodeçš„å›åº”    neighbors struct {        //è·ç¦»targetæ¯”è¾ƒè¿‘çš„èŠ‚ç‚¹å€¼ã€‚        Nodes      []rpcNode        Expiration uint64        // Ignore additional fields (for forward compatibility).        Rest []rlp.RawValue `rlp:"tail"`    }    rpcNode struct {        IP  net.IP // len 4 for IPv4 or 16 for IPv6        UDP uint16 // for discovery protocol        TCP uint16 // for RLPx protocol        ID  NodeID    }    rpcEndpoint struct {        IP  net.IP // len 4 for IPv4 or 16 for IPv6        UDP uint16 // for discovery protocol        TCP uint16 // for RLPx protocol    })</code></pre><p>å®šä¹‰äº†ä¸¤ä¸ªæ¥å£ç±»å‹ï¼Œpacketæ¥å£ç±»å‹åº”è¯¥æ˜¯ç»™4ç§ä¸åŒç±»å‹çš„åŒ…åˆ†æ´¾ä¸åŒçš„handleæ–¹æ³•ã€‚ connæ¥å£å®šä¹‰äº†ä¸€ä¸ªudpçš„è¿æ¥çš„åŠŸèƒ½ã€‚</p><pre><code>type packet interface {    handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error    name() string}type conn interface {    ReadFromUDP(b []byte) (n int, addr *net.UDPAddr, err error)    WriteToUDP(b []byte, addr *net.UDPAddr) (n int, err error)    Close() error    LocalAddr() net.Addr}</code></pre><p>udpçš„ç»“æ„ï¼Œ éœ€è¦æ³¨æ„çš„æ˜¯æœ€åä¸€ä¸ªå­—æ®µ*Tableæ˜¯goé‡Œé¢çš„åŒ¿åå­—æ®µã€‚  ä¹Ÿå°±æ˜¯è¯´udpå¯ä»¥ç›´æ¥è°ƒç”¨åŒ¿åå­—æ®µTableçš„æ–¹æ³•ã€‚</p><pre><code>// udp implements the RPC protocol.type udp struct {    conn        conn                    //ç½‘ç»œè¿æ¥    netrestrict *netutil.Netlist    priv        *ecdsa.PrivateKey        //ç§é’¥ï¼Œè‡ªå·±çš„IDæ˜¯é€šè¿‡è¿™ä¸ªæ¥ç”Ÿæˆçš„ã€‚    ourEndpoint rpcEndpoint    addpending chan *pending            //ç”¨æ¥ç”³è¯·ä¸€ä¸ªpending    gotreply   chan reply                //ç”¨æ¥è·å–å›åº”çš„é˜Ÿåˆ—    closing chan struct{}                //ç”¨æ¥å…³é—­çš„é˜Ÿåˆ—    nat     nat.Interface                    *Table}</code></pre><p>pending å’Œreply ç»“æ„ã€‚ è¿™ä¸¤ä¸ªç»“æ„ç”¨æˆ·å†…éƒ¨çš„go routineä¹‹é—´è¿›è¡Œé€šä¿¡çš„ç»“æ„ä½“ã€‚</p><pre><code>// pending represents a pending reply.// some implementations of the protocol wish to send more than one// reply packet to findnode. in general, any neighbors packet cannot// be matched up with a specific findnode packet.// our implementation handles this by storing a callback function for// each pending reply. incoming packets from a node are dispatched// to all the callback functions for that node.// pendingç»“æ„ ä»£è¡¨æ­£åœ¨ç­‰å¾…ä¸€ä¸ªreply// æˆ‘ä»¬é€šè¿‡ä¸ºæ¯ä¸€ä¸ªpending reply å­˜å‚¨ä¸€ä¸ªcallbackæ¥å®ç°è¿™ä¸ªåŠŸèƒ½ã€‚ä»ä¸€ä¸ªèŠ‚ç‚¹æ¥çš„æ‰€æœ‰æ•°æ®åŒ…éƒ½ä¼šåˆ†é…åˆ°è¿™ä¸ªèŠ‚ç‚¹å¯¹åº”çš„callbackä¸Šé¢ã€‚type pending struct {    // these fields must match in the reply.    from  NodeID    ptype byte    // time when the request must complete    deadline time.Time    // callback is called when a matching reply arrives. if it returns    // true, the callback is removed from the pending reply queue.    // if it returns false, the reply is considered incomplete and    // the callback will be invoked again for the next matching reply.    //å¦‚æœè¿”å›å€¼æ˜¯trueã€‚é‚£ä¹ˆcallbackä¼šä»é˜Ÿåˆ—é‡Œé¢ç§»é™¤ã€‚ å¦‚æœè¿”å›false,é‚£ä¹ˆè®¤ä¸ºreplyè¿˜æ²¡æœ‰å®Œæˆï¼Œä¼šç»§ç»­ç­‰å¾…ä¸‹ä¸€æ¬¡reply.    callback func(resp interface{}) (done bool)    // errc receives nil when the callback indicates completion or an    // error if no further reply is received within the timeout.    errc chan&lt;- error}type reply struct {    from  NodeID    ptype byte    data  interface{}    // loop indicates whether there was    // a matching request by sending on this channel.    //é€šè¿‡å¾€è¿™ä¸ªchannelä¸Šé¢å‘é€æ¶ˆæ¯æ¥è¡¨ç¤ºåŒ¹é…åˆ°ä¸€ä¸ªè¯·æ±‚ã€‚    matched chan&lt;- bool}</code></pre><p>UDPçš„åˆ›å»º</p><pre><code>// ListenUDP returns a new table that listens for UDP packets on laddr.func ListenUDP(priv *ecdsa.PrivateKey, laddr string, natm nat.Interface, nodeDBPath string, netrestrict *netutil.Netlist) (*Table, error) {    addr, err := net.ResolveUDPAddr("udp", laddr)    if err != nil {        return nil, err    }    conn, err := net.ListenUDP("udp", addr)    if err != nil {        return nil, err    }    tab, _, err := newUDP(priv, conn, natm, nodeDBPath, netrestrict)    if err != nil {        return nil, err    }    log.Info("UDP listener up", "self", tab.self)    return tab, nil}func newUDP(priv *ecdsa.PrivateKey, c conn, natm nat.Interface, nodeDBPath string, netrestrict *netutil.Netlist) (*Table, *udp, error) {    udp := &amp;udp{        conn:        c,        priv:        priv,        netrestrict: netrestrict,        closing:     make(chan struct{}),        gotreply:    make(chan reply),        addpending:  make(chan *pending),    }    realaddr := c.LocalAddr().(*net.UDPAddr)    if natm != nil {   //natm nat mapping ç”¨æ¥è·å–å¤–ç½‘åœ°å€        if !realaddr.IP.IsLoopback() {  //å¦‚æœåœ°å€æ˜¯æœ¬åœ°ç¯å›åœ°å€            go nat.Map(natm, udp.closing, "udp", realaddr.Port, realaddr.Port, "ethereum discovery")        }        // TODO: react to external IP changes over time.        if ext, err := natm.ExternalIP(); err == nil {            realaddr = &amp;net.UDPAddr{IP: ext, Port: realaddr.Port}        }    }    // TODO: separate TCP port    udp.ourEndpoint = makeEndpoint(realaddr, uint16(realaddr.Port))    //åˆ›å»ºä¸€ä¸ªtable åç»­ä¼šä»‹ç»ã€‚ Kademliaçš„ä¸»è¦é€»è¾‘åœ¨è¿™ä¸ªç±»é‡Œé¢å®ç°ã€‚    tab, err := newTable(udp, PubkeyID(&amp;priv.PublicKey), realaddr, nodeDBPath)    if err != nil {        return nil, nil, err    }    udp.Table = tab   //åŒ¿åå­—æ®µçš„èµ‹å€¼        go udp.loop()        //go routine     go udp.readLoop()    //ç”¨æ¥ç½‘ç»œæ•°æ®è¯»å–ã€‚    return udp.Table, udp, nil}</code></pre><p>pingæ–¹æ³•ä¸pendingçš„å¤„ç†ï¼Œä¹‹å‰è°ˆåˆ°äº†pendingæ˜¯ç­‰å¾…ä¸€ä¸ªreplyã€‚ è¿™é‡Œé€šè¿‡ä»£ç æ¥åˆ†ææ˜¯å¦‚ä½•å®ç°ç­‰å¾…replyçš„ã€‚</p><p>pendingæ–¹æ³•æŠŠpendingç»“æ„ä½“å‘é€ç»™addpending. ç„¶åç­‰å¾…æ¶ˆæ¯çš„å¤„ç†å’Œæ¥æ”¶ã€‚</p><pre><code>// ping sends a ping message to the given node and waits for a reply.func (t *udp) ping(toid NodeID, toaddr *net.UDPAddr) error {    // TODO: maybe check for ReplyTo field in callback to measure RTT    errc := t.pending(toid, pongPacket, func(interface{}) bool { return true })    t.send(toaddr, pingPacket, &amp;ping{        Version:    Version,        From:       t.ourEndpoint,        To:         makeEndpoint(toaddr, 0), // TODO: maybe use known TCP port from DB        Expiration: uint64(time.Now().Add(expiration).Unix()),    })    return &lt;-errc}// pending adds a reply callback to the pending reply queue.// see the documentation of type pending for a detailed explanation.func (t *udp) pending(id NodeID, ptype byte, callback func(interface{}) bool) &lt;-chan error {    ch := make(chan error, 1)    p := &amp;pending{from: id, ptype: ptype, callback: callback, errc: ch}    select {    case t.addpending &lt;- p:        // loop will handle it    case &lt;-t.closing:        ch &lt;- errClosed    }    return ch}</code></pre><p>addpendingæ¶ˆæ¯çš„å¤„ç†ã€‚ ä¹‹å‰åˆ›å»ºudpçš„æ—¶å€™è°ƒç”¨äº†newUDPæ–¹æ³•ã€‚é‡Œé¢å¯åŠ¨äº†ä¸¤ä¸ªgoroutineã€‚ å…¶ä¸­çš„loop()å°±æ˜¯ç”¨æ¥å¤„ç†pendingæ¶ˆæ¯çš„ã€‚</p><pre><code>// loop runs in its own goroutine. it keeps track of// the refresh timer and the pending reply queue.func (t *udp) loop() {    var (        plist        = list.New()        timeout      = time.NewTimer(0)        nextTimeout  *pending // head of plist when timeout was last reset        contTimeouts = 0      // number of continuous timeouts to do NTP checks        ntpWarnTime  = time.Unix(0, 0)    )    &lt;-timeout.C // ignore first timeout    defer timeout.Stop()    resetTimeout := func() {          //è¿™ä¸ªæ–¹æ³•çš„ä¸»è¦åŠŸèƒ½æ˜¯æŸ¥çœ‹é˜Ÿåˆ—é‡Œé¢æ˜¯å¦æœ‰éœ€è¦è¶…æ—¶çš„pendingæ¶ˆæ¯ã€‚ å¦‚æœæœ‰ã€‚é‚£ä¹ˆ        //æ ¹æ®æœ€å…ˆè¶…æ—¶çš„æ—¶é—´è®¾ç½®è¶…æ—¶é†’æ¥ã€‚         if plist.Front() == nil || nextTimeout == plist.Front().Value {            return        }        // Start the timer so it fires when the next pending reply has expired.        now := time.Now()        for el := plist.Front(); el != nil; el = el.Next() {            nextTimeout = el.Value.(*pending)            if dist := nextTimeout.deadline.Sub(now); dist &lt; 2*respTimeout {                timeout.Reset(dist)                return            }            // Remove pending replies whose deadline is too far in the            // future. These can occur if the system clock jumped            // backwards after the deadline was assigned.            //å¦‚æœæœ‰æ¶ˆæ¯çš„deadlineåœ¨å¾ˆè¿œçš„æœªæ¥ï¼Œé‚£ä¹ˆç›´æ¥è®¾ç½®è¶…æ—¶ï¼Œç„¶åç§»é™¤ã€‚            //è¿™ç§æƒ…å†µåœ¨ä¿®æ”¹ç³»ç»Ÿæ—¶é—´çš„æ—¶å€™æœ‰å¯èƒ½å‘ç”Ÿï¼Œå¦‚æœä¸å¤„ç†å¯èƒ½å¯¼è‡´å µå¡å¤ªé•¿æ—¶é—´ã€‚            nextTimeout.errc &lt;- errClockWarp            plist.Remove(el)        }        nextTimeout = nil        timeout.Stop()    }    for {        resetTimeout()  //é¦–å…ˆå¤„ç†è¶…æ—¶ã€‚        select {        case &lt;-t.closing:  //æ”¶åˆ°å…³é—­ä¿¡æ¯ã€‚ è¶…æ—¶æ‰€æœ‰çš„å µå¡çš„é˜Ÿåˆ—            for el := plist.Front(); el != nil; el = el.Next() {                el.Value.(*pending).errc &lt;- errClosed            }            return        case p := &lt;-t.addpending:  //å¢åŠ ä¸€ä¸ªpending è®¾ç½®deadline            p.deadline = time.Now().Add(respTimeout)            plist.PushBack(p)        case r := &lt;-t.gotreply:  //æ”¶åˆ°ä¸€ä¸ªreply å¯»æ‰¾åŒ¹é…çš„pending            var matched bool            for el := plist.Front(); el != nil; el = el.Next() {                p := el.Value.(*pending)                if p.from == r.from &amp;&amp; p.ptype == r.ptype { //å¦‚æœæ¥è‡ªåŒä¸€ä¸ªäººã€‚ è€Œä¸”ç±»å‹ç›¸åŒ                    matched = true                    // Remove the matcher if its callback indicates                    // that all replies have been received. This is                    // required for packet types that expect multiple                    // reply packets.                    if p.callback(r.data) { //å¦‚æœcallbackè¿”å›å€¼æ˜¯true ã€‚è¯´æ˜pendingå·²ç»å®Œæˆã€‚ ç»™p.errcå†™å…¥nilã€‚ pendingå®Œæˆã€‚                        p.errc &lt;- nil                        plist.Remove(el)                    }                    // Reset the continuous timeout counter (time drift detection)                    contTimeouts = 0                }            }            r.matched &lt;- matched //å†™å…¥replyçš„matched        case now := &lt;-timeout.C:   //å¤„ç†è¶…æ—¶ä¿¡æ¯            nextTimeout = nil            // Notify and remove callbacks whose deadline is in the past.            for el := plist.Front(); el != nil; el = el.Next() {                p := el.Value.(*pending)                if now.After(p.deadline) || now.Equal(p.deadline) { //å¦‚æœè¶…æ—¶å†™å…¥è¶…æ—¶ä¿¡æ¯å¹¶ç§»é™¤                    p.errc &lt;- errTimeout                    plist.Remove(el)                    contTimeouts++                }            }            // If we've accumulated too many timeouts, do an NTP time sync check            if contTimeouts &gt; ntpFailureThreshold {                //å¦‚æœè¿ç»­è¶…æ—¶å¾ˆå¤šæ¬¡ã€‚ é‚£ä¹ˆæŸ¥çœ‹æ˜¯å¦æ˜¯æ—¶é—´ä¸åŒæ­¥ã€‚ å’ŒNTPæœåŠ¡å™¨è¿›è¡ŒåŒæ­¥ã€‚                if time.Since(ntpWarnTime) &gt;= ntpWarningCooldown {                    ntpWarnTime = time.Now()                    go checkClockDrift()                }                contTimeouts = 0            }        }    }}</code></pre><p>ä¸Šé¢çœ‹åˆ°äº†pendingçš„å¤„ç†ã€‚ ä¸è¿‡loop()æ–¹æ³•ç§è¿˜æœ‰ä¸€ä¸ªgotreplyçš„å¤„ç†ã€‚ è¿™ä¸ªå®åœ¨readLoop()è¿™ä¸ªgoroutineä¸­äº§ç”Ÿçš„ã€‚</p><pre><code>// readLoop runs in its own goroutine. it handles incoming UDP packets.func (t *udp) readLoop() {    defer t.conn.Close()    // Discovery packets are defined to be no larger than 1280 bytes.    // Packets larger than this size will be cut at the end and treated    // as invalid because their hash won't match.    buf := make([]byte, 1280)    for {        nbytes, from, err := t.conn.ReadFromUDP(buf)        if netutil.IsTemporaryError(err) {            // Ignore temporary read errors.            log.Debug("Temporary UDP read error", "err", err)            continue        } else if err != nil {            // Shut down the loop for permament errors.            log.Debug("UDP read error", "err", err)            return        }        t.handlePacket(from, buf[:nbytes])    }}func (t *udp) handlePacket(from *net.UDPAddr, buf []byte) error {    packet, fromID, hash, err := decodePacket(buf)    if err != nil {        log.Debug("Bad discv4 packet", "addr", from, "err", err)        return err    }    err = packet.handle(t, from, fromID, hash)    log.Trace("&lt;&lt; "+packet.name(), "addr", from, "err", err)    return err}func (req *ping) handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error {    if expired(req.Expiration) {        return errExpired    }    t.send(from, pongPacket, &amp;pong{        To:         makeEndpoint(from, req.From.TCP),        ReplyTok:   mac,        Expiration: uint64(time.Now().Add(expiration).Unix()),    })    if !t.handleReply(fromID, pingPacket, req) {        // Note: we're ignoring the provided IP address right now        go t.bond(true, fromID, from, req.From.TCP)    }    return nil}func (t *udp) handleReply(from NodeID, ptype byte, req packet) bool {    matched := make(chan bool, 1)    select {    case t.gotreply &lt;- reply{from, ptype, req, matched}:        // loop will handle it        return &lt;-matched    case &lt;-t.closing:        return false    }}</code></pre><p>ä¸Šé¢ä»‹ç»äº†udpçš„å¤§è‡´å¤„ç†çš„æµç¨‹ã€‚ ä¸‹é¢ä»‹ç»ä¸‹udpçš„ä¸»è¦å¤„ç†çš„ä¸šåŠ¡ã€‚ udpä¸»è¦å‘é€ä¸¤ç§è¯·æ±‚ï¼Œå¯¹åº”çš„ä¹Ÿä¼šæ¥æ”¶åˆ«äººå‘é€çš„è¿™ä¸¤ç§è¯·æ±‚ï¼Œ å¯¹åº”è¿™ä¸¤ç§è¯·æ±‚åˆä¼šäº§ç”Ÿä¸¤ç§å›åº”ã€‚</p><p>pingè¯·æ±‚ï¼Œå¯ä»¥çœ‹åˆ°pingè¯·æ±‚å¸Œæœ›å¾—åˆ°ä¸€ä¸ªpongå›ç­”ã€‚ ç„¶åè¿”å›ã€‚</p><pre><code>// ping sends a ping message to the given node and waits for a reply.func (t *udp) ping(toid NodeID, toaddr *net.UDPAddr) error {    // TODO: maybe check for ReplyTo field in callback to measure RTT    errc := t.pending(toid, pongPacket, func(interface{}) bool { return true })    t.send(toaddr, pingPacket, &amp;ping{        Version:    Version,        From:       t.ourEndpoint,        To:         makeEndpoint(toaddr, 0), // TODO: maybe use known TCP port from DB        Expiration: uint64(time.Now().Add(expiration).Unix()),    })    return &lt;-errc}</code></pre><p>pongå›ç­”,å¦‚æœpongå›ç­”æ²¡æœ‰åŒ¹é…åˆ°ä¸€ä¸ªå¯¹åº”çš„pingè¯·æ±‚ã€‚é‚£ä¹ˆè¿”å›errUnsolicitedReplyå¼‚å¸¸ã€‚</p><pre><code>func (req *pong) handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error {    if expired(req.Expiration) {        return errExpired    }    if !t.handleReply(fromID, pongPacket, req) {        return errUnsolicitedReply    }    return nil}</code></pre><p>findnodeè¯·æ±‚, å‘é€findnodeè¯·æ±‚ï¼Œç„¶åç­‰å¾…nodeå›åº” kä¸ªé‚»å±…ã€‚</p><pre><code>// findnode sends a findnode request to the given node and waits until// the node has sent up to k neighbors.func (t *udp) findnode(toid NodeID, toaddr *net.UDPAddr, target NodeID) ([]*Node, error) {    nodes := make([]*Node, 0, bucketSize)    nreceived := 0    errc := t.pending(toid, neighborsPacket, func(r interface{}) bool {        reply := r.(*neighbors)        for _, rn := range reply.Nodes {            nreceived++            n, err := t.nodeFromRPC(toaddr, rn)            if err != nil {                log.Trace("Invalid neighbor node received", "ip", rn.IP, "addr", toaddr, "err", err)                continue            }            nodes = append(nodes, n)        }        return nreceived &gt;= bucketSize    })    t.send(toaddr, findnodePacket, &amp;findnode{        Target:     target,        Expiration: uint64(time.Now().Add(expiration).Unix()),    })    err := &lt;-errc    return nodes, err}</code></pre><p>neighborså›åº”, å¾ˆç®€å•ã€‚ æŠŠå›åº”å‘é€ç»™gotreplyé˜Ÿåˆ—ã€‚ å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„findnodeè¯·æ±‚ã€‚è¿”å›errUnsolicitedReplyé”™è¯¯</p><pre><code>func (req *neighbors) handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error {    if expired(req.Expiration) {        return errExpired    }    if !t.handleReply(fromID, neighborsPacket, req) {        return errUnsolicitedReply    }    return nil}</code></pre><p>æ”¶åˆ°åˆ«çš„èŠ‚ç‚¹å‘é€çš„pingè¯·æ±‚ï¼Œå‘é€pongå›ç­”ã€‚ å¦‚æœæ²¡æœ‰åŒ¹é…ä¸Šä¸€ä¸ªpending(è¯´æ˜ä¸æ˜¯è‡ªå·±æ–¹è¯·æ±‚çš„ç»“æœ)ã€‚ å°±è°ƒç”¨bondæ–¹æ³•æŠŠè¿™ä¸ªèŠ‚ç‚¹åŠ å…¥è‡ªå·±çš„bucketç¼“å­˜ã€‚(è¿™éƒ¨åˆ†åŸç†åœ¨table.goé‡Œé¢ä¼šè¯¦ç»†ä»‹ç»)</p><pre><code>func (req *ping) handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error {    if expired(req.Expiration) {        return errExpired    }    t.send(from, pongPacket, &amp;pong{        To:         makeEndpoint(from, req.From.TCP),        ReplyTok:   mac,        Expiration: uint64(time.Now().Add(expiration).Unix()),    })    if !t.handleReply(fromID, pingPacket, req) {        // Note: we're ignoring the provided IP address right now        go t.bond(true, fromID, from, req.From.TCP)    }    return nil}</code></pre><p>æ”¶åˆ°åˆ«äººå‘é€çš„findnodeè¯·æ±‚ã€‚è¿™ä¸ªè¯·æ±‚å¸Œæœ›æŠŠå’Œtargetè·ç¦»ç›¸è¿‘çš„kä¸ªèŠ‚ç‚¹å‘é€å›å»ã€‚ ç®—æ³•çš„è¯¦ç»†è¯·å‚è€ƒreferencesç›®å½•ä¸‹é¢çš„pdfæ–‡æ¡£ã€‚</p><pre><code>func (req *findnode) handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error {    if expired(req.Expiration) {        return errExpired    }    if t.db.node(fromID) == nil {        // No bond exists, we don't process the packet. This prevents        // an attack vector where the discovery protocol could be used        // to amplify traffic in a DDOS attack. A malicious actor        // would send a findnode request with the IP address and UDP        // port of the target as the source address. The recipient of        // the findnode packet would then send a neighbors packet        // (which is a much bigger packet than findnode) to the victim.        return errUnknownNode    }    target := crypto.Keccak256Hash(req.Target[:])    t.mutex.Lock()    //è·å–bucketSizeä¸ªå’Œtargetè·ç¦»ç›¸è¿‘çš„èŠ‚ç‚¹ã€‚ è¿™ä¸ªæ–¹æ³•åœ¨table.goå†…éƒ¨å®ç°ã€‚åç»­ä¼šè¯¦ç»†ä»‹ç»    closest := t.closest(target, bucketSize).entries    t.mutex.Unlock()    p := neighbors{Expiration: uint64(time.Now().Add(expiration).Unix())}    // Send neighbors in chunks with at most maxNeighbors per packet    // to stay below the 1280 byte limit.    for i, n := range closest {        if netutil.CheckRelayIP(from.IP, n.IP) != nil {            continue        }        p.Nodes = append(p.Nodes, nodeToRPC(n))        if len(p.Nodes) == maxNeighbors || i == len(closest)-1 {            t.send(from, neighborsPacket, &amp;p)            p.Nodes = p.Nodes[:0]        }    }    return nil}</code></pre><h3 id="udpä¿¡æ¯åŠ å¯†å’Œå®‰å…¨é—®é¢˜"><a href="#udpä¿¡æ¯åŠ å¯†å’Œå®‰å…¨é—®é¢˜" class="headerlink" title="udpä¿¡æ¯åŠ å¯†å’Œå®‰å…¨é—®é¢˜"></a>udpä¿¡æ¯åŠ å¯†å’Œå®‰å…¨é—®é¢˜</h3><p>discoveråè®®å› ä¸ºæ²¡æœ‰æ‰¿è½½ä»€ä¹ˆæ•æ„Ÿæ•°æ®ï¼Œæ‰€ä»¥æ•°æ®æ˜¯ä»¥æ˜æ–‡ä¼ è¾“ï¼Œä½†æ˜¯ä¸ºäº†ç¡®ä¿æ•°æ®çš„å®Œæ•´æ€§å’Œä¸è¢«ç¯¡æ”¹ï¼Œæ‰€ä»¥åœ¨æ•°æ®åŒ…çš„åŒ…å¤´åŠ ä¸Šäº†æ•°å­—ç­¾åã€‚</p><pre><code>func encodePacket(priv *ecdsa.PrivateKey, ptype byte, req interface{}) ([]byte, error) {    b := new(bytes.Buffer)    b.Write(headSpace)    b.WriteByte(ptype)    if err := rlp.Encode(b, req); err != nil {        log.Error("Can't encode discv4 packet", "err", err)        return nil, err    }    packet := b.Bytes()    sig, err := crypto.Sign(crypto.Keccak256(packet[headSize:]), priv)    if err != nil {        log.Error("Can't sign discv4 packet", "err", err)        return nil, err    }    copy(packet[macSize:], sig)    // add the hash to the front. Note: this doesn't protect the    // packet in any way. Our public key will be part of this hash in    // The future.    copy(packet, crypto.Keccak256(packet[macSize:]))    return packet, nil}func decodePacket(buf []byte) (packet, NodeID, []byte, error) {    if len(buf) &lt; headSize+1 {        return nil, NodeID{}, nil, errPacketTooSmall    }    hash, sig, sigdata := buf[:macSize], buf[macSize:headSize], buf[headSize:]    shouldhash := crypto.Keccak256(buf[macSize:])    if !bytes.Equal(hash, shouldhash) {        return nil, NodeID{}, nil, errBadHash    }    fromID, err := recoverNodeID(crypto.Keccak256(buf[headSize:]), sig)    if err != nil {        return nil, NodeID{}, hash, err    }    var req packet    switch ptype := sigdata[0]; ptype {    case pingPacket:        req = new(ping)    case pongPacket:        req = new(pong)    case findnodePacket:        req = new(findnode)    case neighborsPacket:        req = new(neighbors)    default:        return nil, fromID, hash, fmt.Errorf("unknown type: %d", ptype)    }    s := rlp.NewStream(bytes.NewReader(sigdata[1:]), 0)    err = s.Decode(req)    return req, fromID, hash, err}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-powä¸€è‡´æ€§ç®—æ³•</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-pow%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-pow%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="eth-PoWåˆ†æ"><a href="#eth-PoWåˆ†æ" class="headerlink" title="eth PoWåˆ†æ"></a>eth PoWåˆ†æ</h2><h3 id="å…±è¯†å¼•æ“æè¿°"><a href="#å…±è¯†å¼•æ“æè¿°" class="headerlink" title="å…±è¯†å¼•æ“æè¿°"></a>å…±è¯†å¼•æ“æè¿°</h3><p>åœ¨CPUæŒ–çŸ¿éƒ¨åˆ†ï¼ŒCpuAgentçš„mineå‡½æ•°ï¼Œæ‰§è¡ŒæŒ–çŸ¿æ“ä½œçš„æ—¶å€™è°ƒç”¨äº†self.engine.Sealå‡½æ•°ã€‚è¿™é‡Œçš„engineæ˜¯å°±æ˜¯å…±è¯†å¼•æ“ã€‚Sealä¸ºå…¶ä¸­å¾ˆé‡è¦çš„ä¸€ä¸ªæ¥å£ã€‚å®ƒå®ç°äº†nonceå€¼çš„å¯»æ‰¾å’Œhashçš„è®¡ç®—ã€‚å¹¶ä¸”è¯¥å‡½æ•°æ˜¯ä¿è¯å…±è¯†å¹¶ä¸”ä¸èƒ½ä¼ªé€ çš„ä¸€ä¸ªé‡è¦çš„å‡½æ•°ã€‚<br>å†PoWå…±è¯†ç®—æ³•ä¸­ï¼ŒSealå‡½æ•°å®ç°äº†å·¥ä½œè¯æ˜ã€‚è¯¥éƒ¨åˆ†æºç åœ¨consensus/ethhashä¸‹ã€‚</p><h3 id="å…±è¯†å¼•æ“æ¥å£"><a href="#å…±è¯†å¼•æ“æ¥å£" class="headerlink" title="å…±è¯†å¼•æ“æ¥å£"></a>å…±è¯†å¼•æ“æ¥å£</h3><pre><code class="go">type Engine interface {    // è·å–åŒºå—æŒ–æ˜è€…, å³coinbase    Author(header *types.Header) (common.Address, error)    // VerifyHeader ç”¨äºæ ¡éªŒåŒºå—å¤´ï¼Œé€šè¿‡å…±è¯†è§„åˆ™æ¥æ ¡éªŒï¼ŒéªŒè¯åŒºå—å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œä¹Ÿç§‘é€šé€šè¿‡VerifySealæ–¹æ³•    VerifyHeader(chain ChainReader, header *types.Header, seal bool) error    // VerifyHeadersä¸VerifyHeaderç›¸ä¼¼,åŒæ—¶è¿™ä¸ªç”¨äºæ‰¹é‡æ“ä½œæ ¡éªŒå¤´ã€‚è¿™ä¸ªæ–¹æ³•è¿”å›ä¸€ä¸ªé€€å‡ºä¿¡å·    // ç”¨äºç»ˆæ­¢æ“ä½œï¼Œç”¨äºå¼‚æ­¥æ ¡éªŒã€‚    VerifyHeaders(chain ChainReader, headers []*types.Header, seals []bool) (chan&lt;- struct{}, &lt;-chan error)    // VerifyUncles ç”¨äºæ ¡éªŒå”å—ä»¥ç¬¦åˆå…±è¯†å¼•æ“çš„è§„åˆ™    VerifyUncles(chain ChainReader, block *types.Block) error    // VerifySealæ ¹æ®å…±è¯†ç®—æ³•çš„è§„åˆ™æ ¡éªŒåŒºå—å¤´    VerifySeal(chain ChainReader, header *types.Header) error    // Prepare ç”¨äºåˆå§‹åŒ–åŒºå—å¤´çš„å…±è¯†å­—æ®µæ ¹æ®å…±è¯†å¼•æ“ã€‚è¿™äº›æ”¹å˜éƒ½æ˜¯å†…è”æ‰§è¡Œçš„ã€‚    Prepare(chain ChainReader, header *types.Header) error    // Finalize å®Œæˆæ‰€æœ‰çš„çŠ¶æ€ä¿®æ”¹ï¼Œå¹¶æœ€ç»ˆç»„è£…æˆå—ã€‚    // åŒºå—å¤´å’ŒçŠ¶æ€æ•°æ®åº“åœ¨æœ€ç»ˆç¡®è®¤çš„æ—¶å€™å¯ä»¥è¢«æ›´æ–°ä½¿ä¹‹ç¬¦åˆå…±è¯†è§„åˆ™ã€‚    Finalize(chain ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction,        uncles []*types.Header, receipts []*types.Receipt) (*types.Block, error)    // Seal æ ¹æ®è¾“å…¥åŒºå—æ‰“åŒ…ç”Ÿäº§ä¸€ä¸ªæ–°çš„åŒºå—    Seal(chain ChainReader, block *types.Block, stop &lt;-chan struct{}) (*types.Block, error)    // CalcDifficulty æ˜¯éš¾åº¦è°ƒæ•´ç®—æ³•ï¼Œå®ƒè¿”å›æ–°çš„åŒºå—çš„éš¾åº¦å€¼ã€‚    CalcDifficulty(chain ChainReader, time uint64, parent *types.Header) *big.Int    // APIs è¿”å›ç”±å…±è¯†å¼•æ“æä¾›çš„RPC APIs     APIs(chain ChainReader) []rpc.API}</code></pre><h3 id="ethhash-å®ç°åˆ†æ"><a href="#ethhash-å®ç°åˆ†æ" class="headerlink" title="ethhash å®ç°åˆ†æ"></a>ethhash å®ç°åˆ†æ</h3><h4 id="ethhash-ç»“æ„ä½“"><a href="#ethhash-ç»“æ„ä½“" class="headerlink" title="ethhash ç»“æ„ä½“"></a>ethhash ç»“æ„ä½“</h4><pre><code class="go">type Ethash struct {    config Config    // ç¼“å­˜    caches   *lru // In memory caches to avoid regenerating too often    // å†…å­˜æ•°æ®é›†    datasets *lru // In memory datasets to avoid regenerating too often    // Mining related fields    rand     *rand.Rand    // Properly seeded random source for nonces    // æŒ–çŸ¿çº¿ç¨‹æ•°é‡    threads  int           // Number of threads to mine on if mining    // channel ç”¨äºæ›´æ–°æŒ–çŸ¿é€šçŸ¥    update   chan struct{} // Notification channel to update mining parameters    hashrate metrics.Meter // Meter tracking the average hashrate    // æµ‹è¯•ç½‘ç»œç›¸å…³å‚æ•°    // The fields below are hooks for testing    shared    *Ethash       // Shared PoW verifier to avoid cache regeneration    fakeFail  uint64        // Block number which fails PoW check even in fake mode    fakeDelay time.Duration // Time delay to sleep for before returning from verify    lock sync.Mutex // Ensures thread safety for the in-memory caches and mining fields}</code></pre><p>Ethhashæ˜¯å®ç°PoWçš„å…·ä½“å®ç°ï¼Œç”±äºè¦ä½¿ç”¨åˆ°å¤§é‡çš„æ•°æ®é›†ï¼Œæ‰€ä»¥æœ‰ä¸¤ä¸ªæŒ‡å‘lruçš„æŒ‡é’ˆã€‚å¹¶ä¸”é€šè¿‡threadsæ§åˆ¶æŒ–çŸ¿çº¿ç¨‹æ•°ã€‚å¹¶åœ¨æµ‹è¯•æ¨¡å¼æˆ–fakeæ¨¡å¼ä¸‹ï¼Œç®€å•å¿«é€Ÿå¤„ç†ï¼Œä½¿ä¹‹å¿«é€Ÿå¾—åˆ°ç»“æœã€‚</p><p>Authoræ–¹æ³•è·å–äº†æŒ–å‡ºè¿™ä¸ªå—çš„çŸ¿å·¥åœ°å€ã€‚</p><pre><code class="go">func (ethash *Ethash) Author(header *types.Header) (common.Address, error) {    return header.Coinbase, nil}</code></pre><p>VerifyHeader ç”¨äºæ ¡éªŒåŒºå—å¤´éƒ¨ä¿¡æ¯æ˜¯å¦ç¬¦åˆethashå…±è¯†å¼•æ“è§„åˆ™ã€‚</p><pre><code class="go">// VerifyHeader checks whether a header conforms to the consensus rules of the// stock Ethereum ethash engine.func (ethash *Ethash) VerifyHeader(chain consensus.ChainReader, header *types.Header, seal bool) error {    // å½“å¤„äºModeFullFakeæ¨¡å¼æ—¶ï¼Œä»»æ„å¤´éƒ¨ä¿¡æ¯éƒ½æ¥å—    if ethash.config.PowMode == ModeFullFake {        return nil    }    // å¦‚æœè¯¥å¤´éƒ¨æ˜¯å·²çŸ¥çš„ï¼Œä¸ç”¨æ ¡éªŒï¼Œç›´æ¥è¿”å›ã€‚    number := header.Number.Uint64()    if chain.GetHeader(header.Hash(), number) != nil {        return nil    }    parent := chain.GetHeader(header.ParentHash, number-1)    if parent == nil {  // è·å–çˆ¶ç»“ç‚¹å¤±è´¥        return consensus.ErrUnknownAncestor    }    // è¿›ä¸€æ­¥è¿›è¡Œå¤´éƒ¨æ ¡éªŒ    return ethash.verifyHeader(chain, header, parent, false, seal)}</code></pre><p>ç„¶åå†çœ‹çœ‹verifyHeaderçš„å®ç°,</p><pre><code class="go">func (ethash *Ethash) verifyHeader(chain consensus.ChainReader, header, parent *types.Header, uncle bool, seal bool) error {    // ç¡®ä¿é¢å¤–æ•°æ®æ®µå…·æœ‰åˆç†çš„é•¿åº¦    if uint64(len(header.Extra)) &gt; params.MaximumExtraDataSize {        return fmt.Errorf("extra-data too long: %d &gt; %d", len(header.Extra), params.MaximumExtraDataSize)    }    // æ ¡éªŒæ—¶é—´æˆ³    if uncle {        if header.Time.Cmp(math.MaxBig256) &gt; 0 {            return errLargeBlockTime        }    } else {        if header.Time.Cmp(big.NewInt(time.Now().Add(allowedFutureBlockTime).Unix())) &gt; 0 {            return consensus.ErrFutureBlock        }    }    if header.Time.Cmp(parent.Time) &lt;= 0 {        return errZeroBlockTime    }    // æ ¹æ®æ—¶é—´æˆ³å’Œçˆ¶çº§å—çš„éš¾åº¦æ ¡éªŒå—çš„éš¾åº¦ã€‚    expected := ethash.CalcDifficulty(chain, header.Time.Uint64(), parent)    if expected.Cmp(header.Difficulty) != 0 {        return fmt.Errorf("invalid difficulty: have %v, want %v", header.Difficulty, expected)    }    // æ ¡éªŒgas limit &lt;= 2^63-1    cap := uint64(0x7fffffffffffffff)    if header.GasLimit &gt; cap {        return fmt.Errorf("invalid gasLimit: have %v, max %v", header.GasLimit, cap)    }    // æ ¡éªŒ gasUsed &lt;= gasLimit    if header.GasUsed &gt; header.GasLimit {        return fmt.Errorf("invalid gasUsed: have %d, gasLimit %d", header.GasUsed, header.GasLimit)    }    // gas limit æ˜¯å¦åœ¨å…è®¸èŒƒå›´å†…    diff := int64(parent.GasLimit) - int64(header.GasLimit)    if diff &lt; 0 {        diff *= -1    }    limit := parent.GasLimit / params.GasLimitBoundDivisor    if uint64(diff) &gt;= limit || header.GasLimit &lt; params.MinGasLimit {        return fmt.Errorf("invalid gas limit: have %d, want %d += %d", header.GasLimit, parent.GasLimit, limit)    }    // æ ¡éªŒåŒºå—å·åº”è¯¥æ˜¯çˆ¶å—åŒºå—å· +1    if diff := new(big.Int).Sub(header.Number, parent.Number); diff.Cmp(big.NewInt(1)) != 0 {        return consensus.ErrInvalidNumber    }    // æ ¡éªŒç‰¹å®šçš„å—æ˜¯å¦ç¬¦åˆè¦æ±‚    if seal {        if err := ethash.VerifySeal(chain, header); err != nil {            return err        }    }    // å¦‚æœæ‰€æœ‰æ£€æŸ¥é€šè¿‡ï¼Œåˆ™éªŒè¯ç¡¬åˆ†å‰çš„ç‰¹æ®Šå­—æ®µã€‚    if err := misc.VerifyDAOHeaderExtraData(chain.Config(), header); err != nil {        return err    }    if err := misc.VerifyForkHashes(chain.Config(), header, uncle); err != nil {        return err    }    return nil}</code></pre><p>Ethashé€šè¿‡CalcDifficultyå‡½æ•°è®¡ç®—ä¸‹ä¸€ä¸ªåŒºå—éš¾åº¦ï¼Œåˆ†åˆ«ä¸ºä¸åŒé˜¶æ®µçš„éš¾åº¦åˆ›å»ºäº†ä¸åŒçš„éš¾åº¦è®¡ç®—æ–¹æ³•ï¼Œè¿™é‡Œæš‚ä¸å±•å¼€æè¿°</p><pre><code class="go">func (ethash *Ethash) CalcDifficulty(chain consensus.ChainReader, time uint64, parent *types.Header) *big.Int {    return CalcDifficulty(chain.Config(), time, parent)}func CalcDifficulty(config *params.ChainConfig, time uint64, parent *types.Header) *big.Int {    next := new(big.Int).Add(parent.Number, big1)    switch {    case config.IsByzantium(next):        return calcDifficultyByzantium(time, parent)    case config.IsHomestead(next):        return calcDifficultyHomestead(time, parent)    default:        return calcDifficultyFrontier(time, parent)    }}</code></pre><p>VerifyHeaderså’ŒVerifyHeaderç±»ä¼¼ï¼Œåªæ˜¯VerifyHeadersè¿›è¡Œæ‰¹é‡æ ¡éªŒæ“ä½œã€‚åˆ›å»ºå¤šä¸ªgoroutineç”¨äºæ‰§è¡Œæ ¡éªŒæ“ä½œï¼Œå†åˆ›å»ºä¸€ä¸ªgoroutineç”¨äºèµ‹å€¼æ§åˆ¶ä»»åŠ¡åˆ†é…å’Œç»“æœè·å–ã€‚æœ€åè¿”å›ä¸€ä¸ªç»“æœchannel</p><pre><code class="go">func (ethash *Ethash) VerifyHeaders(chain consensus.ChainReader, headers []*types.Header, seals []bool) (chan&lt;- struct{}, &lt;-chan error) {    // If we're running a full engine faking, accept any input as valid    if ethash.config.PowMode == ModeFullFake || len(headers) == 0 {        abort, results := make(chan struct{}), make(chan error, len(headers))        for i := 0; i &lt; len(headers); i++ {            results &lt;- nil        }        return abort, results    }    // Spawn as many workers as allowed threads    workers := runtime.GOMAXPROCS(0)    if len(headers) &lt; workers {        workers = len(headers)    }    // Create a task channel and spawn the verifiers    var (        inputs = make(chan int)        done   = make(chan int, workers)        errors = make([]error, len(headers))        abort  = make(chan struct{})    )    // äº§ç”Ÿworkersä¸ªgoroutineç”¨äºæ ¡éªŒå¤´    for i := 0; i &lt; workers; i++ {        go func() {            for index := range inputs {                errors[index] = ethash.verifyHeaderWorker(chain, headers, seals, index)                done &lt;- index            }        }()    }    errorsOut := make(chan error, len(headers))    // goroutine ç”¨äºå‘é€ä»»åŠ¡åˆ°workersä¸ªgoroutineä¸Š    go func() {        defer close(inputs)        var (            in, out = 0, 0            checked = make([]bool, len(headers))            inputs  = inputs        )        for {            select {            case inputs &lt;- in:                if in++; in == len(headers) {                    // Reached end of headers. Stop sending to workers.                    inputs = nil                }            // ç»Ÿè®¡ç»“æœ,å¹¶æŠŠé”™è¯¯æ¶ˆæ¯å‘é€åˆ°errorsOutä¸Š            case index := &lt;-done:                for checked[index] = true; checked[out]; out++ {                    errorsOut &lt;- errors[out]                    if out == len(headers)-1 {                        return                    }                }            case &lt;-abort:                return            }        }    }()    return abort, errorsOut}</code></pre><p>VerifyHeadersåœ¨æ ¡éªŒå•ä¸ªåŒºå—å¤´çš„æ—¶å€™ä½¿ç”¨äº†verifyHeaderWorkerï¼Œè¯¥å‡½æ•°è·å–çˆ¶åŒºå—åï¼Œè°ƒç”¨verifyHeaderè¿›è¡Œæ ¡éªŒ</p><pre><code class="go">func (ethash *Ethash) verifyHeaderWorker(chain consensus.ChainReader, headers []*types.Header, seals []bool, index int) error {    var parent *types.Header    if index == 0 {        parent = chain.GetHeader(headers[0].ParentHash, headers[0].Number.Uint64()-1)    } else if headers[index-1].Hash() == headers[index].ParentHash {        parent = headers[index-1]    }    if parent == nil {        return consensus.ErrUnknownAncestor    }    if chain.GetHeader(headers[index].Hash(), headers[index].Number.Uint64()) != nil {        return nil // known block    }    return ethash.verifyHeader(chain, headers[index], parent, false, seals[index])}</code></pre><p>VerifyUnclesç”¨äºå”å—çš„æ ¡éªŒã€‚å’Œæ ¡éªŒåŒºå—å¤´ç±»ä¼¼ï¼Œå”å—æ ¡éªŒåœ¨ModeFullFakeæ¨¡å¼ä¸‹ç›´æ¥è¿”å›æ ¡éªŒæˆåŠŸã€‚è·å–æ‰€æœ‰çš„å”å—ï¼Œç„¶åéå†æ ¡éªŒï¼Œæ ¡éªŒå¤±è´¥å³ç»ˆæ­¢ï¼Œæˆ–è€…æ ¡éªŒå®Œæˆè¿”å›ã€‚</p><pre><code class="go">func (ethash *Ethash) VerifyUncles(chain consensus.ChainReader, block *types.Block) error {    // If we're running a full engine faking, accept any input as valid    if ethash.config.PowMode == ModeFullFake {        return nil    }    // Verify that there are at most 2 uncles included in this block    if len(block.Uncles()) &gt; maxUncles {        return errTooManyUncles    }    // æ”¶é›†å”å—åŠå…¶ç¥–å…ˆ    uncles, ancestors := set.New(), make(map[common.Hash]*types.Header)    number, parent := block.NumberU64()-1, block.ParentHash()    for i := 0; i &lt; 7; i++ {        ancestor := chain.GetBlock(parent, number)        if ancestor == nil {            break        }        ancestors[ancestor.Hash()] = ancestor.Header()        for _, uncle := range ancestor.Uncles() {            uncles.Add(uncle.Hash())        }        parent, number = ancestor.ParentHash(), number-1    }    ancestors[block.Hash()] = block.Header()    uncles.Add(block.Hash())    // æ ¡éªŒæ¯ä¸ªå”å—    for _, uncle := range block.Uncles() {        // Make sure every uncle is rewarded only once        hash := uncle.Hash()        if uncles.Has(hash) {            return errDuplicateUncle        }        uncles.Add(hash)        // Make sure the uncle has a valid ancestry        if ancestors[hash] != nil {            return errUncleIsAncestor        }        if ancestors[uncle.ParentHash] == nil || uncle.ParentHash == block.ParentHash() {            return errDanglingUncle        }        if err := ethash.verifyHeader(chain, uncle, ancestors[uncle.ParentHash], true, true); err != nil {            return err        }    }    return nil}</code></pre><p>Prepareå®ç°å…±è¯†å¼•æ“çš„Prepareæ¥å£ï¼Œç”¨äºå¡«å……åŒºå—å¤´çš„éš¾åº¦å­—æ®µï¼Œä½¿ä¹‹ç¬¦åˆethashåè®®ã€‚è¿™ä¸ªæ”¹å˜æ˜¯åœ¨çº¿çš„ã€‚</p><pre><code class="go">func (ethash *Ethash) Prepare(chain consensus.ChainReader, header *types.Header) error {    parent := chain.GetHeader(header.ParentHash, header.Number.Uint64()-1)    if parent == nil {        return consensus.ErrUnknownAncestor    }    header.Difficulty = ethash.CalcDifficulty(chain, header.Time.Uint64(), parent)    return nil}</code></pre><p>Finalizeå®ç°å…±è¯†å¼•æ“çš„Finalizeæ¥å£,å¥–åŠ±æŒ–åˆ°åŒºå—è´¦æˆ·å’Œå”å—è´¦æˆ·ï¼Œå¹¶å¡«å……çŠ¶æ€æ ‘çš„æ ¹çš„å€¼ã€‚å¹¶è¿”å›æ–°çš„åŒºå—ã€‚</p><pre><code class="go">func (ethash *Ethash) Finalize(chain consensus.ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction, uncles []*types.Header, receipts []*types.Receipt) (*types.Block, error) {    // Accumulate any block and uncle rewards and commit the final state root    accumulateRewards(chain.Config(), state, header, uncles)    header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))    // Header seems complete, assemble into a block and return    return types.NewBlock(header, txs, uncles, receipts), nil}func accumulateRewards(config *params.ChainConfig, state *state.StateDB, header *types.Header, uncles []*types.Header) {    // Select the correct block reward based on chain progression    blockReward := FrontierBlockReward    if config.IsByzantium(header.Number) {        blockReward = ByzantiumBlockReward    }    // Accumulate the rewards for the miner and any included uncles    reward := new(big.Int).Set(blockReward)    r := new(big.Int)    // å¥–åŠ±å”å—è´¦æˆ·    for _, uncle := range uncles {        r.Add(uncle.Number, big8)        r.Sub(r, header.Number)        r.Mul(r, blockReward)        r.Div(r, big8)        state.AddBalance(uncle.Coinbase, r)        r.Div(blockReward, big32)        reward.Add(reward, r)    }    // å¥–åŠ±coinbaseè´¦æˆ·    state.AddBalance(header.Coinbase, reward)}</code></pre><h4 id="Sealå‡½æ•°å®ç°åˆ†æ"><a href="#Sealå‡½æ•°å®ç°åˆ†æ" class="headerlink" title="Sealå‡½æ•°å®ç°åˆ†æ"></a>Sealå‡½æ•°å®ç°åˆ†æ</h4><p>åœ¨CPUæŒ–çŸ¿éƒ¨åˆ†ï¼ŒCpuAgentçš„mineå‡½æ•°ï¼Œæ‰§è¡ŒæŒ–çŸ¿æ“ä½œçš„æ—¶å€™è°ƒç”¨äº†Sealå‡½æ•°ã€‚Sealå‡½æ•°å°è¯•æ‰¾å‡ºä¸€ä¸ªæ»¡è¶³åŒºå—éš¾åº¦çš„nonceå€¼ã€‚<br>åœ¨ModeFakeå’ŒModeFullFakeæ¨¡å¼ä¸‹ï¼Œå¿«é€Ÿè¿”å›ï¼Œå¹¶ä¸”ç›´æ¥å°†nonceå€¼å–0ã€‚<br>åœ¨shared PoWæ¨¡å¼ä¸‹ï¼Œä½¿ç”¨sharedçš„Sealå‡½æ•°ã€‚<br>å¼€å¯threadsä¸ªgoroutineè¿›è¡ŒæŒ–çŸ¿(æŸ¥æ‰¾ç¬¦åˆæ¡ä»¶çš„nonceå€¼)ã€‚</p><pre><code class="go">// Seal implements consensus.Engine, attempting to find a nonce that satisfies// the block's difficulty requirements.func (ethash *Ethash) Seal(chain consensus.ChainReader, block *types.Block, stop &lt;-chan struct{}) (*types.Block, error) {    // åœ¨ModeFakeå’ŒModeFullFakeæ¨¡å¼ä¸‹ï¼Œå¿«é€Ÿè¿”å›ï¼Œå¹¶ä¸”ç›´æ¥å°†nonceå€¼å–0ã€‚    if ethash.config.PowMode == ModeFake || ethash.config.PowMode == ModeFullFake {        header := block.Header()        header.Nonce, header.MixDigest = types.BlockNonce{}, common.Hash{}        return block.WithSeal(header), nil    }    // åœ¨shared PoWæ¨¡å¼ä¸‹ï¼Œä½¿ç”¨sharedçš„Sealå‡½æ•°ã€‚    if ethash.shared != nil {        return ethash.shared.Seal(chain, block, stop)    }    // Create a runner and the multiple search threads it directs    abort := make(chan struct{})    found := make(chan *types.Block)    ethash.lock.Lock()    threads := ethash.threads    if ethash.rand == nil {        seed, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))        if err != nil {            ethash.lock.Unlock()            return nil, err        }        ethash.rand = rand.New(rand.NewSource(seed.Int64()))    }    ethash.lock.Unlock()    if threads == 0 {        threads = runtime.NumCPU()    }    if threads &lt; 0 {        threads = 0 // Allows disabling local mining without extra logic around local/remote    }    var pend sync.WaitGroup    for i := 0; i &lt; threads; i++ {        pend.Add(1)        go func(id int, nonce uint64) {            defer pend.Done()            ethash.mine(block, id, nonce, abort, found)        }(i, uint64(ethash.rand.Int63()))    }    // Wait until sealing is terminated or a nonce is found    var result *types.Block    select {    case &lt;-stop:        // Outside abort, stop all miner threads        close(abort)    case result = &lt;-found:        // One of the threads found a block, abort all others        close(abort)    case &lt;-ethash.update:        // Thread count was changed on user request, restart        close(abort)        pend.Wait()        return ethash.Seal(chain, block, stop)    }    // ç­‰å¾…æ‰€æœ‰çš„æŒ–çŸ¿goroutineè¿”å›    pend.Wait()    return result, nil}</code></pre><p>mineæ˜¯çœŸæ­£çš„æŸ¥æ‰¾nonceå€¼çš„å‡½æ•°ï¼Œå®ƒä¸æ–­éå†æŸ¥æ‰¾nonceå€¼ï¼Œå¹¶è®¡ç®—PoWå€¼ä¸ç›®æ ‡å€¼è¿›è¡Œæ¯”è¾ƒã€‚<br>å…¶åŸç†å¯ä»¥ç®€è¿°ä¸ºä¸‹ï¼š</p><pre><code>                                RAND(h, n)  &lt;=  M / d</code></pre><p>è¿™é‡ŒMè¡¨ç¤ºä¸€ä¸ªæå¤§çš„æ•°ï¼Œè¿™é‡Œæ˜¯2^256-1ï¼›dè¡¨ç¤ºHeaderæˆå‘˜Difficultyã€‚RAND()æ˜¯ä¸€ä¸ªæ¦‚å¿µå‡½æ•°ï¼Œå®ƒä»£è¡¨äº†ä¸€ç³»åˆ—å¤æ‚çš„è¿ç®—ï¼Œå¹¶æœ€ç»ˆäº§ç”Ÿä¸€ä¸ªç±»ä¼¼éšæœºçš„æ•°ã€‚è¿™ä¸ªå‡½æ•°åŒ…æ‹¬ä¸¤ä¸ªåŸºæœ¬å…¥å‚ï¼šhæ˜¯Headerçš„å“ˆå¸Œå€¼(Header.HashNoNonce())ï¼Œnè¡¨ç¤ºHeaderæˆå‘˜Nonceã€‚æ•´ä¸ªå…³ç³»å¼å¯ä»¥å¤§è‡´ç†è§£ä¸ºï¼Œåœ¨æœ€å¤§ä¸è¶…è¿‡Mçš„èŒƒå›´å†…ï¼Œä»¥æŸä¸ªæ–¹å¼è¯•å›¾æ‰¾åˆ°ä¸€ä¸ªæ•°ï¼Œå¦‚æœè¿™ä¸ªæ•°ç¬¦åˆæ¡ä»¶(&lt;=M/d)ï¼Œé‚£ä¹ˆå°±è®¤ä¸ºSeal()æˆåŠŸã€‚<br>ç”±ä¸Šé¢çš„å…¬å¼å¯ä»¥å¾—çŸ¥ï¼ŒMæ’å®šï¼Œdè¶Šå¤§åˆ™å¯å–èŒƒå›´è¶Šå°ã€‚æ‰€ä»¥å½“éš¾åº¦å€¼å¢åŠ æ—¶ï¼ŒæŒ–å‡ºåŒºå—çš„éš¾åº¦ä¹Ÿåœ¨å¢åŠ ã€‚</p><pre><code class="go">func (ethash *Ethash) mine(block *types.Block, id int, seed uint64, abort chan struct{}, found chan *types.Block) {    // ä»åŒºå—å¤´ä¸­è·å–ä¸€äº›æ•°æ®    var (        header  = block.Header()        hash    = header.HashNoNonce().Bytes()        // target å³æŸ¥æ‰¾çš„PoWçš„ä¸Šé™ target = maxUint256/Difficulty        // å…¶ä¸­maxUint256 = 2^256-1  Difficultyå³éš¾åº¦å€¼        target  = new(big.Int).Div(maxUint256, header.Difficulty)        number  = header.Number.Uint64()        dataset = ethash.dataset(number)    )    // å°è¯•æŸ¥æ‰¾ä¸€ä¸ªnonceå€¼ï¼Œç›´åˆ°ç»ˆæ­¢æˆ–è€…æ‰¾åˆ°ç›®æ ‡å€¼    var (        attempts = int64(0)        nonce    = seed    )    logger := log.New("miner", id)    logger.Trace("Started ethash search for new nonces", "seed", seed)search:    for {        select {        case &lt;-abort:            // ç»ˆæ­¢æŒ–çŸ¿            logger.Trace("Ethash nonce search aborted", "attempts", nonce-seed)            ethash.hashrate.Mark(attempts)            break search        default:            // ä¸å¿…åœ¨æ¯ä¸ªnonceå€¼éƒ½æ›´æ–°hash rateï¼Œæ¯2^xä¸ªnonceå€¼æ›´æ–°ä¸€æ¬¡hash rate            attempts++            if (attempts % (1 &lt;&lt; 15)) == 0 {                ethash.hashrate.Mark(attempts)                attempts = 0            }            // ç”¨è¿™ä¸ªnonceè®¡ç®—PoWå€¼            digest, result := hashimotoFull(dataset.dataset, hash, nonce)            // å°†è®¡ç®—çš„ç»“æœä¸ç›®æ ‡å€¼æ¯”è¾ƒï¼Œå¦‚æœå°äºç›®æ ‡å€¼ï¼Œåˆ™æŸ¥æ‰¾æˆåŠŸã€‚            if new(big.Int).SetBytes(result).Cmp(target) &lt;= 0 {                // æŸ¥æ‰¾åˆ°nonceå€¼ï¼Œæ›´æ–°åŒºå—å¤´                header = types.CopyHeader(header)                header.Nonce = types.EncodeNonce(nonce)                header.MixDigest = common.BytesToHash(digest)                // æ‰“åŒ…åŒºå—å¤´å¹¶è¿”å›                select {                // WithSeal å°†æ–°çš„åŒºå—å¤´æ›¿æ¢æ—§çš„åŒºå—å¤´                case found &lt;- block.WithSeal(header):                    logger.Trace("Ethash nonce found and reported", "attempts", nonce-seed, "nonce", nonce)                case &lt;-abort:                    logger.Trace("Ethash nonce found but discarded", "attempts", nonce-seed, "nonce", nonce)                }                break search            }            nonce++        }    }    // Datasets are unmapped in a finalizer. Ensure that the dataset stays live    // during sealing so it's not unmapped while being read.    runtime.KeepAlive(dataset)}</code></pre><p>ä¸Šè¯‰å‡½æ•°è°ƒç”¨äº†hashimotoFullå‡½æ•°ç”¨æ¥è®¡ç®—PoWçš„å€¼ã€‚</p><pre><code class="go">func hashimotoFull(dataset []uint32, hash []byte, nonce uint64) ([]byte, []byte) {    lookup := func(index uint32) []uint32 {        offset := index * hashWords        return dataset[offset : offset+hashWords]    }    return hashimoto(hash, nonce, uint64(len(dataset))*4, lookup)}</code></pre><p>hashimotoç”¨äºèšåˆæ•°æ®ä»¥äº§ç”Ÿç‰¹å®šçš„åéƒ¨çš„hashå’Œnonceå€¼ã€‚<br><img src="/../../../images/ethereum/source_analysis/pow_hashimoto.png" alt="å›¾ç‰‡æ¥æºï¼šhttps://blog.csdn.net/metal1/article/details/79682636"><br>ç®€è¿°è¯¥éƒ¨åˆ†æµç¨‹:</p><ul><li><p>é¦–å…ˆï¼Œhashimoto()å‡½æ•°å°†å…¥å‚@hashå’Œ@nonceåˆå¹¶æˆä¸€ä¸ª40 bytesé•¿çš„æ•°ç»„ï¼Œå–å®ƒçš„SHA-512å“ˆå¸Œå€¼å–åseedï¼Œé•¿åº¦ä¸º64 bytesã€‚</p></li><li><p>ç„¶åï¼Œå°†seed[]è½¬åŒ–æˆä»¥uint32ä¸ºå…ƒç´ çš„æ•°ç»„mix[]ï¼Œæ³¨æ„ä¸€ä¸ªuint32æ•°ç­‰äº4 bytesï¼Œæ•…è€Œseed[]åªèƒ½è½¬åŒ–æˆ16ä¸ªuint32æ•°ï¼Œè€Œmix[]æ•°ç»„é•¿åº¦32ï¼Œæ‰€ä»¥æ­¤æ—¶mix[]æ•°ç»„å‰åå„åŠæ˜¯ç­‰å€¼çš„ã€‚</p></li><li><p>æ¥ç€ï¼Œlookup()å‡½æ•°ç™»åœºã€‚ç”¨ä¸€ä¸ªå¾ªç¯ï¼Œä¸æ–­è°ƒç”¨lookup()ä»å¤–éƒ¨æ•°æ®é›†ä¸­å–å‡ºuint32å…ƒç´ ç±»å‹æ•°ç»„ï¼Œå‘mix[]æ•°ç»„ä¸­æ··å…¥æœªçŸ¥çš„æ•°æ®ã€‚å¾ªç¯çš„æ¬¡æ•°å¯ç”¨å‚æ•°è°ƒèŠ‚ï¼Œç›®å‰è®¾ä¸º64æ¬¡ã€‚æ¯æ¬¡å¾ªç¯ä¸­ï¼Œå˜åŒ–ç”Ÿæˆå‚æ•°indexï¼Œä»è€Œä½¿å¾—æ¯æ¬¡è°ƒç”¨lookup()å‡½æ•°å–å‡ºçš„æ•°ç»„éƒ½å„ä¸ç›¸åŒã€‚è¿™é‡Œæ··å…¥æ•°æ®çš„æ–¹å¼æ˜¯ä¸€ç§ç±»ä¼¼å‘é‡â€œå¼‚æˆ–â€çš„æ“ä½œï¼Œæ¥è‡ªäºFNVç®—æ³•ã€‚<br>å¾…æ··æ·†æ•°æ®å®Œæˆåï¼Œå¾—åˆ°ä¸€ä¸ªåŸºæœ¬ä¸Šé¢ç›®å…¨éçš„mix[]ï¼Œé•¿åº¦ä¸º32çš„uint32æ•°ç»„ã€‚è¿™æ—¶ï¼Œå°†å…¶æŠ˜å (å‹ç¼©)æˆä¸€ä¸ªé•¿åº¦ç¼©å°æˆåŸé•¿1/4çš„uint32æ•°ç»„ï¼ŒæŠ˜å çš„æ“ä½œæ–¹æ³•è¿˜æ˜¯æ¥è‡ªFNVç®—æ³•ã€‚</p></li><li><p>æœ€åï¼Œå°†æŠ˜å åçš„mix[]ç”±é•¿åº¦ä¸º8çš„uint32å‹æ•°ç»„ç›´æ¥è½¬åŒ–æˆä¸€ä¸ªé•¿åº¦32çš„byteæ•°ç»„ï¼Œè¿™å°±æ˜¯è¿”å›å€¼@digestï¼›åŒæ—¶å°†ä¹‹å‰çš„seed[]æ•°ç»„ä¸digeståˆå¹¶å†å–ä¸€æ¬¡SHA-256å“ˆå¸Œå€¼ï¼Œå¾—åˆ°çš„é•¿åº¦32çš„byteæ•°ç»„ï¼Œå³è¿”å›å€¼@resultã€‚(è½¬è‡ª<a href="https://blog.csdn.net/metal1/article/details/79682636">https://blog.csdn.net/metal1/article/details/79682636</a>)</p><pre><code class="go">func hashimoto(hash []byte, nonce uint64, size uint64, lookup func(index uint32) []uint32) ([]byte, []byte) {  // è®¡ç®—ç†è®ºè¡Œæ•°  rows := uint32(size / mixBytes)  // å°† header+nonce into è£…æ¢ä¸º64å­—èŠ‚çš„seed  seed := make([]byte, 40)  copy(seed, hash)  binary.LittleEndian.PutUint64(seed[32:], nonce)  seed = crypto.Keccak512(seed)  seedHead := binary.LittleEndian.Uint32(seed)  // å°†seed[]è½¬åŒ–æˆä»¥uint32ä¸ºå…ƒç´ çš„æ•°ç»„mix[]  mix := make([]uint32, mixBytes/4)  for i := 0; i &lt; len(mix); i++ {      mix[i] = binary.LittleEndian.Uint32(seed[i%16*4:])  }  // å‘mix[]æ•°ç»„ä¸­æ··å…¥æœªçŸ¥çš„æ•°æ®  temp := make([]uint32, len(mix))  for i := 0; i &lt; loopAccesses; i++ {      parent := fnv(uint32(i)^seedHead, mix[i%len(mix)]) % rows      for j := uint32(0); j &lt; mixBytes/hashBytes; j++ {          copy(temp[j*hashWords:], lookup(2*parent+j))      }      fnvHash(mix, temp)  }  // å‹ç¼©æˆä¸€ä¸ªé•¿åº¦ç¼©å°æˆåŸé•¿1/4çš„uint32æ•°ç»„  for i := 0; i &lt; len(mix); i += 4 {      mix[i/4] = fnv(fnv(fnv(mix[i], mix[i+1]), mix[i+2]), mix[i+3])  }  mix = mix[:len(mix)/4]  digest := make([]byte, common.HashLength)  for i, val := range mix {      binary.LittleEndian.PutUint32(digest[i*4:], val)  }  return digest, crypto.Keccak256(append(seed, digest...))}</code></pre><h4 id="VerifySealå‡½æ•°å®ç°åˆ†æ"><a href="#VerifySealå‡½æ•°å®ç°åˆ†æ" class="headerlink" title="VerifySealå‡½æ•°å®ç°åˆ†æ"></a>VerifySealå‡½æ•°å®ç°åˆ†æ</h4><p>VerifySealç”¨äºæ ¡éªŒåŒºå—çš„nonceå€¼æ˜¯å¦æ»¡è¶³PoWéš¾åº¦è¦æ±‚ã€‚</p><pre><code class="go">func (ethash *Ethash) VerifySeal(chain consensus.ChainReader, header *types.Header) error {  // ModeFakeã€ModeFullFakeæ¨¡å¼ä¸æ ¡éªŒï¼Œç›´æ¥éªŒè¯é€šè¿‡ã€‚  if ethash.config.PowMode == ModeFake || ethash.config.PowMode == ModeFullFake {      time.Sleep(ethash.fakeDelay)      if ethash.fakeFail == header.Number.Uint64() {          return errInvalidPoW      }      return nil  }  // shared PoWä¸‹ï¼Œç”¨sharedçš„æ ¡éªŒæ–¹æ³•  if ethash.shared != nil {      return ethash.shared.VerifySeal(chain, header)  }  // Ensure that we have a valid difficulty for the block  if header.Difficulty.Sign() &lt;= 0 {      return errInvalidDifficulty  }  // è®¡ç®—digestå’ŒPoWå€¼å¹¶æ ¡éªŒåŒºå—å¤´  number := header.Number.Uint64()  cache := ethash.cache(number)  size := datasetSize(number)  if ethash.config.PowMode == ModeTest {      size = 32 * 1024  }  digest, result := hashimotoLight(size, cache.cache, header.HashNoNonce().Bytes(), header.Nonce.Uint64())  // Caches are unmapped in a finalizer. Ensure that the cache stays live  // until after the call to hashimotoLight so it's not unmapped while being used.  runtime.KeepAlive(cache)  if !bytes.Equal(header.MixDigest[:], digest) {      return errInvalidMixDigest  }  target := new(big.Int).Div(maxUint256, header.Difficulty)  // æ¯”è¾ƒæ˜¯å¦æ»¡è¶³ç›®æ ‡éš¾åº¦è¦æ±‚  if new(big.Int).SetBytes(result).Cmp(target) &gt; 0 {      return errInvalidPoW  }  return nil}</code></pre><p>hashimotoLightå’ŒhashimotoFullåŠŸèƒ½ç±»ä¼¼ï¼Œåªæ˜¯hashimotoLightä½¿ç”¨äº†å ç”¨å†…å­˜æ›´å°çš„ç¼“å­˜ã€‚</p><pre><code class="go">func hashimotoLight(size uint64, cache []uint32, hash []byte, nonce uint64) ([]byte, []byte) {  keccak512 := makeHasher(sha3.NewKeccak512())  lookup := func(index uint32) []uint32 {      rawData := generateDatasetItem(cache, index, keccak512)      data := make([]uint32, len(rawData)/4)      for i := 0; i &lt; len(data); i++ {          data[i] = binary.LittleEndian.Uint32(rawData[i*4:])      }      return data  }  return hashimoto(hash, nonce, size, lookup)}</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-ä»¥å¤ªåŠfast syncç®—æ³•</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8Afast%20sync%E7%AE%97%E6%B3%95/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8Afast%20sync%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>ç¿»è¯‘å†…å®¹æ¥è‡ª ( <a href="https://github.com/ethereum/go-ethereum/pull/1889">https://github.com/ethereum/go-ethereum/pull/1889</a> )</p><p>This PR aggregates a lot of small modifications to core, trie, eth and other packages to collectively implement the eth/63 fast synchronization algorithm. In short, geth â€“fast.</p><p>è¿™ä¸ªæäº¤è¯·æ±‚åŒ…å«äº†å¯¹coreï¼Œtrie,ethå’Œå…¶ä»–ä¸€äº›packageçš„å¾®å°çš„ä¿®æ”¹ï¼Œæ¥å…±åŒå®ç°eth/63çš„å¿«é€ŸåŒæ­¥ç®—æ³•ã€‚ ç®€å•æ¥è¯´ï¼Œ geth â€“fast.</p><h2 id="Algorithm-ç®—æ³•"><a href="#Algorithm-ç®—æ³•" class="headerlink" title="Algorithm ç®—æ³•"></a>Algorithm ç®—æ³•</h2><p>The goal of the the fast sync algorithm is to exchange processing power for bandwidth usage. Instead of processing the entire block-chain one link at a time, and replay all transactions that ever happened in history, fast syncing downloads the transaction receipts along the blocks, and pulls an entire recent state database. This allows a fast synced node to still retain its status an an archive node containing all historical data for user queries (and thus not influence the networkâ€™s health in general), but at the same time to reassemble a recent network state at a fraction of the time it would take full block processing.</p><p>å¿«é€ŸåŒæ­¥ç®—æ³•çš„ç›®æ ‡æ˜¯ç”¨å¸¦å®½æ¢è®¡ç®—ã€‚ å¿«é€ŸåŒæ­¥ä¸æ˜¯é€šè¿‡ä¸€ä¸ªé“¾æ¥å¤„ç†æ•´ä¸ªåŒºå—é“¾ï¼Œè€Œæ˜¯é‡æ”¾å†å²ä¸Šå‘ç”Ÿçš„æ‰€æœ‰äº‹åŠ¡ï¼Œå¿«é€ŸåŒæ­¥ä¼šæ²¿ç€è¿™äº›å—ä¸‹è½½äº‹åŠ¡å¤„ç†å•æ®ï¼Œç„¶åæ‹‰å–æ•´ä¸ªæœ€è¿‘çš„çŠ¶æ€æ•°æ®åº“ã€‚ è¿™å…è®¸å¿«é€ŸåŒæ­¥çš„èŠ‚ç‚¹ä»ç„¶ä¿æŒå…¶åŒ…å«ç”¨äºç”¨æˆ·æŸ¥è¯¢çš„æ‰€æœ‰å†å²æ•°æ®çš„å­˜æ¡£èŠ‚ç‚¹çš„çŠ¶æ€ï¼ˆå¹¶ä¸”å› æ­¤ä¸ä¼šä¸€èˆ¬åœ°å½±å“ç½‘ç»œçš„å¥åº·çŠ¶å†µï¼‰ï¼Œå¯¹äºæœ€æ–°çš„åŒºå—çŠ¶æ€æ›´æ”¹ï¼Œä¼šä½¿ç”¨å…¨é‡çš„åŒºå—å¤„ç†æ–¹å¼ã€‚</p><p>An outline of the fast sync algorithm would be:</p><ul><li>Similarly to classical sync, download the block headers and bodies that make up the blockchain</li><li>Similarly to classical sync, verify the header chainâ€™s consistency (POW, total difficulty, etc)</li><li>Instead of processing the blocks, download the transaction receipts as defined by the header</li><li>Store the downloaded blockchain, along with the receipt chain, enabling all historical queries</li><li>When the chain reaches a recent enough state (head - 1024 blocks), pause for state sync:<ul><li>Retrieve the entire Merkel Patricia state trie defined by the root hash of the pivot point</li><li>For every account found in the trie, retrieve itâ€™s contract code and internal storage state trie</li></ul></li><li>Upon successful trie download, mark the pivot point (head - 1024 blocks) as the current head</li><li>Import all remaining blocks (1024) by fully processing them as in the classical sync</li></ul><p>å¿«é€ŸåŒæ­¥ç®—æ³•çš„æ¦‚è¦ï¼š</p><ul><li>ä¸åŸæœ‰çš„åŒæ­¥ç±»ä¼¼ï¼Œä¸‹è½½ç»„æˆåŒºå—é“¾çš„åŒºå—å¤´å’ŒåŒºå—body</li><li>ç±»ä¼¼äºåŸæœ‰çš„åŒæ­¥ï¼ŒéªŒè¯åŒºå—å¤´çš„ä¸€è‡´æ€§ï¼ˆPOWï¼Œæ€»éš¾åº¦ç­‰ï¼‰</li><li>ä¸‹è½½ç”±åŒºå—å¤´å®šä¹‰çš„äº¤æ˜“æ”¶æ®,è€Œä¸æ˜¯å¤„ç†åŒºå—ã€‚</li><li>å­˜å‚¨ä¸‹è½½çš„åŒºå—é“¾å’Œæ”¶æ®é“¾ï¼Œå¯ç”¨æ‰€æœ‰å†å²æŸ¥è¯¢</li><li>å½“é“¾æ¡è¾¾åˆ°æœ€è¿‘çš„çŠ¶æ€ï¼ˆå¤´éƒ¨ - 1024ä¸ªå—ï¼‰æ—¶ï¼Œæš‚åœçŠ¶æ€åŒæ­¥ï¼š<ul><li>è·å–ç”± pivot pointå®šä¹‰çš„åŒºå—çš„å®Œæ•´çš„Merkel Patricia TrieçŠ¶æ€</li><li>å¯¹äºMerkel Patricia Trieé‡Œé¢çš„æ¯ä¸ªè´¦æˆ·ï¼Œè·å–ä»–çš„åˆçº¦ä»£ç å’Œä¸­é—´å­˜å‚¨çš„Trie</li></ul></li><li>å½“Merkel Patricia Trieä¸‹è½½æˆåŠŸåï¼Œå°†pivot pointå®šä¹‰çš„åŒºå—ä½œä¸ºå½“å‰çš„åŒºå—å¤´</li><li>é€šè¿‡åƒåŸæœ‰çš„åŒæ­¥ä¸€æ ·å¯¹å…¶è¿›è¡Œå®Œå…¨å¤„ç†ï¼Œå¯¼å…¥æ‰€æœ‰å‰©ä½™çš„å—ï¼ˆ1024ï¼‰</li></ul><h2 id="åˆ†æ-Analysis"><a href="#åˆ†æ-Analysis" class="headerlink" title="åˆ†æ Analysis"></a>åˆ†æ Analysis</h2><p>By downloading and verifying the entire header chain, we can guarantee with all the security of the classical sync, that the hashes (receipts, state tries, etc) contained within the headers are valid. Based on those hashes, we can confidently download transaction receipts and the entire state trie afterwards. Additionally, by placing the pivoting point (where fast sync switches to block processing) a bit below the current head (1024 blocks), we can ensure that even larger chain reorganizations can be handled without the need of a new sync (as we have all the state going that many blocks back).</p><p>é€šè¿‡ä¸‹è½½å’ŒéªŒè¯æ•´ä¸ªå¤´éƒ¨é“¾ï¼Œæˆ‘ä»¬å¯ä»¥ä¿è¯ä¼ ç»ŸåŒæ­¥çš„æ‰€æœ‰å®‰å…¨æ€§ï¼Œå¤´éƒ¨ä¸­åŒ…å«çš„å“ˆå¸Œï¼ˆæ”¶æ®ï¼ŒçŠ¶æ€å°è¯•ç­‰ï¼‰æ˜¯æœ‰æ•ˆçš„ã€‚ åŸºäºè¿™äº›å“ˆå¸Œï¼Œæˆ‘ä»¬å¯ä»¥è‡ªä¿¡åœ°ä¸‹è½½äº¤æ˜“æ”¶æ®å’Œæ•´ä¸ªçŠ¶æ€æ ‘ã€‚ å¦å¤–ï¼Œé€šè¿‡å°†pivoting pointï¼ˆå¿«é€ŸåŒæ­¥åˆ‡æ¢åˆ°åŒºå—å¤„ç†ï¼‰æ”¾ç½®åœ¨å½“å‰åŒºå—å¤´ï¼ˆ1024å—ï¼‰çš„ä¸‹æ–¹ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®ä¿ç”šè‡³å¯ä»¥å¤„ç†æ›´å¤§çš„åŒºå—é“¾é‡ç»„ï¼Œè€Œä¸éœ€è¦æ–°çš„åŒæ­¥ï¼ˆå› ä¸ºæˆ‘ä»¬æœ‰æ‰€æœ‰çš„çŠ¶æ€ TODOï¼‰ã€‚</p><h2 id="æ³¨æ„äº‹é¡¹-Caveats"><a href="#æ³¨æ„äº‹é¡¹-Caveats" class="headerlink" title="æ³¨æ„äº‹é¡¹ Caveats"></a>æ³¨æ„äº‹é¡¹ Caveats</h2><p>The historical block-processing based synchronization mechanism has two (approximately similarly costing) bottlenecks: transaction processing and PoW verification. The baseline fast sync algorithm successfully circumvents the transaction processing, skipping the need to iterate over every single state the system ever was in. However, verifying the proof of work associated with each header is still a notably CPU intensive operation.</p><p>åŸºäºå†å²å—å¤„ç†çš„åŒæ­¥æœºåˆ¶å…·æœ‰ä¸¤ä¸ªï¼ˆè¿‘ä¼¼ç›¸ä¼¼æˆæœ¬ï¼‰ç“¶é¢ˆï¼šäº¤æ˜“å¤„ç†å’ŒPoWéªŒè¯ã€‚ åŸºçº¿å¿«é€ŸåŒæ­¥ç®—æ³•æˆåŠŸåœ°ç»•å¼€äº†äº‹åŠ¡å¤„ç†ï¼Œè·³è¿‡äº†å¯¹ç³»ç»Ÿæ›¾ç»å¤„äºçš„æ¯ä¸€ä¸ªçŠ¶æ€è¿›è¡Œè¿­ä»£çš„éœ€è¦ã€‚ä½†æ˜¯ï¼ŒéªŒè¯ä¸æ¯ä¸ªå¤´ç›¸å…³è”çš„å·¥ä½œè¯æ˜ä»ç„¶æ˜¯CPUå¯†é›†å‹æ“ä½œã€‚</p><p>However, we can notice an interesting phenomenon during header verification. With a negligible probability of error, we can still guarantee the validity of the chain, only by verifying every K-th header, instead of each and every one. By selecting a single header at random out of every K headers to verify, we guarantee the validity of an N-length chain with the probability of (1/K)^(N/K) (i.e. we have 1/K chance to spot a forgery in K blocks, a verification thatâ€™s repeated N/K times).</p><p>ä½†æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨åŒºå—å¤´éªŒè¯æœŸé—´æ³¨æ„åˆ°ä¸€ä¸ªæœ‰è¶£çš„ç°è±¡ ç”±äºé”™è¯¯æ¦‚ç‡å¯ä»¥å¿½ç•¥ä¸è®¡ï¼Œæˆ‘ä»¬ä»ç„¶å¯ä»¥ä¿è¯é“¾çš„æœ‰æ•ˆæ€§ï¼Œåªéœ€è¦éªŒè¯æ¯ä¸ªç¬¬Kä¸ªå¤´ï¼Œè€Œä¸æ˜¯æ¯ä¸ªå¤´ã€‚ é€šè¿‡ä»æ¯ä¸ªKå¤´ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªå¤´æ¥éªŒè¯ï¼Œæˆ‘ä»¬ä¿è¯Né•¿åº¦é“¾çš„å¯èƒ½ä¼šè¢«ä¼ªé€ çš„æ¦‚ç‡ä¸ºï¼ˆ1 / Kï¼‰^ï¼ˆN / Kï¼‰ï¼ˆåœ¨Kå—ä¸­æˆ‘ä»¬æœ‰1 / Kçš„æœºä¼šå‘ç°ä¸€ä¸ªä¼ªé€ ï¼Œè€ŒéªŒè¯ç»è¡Œäº†N/Kæ¬¡ã€‚ï¼‰ã€‚</p><p>Letâ€™s define the negligible probability Pn as the probability of obtaining a 256 bit SHA3 collision (i.e. the hash Ethereum is built upon): 1/2^128. To honor the Ethereum security requirements, we need to choose the minimum chain length N (below which we veriy every header) and maximum K verification batch size such as (1/K)^(N/K) &lt;= Pn holds. Calculating this for various {N, K} pairs is pretty straighforward, a simple and lenient solution being <a href="http://play.golang.org/p/B-8sX_6Dq0">http://play.golang.org/p/B-8sX_6Dq0</a>.</p><p>æˆ‘ä»¬å°†å¯å¿½ç•¥æ¦‚ç‡Pnå®šä¹‰ä¸ºè·å¾—256ä½SHA3å†²çªï¼ˆä»¥å¤ªåŠçš„Hashç®—æ³•ï¼‰çš„æ¦‚ç‡ï¼š1/2 ^ 128ã€‚ ä¸ºäº†éµå®ˆä»¥å¤ªåŠçš„å®‰å…¨è¦æ±‚ï¼Œæˆ‘ä»¬éœ€è¦é€‰æ‹©æœ€å°é“¾é•¿Nï¼ˆåœ¨æˆ‘ä»¬æ¯ä¸ªå—éƒ½éªŒè¯ä¹‹å‰ï¼‰ï¼Œæœ€å¤§KéªŒè¯æ‰¹é‡å¤§å°å¦‚ï¼ˆ1 / Kï¼‰^ï¼ˆN / Kï¼‰&lt;= Pnã€‚ å¯¹å„ç§{Nï¼ŒK}å¯¹è¿›è¡Œè®¡ç®—æ˜¯éå¸¸ç›´æ¥çš„ï¼Œä¸€ä¸ªç®€å•å’Œå®½æ¾çš„è§£å†³æ–¹æ¡ˆæ˜¯<a href="http://play.golang.org/p/B-8sX_6Dq0%E3%80%82">http://play.golang.org/p/B-8sX_6Dq0ã€‚</a></p><table><thead><tr><th>N</th><th>K</th><th>N</th><th>K</th><th>N</th><th>K</th><th>N</th><th>K</th></tr></thead><tbody><tr><td>1024</td><td>43</td><td>1792</td><td>91</td><td>2560</td><td>143</td><td>3328</td><td>198</td></tr><tr><td>1152</td><td>51</td><td>1920</td><td>99</td><td>2688</td><td>152</td><td>3456</td><td>207</td></tr><tr><td>1280</td><td>58</td><td>2048</td><td>108</td><td>2816</td><td>161</td><td>3584</td><td>217</td></tr><tr><td>1408</td><td>66</td><td>2176</td><td>116</td><td>2944</td><td>170</td><td>3712</td><td>226</td></tr><tr><td>1536</td><td>74</td><td>2304</td><td>128</td><td>3072</td><td>179</td><td>3840</td><td>236</td></tr><tr><td>1664</td><td>82</td><td>2432</td><td>134</td><td>3200</td><td>189</td><td>3968</td><td>246</td></tr></tbody></table><p>The above table should be interpreted in such a way, that if we verify every K-th header, after N headers the probability of a forgery is smaller than the probability of an attacker producing a SHA3 collision. It also means, that if a forgery is indeed detected, the last N headers should be discarded as not safe enough. Any {N, K} pair may be chosen from the above table, and to keep the numbers reasonably looking, we chose N=2048, K=100. This will be fine tuned later after being able to observe network bandwidth/latency effects and possibly behavior on more CPU limited devices.</p><p>ä¸Šé¢çš„è¡¨æ ¼åº”è¯¥è¿™æ ·è§£é‡Šï¼šå¦‚æœæˆ‘ä»¬æ¯éš”Kä¸ªåŒºå—å¤´éªŒè¯ä¸€æ¬¡åŒºå—å¤´ï¼Œåœ¨Nä¸ªåŒºå—å¤´ä¹‹åï¼Œä¼ªé€ çš„æ¦‚ç‡å°äºæ”»å‡»è€…äº§ç”ŸSHA3å†²çªçš„æ¦‚ç‡ã€‚ è¿™ä¹Ÿæ„å‘³ç€ï¼Œå¦‚æœç¡®å®å‘ç°äº†ä¼ªé€ ï¼Œé‚£ä¹ˆæœ€åçš„Nä¸ªå¤´éƒ¨åº”è¯¥è¢«ä¸¢å¼ƒï¼Œå› ä¸ºä¸å¤Ÿå®‰å…¨ã€‚ å¯ä»¥ä»ä¸Šè¡¨ä¸­é€‰æ‹©ä»»ä½•{Nï¼ŒK}å¯¹ï¼Œä¸ºäº†é€‰æ‹©ä¸€ä¸ªçœ‹èµ·æ¥å¥½çœ‹ç‚¹çš„æ•°å­—ï¼Œæˆ‘ä»¬é€‰æ‹©N = 2048ï¼ŒK = 100ã€‚ åç»­å¯èƒ½ä¼šæ ¹æ®ç½‘ç»œå¸¦å®½/å»¶è¿Ÿå½±å“ä»¥åŠå¯èƒ½åœ¨ä¸€äº›CPUæ€§èƒ½æ¯”è¾ƒå—é™çš„è®¾å¤‡ä¸Šè¿è¡Œçš„æƒ…å†µæ¥è¿›è¡Œè°ƒæ•´ã€‚</p><p>Using this caveat however would mean, that the pivot point can be considered secure only after N headers have been imported after the pivot itself. To prove the pivot safe faster, we stop the â€œgapped verificatiosâ€ X headers before the pivot point, and verify every single header onward, including an additioanl X headers post-pivot before accepting the pivotâ€™s state. Given the above N and K numbers, we chose X=24 as a safe number.</p><p>ç„¶è€Œï¼Œä½¿ç”¨è¿™ä¸ªç‰¹æ€§æ„å‘³ç€ï¼Œåªæœ‰å¯¼å…¥Nä¸ªåŒºå—ä¹‹åå†å¯¼å…¥pivotèŠ‚ç‚¹æ‰è¢«è®¤ä¸ºæ˜¯å®‰å…¨çš„ã€‚ ä¸ºäº†æ›´å¿«åœ°è¯æ˜pivotçš„å®‰å…¨æ€§ï¼Œæˆ‘ä»¬åœ¨è·ç¦»pivotèŠ‚ç‚¹Xè·ç¦»çš„åœ°æ–¹åœæ­¢éš”å—éªŒè¯çš„è¡Œä¸º,å¯¹éšåå‡ºç°çš„æ¯ä¸€ä¸ªå—è¿›è¡ŒéªŒè¯ç›´åˆ°pivotã€‚ é‰´äºä¸Šè¿°Nå’ŒKæ•°å­—ï¼Œæˆ‘ä»¬é€‰æ‹©X = 24ä½œä¸ºå®‰å…¨æ•°å­—ã€‚</p><p>With this caveat calculated, the fast sync should be modified so that up to the pivoting point - X, only every K=100-th header should be verified (at random), after which all headers up to pivot point + X should be fully verified before starting state database downloading. Note: if a sync fails due to header verification the last N headers must be discarded as they cannot be trusted enough.</p><p>é€šè¿‡è®¡ç®—caveatï¼Œå¿«é€ŸåŒæ­¥éœ€è¦ä¿®æ”¹ä¸ºpivoting point - X,æ¯éš”100ä¸ªåŒºå—å¤´éšæœºæŒ‘é€‰å…¶ä¸­çš„ä¸€ä¸ªæ¥è¿›è¡ŒéªŒè¯ï¼Œä¹‹åçš„æ¯ä¸€ä¸ªå—éƒ½éœ€è¦åœ¨çŠ¶æ€æ•°æ®åº“ä¸‹è½½å®Œæˆä¹‹åå®Œå…¨éªŒè¯ï¼Œå¦‚æœå› ä¸ºåŒºå—å¤´éªŒè¯å¤±è´¥å¯¼è‡´çš„åŒæ­¥å¤±è´¥ï¼Œé‚£ä¹ˆæœ€åçš„Nä¸ªåŒºå—å¤´éƒ½éœ€è¦è¢«ä¸¢å¼ƒï¼Œåº”ä¸ºä»–ä»¬è¾¾ä¸åˆ°ä¿¡ä»»æ ‡å‡†ã€‚</p><h2 id="ç¼ºç‚¹-Weakness"><a href="#ç¼ºç‚¹-Weakness" class="headerlink" title="ç¼ºç‚¹ Weakness"></a>ç¼ºç‚¹ Weakness</h2><p>Blockchain protocols in general (i.e. Bitcoin, Ethereum, and the others) are susceptible to Sybil attacks, where an attacker tries to completely isolate a node from the rest of the network, making it believe a false truth as to what the state of the real network is. This permits the attacker to spend certain funds in both the real network and this â€œfake bubbleâ€. However, the attacker can only maintain this state as long as itâ€™s feeding new valid blocks it itself is forging; and to successfully shadow the real network, it needs to do this with a chain height and difficulty close to the real network. In short, to pull off a successful Sybil attack, the attacker needs to match the networkâ€™s hash rate, so itâ€™s a very expensive attack.</p><p>å¸¸è§çš„åŒºå—é“¾(æ¯”å¦‚æ¯”ç‰¹å¸ï¼Œä»¥å¤ªåŠä»¥åŠå…¶ä»–)æ˜¯æ¯”è¾ƒå®¹æ˜“å—å¥³å·«æ”»å‡»çš„å½±å“ï¼Œæ”»å‡»è€…è¯•å›¾æŠŠè¢«æ”»å‡»è€…ä»ä¸»ç½‘ç»œä¸Šå®Œå…¨éš”ç¦»å¼€ï¼Œè®©è¢«æ”»å‡»è€…æ¥æ”¶ä¸€ä¸ªè™šå‡çš„çŠ¶æ€ã€‚è¿™å°±å…è®¸æ”»å‡»è€…åœ¨çœŸå®çš„ç½‘ç»œåŒæ—¶è¿™ä¸ªè™šå‡çš„ç½‘ç»œä¸ŠèŠ±è´¹åŒä¸€ç¬”èµ„é‡‘ã€‚ç„¶è€Œè¿™ä¸ªéœ€è¦æ”»å‡»è€…æä¾›çœŸå®çš„è‡ªå·±é”»é€ çš„åŒºå—ï¼Œè€Œä¸”éœ€è¦æˆåŠŸçš„å½±å“çœŸå®çš„ç½‘ç»œï¼Œå°±éœ€è¦åœ¨åŒºå—é«˜åº¦å’Œéš¾åº¦ä¸Šæ¥è¿‘çœŸå®çš„ç½‘ç»œã€‚ç®€å•æ¥è¯´ï¼Œä¸ºäº†æˆåŠŸçš„å®æ–½å¥³å·«æ”»å‡»ï¼Œæ”»å‡»è€…éœ€è¦æ¥è¿‘ä¸»ç½‘ç»œçš„hash rateï¼Œæ‰€ä»¥æ˜¯ä¸€ä¸ªéå¸¸æ˜‚è´µçš„æ”»å‡»ã€‚</p><p>Compared to the classical Sybil attack, fast sync provides such an attacker with an extra ability, that of feeding a node a view of the network thatâ€™s not only different from the real network, but also that might go around the EVM mechanics. The Ethereum protocol only validates state root hashes by processing all the transactions against the previous state root. But by skipping the transaction processing, we cannot prove that the state root contained within the fast sync pivot point is valid or not, so as long as an attacker can maintain a fake blockchain thatâ€™s on par with the real network, it could create an invalid view of the networkâ€™s state.</p><p>ä¸ä¼ ç»Ÿçš„å¥³å·«æ”»å‡»ç›¸æ¯”ï¼Œå¿«é€ŸåŒæ­¥ä¸ºæ”»å‡»è€…æä¾›äº†ä¸€ç§é¢å¤–çš„èƒ½åŠ›ï¼Œå³ä¸ºèŠ‚ç‚¹æä¾›ä¸€ä¸ªä¸ä»…ä¸çœŸå®ç½‘ç»œä¸åŒçš„ç½‘ç»œè§†å›¾ï¼Œè€Œä¸”è¿˜å¯èƒ½ç»•è¿‡EVMæœºåˆ¶ã€‚ ä»¥å¤ªåŠåè®®åªé€šè¿‡å¤„ç†æ‰€æœ‰äº‹åŠ¡ä¸ä»¥å‰çš„çŠ¶æ€æ ¹æ¥éªŒè¯çŠ¶æ€æ ¹æ•£åˆ—ã€‚ ä½†æ˜¯é€šè¿‡è·³è¿‡äº‹åŠ¡å¤„ç†ï¼Œæˆ‘ä»¬æ— æ³•è¯æ˜å¿«é€ŸåŒæ­¥pivot pointä¸­åŒ…å«çš„state rootæ˜¯å¦æœ‰æ•ˆï¼Œæ‰€ä»¥åªè¦æ”»å‡»è€…èƒ½å¤Ÿä¿æŒä¸çœŸå®ç½‘ç»œç›¸åŒçš„å‡åŒºå—é“¾ï¼Œå°±å¯ä»¥åˆ›é€ ä¸€ä¸ªæ— æ•ˆçš„ç½‘ç»œçŠ¶æ€è§†å›¾ã€‚</p><p>To avoid opening up nodes to this extra attacker ability, fast sync (beside being solely opt-in) will only ever run during an initial sync (i.e. when the nodeâ€™s own blockchain is empty). After a node managed to successfully sync with the network, fast sync is forever disabled. This way anybody can quickly catch up with the network, but after the node caught up, the extra attack vector is plugged in. This feature permits users to safely use the fast sync flag (â€“fast), without having to worry about potential state root attacks happening to them in the future. As an additional safety feature, if a fast sync fails close to or after the random pivot point, fast sync is disabled as a safety precaution and the node reverts to full, block-processing based synchronization.</p><p>ä¸ºäº†é¿å…å°†èŠ‚ç‚¹å¼€æ”¾ç»™è¿™ä¸ªé¢å¤–çš„æ”»å‡»è€…èƒ½åŠ›ï¼Œå¿«é€ŸåŒæ­¥(ç‰¹åˆ«æŒ‡å®š)å°†åªåœ¨åˆå§‹åŒæ­¥æœŸé—´è¿è¡Œ(èŠ‚ç‚¹çš„æœ¬åœ°åŒºå—é“¾æ˜¯ç©ºçš„)ã€‚ åœ¨ä¸€ä¸ªèŠ‚ç‚¹æˆåŠŸä¸ç½‘ç»œåŒæ­¥åï¼Œå¿«é€ŸåŒæ­¥æ°¸è¿œè¢«ç¦ç”¨ã€‚ è¿™æ ·ä»»ä½•äººéƒ½å¯ä»¥å¿«é€Ÿåœ°èµ¶ä¸Šç½‘ç»œï¼Œä½†æ˜¯åœ¨èŠ‚ç‚¹è¿½ä¸Šä¹‹åï¼Œé¢å¤–çš„æ”»å‡»çŸ¢é‡å°±è¢«æ’å…¥äº†ã€‚è¿™ä¸ªç‰¹æ€§å…è®¸ç”¨æˆ·å®‰å…¨åœ°ä½¿ç”¨å¿«é€ŸåŒæ­¥æ ‡å¿—ï¼ˆâ€“fastï¼‰ï¼Œè€Œä¸ç”¨æ‹…å¿ƒæ½œåœ¨çš„çŠ¶æ€ åœ¨æœªæ¥å‘ç”Ÿçš„æ ¹æ”»å‡»ã€‚ ä½œä¸ºé™„åŠ çš„å®‰å…¨åŠŸèƒ½ï¼Œå¦‚æœå¿«é€ŸåŒæ­¥åœ¨éšæœº pivot pointé™„è¿‘æˆ–ä¹‹åå¤±è´¥ï¼Œåˆ™ä½œä¸ºå®‰å…¨é¢„é˜²æªæ–½ç¦ç”¨å¿«é€ŸåŒæ­¥ï¼Œå¹¶ä¸”èŠ‚ç‚¹æ¢å¤åˆ°åŸºäºå—å¤„ç†çš„å®Œå…¨åŒæ­¥ã€‚</p><h2 id="æ€§èƒ½-Performance"><a href="#æ€§èƒ½-Performance" class="headerlink" title="æ€§èƒ½ Performance"></a>æ€§èƒ½ Performance</h2><p>To benchmark the performance of the new algorithm, four separate tests were run: full syncing from scrath on Frontier and Olympic, using both the classical sync as well as the new sync mechanism. In all scenarios there were two nodes running on a single machine: a seed node featuring a fully synced database, and a leech node with only the genesis block pulling the data. In all test scenarios the seed node had a fast-synced database (smaller, less disk contention) and both nodes were given 1GB database cache (â€“cache=1024).</p><p>ä¸ºäº†å¯¹æ–°ç®—æ³•çš„æ€§èƒ½è¿›è¡ŒåŸºå‡†æµ‹è¯•ï¼Œè¿è¡Œäº†å››ä¸ªå•ç‹¬çš„æµ‹è¯•ï¼šä½¿ç”¨ç»å…¸åŒæ­¥ä»¥åŠæ–°çš„åŒæ­¥æœºåˆ¶ï¼Œä»Frontierå’ŒOlympicä¸Šçš„scrathå®Œå…¨åŒæ­¥ã€‚ åœ¨æ‰€æœ‰æƒ…å†µä¸‹ï¼Œåœ¨ä¸€å°æœºå™¨ä¸Šè¿è¡Œä¸¤ä¸ªèŠ‚ç‚¹ï¼šå…·æœ‰å®Œå…¨åŒæ­¥çš„æ•°æ®åº“çš„ç§å­èŠ‚ç‚¹ï¼Œä»¥åŠåªæœ‰èµ·å§‹å—æ‹‰åŠ¨æ•°æ®çš„æ°´è›­èŠ‚ç‚¹ã€‚ åœ¨æ‰€æœ‰æµ‹è¯•åœºæ™¯ä¸­ï¼Œç§å­èŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªå¿«é€ŸåŒæ­¥çš„æ•°æ®åº“ï¼ˆæ›´å°ï¼Œæ›´å°‘çš„ç£ç›˜äº‰ç”¨ï¼‰ï¼Œä¸¤ä¸ªèŠ‚ç‚¹éƒ½æœ‰1GBçš„æ•°æ®åº“ç¼“å­˜ï¼ˆâ€“cache = 1024ï¼‰ã€‚</p><p>The machine running the tests was a Zenbook Pro, Core i7 4720HQ, 12GB RAM, 256GB m.2 SSD, Ubuntu 15.04.</p><p>è¿è¡Œæµ‹è¯•çš„æœºå™¨æ˜¯Zenbook Proï¼ŒCore i7 4720HQï¼Œ12GB RAMï¼Œ256GB m.2 SSDï¼ŒUbuntu 15.04ã€‚</p><table><thead><tr><th>Dataset (blocks, states)</th><th align="center">Normal sync (time, db)</th><th align="right">Fast sync (time, db)</th></tr></thead><tbody><tr><td>Frontier, 357677 blocks, 42.4K states</td><td align="center">12:21 mins, 1.6 GB</td><td align="right">2:49 mins, 235.2 MB</td></tr><tr><td>Olympic, 837869 blocks, 10.2M states</td><td align="center">4:07:55 hours, 21 GB</td><td align="right">31:32 mins, 3.8 GB</td></tr></tbody></table><p>The resulting databases contain the entire blockchain (all blocks, all uncles, all transactions), every transaction receipt and generated logs, and the entire state trie of the head 1024 blocks. This allows a fast synced node to act as a full archive node from all intents and purposes.</p><p>ç»“æœæ•°æ®åº“åŒ…å«æ•´ä¸ªåŒºå—é“¾ï¼ˆæ‰€æœ‰åŒºå—ï¼Œæ‰€æœ‰çš„åŒºå—ï¼Œæ‰€æœ‰çš„äº¤æ˜“ï¼‰ï¼Œæ¯ä¸ªäº¤æ˜“æ”¶æ®å’Œç”Ÿæˆçš„æ—¥å¿—ï¼Œä»¥åŠå¤´1024å—çš„æ•´ä¸ªçŠ¶æ€æ ‘ã€‚ è¿™ä½¿å¾—ä¸€ä¸ªå¿«é€Ÿçš„åŒæ­¥èŠ‚ç‚¹å¯ä»¥å……å½“æ‰€æœ‰æ„å›¾å’Œç›®çš„çš„å®Œæ•´å½’æ¡£èŠ‚ç‚¹ã€‚</p><h2 id="ç»“æŸè¯­-Closing-remarks"><a href="#ç»“æŸè¯­-Closing-remarks" class="headerlink" title="ç»“æŸè¯­ Closing remarks"></a>ç»“æŸè¯­ Closing remarks</h2><p>The fast sync algorithm requires the functionality defined by eth/63. Because of this, testing in the live network requires for at least a handful of discoverable peers to update their nodes to eth/63. On the same note, verifying that the implementation is truly correct will also entail waiting for the wider deployment of eth/63.</p><p>å¿«é€ŸåŒæ­¥ç®—æ³•éœ€è¦ç”±eth / 63å®šä¹‰çš„åŠŸèƒ½ã€‚ æ­£å› ä¸ºå¦‚æ­¤ï¼Œç°ç½‘ä¸­çš„æµ‹è¯•è‡³å°‘éœ€è¦å°‘æ•°å‡ ä¸ªå¯å‘ç°çš„å¯¹ç­‰èŠ‚ç‚¹å°†å…¶èŠ‚ç‚¹æ›´æ–°åˆ°eth / 63ã€‚ åŒæ ·çš„è¯´æ˜ï¼ŒéªŒè¯è¿™ä¸ªå®æ–½æ˜¯å¦çœŸæ­£æ­£ç¡®è¿˜éœ€è¦ç­‰å¾…eth / 63çš„æ›´å¹¿æ³›éƒ¨ç½²ã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-ä»¥å¤ªåŠæµ‹è¯•ç½‘ç»œClique_PoAä»‹ç»</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9CClique_PoA%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9CClique_PoA%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/ethereum/EIPs/issues/225">https://github.com/ethereum/EIPs/issues/225</a></p><p>Cliqueçš„æ¨¡å¼ä¸‹ï¼Œç”¨æˆ·æ˜¯æ— æ³•è·å–ä»¥å¤ªå¸çš„ï¼Œå› ä¸ºæ— æ³•æŒ–çŸ¿ï¼Œæ‰€ä»¥å¦‚æœéœ€è¦ä»¥å¤ªå¸ï¼Œ éœ€è¦é€šè¿‡ç‰¹æ®Šçš„é€”å¾„æ¥è·å–ã€‚</p><p>å¯ä»¥é€šè¿‡è¿™ä¸ªç½‘ç«™è·å–ether</p><p><a href="https://faucet.rinkeby.io/">https://faucet.rinkeby.io/</a></p><p>éœ€è¦æœ‰google+è´¦å·ï¼Œfacebookæˆ–è€…twitterè´¦å·æ‰èƒ½è·å–ï¼Œ è¯¦ç»†çš„è·å–åŠæ³•å‚è€ƒä¸Šé¢çš„ç½‘ç«™ã€‚</p><p>Clique æ˜¯ä»¥å¤ªåŠçš„ä¸€ä¸ªPower of authority çš„å®ç°ï¼Œ ç°åœ¨ä¸»è¦åœ¨Rinkeby æµ‹è¯•ç½‘ç»œä½¿ç”¨ã€‚</p><h2 id="èƒŒæ™¯"><a href="#èƒŒæ™¯" class="headerlink" title="èƒŒæ™¯"></a>èƒŒæ™¯</h2><p>ä»¥å¤ªåŠçš„ç¬¬ä¸€ä¸ªå®˜æ–¹æµ‹è¯•ç½‘æ˜¯Mordenã€‚å®ƒä»2015å¹´7æœˆåˆ°2016å¹´11æœˆï¼Œç”±äºGethå’ŒParityä¹‹é—´ç´¯ç§¯çš„åƒåœ¾å’Œä¸€äº›testnetçš„å…±è¯†é—®é¢˜ï¼Œæœ€ç»ˆå†³å®šåœæ­¢é‡æ–°å¯åŠ¨testnetã€‚</p><p>Ropstenå°±è¿™æ ·è¯ç”Ÿäº†ï¼Œæ¸…ç†æ‰äº†æ‰€æœ‰çš„åƒåœ¾ï¼Œä»ä¸€ä¸ªå¹²å‡€çš„çŸ³æ¿å¼€å§‹ã€‚è¿™ä¸€è¿è¡ŒçŠ¶å†µä¸€ç›´æŒç»­åˆ°2017å¹´2æœˆåº•ï¼Œå½“æ—¶æ¶æ„è¡Œä¸ºè€…å†³å®šæ»¥ç”¨Powï¼Œå¹¶é€æ­¥å°†GasLimitä»æ­£å¸¸çš„470ä¸‡æé«˜åˆ°90äº¿ï¼Œæ­¤æ—¶å‘é€å·¨å¤§çš„äº¤æ˜“æŸå®³æ•´ä¸ªç½‘ç»œã€‚ç”šè‡³åœ¨æ­¤ä¹‹å‰ï¼Œæ”»å‡»è€…å°è¯•äº†å¤šæ¬¡éå¸¸é•¿çš„åŒºå—é“¾é‡ç»„ï¼Œå¯¼è‡´ä¸åŒå®¢æˆ·ç«¯ä¹‹é—´çš„ç½‘ç»œåˆ†è£‚ï¼Œç”šè‡³æ˜¯ä¸åŒçš„ç‰ˆæœ¬ã€‚</p><p>è¿™äº›æ”»å‡»çš„æ ¹æœ¬åŸå› åœ¨äºPoWç½‘ç»œçš„å®‰å…¨æ€§ä¸å®ƒèƒŒåçš„è®¡ç®—èƒ½åŠ›ä¸€æ ·å®‰å…¨ã€‚ä»é›¶å¼€å§‹é‡æ–°å¯åŠ¨ä¸€ä¸ªæ–°çš„æµ‹è¯•ç½‘ç»œå¹¶ä¸èƒ½è§£å†³ä»»ä½•é—®é¢˜ï¼Œå› ä¸ºæ”»å‡»è€…å¯ä»¥åå¤å®‰è£…ç›¸åŒçš„æ”»å‡»ã€‚Parity å›¢é˜Ÿå†³å®šé‡‡å–ä¸€ä¸ªç´§æ€¥çš„è§£å†³åŠæ³•ï¼Œå›æ»šå¤§é‡çš„åŒºå—ï¼Œåˆ¶å®šä¸€ä¸ªä¸å…è®¸GasLimitè¶…è¿‡ä¸€å®šé—¨æ§›çš„è½¯äº¤å‰ã€‚</p><p>è™½ç„¶è¿™ä¸ªè§£å†³æ–¹æ¡ˆå¯èƒ½åœ¨çŸ­æœŸå†…å·¥ä½œï¼š</p><p>è¿™å¹¶ä¸é«˜é›…ï¼šä»¥å¤ªåŠåº”è¯¥æœ‰åŠ¨æ€çš„é™åˆ¶<br>è¿™ä¸æ˜¯å¯ç§»æ¤çš„ï¼šå…¶ä»–å®¢æˆ·éœ€è¦è‡ªå·±å®ç°æ–°çš„forké€»è¾‘<br>å®ƒä¸åŒæ­¥æ¨¡å¼ä¸å…¼å®¹ï¼šfast syncå’Œè½»å®¢æˆ·ç«¯éƒ½è¿æ°”ä¸ä½³<br>è¿™åªæ˜¯å»¶é•¿äº†æ”»å‡»çš„æ—¶é—´ï¼šåƒåœ¾ä¾ç„¶å¯ä»¥åœ¨æ— å°½çš„æƒ…å†µä¸‹ç¨³æ­¥æ¨è¿›<br>Parityçš„è§£å†³æ–¹æ¡ˆè™½ç„¶ä¸å®Œç¾ï¼Œä½†ä»ç„¶å¯è¡Œã€‚æˆ‘æƒ³æå‡ºä¸€ä¸ªæ›´é•¿æœŸçš„æ›¿ä»£è§£å†³æ–¹æ¡ˆï¼Œæ¶‰åŠæ›´å¤šï¼Œä½†åº”è¯¥è¶³å¤Ÿç®€å•ï¼Œä»¥ä¾¿èƒ½å¤Ÿåœ¨åˆç†çš„æ—¶é—´å†…æ¨å‡ºã€‚</p><h2 id="æ ‡å‡†åŒ–çš„PoA"><a href="#æ ‡å‡†åŒ–çš„PoA" class="headerlink" title="æ ‡å‡†åŒ–çš„PoA"></a>æ ‡å‡†åŒ–çš„PoA</h2><p>å¦‚ä¸Šæ‰€è¿°ï¼Œåœ¨æ²¡æœ‰ä»·å€¼çš„ç½‘ç»œä¸­ï¼ŒPowä¸èƒ½å®‰å…¨åœ°å·¥ä½œã€‚ ä»¥å¤ªåŠæœ‰ä»¥Casperä¸ºåŸºç¡€çš„é•¿æœŸPoSç›®æ ‡ï¼Œä½†æ˜¯è¿™æ˜¯ä¸€ä¸ªç¹ççš„ç ”ç©¶ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸èƒ½å¾ˆå¿«ä¾é è¿™ä¸ªæ¥è§£å†³ä»Šå¤©çš„é—®é¢˜ã€‚ ç„¶è€Œï¼Œä¸€ç§è§£å†³æ–¹æ¡ˆå¾ˆå®¹æ˜“å®æ–½ï¼Œè€Œä¸”è¶³å¤Ÿæœ‰æ•ˆåœ°æ­£ç¡®åœ°ä¿®å¤æµ‹è¯•ç½‘ç»œï¼Œå³æƒå¨è¯æ˜æ–¹æ¡ˆï¼ˆproof-of-authority schemeï¼‰ã€‚</p><p>æ³¨æ„ï¼ŒParityç¡®å®æœ‰PoAçš„å®ç°ï¼Œè™½ç„¶çœ‹èµ·æ¥æ¯”éœ€è¦çš„æ›´å¤æ‚ï¼Œæ²¡æœ‰å¤ªå¤šçš„åè®®æ–‡æ¡£ï¼Œä½†æ˜¯å¾ˆéš¾çœ‹åˆ°å®ƒå¯ä»¥å’Œå…¶ä»–å®¢æˆ·ä¸€èµ·ç©ã€‚ æˆ‘æ¬¢è¿ä»–ä»¬åŸºäºä»–ä»¬çš„ç»éªŒæ¥ç»™æˆ‘çš„è¿™ä¸ªææ¡ˆæ›´å¤šçš„åé¦ˆã€‚</p><p>è¿™é‡Œæè¿°çš„PoAåè®®çš„ä¸»è¦è®¾è®¡ç›®æ ‡æ˜¯å®ç°å’ŒåµŒå…¥ä»»ä½•ç°æœ‰çš„ä»¥å¤ªåŠå®¢æˆ·ç«¯åº”è¯¥æ˜¯éå¸¸ç®€å•çš„ï¼ŒåŒæ—¶å…è®¸ä½¿ç”¨ç°æœ‰çš„åŒæ­¥æŠ€æœ¯ï¼ˆå¿«é€Ÿï¼Œè½»æ¾ï¼Œæ‰­æ›²ï¼‰ï¼Œè€Œä¸éœ€è¦å®¢æˆ·ç«¯å¼€å‘è€…æ·»åŠ  å®šåˆ¶é€»è¾‘åˆ°å…³é”®è½¯ä»¶ã€‚</p><h2 id="PoA101"><a href="#PoA101" class="headerlink" title="PoA101"></a>PoA101</h2><p>å¯¹äºé‚£äº›æ²¡æœ‰æ„è¯†åˆ°PoAå¦‚ä½•è¿ä½œçš„äººæ¥è¯´ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„åè®®ï¼Œè€Œä¸æ˜¯çŸ¿å·¥ä»¬ä¸ºäº†è§£å†³ä¸€ä¸ªå›°éš¾çš„é—®é¢˜è€Œç«ç›¸äº‰å¤ºï¼Œæˆæƒç­¾ç½²è€…å¯ä»¥éšæ—¶è‡ªè¡Œå†³å®šæ˜¯å¦åˆ›å»ºæ–°çš„å—ã€‚</p><p>æŒ‘æˆ˜å›´ç»•ç€å¦‚ä½•æ§åˆ¶æŒ–çŸ¿é¢‘ç‡ï¼Œå¦‚ä½•åœ¨ä¸åŒçš„ç­¾åè€…ä¹‹é—´åˆ†é…è´Ÿè½½ï¼ˆå’Œæœºä¼šï¼‰ä»¥åŠå¦‚ä½•åŠ¨æ€è°ƒæ•´ç­¾åè€…åˆ—è¡¨ã€‚ ä¸‹ä¸€èŠ‚å®šä¹‰ä¸€ä¸ªå¤„ç†æ‰€æœ‰è¿™äº›åœºæ™¯çš„å»ºè®®åè®®ã€‚</p><h2 id="Rinkeby-proof-of-authority"><a href="#Rinkeby-proof-of-authority" class="headerlink" title="Rinkeby proof-of-authority"></a>Rinkeby proof-of-authority</h2><p>æ€»ä½“æ¥è¯´ï¼Œæœ‰ä¸¤ç§åŒæ­¥åŒºå—é“¾çš„æ–¹æ³•ï¼š</p><ul><li>ä¼ ç»Ÿçš„æ–¹æ³•æ˜¯æŠŠæ‰€æœ‰çš„äº‹åŠ¡ä¸€ä¸ªæ¥ä¸€ä¸ªåœ°è¿›è¡Œèµ·å§‹å—å’Œç´§ç¼©ã€‚è¿™ç§æ–¹å¼å°è¯•è¿‡è€Œä¸”å·²ç»è¢«è¯æ˜åœ¨ä»¥å¤ªåŠè¿™ç§å¤æ‚çš„ç½‘ç»œä¸­éå¸¸è€—è´¹è®¡ç®—èµ„æºã€‚<br>å¦ä¸€ç§æ˜¯åªä¸‹è½½åŒºå—é“¾å¤´å¹¶éªŒè¯å®ƒä»¬çš„æœ‰æ•ˆæ€§ï¼Œæ­¤åå¯ä»¥ä»ç½‘ç»œä¸Šä¸‹è½½ä¸€ä¸ªä»»æ„çš„æœ€è¿‘çš„çŠ¶æ€å¹¶æ£€æŸ¥æœ€è¿‘çš„headerã€‚</li><li>PoAæ–¹æ¡ˆåŸºäºè¿™æ ·çš„æƒ³æ³•ï¼Œå³å—å¯èƒ½åªèƒ½ç”±å¯ä¿¡ç­¾ç½²äººå®Œæˆã€‚ å› æ­¤ï¼Œå®¢æˆ·ç«¯çœ‹åˆ°çš„æ¯ä¸ªå—ï¼ˆæˆ–headerï¼‰éƒ½å¯ä»¥ä¸å¯ä¿¡ä»»çš„ç­¾åè€…åˆ—è¡¨è¿›è¡ŒåŒ¹é…ã€‚ è¿™é‡Œé¢ä¸´çš„æŒ‘æˆ˜æ˜¯å¦‚ä½•ç»´æŠ¤ä¸€ä¸ªå¯ä»¥åŠæ—¶æ›´æ”¹çš„æˆæƒç­¾åè€…åˆ—è¡¨ï¼Ÿ æ˜æ˜¾çš„ç­”æ¡ˆï¼ˆå°†å…¶å­˜å‚¨åœ¨ä»¥å¤ªåŠåˆåŒä¸­ï¼‰ä¹Ÿæ˜¯é”™è¯¯çš„ç­”æ¡ˆï¼šåœ¨å¿«é€ŸåŒæ­¥æœŸé—´æ˜¯æ— æ³•è®¿é—®çŠ¶æ€çš„ã€‚</li></ul><p><strong>ç»´æŠ¤æˆæƒç­¾åè€…åˆ—è¡¨çš„åè®®å¿…é¡»å®Œå…¨åŒ…å«åœ¨å—å¤´ä¸­ã€‚</strong></p><p>ä¸‹ä¸€ä¸ªæ˜¾è€Œæ˜“è§çš„æƒ³æ³•æ˜¯æ”¹å˜å—æ ‡é¢˜çš„ç»“æ„ï¼Œè¿™æ ·å°±å¯ä»¥æ”¾å¼ƒPoWçš„æ¦‚å¿µï¼Œå¹¶å¼•å…¥æ–°çš„å­—æ®µæ¥è¿åˆæŠ•ç¥¨æœºåˆ¶ã€‚ è¿™ä¹Ÿæ˜¯é”™è¯¯çš„ç­”æ¡ˆï¼šåœ¨å¤šä¸ªå®ç°ä¸­æ›´æ”¹è¿™æ ·ä¸€ä¸ªæ ¸å¿ƒæ•°æ®ç»“æ„å°†æ˜¯ä¸€ä¸ªå¼€å‘ï¼Œç»´æŠ¤å’Œå®‰å…¨çš„å™©æ¢¦ã€‚</p><p><strong>ç»´æŠ¤æˆæƒç­¾åè€…åˆ—è¡¨çš„åè®®å¿…é¡»å®Œå…¨é€‚åˆå½“å‰çš„æ•°æ®æ¨¡å‹ã€‚</strong></p><p>æ‰€ä»¥ï¼Œæ ¹æ®ä»¥ä¸Šæ‰€è¿°ï¼Œæˆ‘ä»¬ä¸èƒ½ä½¿ç”¨EVMè¿›è¡ŒæŠ•ç¥¨ï¼Œè€Œæ˜¯ä¸å¾—ä¸æ±‚åŠ©äºåŒºå—å¤´ã€‚ è€Œä¸”æˆ‘ä»¬ä¸èƒ½æ”¹å˜åŒºå—å¤´å­—æ®µï¼Œè€Œä¸å¾—ä¸æ±‚åŠ©äºå½“å‰å¯ç”¨çš„å­—æ®µã€‚ æ²¡æœ‰å¤ªå¤šçš„é€‰æ‹©ã€‚</p><h3 id="æŠŠåŒºå—å¤´çš„ä¸€äº›å…¶ä»–å­—æ®µç”¨æ¥å®ç°æŠ•ç¥¨å’Œç­¾å"><a href="#æŠŠåŒºå—å¤´çš„ä¸€äº›å…¶ä»–å­—æ®µç”¨æ¥å®ç°æŠ•ç¥¨å’Œç­¾å" class="headerlink" title="æŠŠåŒºå—å¤´çš„ä¸€äº›å…¶ä»–å­—æ®µç”¨æ¥å®ç°æŠ•ç¥¨å’Œç­¾å"></a>æŠŠåŒºå—å¤´çš„ä¸€äº›å…¶ä»–å­—æ®µç”¨æ¥å®ç°æŠ•ç¥¨å’Œç­¾å</h3><p>å½“å‰ä»…ç”¨ä½œæœ‰è¶£å…ƒæ•°æ®çš„æœ€æ˜æ˜¾çš„å­—æ®µæ˜¯å—å¤´ä¸­çš„32å­—èŠ‚çš„ExtraDataéƒ¨åˆ†ã€‚ çŸ¿å·¥ä»¬é€šå¸¸æŠŠä»–ä»¬çš„å®¢æˆ·ç«¯å’Œç‰ˆæœ¬æ”¾åœ¨é‚£é‡Œï¼Œä½†æ˜¯æœ‰äº›äººç”¨å¦å¤–çš„â€œä¿¡æ¯â€å¡«å……å®ƒä»¬ã€‚ è¯¥åè®®å°†æ‰©å±•æ­¤å­—æ®µä»¥å¢åŠ 65å­—èŠ‚ç”¨æ¥å­˜æ”¾çŸ¿å·¥çš„KECç­¾åã€‚ è¿™å°†å…è®¸ä»»ä½•è·å¾—ä¸€ä¸ªåŒºå—çš„äººå‘˜æ ¹æ®æˆæƒç­¾åè€…çš„åå•å¯¹å…¶è¿›è¡ŒéªŒè¯ã€‚ åŒæ—¶å®ƒä¹Ÿä½¿å¾—åŒºå—å¤´ä¸­çš„çŸ¿å·¥åœ°å€çš„å­—æ®µä½œåºŸã€‚</p><p>è¯·æ³¨æ„ï¼Œæ›´æ”¹åŒºå—å¤´çš„é•¿åº¦æ˜¯éä¾µå…¥æ€§æ“ä½œï¼Œå› ä¸ºæ‰€æœ‰ä»£ç ï¼ˆä¾‹å¦‚RLPç¼–ç ï¼Œå“ˆå¸Œï¼‰éƒ½ä¸å¯çŸ¥ï¼Œæ‰€ä»¥å®¢æˆ·ç«¯ä¸éœ€è¦å®šåˆ¶é€»è¾‘ã€‚</p><p>ä»¥ä¸Šå°±è¶³ä»¥éªŒè¯ä¸€ä¸ªé“¾ï¼Œä½†æˆ‘ä»¬å¦‚ä½•æ›´æ–°ä¸€ä¸ªåŠ¨æ€çš„ç­¾åè€…åˆ—è¡¨ã€‚ ç­”æ¡ˆæ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ–°ä½¿ç”¨æ–°è¿‘è¿‡æ—¶çš„çŸ¿å·¥å­—æ®µbeneficiaryå’ŒPoAåºŸå¼ƒçš„nonceå­—æ®µæ¥åˆ›å»ºæŠ•ç¥¨åè®®ï¼š</p><ul><li>åœ¨å¸¸è§„å—ä¸­ï¼Œè¿™ä¸¤ä¸ªå­—æ®µéƒ½å°†è¢«è®¾ç½®ä¸ºé›¶ã€‚</li><li>å¦‚æœç­¾åè€…å¸Œæœ›å¯¹æˆæƒç­¾åäººåˆ—è¡¨è¿›è¡Œæ›´æ”¹ï¼Œåˆ™ä¼šï¼š<ul><li>å°†çŸ¿å·¥å­—æ®µ<strong>beneficiary</strong>è®¾ç½®ä¸ºå¸Œæœ›æŠ•ç¥¨çš„ç­¾ç½²è€…</li><li>å°†<strong>nonce</strong>è®¾ç½®ä¸º0æˆ–0xff â€¦ fæ¥æŠ•ç¥¨èµæˆæ·»åŠ æˆ–è¸¢å‡º</li></ul></li></ul><p>ä»»ä½•åŒæ­¥é“¾çš„å®¢æˆ·ç«¯éƒ½å¯ä»¥åœ¨æ•°æ®å—å¤„ç†è¿‡ç¨‹ä¸­â€œç»Ÿè®¡â€é€‰ç¥¨ï¼Œå¹¶é€šè¿‡æ™®é€šæŠ•ç¥¨ä¿æŒæˆæƒç­¾åè€…çš„åŠ¨æ€å˜åŒ–åˆ—è¡¨ã€‚ åˆå§‹çš„ä¸€ç»„ç­¾åè€…é€šè¿‡åˆ›ä¸–åŒºå—çš„å‚æ•°æä¾›ï¼ˆä»¥é¿å…åœ¨èµ·å§‹çŠ¶æ€ä¸­éƒ¨ç½²â€œæœ€åˆé€‰æ°‘åå•â€åˆåŒçš„å¤æ‚æ€§ï¼‰ã€‚</p><p>ä¸ºäº†é¿å…æœ‰ä¸€ä¸ªæ— é™çš„çª—å£æ¥ç»Ÿè®¡ç¥¨æ•°ï¼Œå¹¶ä¸”å…è®¸å®šæœŸæ¸…é™¤é™ˆæ—§çš„æè®®ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ–°ä½¿ç”¨ethashçš„æ¦‚å¿µ epochï¼Œæ¯ä¸ªepoch è½¬æ¢éƒ½ä¼šåˆ·æ–°æ‰€æœ‰æœªå†³çš„æŠ•ç¥¨ã€‚ æ­¤å¤–ï¼Œè¿™äº›epoch è½¬æ¢è¿˜å¯ä»¥ä½œä¸ºåŒ…å«å¤´éƒ¨é¢å¤–æ•°æ®å†…çš„å½“å‰æˆæƒç­¾åè€…åˆ—è¡¨çš„æ— çŠ¶æ€æ£€æŸ¥ç‚¹ã€‚ è¿™å…è®¸å®¢æˆ·ç«¯ä»…åŸºäºæ£€æŸ¥ç‚¹æ•£åˆ—è¿›è¡ŒåŒæ­¥ï¼Œè€Œä¸å¿…é‡æ’­åœ¨é“¾ä¸Šè¿›è¡Œçš„æ‰€æœ‰æŠ•ç¥¨ã€‚ å®ƒåŒæ ·å…è®¸ç”¨åŒ…å«äº†åˆå§‹ç­¾åè€…çš„åˆ›ä¸–åŒºå—æ¥å®Œå…¨å®šä¹‰åŒºå—é“¾</p><h3 id="æ”»å‡»åª’ä»‹ï¼šæ¶æ„ç­¾åè€…"><a href="#æ”»å‡»åª’ä»‹ï¼šæ¶æ„ç­¾åè€…" class="headerlink" title="æ”»å‡»åª’ä»‹ï¼šæ¶æ„ç­¾åè€…"></a>æ”»å‡»åª’ä»‹ï¼šæ¶æ„ç­¾åè€…</h3><p>å¯èƒ½å‘ç”Ÿæ¶æ„ç”¨æˆ·è¢«æ·»åŠ åˆ°ç­¾åè€…åˆ—è¡¨ä¸­ï¼Œæˆ–è€…ç­¾åè€…å¯†é’¥/æœºå™¨å—åˆ°å¨èƒã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œåè®®éœ€è¦èƒ½å¤ŸæŠµå¾¡é‡ç»„å’Œåƒåœ¾é‚®ä»¶ã€‚ æ‰€æå‡ºçš„è§£å†³æ–¹æ¡ˆæ˜¯ï¼Œç»™å®šNä¸ªæˆæƒç­¾åè€…çš„åˆ—è¡¨ï¼Œä»»ä½•ç­¾åè€…å¯èƒ½åªåœ¨æ¯ä¸ªKä¸­å¡«å……1ä¸ªå—ã€‚è¿™ç¡®ä¿æŸå®³æ˜¯æœ‰é™çš„ï¼Œå…¶ä½™çš„çŸ¿å·¥å¯ä»¥æŠ•å‡ºæ¶æ„ç”¨æˆ·ã€‚</p><h2 id="æ”»å‡»åª’ä»‹ï¼šå®¡æŸ¥ç­¾åè€…"><a href="#æ”»å‡»åª’ä»‹ï¼šå®¡æŸ¥ç­¾åè€…" class="headerlink" title="æ”»å‡»åª’ä»‹ï¼šå®¡æŸ¥ç­¾åè€…"></a>æ”»å‡»åª’ä»‹ï¼šå®¡æŸ¥ç­¾åè€…</h2><p>å¦ä¸€ä¸ªæœ‰è¶£çš„æ”»å‡»åª’ä»‹æ˜¯å¦‚æœä¸€ä¸ªç­¾åè€…ï¼ˆæˆ–è€…ä¸€ç»„ç­¾åè€…ï¼‰è¯•å›¾æ£€æŸ¥å‡ºä»æˆæƒåˆ—è¡¨ä¸­åˆ é™¤å®ƒä»¬çš„å—ã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬é™åˆ¶äº†ç­¾åè€…å…è®¸çš„æœ€å°é¢‘ç‡ä¸ºN / 2ã€‚ è¿™ç¡®ä¿äº†æ¶æ„ç­¾åè€…éœ€è¦æ§åˆ¶è‡³å°‘51ï¼…çš„ç­¾åå¸æˆ·ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ¸¸æˆå°±æ˜¯æ— è®ºå¦‚ä½•ä¹Ÿæ— æ³•è¿›è¡Œä¸‹å»äº†ã€‚</p><h2 id="æ”»å‡»åª’ä»‹ï¼šåƒåœ¾é‚®ä»¶ç­¾åè€…"><a href="#æ”»å‡»åª’ä»‹ï¼šåƒåœ¾é‚®ä»¶ç­¾åè€…" class="headerlink" title="æ”»å‡»åª’ä»‹ï¼šåƒåœ¾é‚®ä»¶ç­¾åè€…"></a>æ”»å‡»åª’ä»‹ï¼šåƒåœ¾é‚®ä»¶ç­¾åè€…</h2><p>æœ€åçš„å°å‹æ”»å‡»åª’ä»‹å°±æ˜¯æ¶æ„ç­¾ç½²è€…åœ¨æ¯ä¸€ä¸ªå—å†…æ³¨å…¥æ–°çš„æŠ•ç¥¨å»ºè®®ã€‚ ç”±äºèŠ‚ç‚¹éœ€è¦ç»Ÿè®¡æ‰€æœ‰æŠ•ç¥¨æ¥åˆ›å»ºæˆæƒç­¾åè€…çš„å®é™…åˆ—è¡¨ï¼Œæ‰€ä»¥ä»–ä»¬éœ€è¦é€šè¿‡æ—¶é—´è·Ÿè¸ªæ‰€æœ‰æŠ•ç¥¨ã€‚ æ²¡æœ‰é™åˆ¶æŠ•ç¥¨çª—å£ï¼Œè¿™å¯èƒ½ä¼šæ…¢æ…¢å¢é•¿ï¼Œä½†å´æ˜¯æ— é™çš„ã€‚ è§£å†³æ–¹æ³•æ˜¯æ”¾ç½®ä¸€ä¸ªWå—çš„ç§»åŠ¨çª—å£ï¼Œä¹‹åæŠ•ç¥¨è¢«è®¤ä¸ºæ˜¯é™ˆæ—§çš„ã€‚ ä¸€ä¸ªç†æ™ºçš„çª—æˆ·å¯èƒ½æ˜¯1-2ä¸ªæ—¶ä»£ã€‚ æˆ‘ä»¬å°†è¿™ç§°ä¸ºä¸€ä¸ªæ—¶ä»£ã€‚</p><h2 id="æ”»å‡»åª’ä»‹ï¼šå¹¶å‘å—"><a href="#æ”»å‡»åª’ä»‹ï¼šå¹¶å‘å—" class="headerlink" title="æ”»å‡»åª’ä»‹ï¼šå¹¶å‘å—"></a>æ”»å‡»åª’ä»‹ï¼šå¹¶å‘å—</h2><p>å¦‚æœæˆæƒç­¾åè€…çš„æ•°é‡æ˜¯Nï¼Œå¹¶ä¸”æˆ‘ä»¬å…è®¸æ¯ä¸ªç­¾åè€…åœ¨Kä¸­å¡«å……1ä¸ªå—ï¼Œé‚£ä¹ˆåœ¨ä»»ä½•æ—¶é—´N-Kä¸ªçŸ¿å·¥éƒ½è¢«å…è®¸ä¸ºMintã€‚ ä¸ºäº†é¿å…è¿™äº›äº‰å¤ºå—ï¼Œæ¯ä¸ªç­¾åè€…å°†æ·»åŠ ä¸€ä¸ªå°çš„éšæœºâ€œæŠµæ¶ˆâ€ï¼Œä»¥é‡Šæ”¾ä¸€ä¸ªæ–°çš„å—ã€‚ è¿™ç¡®ä¿äº†å°å‰å­æ˜¯ç½•è§çš„ï¼Œä½†å¶å°”è¿˜ä¼šå‘ç”Ÿï¼ˆå¦‚åœ¨ä¸»ç½‘ä¸Šï¼‰ã€‚ å¦‚æœä¸€ä¸ªç­¾åè€…è¢«æ»¥ç”¨æƒå¨è€Œå¼•èµ·æ··ä¹±ï¼Œé‚£ä¹ˆè¿™ä¸ªç­¾åå°±å¯ä»¥è¢«æŠ•ç¥¨å‡ºå»ã€‚</p><h2 id="æ³¨æ„"><a href="#æ³¨æ„" class="headerlink" title="æ³¨æ„"></a>æ³¨æ„</h2><h3 id="è¿™æ˜¯å¦è¡¨æ˜å»ºè®®æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªè¢«å®¡æŸ¥testnetï¼Ÿ"><a href="#è¿™æ˜¯å¦è¡¨æ˜å»ºè®®æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªè¢«å®¡æŸ¥testnetï¼Ÿ" class="headerlink" title="è¿™æ˜¯å¦è¡¨æ˜å»ºè®®æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªè¢«å®¡æŸ¥testnetï¼Ÿ"></a>è¿™æ˜¯å¦è¡¨æ˜å»ºè®®æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªè¢«å®¡æŸ¥testnetï¼Ÿ</h3><p>è¯¥æè®®è¡¨æ˜ï¼Œè€ƒè™‘åˆ°æŸäº›è¡Œä¸ºè€…çš„æ¶æ„æ€§è´¨ï¼Œå¹¶ä¸”é‰´äºâ€œå„æ–­èµ„é‡‘â€ç½‘ç»œä¸­PoWè®¡åˆ’çš„å¼±ç‚¹ï¼Œæœ€å¥½æ˜¯å»ºç«‹ä¸€ä¸ªç½‘ç»œï¼Œä½¿å…¶å…·æœ‰ä¸€å®šçš„åƒåœ¾è¿‡æ»¤åŠŸèƒ½ï¼Œå¼€å‘äººå‘˜å¯ä»¥ä¾é å®ƒæ¥æµ‹è¯•å…¶ç¨‹åºã€‚</p><p>ä¸ºä»€ä¹ˆè§„èŒƒPoAï¼Ÿ</p><p>ä¸åŒçš„å®¢æˆ·åœ¨ä¸åŒçš„æƒ…å†µä¸‹ä¼šæ›´å¥½ã€‚ Goå¯èƒ½åœ¨æœåŠ¡å™¨ç«¯ç¯å¢ƒä¸­å¾ˆæ£’ï¼Œä½†CPPå¯èƒ½æ›´é€‚åˆåœ¨RPI Zeroä¸Šè¿è¡Œã€‚</p><p>æ‰‹åŠ¨æŠ•ç¥¨æ˜¯ä¸æ˜¯å¾ˆéº»çƒ¦ï¼Ÿ</p><p>è¿™æ˜¯ä¸€ä¸ªå®ç°ç»†èŠ‚ï¼Œä½†æ˜¯ç­¾åè€…å¯ä»¥åˆ©ç”¨åŸºäºåˆåŒçš„æŠ•ç¥¨ç­–ç•¥ï¼Œåˆ©ç”¨EVMçš„å…¨éƒ¨åŠŸèƒ½ï¼Œåªå°†ç»“æœæ¨é€åˆ°å¹³å‡èŠ‚ç‚¹çš„å¤´éƒ¨è¿›è¡ŒéªŒè¯ã€‚</p><h2 id="æ¾„æ¸…å’Œåé¦ˆ"><a href="#æ¾„æ¸…å’Œåé¦ˆ" class="headerlink" title="æ¾„æ¸…å’Œåé¦ˆ"></a>æ¾„æ¸…å’Œåé¦ˆ</h2><ul><li><p>è¿™ä¸ªå»ºè®®å¹¶ä¸æ’é™¤å®¢æˆ·ç«¯è¿è¡ŒåŸºäºPoWçš„æµ‹è¯•ç½‘ç»œï¼Œæ— è®ºæ˜¯Ropstenè¿˜æ˜¯åŸºäºå®ƒçš„æ–°çš„æµ‹è¯•ç½‘ç»œã€‚ç†æƒ³çš„æƒ…å†µæ˜¯å®¢æˆ·æä¾›ä¸€ç§è¿æ¥PoWä»¥åŠåŸºäºPoAçš„æµ‹è¯•ç½‘ç»œçš„æ–¹æ³•ï¼ˆï¼ƒ225ï¼ˆè¯„è®ºï¼‰ï¼‰ã€‚</p></li><li><p>åè®®å‚æ•°å°½ç®¡å¯ä»¥åœ¨å®¢æˆ·ç«¯å®æ–½è€…çš„ç ´åä¸­è¿›è¡Œé…ç½®ï¼Œä½†Rinkebyç½‘ç»œåº”è¯¥å°½å¯èƒ½åœ°é è¿‘ä¸»ç½‘ç»œã€‚è¿™åŒ…æ‹¬åŠ¨æ€GasLimitï¼Œ15ç§’å·¦å³çš„å¯å˜åŒºå—æ—¶é—´ï¼ŒGasPriceç­‰ï¼ˆï¼ƒ225ï¼ˆè¯„è®ºï¼‰ï¼‰ã€‚</p></li><li><p>è¯¥æ–¹æ¡ˆè¦æ±‚è‡³å°‘æœ‰Kä¸ªç­¾åè€…éšæ—¶ä¸Šç½‘ï¼Œå› ä¸ºè¿™æ˜¯ç¡®ä¿â€œæœ€å°åŒ–â€å¤šæ ·æ€§æ‰€éœ€çš„æœ€å°‘äººæ•°ã€‚è¿™æ„å‘³ç€å¦‚æœè¶…è¿‡Kï¼Œåˆ™ç½‘ç»œåœæ­¢ã€‚è¿™åº”è¯¥é€šè¿‡ç¡®ä¿ç­¾åè€…æ˜¯é«˜è¿è¡Œæ—¶é—´çš„æœºå™¨æ¥è§£å†³ï¼Œå¹¶ä¸”åœ¨å‘ç”Ÿå¤ªå¤šæ•…éšœä¹‹å‰åŠæ—¶åœ°å°†å¤±è´¥çš„æœºå™¨æŠ•ç¥¨å‡ºå»ï¼ˆï¼ƒ225ï¼ˆè¯„è®ºï¼‰ï¼‰ã€‚</p></li><li><p>è¯¥ææ¡ˆå¹¶æ²¡æœ‰è§£å†³â€œåˆæ³•çš„â€åƒåœ¾é‚®ä»¶é—®é¢˜ï¼Œå°±åƒåœ¨æ”»å‡»è€…æœ‰æ•ˆåœ°ä½¿ç”¨testnetä»¥åˆ›å»ºåƒåœ¾ä¸€æ ·ï¼Œä½†æ˜¯å¦‚æœæ²¡æœ‰PoWæŒ–æ˜ï¼Œæ”»å‡»è€…å¯èƒ½æ— æ³•è·å¾—æ— é™çš„etheræ¥æ”»å‡»ã€‚ä¸€ç§å¯èƒ½æ€§æ˜¯ä»¥æœ‰é™çš„æ–¹å¼ï¼ˆä¾‹å¦‚æ¯å¤©10æ¬¡ï¼‰ï¼ˆï¼ƒ225ï¼ˆè¯„è®ºï¼‰ï¼‰ï¼Œä»¥GitHubï¼ˆæˆ–å…¶ä»–ä»»ä½•æ–¹å¼ï¼‰å¸æˆ·ä¸ºåŸºç¡€æä¾›ä¸€ä¸ªè·å–etherçš„é€”å¾„ã€‚</p></li><li><p>æœ‰äººå»ºè®®ä¸ºå½“æ—¶åŒ…å«æˆæƒç­¾åè€…åˆ—è¡¨çš„æ¯ä¸ªepochåˆ›å»ºcheckpoint blockã€‚è¿™å°†å…è®¸ç¨åçš„è½»å®¢æˆ·è¯´â€œä»è¿™é‡ŒåŒæ­¥â€ï¼Œè€Œä¸éœ€è¦ä»èµ·æºå¼€å§‹ã€‚è¿™å¯ä»¥åœ¨ç­¾åä¹‹å‰ä½œä¸ºå‰ç¼€æ·»åŠ åˆ°extradataå­—æ®µï¼ˆï¼ƒ225ï¼ˆcommentï¼‰ï¼‰ã€‚</p></li></ul><h2 id="Clique-PoA-ä¸€è‡´æ€§åè®®-Clique-proof-of-authority-consensus-protocol"><a href="#Clique-PoA-ä¸€è‡´æ€§åè®®-Clique-proof-of-authority-consensus-protocol" class="headerlink" title="Clique PoA ä¸€è‡´æ€§åè®® (Clique proof-of-authority consensus protocol )"></a>Clique PoA ä¸€è‡´æ€§åè®® (Clique proof-of-authority consensus protocol )</h2><p>æˆ‘ä»¬å®šä¹‰ä¸‹é¢çš„å¸¸é‡ï¼š</p><ul><li>EPOCH_LENGTHï¼šæ£€æŸ¥ç‚¹å¹¶é‡ç½®æœªå†³æŠ•ç¥¨çš„å—æ•°ã€‚<ul><li>å»ºè®®30000ï¼Œä»¥ä¾¿å’Œä¸»ç½‘ç»œçš„ethhash epochç±»ä¼¼</li></ul></li><li>BLOCK_PERIODï¼šä¸¤ä¸ªè¿ç»­å—çš„æ—¶é—´æˆ³ä¹‹é—´çš„æœ€å°å·®å¼‚ã€‚<ul><li>å»ºè®®15ï¼Œä»¥ä¾¿å’Œä¸»ç½‘ç»œçš„ethhash epochç±»ä¼¼</li></ul></li><li>EXTRA_VANITYï¼šå›ºå®šæ•°é‡çš„ExtraDataå‰ç¼€å­—èŠ‚ä¸ºç­¾åè€…vanityä¿ç•™ã€‚<ul><li>å»ºè®®çš„32ä¸ªå­—èŠ‚ä»¥ä¾¿å’Œå½“å‰çš„ExtraDataçš„é•¿åº¦ç›¸åŒã€‚</li></ul></li><li>EXTRA_SEALï¼šä¸ºç­¾åè€…å°ç« ä¿ç•™çš„å›ºå®šæ•°é‡çš„é¢å¤–æ•°æ®åç¼€å­—èŠ‚ã€‚<ul><li>ä¿å­˜ç­¾åçš„65ä¸ªå­—èŠ‚ï¼ŒåŸºäºæ ‡å‡†secp256k1æ›²çº¿ã€‚</li></ul></li><li>NONCE_AUTHï¼šé­”æœ¯éšæœºæ•°å­—0xffffffffffffffffæŠ•ç¥¨æ·»åŠ ä¸€ä¸ªæ–°çš„ç­¾åè€…ã€‚</li><li>NONCE_DROPï¼šé­”æœ¯éšæœºæ•°å­—0x0000000000000000å¯¹ç§»é™¤ç­¾åè€…è¿›è¡ŒæŠ•ç¥¨ã€‚</li><li>UNCLE_HASHï¼šå§‹ç»ˆKeccak256ï¼ˆRLPï¼ˆ[]ï¼‰ï¼‰ä½œä¸ºUnclesåœ¨PoWä¹‹å¤–æ²¡æœ‰ä»»ä½•æ„ä¹‰ã€‚</li><li>DIFF_NOTURNï¼šå¦‚æœå½“å‰æ²¡æœ‰è½®åˆ°ä½ ç­¾åï¼Œé‚£ä¹ˆä½ ç­¾åçš„åŒºå—çš„éš¾åº¦å°±æ˜¯è¿™ä¸ªéš¾åº¦ã€‚<ul><li>å»ºè®®1ï¼Œå› ä¸ºå®ƒåªéœ€è¦æ˜¯ä¸€ä¸ªä»»æ„çš„åŸºçº¿å¸¸æ•°ã€‚</li></ul></li><li>DIFF_INTURNï¼šå¦‚æœå½“å‰è½®åˆ°ä½ ç­¾åï¼Œé‚£ä¹ˆä½ ç­¾åçš„éš¾åº¦ã€‚<ul><li>å»ºè®®2ï¼Œ è¿™æ ·å°±æ¯”æ²¡æœ‰è½®åˆ°çš„ç­¾åè€…éš¾åº¦è¦é«˜ã€‚</li></ul></li></ul><p>æˆ‘ä»¬è¿˜å®šä¹‰äº†ä»¥ä¸‹æ¯å—çš„å¸¸é‡ï¼š</p><ul><li>BLOCK_NUMBERï¼šé“¾ä¸­çš„å—é«˜åº¦ï¼Œåˆ›ä¸–åŒºå—çš„é«˜åº¦æ˜¯0ã€‚</li><li>SIGNER_COUNTï¼šåœ¨åŒºå—é“¾ä¸­ä¸­ç‰¹å®šå®ä¾‹ä¸Šæœ‰æ•ˆçš„æˆæƒç­¾åè€…çš„æ•°é‡ã€‚</li><li>SIGNER_INDEXï¼šå½“å‰æˆæƒç­¾åè€…çš„æ’åºåˆ—è¡¨ä¸­çš„ç´¢å¼•ã€‚</li><li>SIGNER_LIMITï¼šæ¯éš”è¿™ä¹ˆå¤šå—ï¼Œç­¾åè€…åªèƒ½ç­¾ç½²ä¸€å—ã€‚<ul><li>å¿…é¡»æœ‰floor(SIGNER_COUNT / 2ï¼‰+1 è¿™ä¹ˆå¤šç­¾åè€…åŒæ„æ‰èƒ½è¾¾æˆæŸé¡¹å†³è®®ã€‚</li></ul></li></ul><p>æˆ‘ä»¬é‡æ–°è°ƒæ•´åŒºå—å¤´å­—æ®µçš„ç”¨é€”ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p><ul><li>beneficiaryï¼šå»ºè®®ä¿®æ”¹æˆæƒç­¾åäººåå•çš„åœ°å€ã€‚<ul><li>åº”è¯¥æ­£å¸¸å¡«å†™é›¶ï¼Œåªæœ‰æŠ•ç¥¨æ—¶ä¿®æ”¹ã€‚</li><li>å°½ç®¡å¦‚æ­¤ï¼Œä»ç„¶å…è®¸ä»»æ„å€¼ï¼ˆç”šè‡³æ˜¯æ— æ„ä¹‰çš„å€¼ï¼Œä¾‹å¦‚æŠ•å‡ºéç­¾åè€…ï¼‰ï¼Œä»¥é¿å…å¢åŠ å›´ç»•æŠ•ç¥¨æœºåˆ¶çš„é¢å¤–å¤æ‚æ€§ã€‚</li><li>å¿…é¡»åœ¨æ£€æŸ¥ç‚¹ï¼ˆå³epochè½¬æ¢ï¼‰å—å¡«å……é›¶ã€‚</li></ul></li><li>nonceï¼šSignerå…³äºå—ç›Šäººå­—æ®µä¸­å®šä¹‰çš„è´¦æˆ·çš„å»ºè®®ã€‚<ul><li>NONCE_DROP æè®®å–æ¶ˆæˆæƒå—ç›Šäººä½œä¸ºç°æœ‰ç­¾åè€…ã€‚</li><li>NONCE_AUTH æå‡ºæˆæƒå—ç›Šäººä½œä¸ºæ–°çš„ç­¾åè€…ã€‚</li><li>å¿…é¡»åœ¨æ£€æŸ¥ç‚¹å—å¡«å……é›¶ã€‚</li><li>é™¤äº†ä¸Šè¿°ä¸¤è€…ï¼ˆç°åœ¨ï¼‰ä¹‹å¤–ï¼Œä¸å¾—é‡‡ç”¨ä»»ä½•å…¶ä»–å€¼ã€‚</li></ul></li><li>extraDataï¼š vanity, checkpointing and signer signaturesçš„ç»„åˆå­—æ®µã€‚<ul><li>ç¬¬ä¸€ä¸ªEXTRA_VANITYå­—èŠ‚ï¼ˆå›ºå®šé•¿åº¦ï¼‰å¯ä»¥åŒ…å«ä»»æ„ç­¾åè€…vanity dataã€‚</li><li>æœ€åä¸€ä¸ªEXTRA_SEALå­—èŠ‚ï¼ˆå›ºå®šé•¿åº¦ï¼‰æ˜¯å¯†å°æ ‡é¢˜çš„ç­¾åè€…ç­¾åã€‚</li><li>æ£€æŸ¥ç‚¹å—å¿…é¡»åŒ…å«ä¸€ä¸ªç­¾åè€…åˆ—è¡¨ï¼ˆN * 20å­—èŠ‚ï¼‰ï¼Œå¦åˆ™çœç•¥ã€‚</li><li>æ£€æŸ¥ç‚¹å—é™„åŠ æ•°æ®éƒ¨åˆ†ä¸­çš„ç­¾ç½²è€…åˆ—è¡¨å¿…é¡»æŒ‰å‡åºæ’åºã€‚</li></ul></li><li>mixHashï¼šä¸ºäº†åˆ†å‰ä¿ç•™ã€‚ç±»ä¼¼äºDaoçš„é¢å¤–æ•°æ®<ul><li>åœ¨æ­£å¸¸æ“ä½œæœŸé—´å¿…é¡»å¡«å…¥é›¶ã€‚</li></ul></li><li>ommersHashï¼šå¿…é¡»æ˜¯UNCLE_HASHï¼Œå› ä¸ºåœ¨PoWä¹‹å¤–ï¼ŒUncleså”æ²¡æœ‰ä»»ä½•æ„ä¹‰ã€‚</li><li>timestampï¼šå¿…é¡»è‡³å°‘ä¸ºçˆ¶åŒºå—çš„æ—¶é—´æˆ³ + BLOCK_PERIODã€‚</li><li>difficultyï¼šåŒ…å«å—çš„ç‹¬ç«‹å¾—åˆ† æ¥æ¨å¯¼é“¾çš„è´¨é‡ã€‚ <ul><li>å¦‚æœBLOCK_NUMBERï¼…SIGNER_COUNTï¼= SIGNER_INDEXï¼Œåˆ™å¿…é¡»ä¸ºDIFF_NOTURN</li><li>å¦‚æœBLOCK_NUMBERï¼…SIGNER_COUNT == SIGNER_INDEXï¼Œåˆ™å¿…é¡»ä¸ºDIFF_INTURN</li></ul></li></ul><h3 id="Authorizing-a-block"><a href="#Authorizing-a-block" class="headerlink" title="Authorizing a block"></a>Authorizing a block</h3><p>ä¸ºäº†ç»™ç½‘ç»œæˆæƒä¸€ä¸ªå—ï¼Œç­¾åè€…éœ€è¦ç­¾ç½²åŒ…å«é™¤ç­¾åæœ¬èº«ä»¥å¤–çš„æ‰€æœ‰å†…å®¹ã€‚ è¿™æ„å‘³ç€å“ˆå¸ŒåŒ…å«åŒºå—å¤´çš„æ¯ä¸ªå­—æ®µï¼ˆåŒ…æ‹¬nonceå’ŒmixDigestï¼‰ï¼Œè¿˜æœ‰é™¤äº†65å­—èŠ‚ç­¾ååç¼€å¤–çš„extraDataã€‚ è¿™äº›å­—æ®µæŒ‰ç…§å…¶åœ¨é»„çš®ä¹¦ä¸­å®šä¹‰çš„é¡ºåºè¿›è¡Œhashã€‚</p><p>è¯¥æ•£åˆ—ä½¿ç”¨æ ‡å‡†çš„secp256k1æ›²çº¿è¿›è¡Œç­¾åï¼Œå¾—åˆ°çš„65å­—èŠ‚ç­¾åï¼ˆRï¼ŒSï¼ŒVï¼Œå…¶ä¸­Vä¸º0æˆ–1ï¼‰ä½œä¸ºå°¾éšçš„65å­—èŠ‚åç¼€åµŒå…¥åˆ°extraDataä¸­ã€‚</p><p>ä¸ºäº†ç¡®ä¿æ¶æ„ç­¾åè€…ï¼ˆç­¾åå¯†é’¥ä¸¢å¤±ï¼‰ä¸èƒ½åœ¨ç½‘ç»œä¸Šå—åˆ°ç ´åï¼Œæ¯ä½ç­¾åè€…éƒ½å¯ä»¥åœ¨SIGNER_LIMITè¿ç»­å—ä¸­ç­¾æœ€å¤šä¸€ä¸ªã€‚ é¡ºåºä¸æ˜¯å›ºå®šçš„ï¼Œä¸è¿‡ï¼ˆDIFF_INTURNï¼‰çš„ç­¾åè€…ç­¾å‡ºçš„åŒºå—éš¾åº¦è¦æ¯”ï¼ˆDIFF_NOTURNï¼‰é«˜</p><h4 id="æˆæƒç­–ç•¥"><a href="#æˆæƒç­–ç•¥" class="headerlink" title="æˆæƒç­–ç•¥"></a>æˆæƒç­–ç•¥</h4><p>åªè¦ç­¾åè€…ç¬¦åˆä¸Šè¿°è§„èŒƒï¼Œä»–ä»¬å¯ä»¥æˆæƒå’Œåˆ†é…ä»–ä»¬è®¤ä¸ºåˆé€‚çš„å—ï¼Œ ä¸‹é¢çš„å»ºè®®ç­–ç•¥ä¼šå‡å°‘ç½‘ç»œæµé‡å’Œåˆ†å‰ï¼Œæ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªå»ºè®®çš„åŠŸèƒ½ï¼š</p><ul><li>å¦‚æœç­¾ç½²è€…è¢«å…è®¸ç­¾ç½²ä¸€ä¸ªåŒºå—ï¼ˆåœ¨æˆæƒæ¸…å•ä¸Šå¹¶ä¸”æœ€è¿‘æ²¡æœ‰ç­¾ç½²ï¼‰ã€‚<ul><li>è®¡ç®—ä¸‹ä¸€ä¸ªå—çš„æœ€ä½³ç­¾åæ—¶é—´ï¼ˆçˆ¶+ BLOCK_PERIODï¼‰ã€‚</li><li>å¦‚æœè½®åˆ°äº†ï¼Œç­‰å¾…å‡†ç¡®çš„æ—¶é—´åˆ°è¾¾ï¼Œç«‹å³ç­¾å­—å’Œæ’­æ”¾ã€‚</li><li>å¦‚æœæ²¡æœ‰è½®åˆ°ï¼Œåˆ™å»¶è¿Ÿ randï¼ˆSIGNER_COUNT * 500msï¼‰è¿™ä¹ˆä¹…çš„æ—¶é—´ç­¾åã€‚<br>è¿™ä¸ªå°å°çš„ç­–ç•¥å°†ç¡®ä¿å½“å‰è½®åˆ°çš„ç­¾åè€…ï¼ˆè°çš„å—æ›´é‡ï¼‰å¯¹ç­¾åå’Œä¼ æ’­ä¸å¤–è½¬ç­¾åè€…æœ‰ç¨å¾®çš„ä¼˜åŠ¿ã€‚ æ­¤å¤–ï¼Œè¯¥æ–¹æ¡ˆå…è®¸éšç€ç­¾åè€…æ•°ç›®çš„å¢åŠ è€Œå…·æœ‰ä¸€å®šè§„æ¨¡ã€‚</li></ul></li></ul><h3 id="æŠ•ç¥¨ç­¾ç½²è€…"><a href="#æŠ•ç¥¨ç­¾ç½²è€…" class="headerlink" title="æŠ•ç¥¨ç­¾ç½²è€…"></a>æŠ•ç¥¨ç­¾ç½²è€…</h3><p>æ¯ä¸ªepochè½¬æ¢ï¼ˆåŒ…æ‹¬åˆ›ä¸–åŒºå—ï¼‰ä½œä¸ºä¸€ä¸ªæ— çŠ¶æ€çš„æ£€æŸ¥ç‚¹ï¼Œæœ‰èƒ½åŠ›çš„å®¢æˆ·ç«¯åº”è¯¥èƒ½å¤ŸåŒæ­¥è€Œä¸éœ€è¦ä»»ä½•ä»¥å‰çš„çŠ¶æ€ã€‚ è¿™æ„å‘³ç€æ–°epoch headerä¸å¾—åŒ…å«æŠ•ç¥¨ï¼Œæ‰€æœ‰æœªè½å®çš„æŠ•ç¥¨éƒ½å°†è¢«ä¸¢å¼ƒï¼Œå¹¶ä»å¤´å¼€å§‹è®¡æ•°ã€‚</p><p>å¯¹äºæ‰€æœ‰éepoch è½¬æ¢å—ï¼š</p><ul><li>ç­¾åè€…å¯ä»¥ä½¿ç”¨è‡ªå·±ç­¾ç½²çš„åŒºå—æŠ•ä¸€ç¥¨ï¼Œä»¥æå‡ºå¯¹æˆæƒåˆ—è¡¨çš„æ›´æ”¹ã€‚</li><li>å¯¹æ¯ä¸€ä¸ªææ¡ˆåªä¿ç•™æœ€æ–°çš„ä¸€ä¸ªæŠ•ç¥¨ã€‚</li><li>éšç€é“¾æ¡çš„è¿›å±•ï¼ŒæŠ•ç¥¨ä¹Ÿä¼šç”Ÿæ•ˆï¼ˆå…è®¸åŒæ—¶æäº¤ææ¡ˆï¼‰ã€‚</li><li>è¾¾æˆå¤šæ•°äººæ„è§çš„ææ¡ˆSIGNER_LIMITç«‹å³ç”Ÿæ•ˆã€‚</li><li>å¯¹äºå®¢æˆ·ç«¯å®ç°çš„ç®€å•æ€§ï¼Œæ— æ•ˆçš„æè®®ä¸ä¼šå—åˆ°æƒ©ç½šã€‚</li></ul><p><strong>ç”Ÿæ•ˆçš„ææ¡ˆæ„å‘³ç€æ”¾å¼ƒå¯¹è¯¥ææ¡ˆçš„æ‰€æœ‰æœªå†³æŠ•ç¥¨ï¼ˆæ— è®ºæ˜¯èµæˆè¿˜æ˜¯åå¯¹ï¼‰ï¼Œå¹¶ä»ä¸€ä¸ªæ¸…æ™°çš„åå•å¼€å§‹ã€‚</strong></p><h3 id="çº§è”æŠ•ç¥¨"><a href="#çº§è”æŠ•ç¥¨" class="headerlink" title="çº§è”æŠ•ç¥¨"></a>çº§è”æŠ•ç¥¨</h3><p>ç­¾åè€…å–æ¶ˆæˆæƒæœŸé—´å¯èƒ½ä¼šå‡ºç°å¤æ‚çš„æ¡ˆä¾‹ã€‚å¦‚æœå…ˆå‰æˆæƒçš„ç­¾ç½²è€…è¢«æ’¤é”€ï¼Œåˆ™æ‰¹å‡†ææ¡ˆæ‰€éœ€çš„ç­¾åè€…æ•°é‡å¯èƒ½ä¼šå‡å°‘ä¸€ä¸ªã€‚è¿™å¯èƒ½ä¼šå¯¼è‡´ä¸€ä¸ªæˆ–å¤šä¸ªæœªå†³çš„ææ¡ˆè¾¾æˆå…±è¯†ï¼Œæ‰§è¡Œè¿™äº›ææ¡ˆå¯èƒ½ä¼šè¿›ä¸€æ­¥å½±å“æ–°çš„ææ¡ˆã€‚</p><p>å½“å¤šä¸ªç›¸å†²çªçš„æè®®åŒæ—¶é€šè¿‡æ—¶ï¼ˆä¾‹å¦‚ï¼Œæ·»åŠ æ–°çš„ç­¾åè€…vsåˆ é™¤ç°æœ‰çš„ææ¡ˆè€…ï¼‰ï¼Œå¤„ç†è¿™ç§æƒ…å†µå¹¶ä¸æ˜æ˜¾ï¼Œè¯„ä¼°é¡ºåºå¯èƒ½ä¼šå½»åº•æ”¹å˜æœ€ç»ˆæˆæƒåˆ—è¡¨çš„ç»“æœã€‚ç”±äºç­¾åè€…å¯èƒ½ä¼šåœ¨ä»–ä»¬è‡ªå·±çš„æ¯ä¸€ä¸ªåŒºå—ä¸­åè½¬ä»–ä»¬è‡ªå·±çš„æŠ•ç¥¨ï¼Œæ‰€ä»¥å“ªä¸€ä¸ªææ¡ˆå°†æ˜¯â€œç¬¬ä¸€â€å¹¶ä¸é‚£ä¹ˆæ˜æ˜¾ã€‚</p><p>ä¸ºäº†é¿å…çº§è”æ‰§è¡Œæ‰€å¸¦æ¥çš„ç¼ºé™·ï¼Œè§£å†³çš„åŠæ³•æ˜¯æ˜ç¡®ç¦æ­¢çº§è”æ•ˆåº”ã€‚æ¢å¥è¯è¯´ï¼šåªæœ‰å½“å‰æ ‡é¢˜/æŠ•ç¥¨çš„å—ç›Šäººå¯ä»¥è¢«æ·»åŠ åˆ°æˆæƒåˆ—è¡¨æˆ–ä»æˆæƒåˆ—è¡¨ä¸­åˆ é™¤ã€‚å¦‚æœè¿™å¯¼è‡´å…¶ä»–å»ºè®®è¾¾æˆå…±è¯†ï¼Œé‚£ä¹ˆå½“ä»–ä»¬å„è‡ªçš„å—ç›Šè€…å†æ¬¡â€œè§¦å‘â€æ—¶ï¼Œè¿™äº›å»ºè®®å°†è¢«æ‰§è¡Œï¼ˆå› ä¸ºå¤§å¤šæ•°äººçš„å…±è¯†ä»ç„¶åœ¨è¿™ä¸€ç‚¹ä¸Šï¼‰ã€‚</p><h3 id="æŠ•ç¥¨ç­–ç•¥"><a href="#æŠ•ç¥¨ç­–ç•¥" class="headerlink" title="æŠ•ç¥¨ç­–ç•¥"></a>æŠ•ç¥¨ç­–ç•¥</h3><p>ç”±äºåŒºå—é“¾å¯ä»¥æœ‰å¾ˆå°çš„reorgsï¼Œæ‰€ä»¥â€œcast-and-forgetâ€çš„å¤©çœŸæŠ•ç¥¨æœºåˆ¶å¯èƒ½ä¸æ˜¯æœ€ä¼˜çš„ï¼Œå› ä¸ºåŒ…å«singletonæŠ•ç¥¨çš„åŒºå—å¯èƒ½ä¸ä¼šåœ¨æœ€ç»ˆçš„é“¾ä¸­ç»“æŸã€‚</p><p>ä¸€ä¸ªç®€å•ä½†å·¥ä½œçš„ç­–ç•¥æ˜¯å…è®¸ç”¨æˆ·åœ¨ç­¾åè€…ä¸Šé…ç½®â€œææ¡ˆâ€ï¼ˆä¾‹å¦‚â€œadd 0x â€¦â€ï¼Œâ€œdrop 0x â€¦â€ï¼‰ã€‚ ç­¾ç½²çš„ä»£ç ï¼Œç„¶åå¯ä»¥é€‰æ‹©ä¸€ä¸ªéšæœºçš„å»ºè®®ï¼Œæ¯å—å®ƒç­¾ç½²å’Œæ³¨å…¥ã€‚ è¿™ç¡®ä¿äº†å¤šä¸ªå¹¶å‘ææ¡ˆä»¥åŠreorgsæœ€ç»ˆåœ¨é“¾ä¸Šè¢«æ³¨æ„åˆ°ã€‚</p><p>è¿™ä¸ªåˆ—è¡¨å¯èƒ½åœ¨ä¸€å®šæ•°é‡çš„å—/epochåè¿‡æœŸï¼Œä½†é‡è¦çš„æ˜¯è¦è®¤è¯†åˆ°â€œçœ‹â€ä¸€ä¸ªææ¡ˆé€šè¿‡å¹¶ä¸æ„å‘³ç€å®ƒä¸ä¼šè¢«é‡æ–°ç»„åˆï¼Œæ‰€ä»¥å½“ææ¡ˆé€šè¿‡æ—¶ä¸åº”è¯¥ç«‹å³æ”¾å¼ƒã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-ä»¥å¤ªåŠéšæœºæ•°ç”Ÿæˆæ–¹å¼</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>æœ€è¿‘è€ƒè™‘ä¸€ä¸ªåŸºäºä»¥å¤ªåŠçš„å»ä¸­å¿ƒåŒ–èµŒåœºçš„å®ç°ï¼Œ èµŒåœºå¦‚æœéœ€è¦å®ç°ï¼Œé‚£ä¹ˆéšæœºæ•°æ˜¯å¿…é¡»çš„ã€‚ ç„¶åç ”ç©¶äº†ä¸€ä¸‹ä»¥å¤ªåŠé‡Œé¢çš„éšæœºæ•°ç”Ÿæˆï¼Œå‘ç°å¹¶ä¸å®¹æ˜“ã€‚</p><p>ä»¥å¤ªåŠé‡Œé¢ç”Ÿæˆéšæœºæ•°çš„å‡ ç§æ–¹å¼ã€‚</p><h1 id="oraclize"><a href="#oraclize" class="headerlink" title="oraclize"></a>oraclize</h1><p>Oraclizeå®šä½ä¸ºå»ä¸­å¿ƒåŒ–åº”ç”¨çš„æ•°æ®æ¬è¿å·¥ï¼Œå®ƒä½œä¸ºWeb APIså’ŒDAppçš„å¯é é“¾æ¥ã€‚æœ‰äº†Oraclizeï¼Œå°±ä¸éœ€è¦å»ºç«‹é¢å¤–çš„ä¿¡ä»»é“¾ï¼Œå› ä¸ºæˆ‘ä»¬çš„è¡Œä¸ºå·²ç»è¢«å¼ºåˆ¶åŠ å¯†éªŒè¯ã€‚Oraclizeæ˜¯ä¸€ä¸ªå¯è¯æ˜çš„è¯šå®çš„é¢„è¨€æœºæœåŠ¡ï¼Œå¯ä»¥è®©æ™ºèƒ½åˆçº¦è®¿é—®äº’è”ç½‘ã€‚Oraclizeæ˜¯å¹³å°æ— å…³çš„ï¼Œä¸ºæ‰€æœ‰ä¸»æµçš„æ™ºèƒ½åˆçº¦å¹³å°æä¾›ä¸€ç§è™šæ‹Ÿçš„æ¥å£ã€‚å¯ä»¥æƒ³åƒï¼Œé€šè¿‡OraclizeæŠ•å…¥å¤§é‡æœ‰æ„ä¹‰çš„æ•°æ®åˆ°åŒºå—é“¾ä¸­ï¼Œå¯ä»¥ä½¿å¾—æ™ºèƒ½åˆçº¦äº§ä¸šæ›´åŠ ç¹è£ï¼Œè®©æ›´å¤šæœ‰ä»·å€¼çš„åº”ç”¨å‘ˆç°æ›´å¤§çš„ç”Ÿå‘½åŠ›ã€‚</p><p>Oraclizeçš„ä½¿ç”¨æ–¹å¼å¯ä»¥å‚è€ƒä¸‹é¢çš„<a href="https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol">ä»£ç </a></p><p>åœ¨updateæ–¹æ³•é‡Œé¢è°ƒç”¨oraclize_newRandomDSQueryæ–¹æ³•æ¥è°ƒç”¨Oracleçš„æ™ºèƒ½åˆçº¦çš„ä»£ç ï¼Œ<br>Oracleæ ¹æ®è¯·æ±‚æ¥ç”Ÿæˆå¯¹åº”çš„æ•°æ®ï¼Œ ç„¶åæŠŠç»“æœé€šè¿‡å›è°ƒ__callbackæ¥ä¼ å…¥ã€‚</p><pre><code>/*   Oraclize random-datasource example   This contract uses the random-datasource to securely generate off-chain N random bytes*/pragma solidity ^0.4.11;import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";contract RandomExample is usingOraclize {        event newRandomNumber_bytes(bytes);    event newRandomNumber_uint(uint);    function RandomExample() {        oraclize_setProof(proofType_Ledger); // sets the Ledger authenticity proof in the constructor        update(); // let's ask for N random bytes immediately when the contract is created!    }        // the callback function is called by Oraclize when the result is ready    // the oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:    // the proof validity is fully verified on-chain    function __callback(bytes32 _queryId, string _result, bytes _proof)    {         // if we reach this point successfully, it means that the attached authenticity proof has passed!        if (msg.sender != oraclize_cbAddress()) throw;                if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {            // the proof verification has failed, do we need to take any action here? (depends on the use case)        } else {            // the proof verification has passed            // now that we know that the random number was safely generated, let's use it..                        newRandomNumber_bytes(bytes(_result)); // this is the resulting random number (bytes)                        // for simplicity of use, let's also convert the random bytes to uint if we need            uint maxRange = 2**(8* 7); // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the datasource to return            uint randomNumber = uint(sha3(_result)) % maxRange; // this is an efficient way to get the uint out in the [0, maxRange] range                        newRandomNumber_uint(randomNumber); // this is the resulting random number (uint)        }    }        function update() payable {         uint N = 7; // number of random bytes we want the datasource to return        uint delay = 0; // number of seconds to wait before the execution takes place        uint callbackGas = 200000; // amount of gas we want Oraclize to set for the callback function        bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); // this function internally generates the correct oraclize_query and returns its queryId    }    }</code></pre><p>è€ƒè™‘ä¸€ä¸ªæä¾›æ‰“èµŒçš„æ™ºèƒ½åˆçº¦ã€‚<br>ç”¨æˆ·è°ƒç”¨æ‰“èµŒçš„æ¥å£ï¼Œè¿™ä¸ªæ¥å£ä¼šæŠŠç”¨æˆ·çš„è¯·æ±‚å­˜å‚¨èµ·æ¥ï¼Œç„¶åè°ƒç”¨Oracleéšæœºæ•°ç”ŸæˆæœåŠ¡ã€‚<br>ç„¶åé€šè¿‡Oracleå›è°ƒæœåŠ¡ï¼Œåˆ¤æ–­éšæœºæ•°æ˜¯å¦å¤§äºæŸä¸ªå€¼ï¼Œå¦‚æœæˆç«‹ï¼Œé‚£ä¹ˆç”¨æˆ·æˆåŠŸï¼Œå¦åˆ™ç”¨æˆ·å¤±è´¥ã€‚</p><p>è¿™å°±æ˜¯å…¸å‹çš„Oracleçš„ä½¿ç”¨æ¡ˆä¾‹ã€‚</p><h1 id="RANDAO-A-DAO-working-as-RNG-of-Ethereum"><a href="#RANDAO-A-DAO-working-as-RNG-of-Ethereum" class="headerlink" title="RANDAO: A DAO working as RNG of Ethereum"></a>RANDAO: A DAO working as RNG of Ethereum</h1><p><a href="https://github.com/randao/randao">randao</a>æ˜¯ä¸€ä¸ªç”Ÿæˆä»¥å¤ªåŠéšæœºæ•°çš„å»ä¸­å¿ƒåŒ–ç»„ç»‡ï¼Œ</p><p><strong>Random number in programming is very important!</strong></p><p><strong>RNG in a deterministic system is very difficult</strong></p><p><strong>Miners canâ€™t be trusted!</strong></p><p>éšæœºæ•°åœ¨ç¼–ç¨‹ä¸­æ˜¯éå¸¸é‡è¦çš„ã€‚<br>RNG åœ¨ä¸€ä¸ªç¡®å®šæ€§çš„ç³»ç»Ÿä¸­æ˜¯éå¸¸éš¾çš„ã€‚<br>ä¸èƒ½ç›¸ä¿¡çŸ¿å·¥</p><h2 id="è§£å†³æ–¹æ¡ˆ"><a href="#è§£å†³æ–¹æ¡ˆ" class="headerlink" title="è§£å†³æ–¹æ¡ˆ"></a>è§£å†³æ–¹æ¡ˆ</h2><p>Solutions</p><p>A DAO (decentralised autonomous organisation) that anyone can participate in, and the random number is generated by all participants together! First of all, we need to create a RANDAO contract in the blockchain, which defines the participation rules. Then the basic process of generating a random number can be divided into three phases:</p><p>ä¸€ä¸ªDAO(å»ä¸­å¿ƒåŒ–çš„åŒ¿åç»„ç»‡)å…è®¸ä»»ä½•äººåŠ å…¥ï¼Œéšæœºæ•°æ˜¯è¢«æ‰€æœ‰çš„å‚ä¸è€…ä¸€èµ·åˆä½œç”Ÿæˆçš„ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åœ¨åŒºå—é“¾ä¸Šåˆ›å»ºä¸€ä¸ªRANDAOçš„æ™ºèƒ½åˆçº¦ï¼Œåˆçº¦å®šä¹‰äº†å‚ä¸è§„åˆ™ã€‚ç„¶åç”Ÿæˆéšæœºæ•°çš„åŸºæœ¬è¿‡ç¨‹å¯ä»¥åˆ†ä¸ºä¸‹é¢ä¸‰ä¸ªæ­¥éª¤ï¼š</p><p><strong>The first phase: collecting valid sha3(s)</strong></p><p>Anyone who want to participate in the random number generation needs to send a transaction to the contract C with m ETH as pledge in a specified time period (e.g, 6 block period, approximately 72s), accompanied by the result of sha3(s), s is the secret number respective picked by participant.</p><p><strong>ç¬¬ä¸€æ­¥ï¼šæ”¶é›†æœ‰æ•ˆçš„sha3(s)</strong><br>å‚ä¸éšæœºæ•°ç”Ÿæˆçš„å‚ä¸è€…é¦–å…ˆéœ€è¦åœ¨ä¸€ä¸ªæŒ‡å®šçš„æ—¶é—´åŒºé—´(æ¯”å¦‚ï¼Œ6ä¸ªåŒºå—çš„åŒºé—´ï¼Œå¤§çº¦72ç§’)å‘é€m ETHä½œä¸ºæŠµæŠ¼åˆ°æ™ºèƒ½åˆçº¦ C,åŒæ—¶å‘é€ä¸€ä¸ªsha3(s)çš„å€¼åˆ°æ™ºèƒ½åˆçº¦C ï¼Œsæ˜¯ä¸€ä¸ªåªæœ‰å‚ä¸è€…è‡ªå·±çŸ¥é“çš„æ•°å­—.</p><p><strong>The second phase: collecting valid s</strong></p><p>After the first phase, anyone who submitted sha3(s) successfully needs to send a transaction with the secret number s in the first stage to contract C within a specified time period. Contract C will check if s is valid by running sha3 against s and comparing the result with previous committed data. Valid s will be saved to the collection of seeds to finally generate the random number.</p><p><strong>ç¬¬äºŒæ­¥:æ”¶é›†æœ‰æ•ˆçš„s</strong></p><p>åœ¨ç¬¬ä¸€æ­¥ç»“æŸåï¼Œé‚£äº›æäº¤äº†sha3(s)çš„å‚ä¸è€…éœ€è¦åœ¨æŒ‡å®šçš„æ—¶é—´åŒºé—´å†…å‘é€såˆ°æ™ºèƒ½åˆçº¦C. æ™ºèƒ½åˆçº¦Cä¼šæ£€æŸ¥sha3(s)å’Œä¹‹å‰æäº¤çš„å€¼æ˜¯å¦ç›¸åŒã€‚ ç›¸åŒçš„sä¼šè¢«ä¿å­˜åˆ°ç§å­é›†åˆç”¨æ¥æœ€ç»ˆç”Ÿæˆéšæœºæ•°ã€‚</p><p><strong>The third phase: calculating a random number, refund pledged ETH and bonus</strong></p><ul><li>After all secret numbers have been successfully collected, contract C will calculate the random number from the function f(s1,s2,â€¦,sn), the result will be written to the storage of C, and the result will be sent to all other contracts that requested the random number before.</li><li>Contract C will send back the pledge to the participants in the first phase, and the profit is divided into equal parts and sent to all participants as an additional bonus. The profit comes from the fees that is paid by other contracts that consume the random number.</li></ul><p><strong>ç¬¬ä¸‰æ­¥:è®¡ç®—éšæœºæ•°ï¼Œé€€å›æŠµæŠ¼å’Œå¥–é‡‘</strong></p><ul><li>åœ¨æ‰€æœ‰çš„ç§˜å¯†æ•°å­—sè¢«æˆåŠŸæ”¶é›†å,æ™ºèƒ½åˆçº¦Cä¼šä½¿ç”¨å‡½æ•°f(s1,s2,â€¦,sn)æ¥è®¡ç®—éšæœºæ•°ï¼Œéšæœºæ•°çš„ç»“æœä¼šå†™å…¥æ™ºèƒ½åˆçº¦çš„å­˜å‚¨ï¼Œè€Œä¸”ç»“æœä¼šè¢«å‘é€åˆ°æ‰€æœ‰ä¹‹å‰è¯·æ±‚éšæœºæ•°çš„å…¶ä»–æ™ºèƒ½åˆçº¦ä¸Šé¢ã€‚</li><li>æ™ºèƒ½åˆçº¦Cä¼šæŠŠç¬¬ä¸€é˜¶æ®µçš„æŠµæŠ¼è¿”å›ç»™å‚ä¸è€…ï¼Œç„¶åå¥–é‡‘ä¼šè¢«åˆ†æˆåŒç­‰åˆ†å‘é€ç»™æ‰€æœ‰çš„å‚ä¸è€…ã€‚å¥–é‡‘æ¥æºäºè¯·æ±‚éšæœºå€¼çš„å…¶ä»–æ™ºèƒ½åˆçº¦ã€‚</li></ul><h2 id="Additional-rules"><a href="#Additional-rules" class="headerlink" title="Additional rules"></a>Additional rules</h2><p>In order to ensure the RNG canâ€™t be manipulated, as well as for safety and efficiency, the contract C has the following additional rules:</p><ul><li><p>The first phase, if two or more of the same sha3(s) are submitted in sequence, only the first one is accepted.</p></li><li><p>The first phase, there is a requirement for minimum number of participants, if it fails to collect enough sha3(s) within the time period, then RNG at this block height will fail.</p></li><li><p>If a participant submits the sha3(s) and it is accepted by contract C, he must reveal the s in the second phase.</p><ul><li><p>If the participant fails to reveal s in the second phase, then the m ETH sent in the first phase will be confiscated without providing a return.</p></li><li><p>If one or more s isnâ€™t revealed in the second phase, RNG at this block height will fail. Confiscated ETHs will be divided equally and send to other participants who revealed s at the second phase. The fees paid by other contracts will be refunded.</p></li></ul></li></ul><p>è¡¥å……è§„åˆ™</p><p>ä¸ºäº†ç¡®ä¿RNGä¸èƒ½è¢«æ“æ§ï¼Œä»¥åŠä¸ºäº†å®‰å…¨å’Œæ•ˆç‡ï¼Œæ™ºèƒ½åˆçº¦Cæœ‰ä»¥ä¸‹çš„è¡¥å……è§„åˆ™ï¼š</p><ul><li>åœ¨ç¬¬ä¸€æ­¥ä¸­ï¼Œå¦‚æœæœ‰ä¸¤ä¸ªæˆ–æ›´å¤šä¸ªçš„åŒæ ·çš„sha3(s)è¢«æäº¤ä¸Šæ¥ï¼Œé‚£ä¹ˆåªæœ‰ç¬¬ä¸€ä¸ªä¼šè¢«æ¥å—ã€‚</li><li>åœ¨ç¬¬ä¸€æ­¥ä¸­ï¼Œå¯¹äºå‚ä¸è€…æœ‰æœ€ä½è¦æ±‚ï¼Œå¦‚æœåœ¨æŒ‡å®šçš„æ—¶é—´åŒºé—´å†…æ²¡æœ‰æ”¶é›†åˆ°è¶³å¤Ÿå¤šçš„sha3(s)çš„å€¼ï¼Œé‚£ä¹ˆRNGåœ¨è¿™ä¸ªåŒºå—é«˜åº¦ä¼šå¤±è´¥ã€‚</li><li>å¦‚æœå‚ä¸è€…æäº¤äº†sha3(s),é‚£ä¹ˆä»–å¿…é¡»åœ¨ç¬¬äºŒæ­¥æäº¤s<ul><li>å¦‚æœå‚ä¸è€…åœ¨ç¬¬äºŒæ­¥æ²¡æœ‰æäº¤sï¼Œé‚£ä¹ˆç¬¬ä¸€é˜¶æ®µæä¾›çš„m ETHä¼šè¢«æ²¡æ”¶è€Œä¸”æ²¡æœ‰å¥–åŠ±ã€‚</li><li>å¦‚æœä¸€ä¸ªæˆ–è€…å¤šä¸ªsæ²¡æœ‰åœ¨ç¬¬äºŒæ­¥è¢«æäº¤ï¼ŒRNGåœ¨è¿™ä¸ªåŒºå—é«˜åº¦ä¼šå¤±è´¥ã€‚æ²¡æ”¶çš„ETHä¼šè¢«åˆ†æˆåŒç­‰åˆ†å‘é€ç»™æäº¤äº†sçš„å…¶ä»–å‚ä¸è€…ã€‚å…¶ä»–ç”³è¯·éšæœºæ•°çš„å…¶ä»–åˆçº¦çš„è´¹ç”¨ä¼šè¢«é€€å›ã€‚</li></ul></li></ul><h2 id="Incentive"><a href="#Incentive" class="headerlink" title="Incentive"></a>Incentive</h2><p>The RNG cycle is very short, and could be for example 20 cycles in one hour, if one cycleâ€™s profit is 0.001% , the monthly rate of return is up to 0.00001 * 20 * 24 * 30 = 0.144. Targeting to 14.4% monthly rate of return, and RNG has n participants on average, the running costs of contract is n * 3 * 500 * gasPrice + Ccost. (Ccost is gas consumed by contract internally, including computing and storage, etc. ) Assuming each random numbers has r time requests on average, the call price is p ETH, the income is r * p. So each participant will get (rp - 1500n * gasPrice - Ccost) / n from one time participation. The current gasPrice is 10 szabo, and estimate of contract consumption is 1500n gas, so estimate of net income is (rp / n - 0.03) ETH. Assuming each RNG has 10 participation, and the pledge is 1000ETH, the minimum required income is 0.4 ETH, which over 0.001% profit in this case. So if the RNG is requested only once, the service price is 0.4 ETH, and if it is requested 10 times, the price is just 0.04 ETH for each request.</p><p>æ¿€åŠ±</p><p>RNGçš„å‘¨æœŸéå¸¸çŸ­ï¼Œä¾‹å¦‚ä¸€ä¸ªå°æ—¶20ä¸ªç”Ÿæˆå‘¨æœŸï¼Œå¦‚æœæ²¡æœ‰å‘¨æœŸçš„åˆ©æ¶¦æ˜¯0.001%,ä¸€ä¸ªæœˆçš„ç›ˆåˆ©ä¼šè¾¾åˆ°0.00001 * 20 * 24 * 30 = 0.144ã€‚ ä¸ºäº†è¾¾åˆ°14.4%æ¯ä¸ªæœˆçš„ç›ˆåˆ©ï¼Œå¹¶ä¸”RNGå¹³å‡æœ‰nä¸ªå‚ä¸è€…ï¼Œè¿è¡Œæ™ºèƒ½åˆçº¦Cçš„è´¹ç”¨ä¸º  n * 3 * 500 * gasPrice + Ccost.ï¼ˆCCostæ˜¯åˆçº¦å†…éƒ¨çš„gasæ¶ˆè´¹ï¼ŒåŒ…æ‹¬è®¡ç®—å’Œå­˜å‚¨ï¼‰å‡è®¾æ¯ä¸ªéšæœºå€¼å¹³å‡æœ‰rä¸ªè¯·æ±‚ï¼Œæ¯ä¸ªè¯·æ±‚çš„è´¹ç”¨æ˜¯ p ETH, é‚£ä¹ˆæ”¶å…¥æ˜¯ r*p. æ‰€ä»¥æ¯ä¸ªå‚ä¸è€…æ¯ä¸€æ¬¡å‚ä¸ä¼šæ”¶åˆ°rp - 1500n * gasPrice - Ccost) / nã€‚å½“å‰çš„gasPriceæ˜¯10 szabo, åˆçº¦çš„æ¶ˆè´¹å¤§æ¦‚æ˜¯1500n gasï¼Œ æ‰€ä»¥å¤§æ¦‚çš„å‡€æ”¶å…¥æ˜¯(rp/n-0.03ï¼‰ETH. å‡è®¾æ¯ä¸ªRNGæœ‰10ä¸ªå‚ä¸è€…ï¼Œå¹¶ä¸”æŠµæŠ¼æ˜¯1000ETHï¼Œæ‰€ä»¥å¦‚æœRNGå¦‚æœåªè¯·æ±‚ä¸€æ¬¡ï¼Œé‚£ä¹ˆä¸€æ¬¡çš„è´¹ç”¨æ˜¯0.4 ETH, å¦‚æœè¯·æ±‚æ˜¯10æ¬¡ï¼Œé‚£ä¹ˆä¸€æ¬¡è¯·æ±‚çš„ä»·æ ¼ä¼šè¢«é™åˆ°0.04ETH</p><p>The RANDAO acts as an infrastructure in the Ethereum system. It is called by other contracts. Contracts for different purposes require different random numbers: some need high security, such as lottery; some need steady responses and the request should be responded immediately, these contracts are normally low-value; some need a callback, they want to receive a notification with random numbers when numbers are ready.</p><p>Obviously itâ€™s impossible to meet different requirements in various scenarios with only one RNG contract, so a lot of contracts will be created with different initial parameters, but the basic rules are the same.</p><p>RANDAOä½œä¸ºä»¥å¤ªåŠç³»ç»Ÿçš„åŸºç¡€è®¾æ–½ã€‚è¢«å…¶ä»–çš„åˆçº¦è°ƒç”¨ã€‚ä¸åŒçš„åˆçº¦å› ä¸ºæœ‰ä¸åŒçš„ç›®çš„æ‰€ä»¥éœ€è¦ä¸åŒçš„éšæœºå€¼ï¼šæœ‰äº›éœ€è¦é«˜åº¦åŠ å¯†çš„ï¼Œæ¯”å¦‚è¯´æŠ½å¥–;æœ‰äº›éœ€è¦ç¨³å®šçš„å›åº”ï¼Œå¹¶ä¸”è¦æ±‚ç«‹å³ä½œå‡ºå›åº”,è¿™äº›åˆçº¦æœ¬èº«çš„ä»·å€¼ä¸é«˜;æœ‰äº›éœ€è¦å›è°ƒå‡½æ•°ï¼Œå½“éšæœºå€¼å·²ç»ç”Ÿæˆçš„æ—¶å€™éœ€è¦æ¥æ”¶åˆ°é€šçŸ¥ã€‚</p><p>å¾ˆæ˜æ˜¾é€šè¿‡å•ä¸€çš„RNGåˆçº¦ä¸å¯èƒ½æ»¡è¶³æ‰€æœ‰çš„ä¸åŒçš„è¯·æ±‚ï¼Œæ‰€ä»¥ä½¿ç”¨äº†ä¸åŒçš„åˆå§‹å€¼åˆ›å»ºäº†å¾ˆå¤šæ™ºèƒ½åˆçº¦ï¼Œä¸è¿‡ä»–ä»¬åŸºæœ¬çš„è§„åˆ™æ˜¯ç›¸åŒçš„ã€‚</p><p>For example, if we need high security, we can substantially increase the pledge of the first phase. Thus, the cost of leading to failure of RNG process by not revealing s is greatly increased. And for the contracts without much interest involved, the minimum number of participants and the pledge can be lower.</p><p>Letâ€™s look at an example of a dApp betting on odd or even numbers, weâ€™ll show how to adjust the contractâ€™s parameters to meet the desired security level, by making the cost of cheating higher than expected earnings. Assuming the bet is 1000 ETH, the betting contract calls a RNG contract C1, if C1 failed to generate a random number at requested block height, then betting contract waits for the next random number of C1, until there is one generated.</p><p>æ¯”å¦‚ï¼Œå¦‚æœä½ éœ€è¦é«˜åº¦å®‰å…¨ï¼Œæˆ‘ä»¬å¯ä»¥å¤§å¤§çš„å¢åŠ ç¬¬ä¸€é˜¶æ®µçš„æŠµæŠ¼ã€‚è¿™æ ·ä¸æä¾›sçš„å¯¼è‡´å¤±è´¥çš„æ¦‚ç‡ä¼šå¤§å¤§é™ä½ã€‚å¯¹äºé‚£ä¹ˆèµ„é‡‘ä¸æ˜¯å¾ˆå……è¶³çš„åˆçº¦ï¼Œé‚£ä¹ˆå‚ä¸è€…çš„æœ€å°ä¸ªæ•°å’ŒæŠµæŠ¼éƒ½å¯ä»¥é™ä½ã€‚</p><p>è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªdappçš„ä¾‹å­ï¼Œè¿™ä¸ªä¾‹å­ç”¨æ¥èµŒæ•°çš„å¥‡æ•°å’Œå¶æ•°ï¼Œæˆ‘ä»¬ä¼šæ˜¾ç¤ºå¦‚ä½•è°ƒæ•´åˆçº¦çš„å‚æ•°æ¥åŒ¹é…é€‚åˆçš„å®‰å…¨ç¨‹åº¦ï¼Œé€šè¿‡è®©é€ å‡çš„æˆæœ¬å¤§å¤§é«˜äºæ”¶ç›Šã€‚å‡è®¾æ‰“èµŒæ˜¯1000ETHï¼Œè¿™ä¸ªæ‰“èµŒçš„åˆçº¦è°ƒç”¨äº†RNGçš„åˆçº¦C1, å¦‚æœC1åœ¨è¯·æ±‚çš„åŒºå—é«˜åº¦ç”Ÿæˆéšæœºæ•°å¤±è´¥äº†ï¼Œæ‰“èµŒçš„åˆçº¦ä¼šç­‰å¾…C1çš„ä¸‹ä¸€ä¸ªéšæœºæ•°ï¼Œç›´åˆ°æœ‰ä¸€ä¸ªç”ŸæˆæˆåŠŸã€‚</p><p>Letâ€™s build the RNG contract C1, and set the pledged ETH of C1 to 2000. The gambler G plays the betting dApp but also participates in the contract. When he finds himself in a disadvantageous position before he reveals his secret number, he can choose not to reveal s, so that the RNG failed and he got another chance. But he will lose the 2000 pledged ETH, so although he can get 1000 ETH expected return, it is still a bad deal. However, G can reduce his losses on C1 by some means, such as participating in C1 using two accounts, sending two sha3(s). if in a disadvantageous position, G will keep only one accountâ€™s secret, and if only one participant expect G participate to in C1, G will only lose 1000 ETH in C1, but G will get 1000 ETH as expected return, which is a worthy try.</p><p>è®©æˆ‘ä»¬æ„å»ºRNGæ™ºèƒ½åˆçº¦C1, å¹¶ä¸”è®¾ç½®æŠµæŠ¼çš„å€¼æ˜¯2000ã€‚ èµŒå¾’Gå‚ä¸äº†dAppçš„èµŒæ³¨ï¼ŒåŒæ—¶å‚ä¸äº†RNGçš„æ™ºèƒ½åˆçº¦ã€‚åœ¨ä»–æäº¤sä¹‹å‰ï¼Œå‘ç°è‡ªå·±å¤„åœ¨ä¸åˆ©çš„çŠ¶æ€ã€‚ä»–å¯ä»¥é€‰æ‹©ä¸æäº¤è‡ªå·±çš„sï¼Œè¿™æ ·RNGä¼šå¤±è´¥ï¼Œä»–ä¼šå¾—åˆ°ä¸‹ä¸€ä¸ªæœºä¼šã€‚ ä½†æ˜¯ä»–ä¼šæŸå¤±2000ETHçš„æŠµæŠ¼ï¼Œå°½ç®¡ä»–å¯ä»¥å¾—åˆ°1000ETHçš„èµŒæ³¨ï¼Œæ‰€ä»¥è¿™æ ·å¹¶ä¸æ˜¯ä¸€ä¸ªå¥½çš„äº¤æ˜“ã€‚ç„¶è€ŒèµŒå¾’Gå¯ä»¥ä½¿ç”¨å…¶ä»–çš„æ–¹å¼æ¥å‡å°‘æŸå¤±ï¼Œæ¯”å¦‚Gå¯ä»¥ä½¿ç”¨ä¸¤ä¸ªè´¦å·å‚ä¸RNGï¼Œå‘é€ä¸¤ä¸ªsha3(s).å¦‚æœåœ¨ä¸åˆ©çš„çŠ¶æ€ï¼ŒGä¼šè®©ä¸€ä¸ªè´¦å·ä¸æäº¤sï¼Œè¿™æ ·å¦‚æœé™¤äº†Gä¹‹å¤–åªæœ‰å¦å¤–ä¸€ä¸ªå…¶ä»–çš„è´¦å·ï¼ŒGåªä¼šåœ¨G1ä¸Šé¢æŸå¤±1000ETHï¼Œä½†æ˜¯Gå¦‚æœèµŒèµ¢äº†å¯ä»¥å¾—åˆ°1000ETHï¼Œæ‰€ä»¥ä¹Ÿå€¼å¾—ä¸€è¯•ã€‚</p><p>This issue can be fixed by confiscating the pledged ETH, and not return them to participants as bonus. so a contract with 1000 pledged ETH will meet the requirement of the betting dApp.</p><p>è¿™ç§æƒ…å†µå¯ä»¥é€šè¿‡æ²¡æ”¶æ‰€æœ‰æŠµæŠ¼æ¥ä¿®å¤ï¼Œä¸ä¼šæŠŠä»–ä»¬ä½œä¸ºå¥–åŠ±è¿”å›ã€‚æ‰€ä»¥ä¸€ä¸ª1000æŠµæŠ¼çš„åˆçº¦ä¼šç¬¦åˆèµŒåšçš„è¦æ±‚ã€‚</p><p>Besides confiscation, another scheme can prevent such attacks by introducing an additional system: RANDAO membership. To become a member you must pay dues, anyone paid their dues is a member. Members have different levels according to the dues they paid. Membership does not belong to a contract, but instead functions like a passport to participate in some RANDAO contracts. If a breach of any contract happens, that personâ€™s membership will be ended and the dues will be confiscated. Now we can add an additional agreement to C1, C1 will only accept numbers committed by members whose level of investment is high enough (membership dues over 1000 ETH). This will ensure that nobody has a financial motive to try an attack.</p><p>é™¤äº†æ²¡æ”¶ï¼Œè¿˜æœ‰ä¸€ä¸ªæ–¹æ¡ˆå¯ä»¥é˜»æ­¢è¿™ç§æ”»å‡»ï¼Œé‚£å°±æ˜¯ RANDAO membershipã€‚ ä¸ºäº†æˆä¸ºæˆå‘˜ï¼Œä½ å¿…é¡»ç¼´çº³æˆå‘˜è´¹ç”¨ã€‚æ ¹æ®æˆå‘˜ç¼´çº³çš„è´¹ç”¨çš„å¤šå°‘æŠŠæˆå‘˜åˆ†æˆä¸åŒçš„ç­‰çº§ï¼Œ æˆå‘˜ç³»ç»Ÿä¸å±äºæ™ºèƒ½åˆçº¦ï¼Œè€Œæ˜¯ä½œä¸ºä¸€ç§ç±»ä¼¼æŠ¤ç…§çš„å½¢å¼æ¥å‚ä¸ä¸€äº›RANDAOåˆçº¦ã€‚ å¦‚æœå‘ç”Ÿè¿çº¦æƒ…å†µï¼Œè¿™ä¸ªæˆå‘˜çš„ä¼šå‘˜èµ„æ ¼ä¼šè¢«ç»ˆæ­¢ï¼Œæˆå‘˜ä¼šç”¨ä¼šè¢«æ²¡æ”¶ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥ç»™æ™ºèƒ½åˆçº¦C1å¢åŠ ä¸€ä¸ªé¢å¤–çš„åè®®ï¼ŒC1åªæ¥å—ä¼šå‘˜ä¼šç”¨å¤§äºä¸€å®šå€¼çš„æˆå‘˜æ¥å‚ä¸ã€‚ è¿™æ ·æ¥ä¿è¯æ²¡æœ‰ä»»ä½•äººä¼šæœ‰è´¢åŠ¡åŠ¨æœºæ¥å‘åŠ¨æ”»å‡»ã€‚</p><h2 id="QA-Quest-and-Answer"><a href="#QA-Quest-and-Answer" class="headerlink" title="QA: Quest and Answer"></a>QA: Quest and Answer</h2><p>Q: Why not let the miners participate in RNG? Why not use tx hash, nonce and other blockchain data? A: Miners have the ability to manipulate these blockchain data, and thus can indirectly affect RNG. If RNG contains blockchain data, it will give the miners capacity to construct random numbers in their favor.</p><p>Q: ä¸ºä»€ä¹ˆä¸è®©çŸ¿å·¥æ¥å‚ä¸åˆ°RNGä¸­ï¼Ÿ ä¸ºä»€ä¹ˆä¸ä½¿ç”¨txhash,nonceæˆ–è€…å…¶ä»–åŒºå—é“¾æ•°æ®?  A:çŸ¿å·¥æœ‰èƒ½åŠ›æ‰æ“çºµè¿™äº›åŒºå—é“¾æ•°æ®ï¼Œè€Œè¿™äº›ä¼šå¯¹RNGäº§ç”Ÿå½±å“ã€‚å¦‚æœRNGåŒ…å«äº†åŒºå—é“¾æ•°æ®ï¼Œä¼šç»™äºˆçŸ¿å·¥æŒ‰ç…§è‡ªå·±çš„è¡Œä¸ºæ„é€ éšæœºæ•°çš„èƒ½åŠ›ã€‚</p><p>Q: the miners can ignore certain transactions that contain random number they dislike, how to deal with that? A: Thatâ€™s why we need a time window period. A reasonable period should be greater than 6 blocks, we believe that nobody can produce 6 blocks in succession. So if the participant is honest, and he send numbers immediately as long as each time window open, he doesnâ€™t need to worry about being excluded.</p><p>Q: çŸ¿å·¥æœ‰èƒ½åŠ›å¿½ç•¥ç‰¹å®šçš„åŒ…å«äº†éšæœºæ•°çš„äº¤æ˜“ï¼Œå¦‚ä½•å¤„ç†è¿™ç§æƒ…å†µï¼Ÿ A: è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦æ—¶é—´é—´éš”ã€‚ ä¸€ä¸ªåˆç†çš„æ—¶é—´é—´éš”ä¼šå¤§äº6ä¸ªåŒºå—ï¼Œæˆ‘ä»¬ä»»åŠ¡æ²¡æœ‰äººèƒ½è¿ç»­ç”Ÿæˆ6ä¸ªåŒºå—ã€‚ æ‰€ä»¥å¦‚æœå‚ä¸è€…æ˜¯å¿ è¯šçš„ï¼Œè€Œä¸”åœ¨æ—¶é—´çª—å£å†…å‘é€äº†é‚£ä¸ªæ•°å­—ï¼Œ é‚£ä¹ˆä»–ä¸åŒæ‹…å¿ƒä¼šè¢«çŸ¿å·¥æ’é™¤åœ¨å¤–ã€‚</p><p>Q: Why use all numbers of all participants, rather than a subset? A: The rule to pick a subset is deterministic, so participants will try to take specified position of the collection by various means, if they succeed, they will know in advance what the random number is generating from subsets. If the rule to pick a subset is randomised, then we still have the problem of true randomisation.</p><p>Q: ä¸ºä»€ä¹ˆä½¿ç”¨æ‰€æœ‰çš„å‚ä¸è€…çš„æ‰€æœ‰çš„å€¼ï¼Œè€Œä¸æ˜¯å…¶å­é›†ï¼Ÿ A: é€‰æ‹©ä¸€ä¸ªå­é›†çš„è§„åˆ™æ˜¯ç¡®å®šæ€§çš„ï¼Œæ‰€ä»¥å‚ä¸è€…å°†å°è¯•é€šè¿‡å„ç§æ–¹å¼æ¥é‡‡é›†æŒ‡å®šçš„é›†åˆä½ç½®ï¼Œå¦‚æœå®ƒä»¬æˆåŠŸï¼Œä»–ä»¬å°†äº‹å…ˆçŸ¥é“ä»å­é›†ä¸­äº§ç”Ÿçš„éšæœºæ•°ã€‚ å¦‚æœé€‰æ‹©ä¸€ä¸ªå­é›†çš„è§„åˆ™æ˜¯éšæœºçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»ç„¶å­˜åœ¨çœŸæ­£çš„éšæœºåŒ–é—®é¢˜ã€‚</p><p>Q: Where does pledged dues go? A: It will be donated to a charity, or RANDAO to maintain funding. Q: æ²¡æ”¶çš„è´¹ç”¨å»å“ªäº†ã€‚ ä¼šæçŒ®ç»™æ…ˆå–„æœºæ„ï¼Œæˆ–è€…æ˜¯RANDAOä¼šç»´æŠ¤ä¸€ä¸ªåŸºé‡‘ã€‚</p><p>Note: f(s1, s2, â€¦, sn) is a function with multiple inputs, for example r = s1 xor s2 xor s3 â€¦ xor sn, or r = sha3(sn + sha3(sn-1 + â€¦ (sha3(s2 + s1))))</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-core-bloombitsæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-bloombits%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-bloombits%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="scheduler-go"><a href="#scheduler-go" class="headerlink" title="scheduler.go"></a>scheduler.go</h2><p>scheduleræ˜¯åŸºäºsectionçš„å¸ƒéš†è¿‡æ»¤å™¨çš„å•ä¸ªbitå€¼æ£€ç´¢çš„è°ƒåº¦ã€‚ é™¤äº†è°ƒåº¦æ£€ç´¢æ“ä½œä¹‹å¤–ï¼Œè¿™ä¸ªç»“æ„è¿˜å¯ä»¥å¯¹è¯·æ±‚è¿›è¡Œé‡å¤æ•°æ®åˆ é™¤å¹¶ç¼“å­˜ç»“æœï¼Œä»è€Œå³ä½¿åœ¨å¤æ‚çš„è¿‡æ»¤æƒ…å†µä¸‹ä¹Ÿå¯ä»¥å°†ç½‘ç»œ/æ•°æ®åº“å¼€é”€é™è‡³æœ€ä½ã€‚</p><h3 id="æ•°æ®ç»“æ„"><a href="#æ•°æ®ç»“æ„" class="headerlink" title="æ•°æ®ç»“æ„"></a>æ•°æ®ç»“æ„</h3><p>requestè¡¨ç¤ºä¸€ä¸ªbloomæ£€ç´¢ä»»åŠ¡ï¼Œä»¥ä¾¿ä¼˜å…ˆä»æœ¬åœ°æ•°æ®åº“ä¸­æˆ–ä»ç½‘ç»œä¸­å‰ªæ£€ç´¢ã€‚ section è¡¨ç¤ºåŒºå—æ®µå·ï¼Œæ¯æ®µ4096ä¸ªåŒºå—ï¼Œ bitä»£è¡¨æ£€ç´¢çš„æ˜¯å¸ƒéš†è¿‡æ»¤å™¨çš„å“ªä¸€ä½(ä¸€å…±æœ‰2048ä½)ã€‚è¿™ä¸ªåœ¨ä¹‹å‰çš„(eth-bloombitså’Œfilteræºç åˆ†æ.md)ä¸­æœ‰ä»‹ç»ã€‚</p><pre><code>// request represents a bloom retrieval task to prioritize and pull from the local// database or remotely from the network.type request struct {    section uint64 // Section index to retrieve the a bit-vector from    bit     uint   // Bit index within the section to retrieve the vector of}</code></pre><p>responseå½“å‰è°ƒåº¦çš„è¯·æ±‚çš„çŠ¶æ€ã€‚ æ²¡å‘é€ä¸€ä¸ªè¯·æ±‚ï¼Œä¼šç”Ÿæˆä¸€ä¸ªresponseå¯¹è±¡æ¥æœ€ç»ˆè¿™ä¸ªè¯·æ±‚çš„çŠ¶æ€ã€‚<br>cachedç”¨æ¥ç¼“å­˜è¿™ä¸ªsectionçš„ç»“æœã€‚ </p><pre><code>// response represents the state of a requested bit-vector through a scheduler.type response struct {    cached []byte        // Cached bits to dedup multiple requests    done   chan struct{} // Channel to allow waiting for completion}</code></pre><p>scheduler</p><pre><code>// scheduler handles the scheduling of bloom-filter retrieval operations for// entire section-batches belonging to a single bloom bit. Beside scheduling the// retrieval operations, this struct also deduplicates the requests and caches// the results to minimize network/database overhead even in complex filtering// scenarios.type scheduler struct {    bit       uint                 // Index of the bit in the bloom filter this scheduler is responsible for å¸ƒéš†è¿‡æ»¤å™¨çš„å“ªä¸€ä¸ªbitä½(0-2047)    responses map[uint64]*response // Currently pending retrieval requests or already cached responses å½“å‰æ­£åœ¨è¿›è¡Œçš„è¯·æ±‚æˆ–è€…æ˜¯å·²ç»ç¼“å­˜çš„ç»“æœã€‚    lock      sync.Mutex           // Lock protecting the responses from concurrent access}</code></pre><h3 id="æ„é€ å‡½æ•°"><a href="#æ„é€ å‡½æ•°" class="headerlink" title="æ„é€ å‡½æ•°"></a>æ„é€ å‡½æ•°</h3><p>newSchedulerå’Œresetæ–¹æ³•</p><pre><code>// newScheduler creates a new bloom-filter retrieval scheduler for a specific// bit index.func newScheduler(idx uint) *scheduler {    return &amp;scheduler{        bit:       idx,        responses: make(map[uint64]*response),    }}// reset cleans up any leftovers from previous runs. This is required before a// restart to ensure the no previously requested but never delivered state will// cause a lockup.resetç”¨æ³•ç”¨æ¥æ¸…ç†ä¹‹å‰çš„æ‰€æœ‰ä»»ä½•è¯·æ±‚ã€‚func (s *scheduler) reset() {    s.lock.Lock()    defer s.lock.Unlock()    for section, res := range s.responses {        if res.cached == nil {            delete(s.responses, section)        }    }}</code></pre><h3 id="è¿è¡Œ-runæ–¹æ³•"><a href="#è¿è¡Œ-runæ–¹æ³•" class="headerlink" title="è¿è¡Œ runæ–¹æ³•"></a>è¿è¡Œ runæ–¹æ³•</h3><p>runæ–¹æ³•åˆ›å»ºäº†ä¸€ä¸ªæµæ°´çº¿ï¼Œ ä»sections channelæ¥æ¥æ”¶éœ€è¦è¯·æ±‚çš„sectionsï¼Œé€šè¿‡done channelæ¥æŒ‰ç…§è¯·æ±‚çš„é¡ºåºè¿”å›ç»“æœã€‚ å¹¶å‘çš„è¿è¡ŒåŒæ ·çš„scheduleræ˜¯å¯ä»¥çš„ï¼Œè¿™æ ·ä¼šå¯¼è‡´ä»»åŠ¡é‡å¤ã€‚</p><pre><code>// run creates a retrieval pipeline, receiving section indexes from sections and// returning the results in the same order through the done channel. Concurrent// runs of the same scheduler are allowed, leading to retrieval task deduplication.func (s *scheduler) run(sections chan uint64, dist chan *request, done chan []byte, quit chan struct{}, wg *sync.WaitGroup) {    // sections é€šé“ç±»å‹ è¿™ä¸ªæ˜¯ç”¨æ¥ä¼ é€’éœ€è¦æ£€ç´¢çš„sectionçš„é€šé“ï¼Œè¾“å…¥å‚æ•°    // dist     é€šé“ç±»å‹ï¼Œ å±äºè¾“å‡ºé€šé“(å¯èƒ½æ˜¯ç½‘ç»œå‘é€æˆ–è€…æ˜¯æœ¬åœ°æ£€ç´¢)ï¼Œå¾€è¿™ä¸ªé€šé“ä¸Šå‘é€è¯·æ±‚ï¼Œ ç„¶ååœ¨doneä¸Šè·å–å›åº”ã€‚    // done  ç”¨æ¥ä¼ é€’æ£€ç´¢ç»“æœçš„é€šé“ï¼Œ å¯ä»¥ç†è§£ä¸ºè¿”å›å€¼é€šé“ã€‚    // Create a forwarder channel between requests and responses of the same size as    // the distribution channel (since that will block the pipeline anyway).    åœ¨è¯·æ±‚å’Œå“åº”ä¹‹é—´åˆ›å»ºä¸€ä¸ªä¸åˆ†å‘é€šé“å¤§å°ç›¸åŒçš„è½¬å‘å™¨é€šé“ï¼ˆå› ä¸ºè¿™æ ·ä¼šé˜»å¡ç®¡é“ï¼‰    pend := make(chan uint64, cap(dist))    // Start the pipeline schedulers to forward between user -&gt; distributor -&gt; user    wg.Add(2)    go s.scheduleRequests(sections, dist, pend, quit, wg)    go s.scheduleDeliveries(pend, done, quit, wg)}</code></pre><h3 id="schedulerçš„æµç¨‹å›¾"><a href="#schedulerçš„æµç¨‹å›¾" class="headerlink" title="schedulerçš„æµç¨‹å›¾"></a>schedulerçš„æµç¨‹å›¾</h3><p><img src="/images/ethereum/source_analysis/chainindexer_2.png" alt="image"><br>å›¾ä¸­æ¤­åœ†ä»£è¡¨äº†goroutine. çŸ©å½¢ä»£è¡¨äº†channel. ä¸‰è§’å½¢ä»£è¡¨å¤–éƒ¨çš„æ–¹æ³•è°ƒç”¨ã€‚</p><ol><li>scheduleRequests goroutineä»sectionsæ¥æ”¶åˆ°sectionæ¶ˆæ¯</li><li>scheduleRequestsæŠŠæ¥æ”¶åˆ°çš„sectionç»„è£…æˆrequtestå‘é€åˆ°dist channelï¼Œå¹¶æ„å»ºå¯¹è±¡response[section]</li><li>scheduleRequestsæŠŠä¸Šä¸€éƒ¨çš„sectionå‘é€ç»™pendé˜Ÿåˆ—ã€‚scheduleDeliversæ¥æ”¶åˆ°pendæ¶ˆæ¯ï¼Œé˜»å¡åœ¨response[section].doneä¸Šé¢</li><li>å¤–éƒ¨è°ƒç”¨deliveræ–¹æ³•ï¼ŒæŠŠsecitonçš„requestè¯·æ±‚ç»“æœå†™å…¥response[section].cached.å¹¶å…³é—­response[section].done channel</li><li>scheduleDeliversæ¥æ”¶åˆ°response[section].done ä¿¡æ¯ã€‚ æŠŠresponse[section].cached å‘é€åˆ°done channel</li></ol><h3 id="scheduleRequests"><a href="#scheduleRequests" class="headerlink" title="scheduleRequests"></a>scheduleRequests</h3><pre><code>// scheduleRequests reads section retrieval requests from the input channel,// deduplicates the stream and pushes unique retrieval tasks into the distribution// channel for a database or network layer to honour.func (s *scheduler) scheduleRequests(reqs chan uint64, dist chan *request, pend chan uint64, quit chan struct{}, wg *sync.WaitGroup) {    // Clean up the goroutine and pipeline when done    defer wg.Done()    defer close(pend)    // Keep reading and scheduling section requests    for {        select {        case &lt;-quit:            return        case section, ok := &lt;-reqs:            // New section retrieval requested            if !ok {                return            }            // Deduplicate retrieval requests            unique := false            s.lock.Lock()            if s.responses[section] == nil {                s.responses[section] = &amp;response{                    done: make(chan struct{}),                }                unique = true            }            s.lock.Unlock()            // Schedule the section for retrieval and notify the deliverer to expect this section            if unique {                select {                case &lt;-quit:                    return                case dist &lt;- &amp;request{bit: s.bit, section: section}:                }            }            select {            case &lt;-quit:                return            case pend &lt;- section:            }        }    }}</code></pre><h2 id="generator-go"><a href="#generator-go" class="headerlink" title="generator.go"></a>generator.go</h2><p>generatorç”¨æ¥äº§ç”ŸåŸºäºsectionçš„å¸ƒéš†è¿‡æ»¤å™¨ç´¢å¼•æ•°æ®çš„å¯¹è±¡ã€‚ generatorå†…éƒ¨ä¸»è¦çš„æ•°æ®ç»“æ„æ˜¯ bloom[2048][4096]bit çš„æ•°æ®ç»“æ„ã€‚  è¾“å…¥æ˜¯4096ä¸ªheader.logBloomæ•°æ®ã€‚  æ¯”å¦‚ç¬¬20ä¸ªheaderçš„logBloomå­˜å‚¨åœ¨  bloom[0:2048][20]</p><p>æ•°æ®ç»“æ„ï¼š</p><pre><code>// Generator takes a number of bloom filters and generates the rotated bloom bits// to be used for batched filtering.type Generator struct {    blooms   [types.BloomBitLength][]byte // Rotated blooms for per-bit matching    sections uint                         // Number of sections to batch together  //ä¸€ä¸ªsectionåŒ…å«çš„åŒºå—å¤´çš„æ•°é‡ã€‚  é»˜è®¤æ˜¯4096    nextBit  uint                         // Next bit to set when adding a bloom å½“å¢åŠ ä¸€ä¸ªbloomçš„æ—¶å€™ï¼Œéœ€è¦è®¾ç½®å“ªä¸ªbitä½ç½®}</code></pre><p>æ„é€ ï¼š</p><pre><code>// NewGenerator creates a rotated bloom generator that can iteratively fill a// batched bloom filter's bits.// func NewGenerator(sections uint) (*Generator, error) {    if sections%8 != 0 {        return nil, errors.New("section count not multiple of 8")    }    b := &amp;Generator{sections: sections}    for i := 0; i &lt; types.BloomBitLength; i++ { //BloomBitLength=2048        b.blooms[i] = make([]byte, sections/8)  // é™¤ä»¥8æ˜¯å› ä¸ºä¸€ä¸ªbyteæ˜¯8ä¸ªbit    }    return b, nil}</code></pre><p>AddBloomå¢åŠ ä¸€ä¸ªåŒºå—å¤´çš„logsBloom</p><pre><code>// AddBloom takes a single bloom filter and sets the corresponding bit column// in memory accordingly.func (b *Generator) AddBloom(index uint, bloom types.Bloom) error {    // Make sure we're not adding more bloom filters than our capacity    if b.nextBit &gt;= b.sections { //è¶…è¿‡äº†sectionçš„æœ€å¤§æ•°é‡        return errSectionOutOfBounds    }    if b.nextBit != index {  //indexæ˜¯bloomåœ¨sectionä¸­çš„ä¸‹æ ‡        return errors.New("bloom filter with unexpected index")    }    // Rotate the bloom and insert into our collection    byteIndex := b.nextBit / 8  // æŸ¥æ‰¾åˆ°å¯¹åº”çš„byteï¼Œéœ€è¦è®¾ç½®è¿™ä¸ªbyteä½ç½®    bitMask := byte(1) &lt;&lt; byte(7-b.nextBit%8) // æ‰¾åˆ°éœ€è¦è®¾ç½®å€¼çš„bitåœ¨byteçš„ä¸‹æ ‡    for i := 0; i &lt; types.BloomBitLength; i++ {        bloomByteIndex := types.BloomByteLength - 1 - i/8        bloomBitMask := byte(1) &lt;&lt; byte(i%8)        if (bloom[bloomByteIndex] &amp; bloomBitMask) != 0 {            b.blooms[i][byteIndex] |= bitMask        }    }    b.nextBit++    return nil}</code></pre><p>Bitsetè¿”å›</p><pre><code>// Bitset returns the bit vector belonging to the given bit index after all// blooms have been added.// åœ¨æ‰€æœ‰çš„Bloomsè¢«æ·»åŠ ä¹‹åï¼ŒBitsetè¿”å›å±äºç»™å®šä½ç´¢å¼•çš„æ•°æ®ã€‚func (b *Generator) Bitset(idx uint) ([]byte, error) {    if b.nextBit != b.sections {        return nil, errors.New("bloom not fully generated yet")    }    if idx &gt;= b.sections {        return nil, errSectionOutOfBounds    }    return b.blooms[idx], nil}</code></pre><h2 id="matcher-go"><a href="#matcher-go" class="headerlink" title="matcher.go"></a>matcher.go</h2><p>Matcheræ˜¯ä¸€ä¸ªæµæ°´çº¿ç³»ç»Ÿçš„è°ƒåº¦å™¨å’Œé€»è¾‘åŒ¹é…å™¨ï¼Œå®ƒä»¬å¯¹æ¯”ç‰¹æµæ‰§è¡ŒäºŒè¿›åˆ¶ä¸/æˆ–æ“ä½œï¼Œåˆ›å»ºä¸€ä¸ªæ½œåœ¨å—çš„æµæ¥æ£€æŸ¥æ•°æ®å†…å®¹ã€‚</p><p>æ•°æ®ç»“æ„</p><pre><code>// partialMatches with a non-nil vector represents a section in which some sub-// matchers have already found potential matches. Subsequent sub-matchers will// binary AND their matches with this vector. If vector is nil, it represents a// section to be processed by the first sub-matcher.// partialMatchesä»£è¡¨äº†éƒ¨åˆ†åŒ¹é…çš„ç»“æœã€‚ æ¯”å…¥æœ‰ä¸‰ä¸ªéœ€è¦è¿‡æ»¤çš„æ¡ä»¶ addr1, addr2, addr3 ï¼Œéœ€è¦æ‰¾åˆ°åŒæ—¶åŒ¹é…è¿™ä¸‰ä¸ªæ¡ä»¶çš„æ•°æ®ã€‚ é‚£ä¹ˆæˆ‘ä»¬å¯åŠ¨åŒ…å«äº†åŒ¹é…è¿™ä¸‰ä¸ªæ¡ä»¶çš„æµæ°´çº¿ã€‚// ç¬¬ä¸€ä¸ªåŒ¹é…çš„ç»“æœä¼šé€ç»™ç¬¬äºŒä¸ªï¼Œç¬¬äºŒä¸ªæŠŠç¬¬ä¸€ä¸ªçš„ç»“æœå’Œè‡ªå·±çš„ç»“æœæ‰§è¡Œbitä¸æ“ä½œï¼Œç„¶åä½œä¸ºåŒ¹é…çš„ç»“æœé€ç»™ç¬¬ä¸‰ä¸ªå¤„ç†ã€‚type partialMatches struct {    section uint64    bitset  []byte}// Retrieval represents a request for retrieval task assignments for a given// bit with the given number of fetch elements, or a response for such a request.// It can also have the actual results set to be used as a delivery data struct.// Retrieval ä»£è¡¨äº† ä¸€æ¬¡åŒºå—å¸ƒéš†è¿‡æ»¤å™¨ç´¢å¼•çš„æ£€ç´¢å·¥ä½œï¼Œ è¿™ä¸ªå¯¹è±¡è¢«å‘é€ç»™ eth/bloombits.go é‡Œé¢çš„ startBloomHandlersæ¥å¤„ç†ï¼Œ è¿™ä¸ªæ–¹æ³•ä»æ•°æ®åº“æ¥åŠ è½½å¸ƒéš†è¿‡æ»¤å™¨ç´¢å¼•ç„¶åæ”¾åœ¨Bitsetsé‡Œé¢è¿”å›ã€‚type Retrieval struct {    Bit      uint    Sections []uint64    Bitsets  [][]byte}// Matcher is a pipelined system of schedulers and logic matchers which perform// binary AND/OR operations on the bit-streams, creating a stream of potential// blocks to inspect for data content.type Matcher struct {    sectionSize uint64 // Size of the data batches to filter on    filters    [][]bloomIndexes    // Filter the system is matching for    schedulers map[uint]*scheduler // Retrieval schedulers for loading bloom bits     retrievers chan chan uint       // Retriever processes waiting for bit allocations  ç”¨æ¥ä¼ é€’ æ£€ç´¢ä»»åŠ¡çš„é€šé“    counters   chan chan uint       // Retriever processes waiting for task count reports  ç”¨æ¥è¿”å›å½“å‰æ‰€æœ‰çš„ä»»åŠ¡æ•°é‡    retrievals chan chan *Retrieval // Retriever processes waiting for task allocations  ç”¨æ¥ä¼ é€’ æ£€ç´¢ä»»åŠ¡çš„åˆ†é…    deliveries chan *Retrieval      // Retriever processes waiting for task response deliveries  æ£€ç´¢å®Œæˆçš„ç»“æœä¼ é€’åˆ°è¿™ä¸ªé€šé“    running uint32 // Atomic flag whether a session is live or not}</code></pre><p>matcherçš„å¤§ä½“æµç¨‹å›¾ç‰‡ï¼Œé€”ä¸­æ¤­åœ†ä»£è¡¨goroutine. çŸ©å½¢ä»£è¡¨channelã€‚ ä¸‰è§’å½¢ä»£è¡¨æ–¹æ³•è°ƒç”¨ã€‚</p><p><img src="/images/ethereum/source_analysis/matcher_1.png" alt="image"></p><ol><li>é¦–å…ˆMatcheræ ¹æ®ä¼ å…¥çš„filterçš„ä¸ªæ•° åˆ›å»ºäº†å¯¹åº”ä¸ªæ•°çš„ subMatch ã€‚ æ¯ä¸€ä¸ªsubMatchå¯¹åº”äº†ä¸€ä¸ªfilterå¯¹è±¡ã€‚ æ¯ä¸€ä¸ªsubMatchä¼šæŠŠè‡ªå·±çš„æŸ¥æ‰¾ç»“æœå’Œä¸Šä¸€ä¸ªæŸ¥æ‰¾ç»“æœæŒ‰ç…§ä½ä¸çš„æ–¹å¼å¾—åˆ°æ–°çš„ç»“æœã€‚ å¦‚æœæ–°çš„ç»“æœæ‰€æœ‰çš„bitä½éƒ½æœ‰ç½®ä½ï¼Œå°±ä¼šæŠŠè¿™ä¸ªæŸ¥æ‰¾ç»“æœä¼ é€’ç»™ä¸‹ä¸€ä¸ªã€‚ è¿™æ˜¯å®ç°å¯¹æ‰€æœ‰çš„filterçš„ç»“æœæ±‚ä¸çš„çŸ­è·¯ç®—æ³•ã€‚  å¦‚æœå‰é¢çš„è®¡ç®—å·²ç»ä¸èƒ½åŒ¹é…ä»»ä½•ä¸œè¥¿ï¼Œé‚£ä¹ˆå°±ä¸ç”¨è¿›è¡Œä¸‹é¢çš„æ¡ä»¶çš„åŒ¹é…äº†ã€‚</li><li>Matcherä¼šæ ¹æ®fitersçš„å¸ƒéš†è¿‡æ»¤å™¨çš„ç»„åˆä¸‹æ ‡çš„ä¸ªæ•°æ¥å¯åŠ¨å¯¹åº”ä¸ªæ•°çš„scheduleã€‚</li><li>subMatchä¼šæŠŠè¯·æ±‚å‘é€ç»™å¯¹åº”çš„scheduleã€‚</li><li>scheduleä¼šæŠŠè¯·æ±‚è°ƒåº¦åé€šè¿‡distå‘é€ç»™distributorï¼Œ åœ¨distributorä¸­ç®¡ç†èµ·æ¥ã€‚</li><li>ä¼šå¯åŠ¨å¤šä¸ª(16)Multiplexçº¿ç¨‹ï¼Œä»distributorä¸­è·å–è¯·æ±‚ï¼Œç„¶åæŠŠè¯·æ±‚å‘é€ç»™bloomRequestsé˜Ÿåˆ—, startBloomHandlersä¼šè®¿é—®æ•°æ®åº“ï¼Œæ‹¿åˆ°æ•°æ®ç„¶åè¿”å›ç»™Multiplexã€‚</li><li>Multiplexé€šè¿‡deliveriesé€šé“æŠŠå›ç­”å‘Šè¯‰distributorã€‚</li><li>distributorè°ƒç”¨scheduleçš„deliveræ–¹æ³•ï¼ŒæŠŠç»“æœå‘é€ç»™schedule</li><li>scheduleæŠŠç»“æœè¿”å›ç»™subMatchã€‚</li><li>subMatchæŠŠç»“æœè¿›è¡Œè®¡ç®—åå‘é€ç»™ä¸‹ä¸€ä¸ªsubMatchè¿›è¡Œå¤„ç†ã€‚å¦‚æœæ˜¯æœ€åä¸€ä¸ªsubMatchï¼Œé‚£ä¹ˆç»“æœä¼šè¿›è¡Œå¤„ç†åå‘é€ç»™resultsé€šé“ã€‚</li></ol><p>matcher</p><pre><code>filter := New(backend, 0, -1, []common.Address{addr}, [][]common.Hash{{hash1, hash2, hash3, hash4}}) ç»„é—´æ˜¯ä¸çš„å…³ç³» ç»„å†…æ˜¯æˆ–çš„å…³ç³»ã€‚  (addr &amp;&amp; hash1) ||(addr &amp;&amp; hash2)||(addr &amp;&amp; hash3)||(addr &amp;&amp; hash4)</code></pre><p>æ„é€ å‡½æ•°ï¼Œ éœ€è¦ç‰¹åˆ«æ³¨æ„çš„æ˜¯è¾“å…¥çš„filtersè¿™ä¸ªå‚æ•°ã€‚ è¿™ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªä¸‰ç»´åº¦çš„æ•°ç»„  [][]bloomIndexes === [ç¬¬ä¸€ç»´åº¦][ç¬¬äºŒç»´åº¦][3] ã€‚ </p><pre><code>// è¿™ä¸ªæ˜¯filter.goé‡Œé¢çš„ä»£ç ï¼Œå¯¹äºç†è§£filtersè¿™ä¸ªå‚æ•°æ¯”è¾ƒæœ‰ç”¨ã€‚ filter.goæ˜¯Matcherçš„è°ƒç”¨è€…ã€‚ // å¯ä»¥çœ‹åˆ°æ— è®ºæœ‰å¤šå°‘ä¸ªaddressesï¼Œåœ¨filtersé‡Œé¢ä¹Ÿåªå ä¸€ä¸ªä½ç½®ã€‚ filters[0]=addresses// filters[1] = topics[0] = å¤šä¸ªtopic// filters[2] = topics[1] = å¤šä¸ªtopic// filters[n] = topics[n] = å¤šä¸ªtopic// filter çš„å‚æ•°addresses å’Œ topics çš„è¿‡æ»¤ç®—æ³•æ˜¯ï¼Œ (å«æœ‰addressesä¸­ä»»æ„ä¸€ä¸ªaddress) å¹¶ä¸” (å«æœ‰topics[0]é‡Œé¢çš„ä»»æ„ä¸€ä¸ªtopic) å¹¶ä¸” (å«æœ‰topics[1]é‡Œé¢ä»»æ„ä¸€ä¸ªtopic) å¹¶ä¸” (å«æœ‰topics[n]é‡Œé¢çš„ä»»æ„ä¸€ä¸ªtopic)// å¯ä»¥çœ‹åˆ° å¯¹äºfilter å®è¡Œçš„æ˜¯  å¯¹ç¬¬ä¸€ç»´çš„æ•°æ® æ‰§è¡Œ ä¸æ“ä½œï¼Œ å¯¹äºç¬¬äºŒç»´åº¦çš„æ•°æ®ï¼Œ æ‰§è¡Œæˆ–æ“ä½œã€‚// è€Œåœ¨NewMatcheræ–¹æ³•ä¸­ï¼ŒæŠŠç¬¬ä¸‰ç»´çš„å…·ä½“æ•°æ®è½¬æ¢æˆ å¸ƒéš†è¿‡æ»¤å™¨çš„æŒ‡å®šä¸‰ä¸ªä½ç½®ã€‚ æ‰€ä»¥åœ¨filter.goé‡Œé¢çš„var filters [][][]byte åœ¨Matcheré‡Œé¢çš„filterså˜æˆäº† [][][3]func New(backend Backend, begin, end int64, addresses []common.Address, topics [][]common.Hash) *Filter {    // Flatten the address and topic filter clauses into a single bloombits filter    // system. Since the bloombits are not positional, nil topics are permitted,    // which get flattened into a nil byte slice.    var filters [][][]byte    if len(addresses) &gt; 0 {        filter := make([][]byte, len(addresses))        for i, address := range addresses {            filter[i] = address.Bytes()        }        filters = append(filters, filter)    }    for _, topicList := range topics {        filter := make([][]byte, len(topicList))        for i, topic := range topicList {            filter[i] = topic.Bytes()        }        filters = append(filters, filter)    }// NewMatcher creates a new pipeline for retrieving bloom bit streams and doing// address and topic filtering on them. Setting a filter component to `nil` is// allowed and will result in that filter rule being skipped (OR 0x11...1).func NewMatcher(sectionSize uint64, filters [][][]byte) *Matcher {    // Create the matcher instance    m := &amp;Matcher{        sectionSize: sectionSize,        schedulers:  make(map[uint]*scheduler),        retrievers:  make(chan chan uint),        counters:    make(chan chan uint),        retrievals:  make(chan chan *Retrieval),        deliveries:  make(chan *Retrieval),    }    // Calculate the bloom bit indexes for the groups we're interested in    m.filters = nil    for _, filter := range filters {        // Gather the bit indexes of the filter rule, special casing the nil filter        if len(filter) == 0 {            continue        }        bloomBits := make([]bloomIndexes, len(filter))        for i, clause := range filter {            if clause == nil {                bloomBits = nil                break            }             // clause å¯¹åº”äº†è¾“å…¥çš„ç¬¬ä¸‰ç»´åº¦çš„æ•°æ®ï¼Œå¯èƒ½æ˜¯ä¸€ä¸ªaddressæˆ–è€…æ˜¯ä¸€ä¸ªtopic            // calcBloomIndexesè®¡ç®—äº†è¿™ä¸ªæ•°æ®å¯¹åº”çš„(0-2048)çš„å¸ƒéš†è¿‡æ»¤å™¨ä¸­çš„ä¸‰ä¸ªä¸‹æ ‡ï¼Œ å°±æ˜¯è¯´å¦‚æœåœ¨å¸ƒéš†è¿‡æ»¤å™¨ä¸­å¯¹åº”çš„ä¸‰ä½éƒ½ä¸º1ï¼Œé‚£ä¹ˆclauseè¿™ä¸ªæ•°æ®å°±æœ‰å¯èƒ½åœ¨è¿™é‡Œã€‚            bloomBits[i] = calcBloomIndexes(clause)        }        // Accumulate the filter rules if no nil rule was within        // åœ¨è®¡ç®—ä¸­ å¦‚æœbloomBitsä¸­åªè¦å…¶ä¸­çš„ä¸€æ¡èƒ½å¤Ÿæ‰¾åˆ°ã€‚é‚£ä¹ˆå°±è®¤ä¸ºæ•´ä¸ªæˆç«‹ã€‚        if bloomBits != nil {            // ä¸åŒçš„bloomBits éœ€è¦åŒæ—¶æˆç«‹ï¼Œæ•´ä¸ªç»“æœæ‰èƒ½æˆç«‹ã€‚            m.filters = append(m.filters, bloomBits)        }    }    // For every bit, create a scheduler to load/download the bit vectors    for _, bloomIndexLists := range m.filters {        for _, bloomIndexList := range bloomIndexLists {            for _, bloomIndex := range bloomIndexList {                // å¯¹äºæ‰€æœ‰å¯èƒ½å‡ºç°çš„ä¸‹æ ‡ã€‚ æˆ‘ä»¬éƒ½ç”Ÿæˆä¸€ä¸ªscheduleræ¥è¿›è¡Œå¯¹åº”ä½ç½®çš„                // å¸ƒéš†è¿‡æ»¤æ•°æ®çš„æ£€ç´¢ã€‚                m.addScheduler(bloomIndex)            }        }    }    return m}</code></pre><p>Start å¯åŠ¨</p><pre><code>// Start starts the matching process and returns a stream of bloom matches in// a given range of blocks. If there are no more matches in the range, the result// channel is closed.func (m *Matcher) Start(begin, end uint64, results chan uint64) (*MatcherSession, error) {    // Make sure we're not creating concurrent sessions    if atomic.SwapUint32(&amp;m.running, 1) == 1 {        return nil, errors.New("matcher already running")    }    defer atomic.StoreUint32(&amp;m.running, 0)    // Initiate a new matching round    // å¯åŠ¨äº†ä¸€ä¸ªsessionï¼Œä½œä¸ºè¿”å›å€¼ï¼Œç®¡ç†æŸ¥æ‰¾çš„ç”Ÿå‘½å‘¨æœŸã€‚    session := &amp;MatcherSession{        matcher: m,        quit:    make(chan struct{}),        kill:    make(chan struct{}),    }    for _, scheduler := range m.schedulers {        scheduler.reset()    }    // è¿™ä¸ªè¿è¡Œä¼šå»ºç«‹èµ·æµç¨‹ï¼Œè¿”å›äº†ä¸€ä¸ªpartialMatchesç±»å‹çš„ç®¡é“è¡¨ç¤ºæŸ¥è¯¢çš„éƒ¨åˆ†ç»“æœã€‚    sink := m.run(begin, end, cap(results), session)    // Read the output from the result sink and deliver to the user    session.pend.Add(1)    go func() {        defer session.pend.Done()        defer close(results)        for {            select {            case &lt;-session.quit:                return            case res, ok := &lt;-sink:                // New match result found                // æ‰¾åˆ°è¿”å›ç»“æœ å› ä¸ºè¿”å›å€¼æ˜¯ sectionå’Œ sectionä¸­å“ªäº›åŒºå—å¯èƒ½æœ‰å€¼çš„bitmap                // æ‰€ä»¥éœ€è¦éå†è¿™ä¸ªbitmapï¼Œæ‰¾åˆ°é‚£äº›è¢«ç½®ä½çš„åŒºå—ï¼ŒæŠŠåŒºå—å·è¿”å›å›å»ã€‚                if !ok {                    return                }                // Calculate the first and last blocks of the section                sectionStart := res.section * m.sectionSize                first := sectionStart                if begin &gt; first {                    first = begin                }                last := sectionStart + m.sectionSize - 1                if end &lt; last {                    last = end                }                // Iterate over all the blocks in the section and return the matching ones                for i := first; i &lt;= last; i++ {                    // Skip the entire byte if no matches are found inside                    next := res.bitset[(i-sectionStart)/8]                    if next == 0 {                        i += 7                        continue                    }                    // Some bit it set, do the actual submatching                    if bit := 7 - i%8; next&amp;(1&lt;&lt;bit) != 0 {                        select {                        case &lt;-session.quit:                            return                        case results &lt;- i:                        }                    }                }            }        }    }()    return session, nil}</code></pre><p>runæ–¹æ³•</p><pre><code>// run creates a daisy-chain of sub-matchers, one for the address set and one// for each topic set, each sub-matcher receiving a section only if the previous// ones have all found a potential match in one of the blocks of the section,// then binary AND-ing its own matches and forwaring the result to the next one.//  åˆ›å»ºä¸€ä¸ªå­åŒ¹é…å™¨çš„æµæ°´çº¿ï¼Œä¸€ä¸ªç”¨äºåœ°å€é›†ï¼Œä¸€ä¸ªç”¨äºæ¯ä¸ªä¸»é¢˜é›†ï¼Œæ¯ä¸ªå­åŒ¹é…å™¨åªæœ‰åœ¨å…ˆå‰çš„æ‰€æœ‰å­å—éƒ½åœ¨è¯¥éƒ¨åˆ†çš„ä¸€ä¸ªå—ä¸­æ‰¾åˆ°å¯èƒ½çš„åŒ¹é…æ—¶æ‰æ¥æ”¶ä¸€ä¸ªéƒ¨åˆ†ï¼Œç„¶åæŠŠæ¥æ”¶åˆ°çš„å’Œè‡ªå·±çš„åŒ¹é…ï¼Œå¹¶å°†ç»“æœè½¬äº¤ç»™ä¸‹ä¸€ä¸ªã€‚// The method starts feeding the section indexes into the first sub-matcher on a// new goroutine and returns a sink channel receiving the results.è¯¥æ–¹æ³•å¼€å§‹section indexeré€åˆ°ç¬¬ä¸€ä¸ªå­åŒ¹é…å™¨ï¼Œå¹¶è¿”å›æ¥æ”¶ç»“æœçš„æ¥æ”¶å™¨é€šé“ã€‚func (m *Matcher) run(begin, end uint64, buffer int, session *MatcherSession) chan *partialMatches {    // Create the source channel and feed section indexes into    source := make(chan *partialMatches, buffer)    session.pend.Add(1)    go func() {        defer session.pend.Done()        defer close(source)        for i := begin / m.sectionSize; i &lt;= end/m.sectionSize; i++ {            // è¿™ä¸ªforå¾ªç¯ æ„é€ äº†subMatchçš„ç¬¬ä¸€ä¸ªè¾“å…¥æºï¼Œå‰©ä¸‹çš„subMatchæŠŠä¸Šä¸€ä¸ªçš„ç»“æœä½œä¸ºè‡ªå·±çš„æº            // è¿™ä¸ªæºçš„bitsetå­—æ®µéƒ½æ˜¯0xffï¼Œä»£è¡¨å®Œå…¨çš„åŒ¹é…ï¼Œå®ƒå°†å’Œæˆ‘ä»¬è¿™ä¸€æ­¥çš„åŒ¹é…è¿›è¡Œä¸æ“ä½œï¼Œå¾—åˆ°è¿™ä¸€æ­¥åŒ¹é…çš„ç»“æœã€‚            select {            case &lt;-session.quit:                return            case source &lt;- &amp;partialMatches{i, bytes.Repeat([]byte{0xff}, int(m.sectionSize/8))}:            }        }    }()    // Assemble the daisy-chained filtering pipeline    next := source    dist := make(chan *request, buffer)    for _, bloom := range m.filters {  //æ„å»ºæµæ°´çº¿ï¼Œ å‰ä¸€ä¸ªçš„è¾“å‡ºä½œä¸ºä¸‹ä¸€ä¸ªsubMatchçš„è¾“å…¥ã€‚        next = m.subMatch(next, dist, bloom, session)    }    // Start the request distribution    session.pend.Add(1)    // å¯åŠ¨distributorçº¿ç¨‹ã€‚     go m.distributor(dist, session)    return next}</code></pre><p>subMatchå‡½æ•°</p><pre><code>// subMatch creates a sub-matcher that filters for a set of addresses or topics, binary OR-s those matches, then// binary AND-s the result to the daisy-chain input (source) and forwards it to the daisy-chain output.// The matches of each address/topic are calculated by fetching the given sections of the three bloom bit indexes belonging to// that address/topic, and binary AND-ing those vectors together.// subMatchåˆ›å»ºä¸€ä¸ªå­åŒ¹é…å™¨ï¼Œç”¨äºè¿‡æ»¤ä¸€ç»„åœ°å€æˆ–ä¸»é¢˜ï¼Œå¯¹è¿™äº›ä¸»é¢˜è¿›è¡Œbitä½æˆ–æ“ä½œï¼Œç„¶åå°†ä¸Šä¸€ä¸ªç»“æœä¸å½“å‰è¿‡æ»¤ç»“æœè¿›è¡Œä½ä¸æ“ä½œï¼Œå¦‚æœç»“æœä¸å…¨ä½ç©ºï¼Œå°±æŠŠç»“æœä¼ é€’ç»™ä¸‹ä¸€ä¸ªå­åŒ¹é…å™¨ã€‚ æ¯ä¸ªåœ°å€/é¢˜ç›®çš„åŒ¹é…æ˜¯é€šè¿‡è·å–å±äºè¯¥åœ°å€/é¢˜ç›®çš„ä¸‰ä¸ªå¸ƒéš†è¿‡æ»¤å™¨ä½ç´¢å¼•çš„ç»™å®šéƒ¨åˆ†ä»¥åŠå°†è¿™äº›å‘é‡äºŒè¿›åˆ¶ANDå¹¶åœ¨ä¸€èµ·æ¥è®¡ç®—çš„ã€‚subMatchæ˜¯æœ€é‡è¦çš„ä¸€ä¸ªå‡½æ•°ï¼Œ æŠŠfilters [][][3]çš„ ç¬¬ä¸€ç»´åº¦çš„ä¸ï¼Œç¬¬äºŒç»´åº¦çš„æˆ–ï¼Œ ç¬¬ä¸‰ç»´åº¦çš„ä¸æ“ä½œ ç»“åˆåœ¨ä¸€èµ·ã€‚ func (m *Matcher) subMatch(source chan *partialMatches, dist chan *request, bloom []bloomIndexes, session *MatcherSession) chan *partialMatches {    // Start the concurrent schedulers for each bit required by the bloom filter    // ä¼ å…¥çš„bloom []bloomIndexeså‚æ•°æ˜¯filtersçš„ç¬¬äºŒ,ç¬¬ä¸‰ç»´åº¦  [][3]      sectionSources := make([][3]chan uint64, len(bloom))    sectionSinks := make([][3]chan []byte, len(bloom))    for i, bits := range bloom { // iä»£è¡¨äº†ç¬¬äºŒç»´åº¦çš„æ•°é‡        for j, bit := range bits {  //j ä»£è¡¨äº†å¸ƒéš†è¿‡æ»¤å™¨çš„ä¸‹æ ‡ è‚¯å®šåªæœ‰ä¸‰ä¸ª å–å€¼(0-2048)            sectionSources[i][j] = make(chan uint64, cap(source)) // åˆ›å»ºschedulerçš„è¾“å…¥channel            sectionSinks[i][j] = make(chan []byte, cap(source)) // åˆ›å»º schedulerçš„è¾“å‡ºchannel            // å¯¹è¿™ä¸ªbitå‘èµ·è°ƒåº¦è¯·æ±‚ï¼Œ é€šè¿‡sectionSources[i][j]ä¼ é€’éœ€è¦æŸ¥è¯¢çš„section            // é€šè¿‡sectionSinks[i][j]æ¥æ¥æ”¶ç»“æœ            // dist æ˜¯schedulerä¼ é€’è¯·æ±‚çš„é€šé“ã€‚ è¿™ä¸ªåœ¨schedulerçš„ä»‹ç»é‡Œé¢æœ‰ã€‚            m.schedulers[bit].run(sectionSources[i][j], dist, sectionSinks[i][j], session.quit, &amp;session.pend)        }    }    process := make(chan *partialMatches, cap(source)) // entries from source are forwarded here after fetches have been initiated  ä¸­é—´channel    results := make(chan *partialMatches, cap(source)) // è¿”å›å€¼channel    session.pend.Add(2)    go func() {        // Tear down the goroutine and terminate all source channels        defer session.pend.Done()        defer close(process)        defer func() {            for _, bloomSources := range sectionSources {                for _, bitSource := range bloomSources {                    close(bitSource)                }            }        }()        // Read sections from the source channel and multiplex into all bit-schedulers        // ä»source channelè¯»å–sections å¹¶æŠŠè¿™äº›æ•°æ®é€šè¿‡sectionSourcesä¼ é€’ç»™scheduler        for {            select {            case &lt;-session.quit:                return            case subres, ok := &lt;-source:                // New subresult from previous link                if !ok {                    return                }                // Multiplex the section index to all bit-schedulers                for _, bloomSources := range sectionSources {                    for _, bitSource := range bloomSources {                        // ä¼ é€’ç»™ä¸Šé¢çš„æ‰€æœ‰çš„schedulerçš„è¾“å…¥é€šé“ã€‚ ç”³è¯·å¯¹è¿™äº›                        // section çš„æŒ‡å®šbitè¿›è¡ŒæŸ¥æ‰¾ã€‚ ç»“æœä¼šå‘é€ç»™sectionSinks[i][j]                        select {                        case &lt;-session.quit:                            return                        case bitSource &lt;- subres.section:                        }                    }                }                // Notify the processor that this section will become available                select {                case &lt;-session.quit:                    return                case process &lt;- subres: //ç­‰åˆ°æ‰€æœ‰çš„è¯·æ±‚éƒ½é€’äº¤ç»™scheduler ç»™processå‘é€æ¶ˆæ¯ã€‚                }            }        }    }()    go func() {        // Tear down the goroutine and terminate the final sink channel        defer session.pend.Done()        defer close(results)        // Read the source notifications and collect the delivered results        for {            select {            case &lt;-session.quit:                return            case subres, ok := &lt;-process:                 // è¿™é‡Œæœ‰ä¸ªé—®é¢˜ã€‚ æœ‰æ²¡æœ‰å¯èƒ½ä¹±åºã€‚ å› ä¸ºé€šé“éƒ½æ˜¯æœ‰ç¼“å­˜çš„ã€‚ å¯èƒ½æŸ¥è¯¢å¾—å¿«æ…¢å¯¼è‡´                // æŸ¥çœ‹äº†schedulerçš„å®ç°ï¼Œ scheduleræ˜¯ä¿è¯é¡ºåºçš„ã€‚æ€ä¹ˆè¿›æ¥ï¼Œå°±ä¼šæ€ä¹ˆå‡ºå»ã€‚                // Notified of a section being retrieved                if !ok {                    return                }                // Gather all the sub-results and merge them together                var orVector []byte                for _, bloomSinks := range sectionSinks {                    var andVector []byte                    for _, bitSink := range bloomSinks { // è¿™é‡Œå¯ä»¥æ¥æ”¶åˆ°ä¸‰ä¸ªå€¼ æ¯ä¸ªä»£è¡¨äº†å¯¹åº”ä¸‹æ ‡çš„ å¸ƒéš†è¿‡æ»¤å™¨çš„å€¼,å¯¹è¿™ä¸‰ä¸ªå€¼è¿›è¡Œä¸æ“ä½œï¼Œ                    å°±å¯ä»¥å¾—åˆ°é‚£äº›åŒºå—å¯èƒ½å­˜åœ¨å¯¹åº”çš„å€¼ã€‚                        var data []byte                        select {                        case &lt;-session.quit:                            return                        case data = &lt;-bitSink:                        }                        if andVector == nil {                            andVector = make([]byte, int(m.sectionSize/8))                            copy(andVector, data)                        } else {                            bitutil.ANDBytes(andVector, andVector, data)                        }                    }                    if orVector == nil { å¯¹ç¬¬ä¸€ç»´åº¦çš„æ•°æ®æ‰§è¡Œ Oræ“ä½œã€‚                        orVector = andVector                    } else {                        bitutil.ORBytes(orVector, orVector, andVector)                    }                }                if orVector == nil { //å¯èƒ½é€šé“è¢«å…³é—­äº†ã€‚ æ²¡æœ‰æŸ¥è¯¢åˆ°ä»»ä½•å€¼                    orVector = make([]byte, int(m.sectionSize/8))                }                if subres.bitset != nil {                    // å’Œè¾“å…¥çš„ä¸Šä¸€æ¬¡çš„ç»“æœè¿›è¡Œä¸æ“ä½œã€‚ è®°å¾—æœ€å¼€å§‹è¿™ä¸ªå€¼è¢«åˆå§‹åŒ–ä¸ºå…¨1                    bitutil.ANDBytes(orVector, orVector, subres.bitset)                }                if bitutil.TestBytes(orVector) { // å¦‚æœä¸å…¨ä¸º0 é‚£ä¹ˆæ·»åŠ åˆ°ç»“æœã€‚å¯èƒ½ä¼šç»™ä¸‹ä¸€ä¸ªåŒ¹é…ã€‚æˆ–è€…æ˜¯è¿”å›ã€‚                    select {                    case &lt;-session.quit:                        return                    case results &lt;- &amp;partialMatches{subres.section, orVector}:                    }                }            }        }    }()    return results}</code></pre><p>distributor,æ¥å—æ¥è‡ªschedulerçš„è¯·æ±‚ï¼Œå¹¶æŠŠä»–ä»¬æ”¾åˆ°ä¸€ä¸ªseté‡Œé¢ã€‚ ç„¶åæŠŠè¿™äº›ä»»åŠ¡æŒ‡æ´¾ç»™retrieversæ¥å¡«å……ä»–ä»¬ã€‚</p><pre><code>// distributor receives requests from the schedulers and queues them into a set// of pending requests, which are assigned to retrievers wanting to fulfil them.func (m *Matcher) distributor(dist chan *request, session *MatcherSession) {    defer session.pend.Done()    var (        requests   = make(map[uint][]uint64) // Per-bit list of section requests, ordered by section number        unallocs   = make(map[uint]struct{}) // Bits with pending requests but not allocated to any retriever        retrievers chan chan uint            // Waiting retrievers (toggled to nil if unallocs is empty)    )    var (        allocs   int            // Number of active allocations to handle graceful shutdown requests        shutdown = session.quit // Shutdown request channel, will gracefully wait for pending requests    )    // assign is a helper method fo try to assign a pending bit an an actively    // listening servicer, or schedule it up for later when one arrives.    assign := func(bit uint) {        select {        case fetcher := &lt;-m.retrievers:            allocs++            fetcher &lt;- bit        default:            // No retrievers active, start listening for new ones            retrievers = m.retrievers            unallocs[bit] = struct{}{}        }    }    for {        select {        case &lt;-shutdown:            // Graceful shutdown requested, wait until all pending requests are honoured            if allocs == 0 {                return            }            shutdown = nil        case &lt;-session.kill:            // Pending requests not honoured in time, hard terminate            return        case req := &lt;-dist: // schedulerå‘é€æ¥çš„è¯·æ±‚ æ·»åŠ åˆ°æŒ‡å®šbitä½ç½®çš„queueé‡Œé¢            // New retrieval request arrived to be distributed to some fetcher process            queue := requests[req.bit]            index := sort.Search(len(queue), func(i int) bool { return queue[i] &gt;= req.section })            requests[req.bit] = append(queue[:index], append([]uint64{req.section}, queue[index:]...)...)            // If it's a new bit and we have waiting fetchers, allocate to them            // å¦‚æœè¿™ä¸ªbitæ˜¯ä¸€ä¸ªæ–°çš„ã€‚ è¿˜æ²¡æœ‰è¢«æŒ‡æ´¾ï¼Œé‚£ä¹ˆæˆ‘ä»¬æŠŠä»–æŒ‡æ´¾ç»™ç­‰å¾…çš„fetchers            if len(queue) == 0 {                assign(req.bit)            }        case fetcher := &lt;-retrievers:            // New retriever arrived, find the lowest section-ed bit to assign            // å¦‚æœæ–°çš„retrieversè¿›æ¥äº†ï¼Œ é‚£ä¹ˆæˆ‘ä»¬æŸ¥çœ‹æ˜¯å¦æœ‰ä»»åŠ¡æ²¡æœ‰æŒ‡æ´¾            bit, best := uint(0), uint64(math.MaxUint64)            for idx := range unallocs {                if requests[idx][0] &lt; best {                    bit, best = idx, requests[idx][0]                }            }            // Stop tracking this bit (and alloc notifications if no more work is available)            delete(unallocs, bit)            if len(unallocs) == 0 { //å¦‚æœæ‰€æœ‰ä»»åŠ¡éƒ½è¢«æŒ‡æ´¾ã€‚é‚£ä¹ˆåœæ­¢å…³æ³¨retrievers                retrievers = nil            }            allocs++            fetcher &lt;- bit        case fetcher := &lt;-m.counters:            // New task count request arrives, return number of items            // æ¥äº†æ–°çš„è¯·æ±‚ï¼Œè®¿é—®requestçš„æŒ‡å®šbitçš„æ•°é‡ã€‚            fetcher &lt;- uint(len(requests[&lt;-fetcher]))        case fetcher := &lt;-m.retrievals:            // New fetcher waiting for tasks to retrieve, assign            // æœ‰äººæ¥é¢†å–ä»»åŠ¡ã€‚            task := &lt;-fetcher            if want := len(task.Sections); want &gt;= len(requests[task.Bit]) {                task.Sections = requests[task.Bit]                delete(requests, task.Bit)            } else {                task.Sections = append(task.Sections[:0], requests[task.Bit][:want]...)                requests[task.Bit] = append(requests[task.Bit][:0], requests[task.Bit][want:]...)            }            fetcher &lt;- task            // If anything was left unallocated, try to assign to someone else            // å¦‚æœè¿˜æœ‰ä»»åŠ¡æ²¡æœ‰åˆ†æ´¾å®Œã€‚ å°è¯•åˆ†é…ç»™å…¶ä»–äººã€‚            if len(requests[task.Bit]) &gt; 0 {                assign(task.Bit)            }        case result := &lt;-m.deliveries:            // New retrieval task response from fetcher, split out missing sections and            // deliver complete ones            // æ”¶åˆ°äº†ä»»åŠ¡çš„ç»“æœã€‚             var (                sections = make([]uint64, 0, len(result.Sections))                bitsets  = make([][]byte, 0, len(result.Bitsets))                missing  = make([]uint64, 0, len(result.Sections))            )            for i, bitset := range result.Bitsets {                if len(bitset) == 0 { //å¦‚æœä»»åŠ¡ç»“æœæœ‰ç¼ºå¤±ï¼Œè®°å½•ä¸‹æ¥                    missing = append(missing, result.Sections[i])                    continue                }                sections = append(sections, result.Sections[i])                bitsets = append(bitsets, bitset)            }            // æŠ•é€’ç»“æœ            m.schedulers[result.Bit].deliver(sections, bitsets)            allocs--            // Reschedule missing sections and allocate bit if newly available            if len(missing) &gt; 0 { //å¦‚æœæœ‰ç¼ºå¤±ï¼Œ é‚£ä¹ˆé‡æ–°ç”Ÿæˆæ–°çš„ä»»åŠ¡ã€‚                queue := requests[result.Bit]                for _, section := range missing {                    index := sort.Search(len(queue), func(i int) bool { return queue[i] &gt;= section })                    queue = append(queue[:index], append([]uint64{section}, queue[index:]...)...)                }                requests[result.Bit] = queue                if len(queue) == len(missing) {                    assign(result.Bit)                }            }            // If we're in the process of shutting down, terminate            if allocs == 0 &amp;&amp; shutdown == nil {                return            }        }    }}</code></pre><p>ä»»åŠ¡é¢†å–AllocateRetrievalã€‚ ä»»åŠ¡é¢†å–äº†ä¸€ä¸ªä»»åŠ¡ã€‚ ä¼šè¿”å›æŒ‡å®šçš„bitçš„æ£€ç´¢ä»»åŠ¡ã€‚</p><pre><code>// AllocateRetrieval assigns a bloom bit index to a client process that can either// immediately reuest and fetch the section contents assigned to this bit or wait// a little while for more sections to be requested.func (s *MatcherSession) AllocateRetrieval() (uint, bool) {    fetcher := make(chan uint)    select {    case &lt;-s.quit:        return 0, false    case s.matcher.retrievers &lt;- fetcher:        bit, ok := &lt;-fetcher        return bit, ok    }}</code></pre><p>AllocateSections,é¢†å–æŒ‡å®šbitçš„sectionæŸ¥è¯¢ä»»åŠ¡ã€‚</p><pre><code>// AllocateSections assigns all or part of an already allocated bit-task queue// to the requesting process.func (s *MatcherSession) AllocateSections(bit uint, count int) []uint64 {    fetcher := make(chan *Retrieval)    select {    case &lt;-s.quit:        return nil    case s.matcher.retrievals &lt;- fetcher:        task := &amp;Retrieval{            Bit:      bit,            Sections: make([]uint64, count),        }        fetcher &lt;- task        return (&lt;-fetcher).Sections    }}</code></pre><p>DeliverSectionsï¼ŒæŠŠç»“æœæŠ•é€’ç»™deliveries é€šé“ã€‚</p><pre><code>// DeliverSections delivers a batch of section bit-vectors for a specific bloom// bit index to be injected into the processing pipeline.func (s *MatcherSession) DeliverSections(bit uint, sections []uint64, bitsets [][]byte) {    select {    case &lt;-s.kill:        return    case s.matcher.deliveries &lt;- &amp;Retrieval{Bit: bit, Sections: sections, Bitsets: bitsets}:    }}</code></pre><p>ä»»åŠ¡çš„æ‰§è¡ŒMultiplex,Multiplexå‡½æ•°ä¸æ–­çš„é¢†å–ä»»åŠ¡ï¼ŒæŠŠä»»åŠ¡æŠ•é€’ç»™bloomRequesté˜Ÿåˆ—ã€‚ä»é˜Ÿåˆ—è·å–ç»“æœã€‚ç„¶åæŠ•é€’ç»™distributorã€‚ å®Œæˆäº†æ•´ä¸ªè¿‡ç¨‹ã€‚</p><pre><code>// Multiplex polls the matcher session for rerieval tasks and multiplexes it into// the reuested retrieval queue to be serviced together with other sessions.//// This method will block for the lifetime of the session. Even after termination// of the session, any request in-flight need to be responded to! Empty responses// are fine though in that case.func (s *MatcherSession) Multiplex(batch int, wait time.Duration, mux chan chan *Retrieval) {    for {        // Allocate a new bloom bit index to retrieve data for, stopping when done        bit, ok := s.AllocateRetrieval()        if !ok {            return        }        // Bit allocated, throttle a bit if we're below our batch limit        if s.PendingSections(bit) &lt; batch {            select {            case &lt;-s.quit:                // Session terminating, we can't meaningfully service, abort                s.AllocateSections(bit, 0)                s.DeliverSections(bit, []uint64{}, [][]byte{})                return            case &lt;-time.After(wait):                // Throttling up, fetch whatever's available            }        }        // Allocate as much as we can handle and request servicing        sections := s.AllocateSections(bit, batch)        request := make(chan *Retrieval)        select {        case &lt;-s.quit:            // Session terminating, we can't meaningfully service, abort            s.DeliverSections(bit, sections, make([][]byte, len(sections)))            return        case mux &lt;- request:            // Retrieval accepted, something must arrive before we're aborting            request &lt;- &amp;Retrieval{Bit: bit, Sections: sections}            result := &lt;-request            s.DeliverSections(result.Bit, result.Sections, result.Bitsets)        }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-core-txpooläº¤æ˜“æ± æºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-txpool%E4%BA%A4%E6%98%93%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-txpool%E4%BA%A4%E6%98%93%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>txpoolä¸»è¦ç”¨æ¥å­˜æ”¾å½“å‰æäº¤çš„ç­‰å¾…å†™å…¥åŒºå—çš„äº¤æ˜“ï¼Œæœ‰è¿œç«¯å’Œæœ¬åœ°çš„ã€‚</p><p>txpoolé‡Œé¢çš„äº¤æ˜“åˆ†ä¸ºä¸¤ç§ï¼Œ</p><ol><li>æäº¤ä½†æ˜¯è¿˜ä¸èƒ½æ‰§è¡Œçš„ï¼Œæ”¾åœ¨queueé‡Œé¢ç­‰å¾…èƒ½å¤Ÿæ‰§è¡Œ(æ¯”å¦‚è¯´nonceå¤ªé«˜)ã€‚</li><li>ç­‰å¾…æ‰§è¡Œçš„ï¼Œæ”¾åœ¨pendingé‡Œé¢ç­‰å¾…æ‰§è¡Œã€‚</li></ol><p>ä»txpoolçš„æµ‹è¯•æ¡ˆä¾‹æ¥çœ‹ï¼Œtxpoolä¸»è¦åŠŸèƒ½æœ‰ä¸‹é¢å‡ ç‚¹ã€‚</p><ol><li>äº¤æ˜“éªŒè¯çš„åŠŸèƒ½ï¼ŒåŒ…æ‹¬ä½™é¢ä¸è¶³ï¼ŒGasä¸è¶³ï¼ŒNonceå¤ªä½, valueå€¼æ˜¯åˆæ³•çš„ï¼Œä¸èƒ½ä¸ºè´Ÿæ•°ã€‚</li><li>èƒ½å¤Ÿç¼“å­˜Nonceæ¯”å½“å‰æœ¬åœ°è´¦å·çŠ¶æ€é«˜çš„äº¤æ˜“ã€‚ å­˜æ”¾åœ¨queueå­—æ®µã€‚ å¦‚æœæ˜¯èƒ½å¤Ÿæ‰§è¡Œçš„äº¤æ˜“å­˜æ”¾åœ¨pendingå­—æ®µ</li><li>ç›¸åŒç”¨æˆ·çš„ç›¸åŒNonceçš„äº¤æ˜“åªä¼šä¿ç•™ä¸€ä¸ªGasPriceæœ€å¤§çš„é‚£ä¸ªã€‚ å…¶ä»–çš„æ’å…¥ä¸æˆåŠŸã€‚</li><li>å¦‚æœè´¦å·æ²¡æœ‰é’±äº†ï¼Œé‚£ä¹ˆqueueå’Œpendingä¸­å¯¹åº”è´¦å·çš„äº¤æ˜“ä¼šè¢«åˆ é™¤ã€‚</li><li>å¦‚æœè´¦å·çš„ä½™é¢å°äºä¸€äº›äº¤æ˜“çš„é¢åº¦ï¼Œé‚£ä¹ˆå¯¹åº”çš„äº¤æ˜“ä¼šè¢«åˆ é™¤ï¼ŒåŒæ—¶æœ‰æ•ˆçš„äº¤æ˜“ä¼šä»pendingç§»åŠ¨åˆ°queueé‡Œé¢ã€‚é˜²æ­¢è¢«å¹¿æ’­ã€‚</li><li>txPoolæ”¯æŒä¸€äº›é™åˆ¶PriceLimit(removeçš„æœ€ä½GasPriceé™åˆ¶)ï¼ŒPriceBump(æ›¿æ¢ç›¸åŒNonceçš„äº¤æ˜“çš„ä»·æ ¼çš„ç™¾åˆ†æ¯”) AccountSlots(æ¯ä¸ªè´¦æˆ·çš„pendingçš„æ§½ä½çš„æœ€å°å€¼) GlobalSlots(å…¨å±€pendingé˜Ÿåˆ—çš„æœ€å¤§å€¼)AccountQueue(æ¯ä¸ªè´¦æˆ·çš„queueingçš„æ§½ä½çš„æœ€å°å€¼) GlobalQueue(å…¨å±€queueingçš„æœ€å¤§å€¼) Lifetime(åœ¨queueé˜Ÿåˆ—çš„æœ€é•¿ç­‰å¾…æ—¶é—´)</li><li>æœ‰é™çš„èµ„æºæƒ…å†µä¸‹æŒ‰ç…§GasPriceçš„ä¼˜å…ˆçº§è¿›è¡Œæ›¿æ¢ã€‚</li><li>æœ¬åœ°çš„äº¤æ˜“ä¼šä½¿ç”¨journalçš„åŠŸèƒ½å­˜æ”¾åœ¨ç£ç›˜ä¸Šï¼Œé‡å¯ä¹‹åä¼šé‡æ–°å¯¼å…¥ã€‚ è¿œç¨‹çš„äº¤æ˜“ä¸ä¼šã€‚</li></ol><p>æ•°æ®ç»“æ„</p><pre><code>// TxPool contains all currently known transactions. Transactions// enter the pool when they are received from the network or submitted// locally. They exit the pool when they are included in the blockchain.// TxPool åŒ…å«äº†å½“å‰çŸ¥çš„äº¤æ˜“ï¼Œ å½“å‰ç½‘ç»œæ¥æ”¶åˆ°äº¤æ˜“ï¼Œæˆ–è€…æœ¬åœ°æäº¤çš„äº¤æ˜“ä¼šåŠ å…¥åˆ°TxPoolã€‚// å½“ä»–ä»¬å·²ç»è¢«æ·»åŠ åˆ°åŒºå—é“¾çš„æ—¶å€™è¢«ç§»é™¤ã€‚// The pool separates processable transactions (which can be applied to the// current state) and future transactions. Transactions move between those// two states over time as they are received and processed.// TxPoolåˆ†ä¸ºå¯æ‰§è¡Œçš„äº¤æ˜“(å¯ä»¥åº”ç”¨åˆ°å½“å‰çš„çŠ¶æ€)å’Œæœªæ¥çš„äº¤æ˜“ã€‚ äº¤æ˜“åœ¨è¿™ä¸¤ç§çŠ¶æ€ä¹‹é—´è½¬æ¢ï¼Œtype TxPool struct {    config       TxPoolConfig    chainconfig  *params.ChainConfig    chain        blockChain    gasPrice     *big.Int             //æœ€ä½çš„GasPriceé™åˆ¶    txFeed       event.Feed              //é€šè¿‡txFeedæ¥è®¢é˜…TxPoolçš„æ¶ˆæ¯    scope        event.SubscriptionScope    chainHeadCh  chan ChainHeadEvent  // è®¢é˜…äº†åŒºå—å¤´çš„æ¶ˆæ¯ï¼Œå½“æœ‰äº†æ–°çš„åŒºå—å¤´ç”Ÿæˆçš„æ—¶å€™ä¼šåœ¨è¿™é‡Œæ”¶åˆ°é€šçŸ¥    chainHeadSub event.Subscription   // åŒºå—å¤´æ¶ˆæ¯çš„è®¢é˜…å™¨ã€‚    signer       types.Signer          // å°è£…äº†äº‹åŠ¡ç­¾åå¤„ç†ã€‚    mu           sync.RWMutex    currentState  *state.StateDB      // Current state in the blockchain head    pendingState  *state.ManagedState // Pending state tracking virtual nonces    currentMaxGas *big.Int            // Current gas limit for transaction caps ç›®å‰äº¤æ˜“ä¸Šé™çš„GasLimit    locals  *accountSet // Set of local transaction to exepmt from evicion rules  æœ¬åœ°äº¤æ˜“å…é™¤é©±é€è§„åˆ™    journal *txJournal  // Journal of local transaction to back up to disk æœ¬åœ°äº¤æ˜“ä¼šå†™å…¥ç£ç›˜    pending map[common.Address]*txList         // All currently processable transactions æ‰€æœ‰å½“å‰å¯ä»¥å¤„ç†çš„äº¤æ˜“    queue   map[common.Address]*txList         // Queued but non-processable transactions å½“å‰è¿˜ä¸èƒ½å¤„ç†çš„äº¤æ˜“    beats   map[common.Address]time.Time       // Last heartbeat from each known account æ¯ä¸€ä¸ªå·²çŸ¥è´¦å·çš„æœ€åä¸€æ¬¡å¿ƒè·³ä¿¡æ¯çš„æ—¶é—´    all     map[common.Hash]*types.Transaction // All transactions to allow lookups å¯ä»¥æŸ¥æ‰¾åˆ°æ‰€æœ‰äº¤æ˜“    priced  *txPricedList                      // All transactions sorted by price æŒ‰ç…§ä»·æ ¼æ’åºçš„äº¤æ˜“    wg sync.WaitGroup // for shutdown sync    homestead bool  // å®¶å›­ç‰ˆæœ¬}</code></pre><p>æ„å»º</p><pre><code>// NewTxPool creates a new transaction pool to gather, sort and filter inbound// trnsactions from the network.func NewTxPool(config TxPoolConfig, chainconfig *params.ChainConfig, chain blockChain) *TxPool {    // Sanitize the input to ensure no vulnerable gas prices are set    config = (&amp;config).sanitize()    // Create the transaction pool with its initial settings    pool := &amp;TxPool{        config:      config,        chainconfig: chainconfig,        chain:       chain,        signer:      types.NewEIP155Signer(chainconfig.ChainId),        pending:     make(map[common.Address]*txList),        queue:       make(map[common.Address]*txList),        beats:       make(map[common.Address]time.Time),        all:         make(map[common.Hash]*types.Transaction),        chainHeadCh: make(chan ChainHeadEvent, chainHeadChanSize),        gasPrice:    new(big.Int).SetUint64(config.PriceLimit),    }    pool.locals = newAccountSet(pool.signer)    pool.priced = newTxPricedList(&amp;pool.all)    pool.reset(nil, chain.CurrentBlock().Header())    // If local transactions and journaling is enabled, load from disk    // å¦‚æœæœ¬åœ°äº¤æ˜“è¢«å…è®¸,è€Œä¸”é…ç½®çš„Journalç›®å½•ä¸ä¸ºç©º,é‚£ä¹ˆä»æŒ‡å®šçš„ç›®å½•åŠ è½½æ—¥å¿—.    // ç„¶årotateäº¤æ˜“æ—¥å¿—. å› ä¸ºè€çš„äº¤æ˜“å¯èƒ½å·²ç»å¤±æ•ˆäº†, æ‰€ä»¥è°ƒç”¨addæ–¹æ³•ä¹‹åå†æŠŠè¢«æ¥æ”¶çš„äº¤æ˜“å†™å…¥æ—¥å¿—.    //     if !config.NoLocals &amp;&amp; config.Journal != "" {        pool.journal = newTxJournal(config.Journal)        if err := pool.journal.load(pool.AddLocal); err != nil {            log.Warn("Failed to load transaction journal", "err", err)        }        if err := pool.journal.rotate(pool.local()); err != nil {            log.Warn("Failed to rotate transaction journal", "err", err)        }    }    // Subscribe events from blockchain ä»åŒºå—é“¾è®¢é˜…äº‹ä»¶ã€‚    pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)    // Start the event loop and return    pool.wg.Add(1)    go pool.loop()    return pool}</code></pre><p>resetæ–¹æ³•æ£€ç´¢åŒºå—é“¾çš„å½“å‰çŠ¶æ€å¹¶ä¸”ç¡®ä¿äº‹åŠ¡æ± çš„å†…å®¹å…³äºå½“å‰çš„åŒºå—é“¾çŠ¶æ€æ˜¯æœ‰æ•ˆçš„ã€‚ä¸»è¦åŠŸèƒ½åŒ…æ‹¬ï¼š</p><ol><li>å› ä¸ºæ›´æ¢äº†åŒºå—å¤´ï¼Œæ‰€ä»¥åŸæœ‰çš„åŒºå—ä¸­æœ‰ä¸€äº›äº¤æ˜“å› ä¸ºåŒºå—å¤´çš„æ›´æ¢è€Œä½œåºŸï¼Œè¿™éƒ¨åˆ†äº¤æ˜“éœ€è¦é‡æ–°åŠ å…¥åˆ°txPoolé‡Œé¢ç­‰å¾…æ’å…¥æ–°çš„åŒºå—</li><li>ç”Ÿæˆæ–°çš„currentStateå’ŒpendingState</li><li>å› ä¸ºçŠ¶æ€çš„æ”¹å˜ã€‚å°†pendingä¸­çš„éƒ¨åˆ†äº¤æ˜“ç§»åˆ°queueé‡Œé¢</li><li>å› ä¸ºçŠ¶æ€çš„æ”¹å˜ï¼Œå°†queueé‡Œé¢çš„äº¤æ˜“ç§»å…¥åˆ°pendingé‡Œé¢ã€‚</li></ol><p>resetä»£ç </p><pre><code>// reset retrieves the current state of the blockchain and ensures the content// of the transaction pool is valid with regard to the chain state.func (pool *TxPool) reset(oldHead, newHead *types.Header) {    // If we're reorging an old state, reinject all dropped transactions    var reinject types.Transactions    if oldHead != nil &amp;&amp; oldHead.Hash() != newHead.ParentHash {        // If the reorg is too deep, avoid doing it (will happen during fast sync)        oldNum := oldHead.Number.Uint64()        newNum := newHead.Number.Uint64()        if depth := uint64(math.Abs(float64(oldNum) - float64(newNum))); depth &gt; 64 { //å¦‚æœè€çš„å¤´å’Œæ–°çš„å¤´å·®è·å¤ªè¿œ, é‚£ä¹ˆå–æ¶ˆé‡å»º            log.Warn("Skipping deep transaction reorg", "depth", depth)        } else {            // Reorg seems shallow enough to pull in all transactions into memory            var discarded, included types.Transactions            var (                rem = pool.chain.GetBlock(oldHead.Hash(), oldHead.Number.Uint64())                add = pool.chain.GetBlock(newHead.Hash(), newHead.Number.Uint64())            )            // å¦‚æœè€çš„é«˜åº¦å¤§äºæ–°çš„.é‚£ä¹ˆéœ€è¦æŠŠå¤šçš„å…¨éƒ¨åˆ é™¤.            for rem.NumberU64() &gt; add.NumberU64() {                discarded = append(discarded, rem.Transactions()...)                if rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()-1); rem == nil {                    log.Error("Unrooted old chain seen by tx pool", "block", oldHead.Number, "hash", oldHead.Hash())                    return                }            }            // å¦‚æœæ–°çš„é«˜åº¦å¤§äºè€çš„, é‚£ä¹ˆéœ€è¦å¢åŠ .            for add.NumberU64() &gt; rem.NumberU64() {                included = append(included, add.Transactions()...)                if add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()-1); add == nil {                    log.Error("Unrooted new chain seen by tx pool", "block", newHead.Number, "hash", newHead.Hash())                    return                }            }            // é«˜åº¦ç›¸åŒäº†.å¦‚æœhashä¸åŒ,é‚£ä¹ˆéœ€è¦å¾€åæ‰¾,ä¸€ç›´æ‰¾åˆ°ä»–ä»¬ç›¸åŒhashæ ¹çš„èŠ‚ç‚¹.            for rem.Hash() != add.Hash() {                discarded = append(discarded, rem.Transactions()...)                if rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()-1); rem == nil {                    log.Error("Unrooted old chain seen by tx pool", "block", oldHead.Number, "hash", oldHead.Hash())                    return                }                included = append(included, add.Transactions()...)                if add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()-1); add == nil {                    log.Error("Unrooted new chain seen by tx pool", "block", newHead.Number, "hash", newHead.Hash())                    return                }            }            // æ‰¾å‡ºæ‰€æœ‰å­˜åœ¨discardé‡Œé¢,ä½†æ˜¯ä¸åœ¨includedé‡Œé¢çš„å€¼.            // éœ€è¦ç­‰ä¸‹æŠŠè¿™äº›äº¤æ˜“é‡æ–°æ’å…¥åˆ°poolé‡Œé¢ã€‚            reinject = types.TxDifference(discarded, included)        }    }    // Initialize the internal state to the current head    if newHead == nil {        newHead = pool.chain.CurrentBlock().Header() // Special case during testing    }    statedb, err := pool.chain.StateAt(newHead.Root)    if err != nil {        log.Error("Failed to reset txpool state", "err", err)        return    }    pool.currentState = statedb    pool.pendingState = state.ManageState(statedb)    pool.currentMaxGas = newHead.GasLimit    // Inject any transactions discarded due to reorgs    log.Debug("Reinjecting stale transactions", "count", len(reinject))    pool.addTxsLocked(reinject, false)    // validate the pool of pending transactions, this will remove    // any transactions that have been included in the block or    // have been invalidated because of another transaction (e.g.    // higher gas price)    // éªŒè¯pending transactionæ± é‡Œé¢çš„äº¤æ˜“ï¼Œ ä¼šç§»é™¤æ‰€æœ‰å·²ç»å­˜åœ¨åŒºå—é“¾é‡Œé¢çš„äº¤æ˜“ï¼Œæˆ–è€…æ˜¯å› ä¸ºå…¶ä»–äº¤æ˜“å¯¼è‡´ä¸å¯ç”¨çš„äº¤æ˜“(æ¯”å¦‚æœ‰ä¸€ä¸ªæ›´é«˜çš„gasPrice)    // demote é™çº§ å°†pendingä¸­çš„ä¸€äº›äº¤æ˜“é™çº§åˆ°queueé‡Œé¢ã€‚    pool.demoteUnexecutables()    // Update all accounts to the latest known pending nonce    // æ ¹æ®pendingé˜Ÿåˆ—çš„nonceæ›´æ–°æ‰€æœ‰è´¦å·çš„nonce    for addr, list := range pool.pending {        txs := list.Flatten() // Heavy but will be cached and is needed by the miner anyway        pool.pendingState.SetNonce(addr, txs[len(txs)-1].Nonce()+1)    }    // Check the queue and move transactions over to the pending if possible    // or remove those that have become invalid    // æ£€æŸ¥é˜Ÿåˆ—å¹¶å°½å¯èƒ½åœ°å°†äº‹åŠ¡ç§»åˆ°pendingï¼Œæˆ–åˆ é™¤é‚£äº›å·²ç»å¤±æ•ˆçš„äº‹åŠ¡    // promote å‡çº§     pool.promoteExecutables(nil)}</code></pre><p>addTx </p><pre><code>// addTx enqueues a single transaction into the pool if it is valid.func (pool *TxPool) addTx(tx *types.Transaction, local bool) error {    pool.mu.Lock()    defer pool.mu.Unlock()    // Try to inject the transaction and update any state    replace, err := pool.add(tx, local)    if err != nil {        return err    }    // If we added a new transaction, run promotion checks and return    if !replace {        from, _ := types.Sender(pool.signer, tx) // already validated        pool.promoteExecutables([]common.Address{from})    }    return nil}</code></pre><p>addTxsLocked</p><pre><code>// addTxsLocked attempts to queue a batch of transactions if they are valid,// whilst assuming the transaction pool lock is already held.// addTxsLockedå°è¯•æŠŠæœ‰æ•ˆçš„äº¤æ˜“æ”¾å…¥queueé˜Ÿåˆ—ï¼Œè°ƒç”¨è¿™ä¸ªå‡½æ•°çš„æ—¶å€™å‡è®¾å·²ç»è·å–åˆ°é”func (pool *TxPool) addTxsLocked(txs []*types.Transaction, local bool) error {    // Add the batch of transaction, tracking the accepted ones    dirty := make(map[common.Address]struct{})    for _, tx := range txs {        if replace, err := pool.add(tx, local); err == nil {            if !replace { // replace æ˜¯æ›¿æ¢çš„æ„æ€ï¼Œ å¦‚æœä¸æ˜¯æ›¿æ¢ï¼Œé‚£ä¹ˆå°±è¯´æ˜çŠ¶æ€æœ‰æ›´æ–°ï¼Œæœ‰å¯ä»¥ä¸‹ä¸€æ­¥å¤„ç†çš„å¯èƒ½ã€‚                from, _ := types.Sender(pool.signer, tx) // already validated                dirty[from] = struct{}{}            }        }    }    // Only reprocess the internal state if something was actually added    if len(dirty) &gt; 0 {        addrs := make([]common.Address, 0, len(dirty))        for addr, _ := range dirty {            addrs = append(addrs, addr)        }            // ä¼ å…¥äº†è¢«ä¿®æ”¹çš„åœ°å€ï¼Œ        pool.promoteExecutables(addrs)    }    return nil}</code></pre><p>demoteUnexecutables ä»pendingåˆ é™¤æ— æ•ˆçš„æˆ–è€…æ˜¯å·²ç»å¤„ç†è¿‡çš„äº¤æ˜“ï¼Œå…¶ä»–çš„ä¸å¯æ‰§è¡Œçš„äº¤æ˜“ä¼šè¢«ç§»åŠ¨åˆ°future queueä¸­ã€‚</p><pre><code>// demoteUnexecutables removes invalid and processed transactions from the pools// executable/pending queue and any subsequent transactions that become unexecutable// are moved back into the future queue.func (pool *TxPool) demoteUnexecutables() {    // Iterate over all accounts and demote any non-executable transactions    for addr, list := range pool.pending {        nonce := pool.currentState.GetNonce(addr)        // Drop all transactions that are deemed too old (low nonce)        // åˆ é™¤æ‰€æœ‰å°äºå½“å‰åœ°å€çš„nonceçš„äº¤æ˜“ï¼Œå¹¶ä»pool.allåˆ é™¤ã€‚        for _, tx := range list.Forward(nonce) {            hash := tx.Hash()            log.Trace("Removed old pending transaction", "hash", hash)            delete(pool.all, hash)            pool.priced.Removed()        }        // Drop all transactions that are too costly (low balance or out of gas), and queue any invalids back for later        // åˆ é™¤æ‰€æœ‰çš„å¤ªæ˜‚è´µçš„äº¤æ˜“ã€‚ ç”¨æˆ·çš„balanceå¯èƒ½ä¸å¤Ÿç”¨ã€‚æˆ–è€…æ˜¯out of gas        drops, invalids := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)        for _, tx := range drops {            hash := tx.Hash()            log.Trace("Removed unpayable pending transaction", "hash", hash)            delete(pool.all, hash)            pool.priced.Removed()            pendingNofundsCounter.Inc(1)        }        for _, tx := range invalids {            hash := tx.Hash()            log.Trace("Demoting pending transaction", "hash", hash)            pool.enqueueTx(hash, tx)        }        // If there's a gap in front, warn (should never happen) and postpone all transactions        // å¦‚æœå­˜åœ¨ä¸€ä¸ªç©ºæ´(nonceç©ºæ´)ï¼Œ é‚£ä¹ˆéœ€è¦æŠŠæ‰€æœ‰çš„äº¤æ˜“éƒ½æ”¾å…¥future queueã€‚        // è¿™ä¸€æ­¥ç¡®å®åº”è¯¥ä¸å¯èƒ½å‘ç”Ÿï¼Œå› ä¸ºFilterå·²ç»æŠŠ invalidsçš„éƒ½å¤„ç†äº†ã€‚ åº”è¯¥ä¸å­˜åœ¨invalidsçš„äº¤æ˜“ï¼Œä¹Ÿå°±æ˜¯ä¸å­˜åœ¨ç©ºæ´çš„ã€‚        if list.Len() &gt; 0 &amp;&amp; list.txs.Get(nonce) == nil {            for _, tx := range list.Cap(0) {                hash := tx.Hash()                log.Error("Demoting invalidated transaction", "hash", hash)                pool.enqueueTx(hash, tx)            }        }        // Delete the entire queue entry if it became empty.        if list.Empty() {             delete(pool.pending, addr)            delete(pool.beats, addr)        }    }}</code></pre><p>enqueueTx æŠŠä¸€ä¸ªæ–°çš„äº¤æ˜“æ’å…¥åˆ°future queueã€‚ è¿™ä¸ªæ–¹æ³•å‡è®¾å·²ç»è·å–äº†æ± çš„é”ã€‚</p><pre><code>// enqueueTx inserts a new transaction into the non-executable transaction queue.//// Note, this method assumes the pool lock is held!func (pool *TxPool) enqueueTx(hash common.Hash, tx *types.Transaction) (bool, error) {    // Try to insert the transaction into the future queue    from, _ := types.Sender(pool.signer, tx) // already validated    if pool.queue[from] == nil {        pool.queue[from] = newTxList(false)    }    inserted, old := pool.queue[from].Add(tx, pool.config.PriceBump)    if !inserted {        // An older transaction was better, discard this        queuedDiscardCounter.Inc(1)        return false, ErrReplaceUnderpriced    }    // Discard any previous transaction and mark this    if old != nil {        delete(pool.all, old.Hash())        pool.priced.Removed()        queuedReplaceCounter.Inc(1)    }    pool.all[hash] = tx    pool.priced.Put(tx)    return old != nil, nil}</code></pre><p>promoteExecutablesæ–¹æ³•æŠŠ å·²ç»å˜å¾—å¯ä»¥æ‰§è¡Œçš„äº¤æ˜“ä»future queue æ’å…¥åˆ°pending queueã€‚é€šè¿‡è¿™ä¸ªå¤„ç†è¿‡ç¨‹ï¼Œæ‰€æœ‰çš„æ— æ•ˆçš„äº¤æ˜“(nonceå¤ªä½ï¼Œä½™é¢ä¸è¶³)ä¼šè¢«åˆ é™¤ã€‚</p><pre><code>// promoteExecutables moves transactions that have become processable from the// future queue to the set of pending transactions. During this process, all// invalidated transactions (low nonce, low balance) are deleted.func (pool *TxPool) promoteExecutables(accounts []common.Address) {    // Gather all the accounts potentially needing updates    // accountså­˜å‚¨äº†æ‰€æœ‰æ½œåœ¨éœ€è¦æ›´æ–°çš„è´¦æˆ·ã€‚ å¦‚æœè´¦æˆ·ä¼ å…¥ä¸ºnilï¼Œä»£è¡¨æ‰€æœ‰å·²çŸ¥çš„è´¦æˆ·ã€‚    if accounts == nil {        accounts = make([]common.Address, 0, len(pool.queue))        for addr, _ := range pool.queue {            accounts = append(accounts, addr)        }    }    // Iterate over all accounts and promote any executable transactions    for _, addr := range accounts {        list := pool.queue[addr]        if list == nil {            continue // Just in case someone calls with a non existing account        }        // Drop all transactions that are deemed too old (low nonce)        // åˆ é™¤æ‰€æœ‰çš„nonceå¤ªä½çš„äº¤æ˜“        for _, tx := range list.Forward(pool.currentState.GetNonce(addr)) {            hash := tx.Hash()            log.Trace("Removed old queued transaction", "hash", hash)            delete(pool.all, hash)            pool.priced.Removed()        }        // Drop all transactions that are too costly (low balance or out of gas)        // åˆ é™¤æ‰€æœ‰ä½™é¢ä¸è¶³çš„äº¤æ˜“ã€‚        drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)        for _, tx := range drops {            hash := tx.Hash()            log.Trace("Removed unpayable queued transaction", "hash", hash)            delete(pool.all, hash)            pool.priced.Removed()            queuedNofundsCounter.Inc(1)        }        // Gather all executable transactions and promote them        // å¾—åˆ°æ‰€æœ‰çš„å¯ä»¥æ‰§è¡Œçš„äº¤æ˜“ï¼Œå¹¶promoteTxåŠ å…¥pending        for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) {            hash := tx.Hash()            log.Trace("Promoting queued transaction", "hash", hash)            pool.promoteTx(addr, hash, tx)        }        // Drop all transactions over the allowed limit        // åˆ é™¤æ‰€æœ‰è¶…è¿‡é™åˆ¶çš„äº¤æ˜“ã€‚        if !pool.locals.contains(addr) {            for _, tx := range list.Cap(int(pool.config.AccountQueue)) {                hash := tx.Hash()                delete(pool.all, hash)                pool.priced.Removed()                queuedRateLimitCounter.Inc(1)                log.Trace("Removed cap-exceeding queued transaction", "hash", hash)            }        }        // Delete the entire queue entry if it became empty.        if list.Empty() {            delete(pool.queue, addr)        }    }    // If the pending limit is overflown, start equalizing allowances    pending := uint64(0)    for _, list := range pool.pending {        pending += uint64(list.Len())    }    // å¦‚æœpendingçš„æ€»æ•°è¶…è¿‡ç³»ç»Ÿçš„é…ç½®ã€‚     if pending &gt; pool.config.GlobalSlots {                pendingBeforeCap := pending        // Assemble a spam order to penalize large transactors first        spammers := prque.New()        for addr, list := range pool.pending {            // Only evict transactions from high rollers            // é¦–å…ˆæŠŠæ‰€æœ‰å¤§äºAccountSlotsæœ€å°å€¼çš„è´¦æˆ·è®°å½•ä¸‹æ¥ï¼Œ ä¼šä»è¿™äº›è´¦æˆ·é‡Œé¢å‰”é™¤ä¸€äº›äº¤æ˜“ã€‚            // æ³¨æ„spammersæ˜¯ä¸€ä¸ªä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œä¹Ÿå°±æ˜¯è¯´æ˜¯æŒ‰ç…§äº¤æ˜“çš„å¤šå°‘ä»å¤§åˆ°å°æ’åºçš„ã€‚            if !pool.locals.contains(addr) &amp;&amp; uint64(list.Len()) &gt; pool.config.AccountSlots {                spammers.Push(addr, float32(list.Len()))            }        }        // Gradually drop transactions from offenders        offenders := []common.Address{}        for pending &gt; pool.config.GlobalSlots &amp;&amp; !spammers.Empty() {            /*                æ¨¡æ‹Ÿä¸€ä¸‹offendersé˜Ÿåˆ—çš„è´¦æˆ·äº¤æ˜“æ•°é‡çš„å˜åŒ–æƒ…å†µã€‚                 ç¬¬ä¸€æ¬¡å¾ªç¯   [10]    å¾ªç¯ç»“æŸ  [10]                ç¬¬äºŒæ¬¡å¾ªç¯   [10, 9] å¾ªç¯ç»“æŸ  [9,9]                ç¬¬ä¸‰æ¬¡å¾ªç¯   [9, 9, 7] å¾ªç¯ç»“æŸ [7, 7, 7]                ç¬¬å››æ¬¡å¾ªç¯   [7, 7 , 7 ,2] å¾ªç¯ç»“æŸ [2, 2 ,2, 2]            */            // Retrieve the next offender if not local address            offender, _ := spammers.Pop()            offenders = append(offenders, offender.(common.Address))            // Equalize balances until all the same or below threshold            if len(offenders) &gt; 1 { // ç¬¬ä¸€æ¬¡è¿›å…¥è¿™ä¸ªå¾ªç¯çš„æ—¶å€™ï¼Œ offendersé˜Ÿåˆ—é‡Œé¢æœ‰äº¤æ˜“æ•°é‡æœ€å¤§çš„ä¸¤ä¸ªè´¦æˆ·                // Calculate the equalization threshold for all current offenders                // æŠŠæœ€ååŠ å…¥çš„è´¦æˆ·çš„äº¤æ˜“æ•°é‡å½“æˆæœ¬æ¬¡çš„é˜ˆå€¼                threshold := pool.pending[offender.(common.Address)].Len()                // Iteratively reduce all offenders until below limit or threshold reached                // éå†ç›´åˆ°pendingæœ‰æ•ˆï¼Œæˆ–è€…æ˜¯å€’æ•°ç¬¬äºŒä¸ªçš„äº¤æ˜“æ•°é‡ç­‰äºæœ€åä¸€ä¸ªçš„äº¤æ˜“æ•°é‡                for pending &gt; pool.config.GlobalSlots &amp;&amp; pool.pending[offenders[len(offenders)-2]].Len() &gt; threshold {                    // éå†é™¤äº†æœ€åä¸€ä¸ªè´¦æˆ·ä»¥å¤–çš„æ‰€æœ‰è´¦æˆ·ï¼Œ æŠŠä»–ä»¬çš„äº¤æ˜“æ•°é‡å‡å»1.                    for i := 0; i &lt; len(offenders)-1; i++ {                        list := pool.pending[offenders[i]]                        for _, tx := range list.Cap(list.Len() - 1) {                            // Drop the transaction from the global pools too                            hash := tx.Hash()                            delete(pool.all, hash)                            pool.priced.Removed()                            // Update the account nonce to the dropped transaction                            if nonce := tx.Nonce(); pool.pendingState.GetNonce(offenders[i]) &gt; nonce {                                pool.pendingState.SetNonce(offenders[i], nonce)                            }                            log.Trace("Removed fairness-exceeding pending transaction", "hash", hash)                        }                        pending--                    }                }            }        }        // If still above threshold, reduce to limit or min allowance        // ç»è¿‡ä¸Šé¢çš„å¾ªç¯ï¼Œæ‰€æœ‰çš„è¶…è¿‡AccountSlotsçš„è´¦æˆ·çš„äº¤æ˜“æ•°é‡éƒ½å˜æˆäº†ä¹‹å‰çš„æœ€å°å€¼ã€‚        // å¦‚æœè¿˜æ˜¯è¶…è¿‡é˜ˆå€¼ï¼Œé‚£ä¹ˆåœ¨ç»§ç»­ä»offendersé‡Œé¢æ¯æ¬¡åˆ é™¤ä¸€ä¸ªã€‚        if pending &gt; pool.config.GlobalSlots &amp;&amp; len(offenders) &gt; 0 {            for pending &gt; pool.config.GlobalSlots &amp;&amp; uint64(pool.pending[offenders[len(offenders)-1]].Len()) &gt; pool.config.AccountSlots {                for _, addr := range offenders {                    list := pool.pending[addr]                    for _, tx := range list.Cap(list.Len() - 1) {                        // Drop the transaction from the global pools too                        hash := tx.Hash()                        delete(pool.all, hash)                        pool.priced.Removed()                        // Update the account nonce to the dropped transaction                        if nonce := tx.Nonce(); pool.pendingState.GetNonce(addr) &gt; nonce {                            pool.pendingState.SetNonce(addr, nonce)                        }                        log.Trace("Removed fairness-exceeding pending transaction", "hash", hash)                    }                    pending--                }            }        }        pendingRateLimitCounter.Inc(int64(pendingBeforeCap - pending))    }  //end if pending &gt; pool.config.GlobalSlots {    // If we've queued more transactions than the hard limit, drop oldest ones    // æˆ‘ä»¬å¤„ç†äº†pendingçš„é™åˆ¶ï¼Œ ä¸‹é¢éœ€è¦å¤„ç†future queueçš„é™åˆ¶äº†ã€‚    queued := uint64(0)    for _, list := range pool.queue {        queued += uint64(list.Len())    }    if queued &gt; pool.config.GlobalQueue {        // Sort all accounts with queued transactions by heartbeat        addresses := make(addresssByHeartbeat, 0, len(pool.queue))        for addr := range pool.queue {            if !pool.locals.contains(addr) { // don't drop locals                addresses = append(addresses, addressByHeartbeat{addr, pool.beats[addr]})            }        }        sort.Sort(addresses)        // Drop transactions until the total is below the limit or only locals remain        // ä»åå¾€å‰ï¼Œä¹Ÿå°±æ˜¯å¿ƒè·³è¶Šæ–°çš„å°±è¶Šä¼šè¢«åˆ é™¤ã€‚        for drop := queued - pool.config.GlobalQueue; drop &gt; 0 &amp;&amp; len(addresses) &gt; 0; {            addr := addresses[len(addresses)-1]            list := pool.queue[addr.address]            addresses = addresses[:len(addresses)-1]            // Drop all transactions if they are less than the overflow            if size := uint64(list.Len()); size &lt;= drop {                for _, tx := range list.Flatten() {                    pool.removeTx(tx.Hash())                }                drop -= size                queuedRateLimitCounter.Inc(int64(size))                continue            }            // Otherwise drop only last few transactions            txs := list.Flatten()            for i := len(txs) - 1; i &gt;= 0 &amp;&amp; drop &gt; 0; i-- {                pool.removeTx(txs[i].Hash())                drop--                queuedRateLimitCounter.Inc(1)            }        }    }}</code></pre><p>promoteTxæŠŠæŸä¸ªäº¤æ˜“åŠ å…¥åˆ°pending é˜Ÿåˆ—. è¿™ä¸ªæ–¹æ³•å‡è®¾å·²ç»è·å–åˆ°äº†é”.</p><pre><code>// promoteTx adds a transaction to the pending (processable) list of transactions.//// Note, this method assumes the pool lock is held!func (pool *TxPool) promoteTx(addr common.Address, hash common.Hash, tx *types.Transaction) {    // Try to insert the transaction into the pending queue    if pool.pending[addr] == nil {        pool.pending[addr] = newTxList(true)    }    list := pool.pending[addr]    inserted, old := list.Add(tx, pool.config.PriceBump)    if !inserted { // å¦‚æœä¸èƒ½æ›¿æ¢, å·²ç»å­˜åœ¨ä¸€ä¸ªè€çš„äº¤æ˜“äº†. åˆ é™¤.        // An older transaction was better, discard this        delete(pool.all, hash)        pool.priced.Removed()        pendingDiscardCounter.Inc(1)        return    }    // Otherwise discard any previous transaction and mark this    if old != nil {         delete(pool.all, old.Hash())        pool.priced.Removed()        pendingReplaceCounter.Inc(1)    }    // Failsafe to work around direct pending inserts (tests)    if pool.all[hash] == nil {        pool.all[hash] = tx        pool.priced.Put(tx)    }    // Set the potentially new pending nonce and notify any subsystems of the new tx    // æŠŠäº¤æ˜“åŠ å…¥åˆ°é˜Ÿåˆ—,å¹¶å‘é€æ¶ˆæ¯å‘Šè¯‰æ‰€æœ‰çš„è®¢é˜…è€…, è¿™ä¸ªè®¢é˜…è€…åœ¨ethåè®®å†…éƒ¨. ä¼šæ¥æ”¶è¿™ä¸ªæ¶ˆæ¯å¹¶æŠŠè¿™ä¸ªæ¶ˆæ¯é€šè¿‡ç½‘è·¯å¹¿æ’­å‡ºå».    pool.beats[addr] = time.Now()    pool.pendingState.SetNonce(addr, tx.Nonce()+1)    go pool.txFeed.Send(TxPreEvent{tx})}</code></pre><p>removeTxï¼Œåˆ é™¤æŸä¸ªäº¤æ˜“ï¼Œ å¹¶æŠŠæ‰€æœ‰åç»­çš„äº¤æ˜“ç§»åŠ¨åˆ°future queue</p><pre><code>// removeTx removes a single transaction from the queue, moving all subsequent// transactions back to the future queue.func (pool *TxPool) removeTx(hash common.Hash) {    // Fetch the transaction we wish to delete    tx, ok := pool.all[hash]    if !ok {        return    }    addr, _ := types.Sender(pool.signer, tx) // already validated during insertion    // Remove it from the list of known transactions    delete(pool.all, hash)    pool.priced.Removed()    // Remove the transaction from the pending lists and reset the account nonce    // æŠŠäº¤æ˜“ä»pendingåˆ é™¤ï¼Œ å¹¶æŠŠå› ä¸ºè¿™ä¸ªäº¤æ˜“çš„åˆ é™¤è€Œå˜å¾—æ— æ•ˆçš„äº¤æ˜“æ”¾åˆ°future queue    // ç„¶åæ›´æ–°pendingStateçš„çŠ¶æ€    if pending := pool.pending[addr]; pending != nil {        if removed, invalids := pending.Remove(tx); removed {            // If no more transactions are left, remove the list            if pending.Empty() {                delete(pool.pending, addr)                delete(pool.beats, addr)            } else {                // Otherwise postpone any invalidated transactions                for _, tx := range invalids {                    pool.enqueueTx(tx.Hash(), tx)                }            }            // Update the account nonce if needed            if nonce := tx.Nonce(); pool.pendingState.GetNonce(addr) &gt; nonce {                pool.pendingState.SetNonce(addr, nonce)            }            return        }    }    // Transaction is in the future queue    // æŠŠäº¤æ˜“ä»future queueåˆ é™¤.    if future := pool.queue[addr]; future != nil {        future.Remove(tx)        if future.Empty() {            delete(pool.queue, addr)        }    }}</code></pre><p>loopæ˜¯txPoolçš„ä¸€ä¸ªgoroutine.ä¹Ÿæ˜¯ä¸»è¦çš„äº‹ä»¶å¾ªç¯.ç­‰å¾…å’Œå“åº”å¤–éƒ¨åŒºå—é“¾äº‹ä»¶ä»¥åŠå„ç§æŠ¥å‘Šå’Œäº¤æ˜“é©±é€äº‹ä»¶ã€‚</p><pre><code>// loop is the transaction pool's main event loop, waiting for and reacting to// outside blockchain events as well as for various reporting and transaction// eviction events.func (pool *TxPool) loop() {    defer pool.wg.Done()    // Start the stats reporting and transaction eviction tickers    var prevPending, prevQueued, prevStales int    report := time.NewTicker(statsReportInterval)    defer report.Stop()    evict := time.NewTicker(evictionInterval)    defer evict.Stop()    journal := time.NewTicker(pool.config.Rejournal)    defer journal.Stop()    // Track the previous head headers for transaction reorgs    head := pool.chain.CurrentBlock()    // Keep waiting for and reacting to the various events    for {        select {        // Handle ChainHeadEvent        // ç›‘å¬åˆ°åŒºå—å¤´çš„äº‹ä»¶, è·å–åˆ°æ–°çš„åŒºå—å¤´.        // è°ƒç”¨resetæ–¹æ³•        case ev := &lt;-pool.chainHeadCh:            if ev.Block != nil {                pool.mu.Lock()                if pool.chainconfig.IsHomestead(ev.Block.Number()) {                    pool.homestead = true                }                pool.reset(head.Header(), ev.Block.Header())                head = ev.Block                pool.mu.Unlock()            }        // Be unsubscribed due to system stopped        case &lt;-pool.chainHeadSub.Err():            return        // Handle stats reporting ticks æŠ¥å‘Šå°±æ˜¯æ‰“å°äº†ä¸€äº›æ—¥å¿—        case &lt;-report.C:            pool.mu.RLock()            pending, queued := pool.stats()            stales := pool.priced.stales            pool.mu.RUnlock()            if pending != prevPending || queued != prevQueued || stales != prevStales {                log.Debug("Transaction pool status report", "executable", pending, "queued", queued, "stales", stales)                prevPending, prevQueued, prevStales = pending, queued, stales            }        // Handle inactive account transaction eviction        // å¤„ç†è¶…æ—¶çš„äº¤æ˜“ä¿¡æ¯,        case &lt;-evict.C:            pool.mu.Lock()            for addr := range pool.queue {                // Skip local transactions from the eviction mechanism                if pool.locals.contains(addr) {                    continue                }                // Any non-locals old enough should be removed                if time.Since(pool.beats[addr]) &gt; pool.config.Lifetime {                    for _, tx := range pool.queue[addr].Flatten() {                        pool.removeTx(tx.Hash())                    }                }            }            pool.mu.Unlock()        // Handle local transaction journal rotation å¤„ç†å®šæ—¶å†™äº¤æ˜“æ—¥å¿—çš„ä¿¡æ¯.        case &lt;-journal.C:            if pool.journal != nil {                pool.mu.Lock()                if err := pool.journal.rotate(pool.local()); err != nil {                    log.Warn("Failed to rotate local tx journal", "err", err)                }                pool.mu.Unlock()            }        }    }}</code></pre><p>add æ–¹æ³•, éªŒè¯äº¤æ˜“å¹¶å°†å…¶æ’å…¥åˆ°future queue. å¦‚æœè¿™ä¸ªäº¤æ˜“æ˜¯æ›¿æ¢äº†å½“å‰å­˜åœ¨çš„æŸä¸ªäº¤æ˜“,é‚£ä¹ˆä¼šè¿”å›ä¹‹å‰çš„é‚£ä¸ªäº¤æ˜“,è¿™æ ·å¤–éƒ¨å°±ä¸ç”¨è°ƒç”¨promoteæ–¹æ³•. å¦‚æœæŸä¸ªæ–°å¢åŠ çš„äº¤æ˜“è¢«æ ‡è®°ä¸ºlocal, é‚£ä¹ˆå®ƒçš„å‘é€è´¦æˆ·ä¼šè¿›å…¥ç™½åå•,è¿™ä¸ªè´¦æˆ·çš„å…³è”çš„äº¤æ˜“å°†ä¸ä¼šå› ä¸ºä»·æ ¼çš„é™åˆ¶æˆ–è€…å…¶ä»–çš„ä¸€äº›é™åˆ¶è¢«åˆ é™¤.</p><pre><code>// add validates a transaction and inserts it into the non-executable queue for// later pending promotion and execution. If the transaction is a replacement for// an already pending or queued one, it overwrites the previous and returns this// so outer code doesn't uselessly call promote.//// If a newly added transaction is marked as local, its sending account will be// whitelisted, preventing any associated transaction from being dropped out of// the pool due to pricing constraints.func (pool *TxPool) add(tx *types.Transaction, local bool) (bool, error) {    // If the transaction is already known, discard it    hash := tx.Hash()    if pool.all[hash] != nil {        log.Trace("Discarding already known transaction", "hash", hash)        return false, fmt.Errorf("known transaction: %x", hash)    }    // If the transaction fails basic validation, discard it    // å¦‚æœäº¤æ˜“ä¸èƒ½é€šè¿‡åŸºæœ¬çš„éªŒè¯,é‚£ä¹ˆä¸¢å¼ƒå®ƒ    if err := pool.validateTx(tx, local); err != nil {        log.Trace("Discarding invalid transaction", "hash", hash, "err", err)        invalidTxCounter.Inc(1)        return false, err    }    // If the transaction pool is full, discard underpriced transactions    // å¦‚æœäº¤æ˜“æ± æ»¡äº†. é‚£ä¹ˆåˆ é™¤ä¸€äº›ä½ä»·çš„äº¤æ˜“.    if uint64(len(pool.all)) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue {        // If the new transaction is underpriced, don't accept it        // å¦‚æœæ–°äº¤æ˜“æœ¬èº«å°±æ˜¯ä½ä»·çš„.é‚£ä¹ˆä¸æ¥æ”¶å®ƒ        if pool.priced.Underpriced(tx, pool.locals) {            log.Trace("Discarding underpriced transaction", "hash", hash, "price", tx.GasPrice())            underpricedTxCounter.Inc(1)            return false, ErrUnderpriced        }        // New transaction is better than our worse ones, make room for it        // å¦åˆ™åˆ é™¤ä½ä»·å€¼çš„ç»™ä»–è…¾ç©ºé—´.        drop := pool.priced.Discard(len(pool.all)-int(pool.config.GlobalSlots+pool.config.GlobalQueue-1), pool.locals)        for _, tx := range drop {            log.Trace("Discarding freshly underpriced transaction", "hash", tx.Hash(), "price", tx.GasPrice())            underpricedTxCounter.Inc(1)            pool.removeTx(tx.Hash())        }    }    // If the transaction is replacing an already pending one, do directly    from, _ := types.Sender(pool.signer, tx) // already validated    if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) {        // Nonce already pending, check if required price bump is met        // å¦‚æœäº¤æ˜“å¯¹åº”çš„Nonceå·²ç»åœ¨pendingé˜Ÿåˆ—äº†,é‚£ä¹ˆäº§çœ‹æ˜¯å¦èƒ½å¤Ÿæ›¿æ¢.        inserted, old := list.Add(tx, pool.config.PriceBump)        if !inserted {            pendingDiscardCounter.Inc(1)            return false, ErrReplaceUnderpriced        }        // New transaction is better, replace old one        if old != nil {            delete(pool.all, old.Hash())            pool.priced.Removed()            pendingReplaceCounter.Inc(1)        }        pool.all[tx.Hash()] = tx        pool.priced.Put(tx)        pool.journalTx(from, tx)        log.Trace("Pooled new executable transaction", "hash", hash, "from", from, "to", tx.To())        return old != nil, nil    }    // New transaction isn't replacing a pending one, push into queue    // æ–°äº¤æ˜“ä¸èƒ½æ›¿æ¢pendingé‡Œé¢çš„ä»»æ„ä¸€ä¸ªäº¤æ˜“,é‚£ä¹ˆæŠŠä»–pushåˆ°futuren é˜Ÿåˆ—é‡Œé¢.    replace, err := pool.enqueueTx(hash, tx)    if err != nil {        return false, err    }    // Mark local addresses and journal local transactions    if local {        pool.locals.add(from)    }    // å¦‚æœæ˜¯æœ¬åœ°çš„äº¤æ˜“,ä¼šè¢«è®°å½•è¿›å…¥journalTx    pool.journalTx(from, tx)    log.Trace("Pooled new future transaction", "hash", hash, "from", from, "to", tx.To())    return replace, nil}</code></pre><p>validateTx ä½¿ç”¨ä¸€è‡´æ€§è§„åˆ™æ¥æ£€æŸ¥ä¸€ä¸ªäº¤æ˜“æ˜¯å¦æœ‰æ•ˆ,å¹¶é‡‡ç”¨æœ¬åœ°èŠ‚ç‚¹çš„ä¸€äº›å¯å‘å¼çš„é™åˆ¶.</p><pre><code>// validateTx checks whether a transaction is valid according to the consensus// rules and adheres to some heuristic limits of the local node (price and size).func (pool *TxPool) validateTx(tx *types.Transaction, local bool) error {    // Heuristic limit, reject transactions over 32KB to prevent DOS attacks    if tx.Size() &gt; 32*1024 {        return ErrOversizedData    }    // Transactions can't be negative. This may never happen using RLP decoded    // transactions but may occur if you create a transaction using the RPC.    if tx.Value().Sign() &lt; 0 {        return ErrNegativeValue    }    // Ensure the transaction doesn't exceed the current block limit gas.    if pool.currentMaxGas.Cmp(tx.Gas()) &lt; 0 {        return ErrGasLimit    }    // Make sure the transaction is signed properly    // ç¡®ä¿äº¤æ˜“è¢«æ­£ç¡®ç­¾å.    from, err := types.Sender(pool.signer, tx)    if err != nil {        return ErrInvalidSender    }    // Drop non-local transactions under our own minimal accepted gas price    local = local || pool.locals.contains(from) // account may be local even if the transaction arrived from the network    // å¦‚æœä¸æ˜¯æœ¬åœ°çš„äº¤æ˜“,å¹¶ä¸”GasPriceä½äºæˆ‘ä»¬çš„è®¾ç½®,é‚£ä¹ˆä¹Ÿä¸ä¼šæ¥æ”¶.    if !local &amp;&amp; pool.gasPrice.Cmp(tx.GasPrice()) &gt; 0 {        return ErrUnderpriced    }    // Ensure the transaction adheres to nonce ordering    // ç¡®ä¿äº¤æ˜“éµå®ˆäº†Nonceçš„é¡ºåº    if pool.currentState.GetNonce(from) &gt; tx.Nonce() {        return ErrNonceTooLow    }    // Transactor should have enough funds to cover the costs    // cost == V + GP * GL    // ç¡®ä¿ç”¨æˆ·æœ‰è¶³å¤Ÿçš„ä½™é¢æ¥æ”¯ä»˜.    if pool.currentState.GetBalance(from).Cmp(tx.Cost()) &lt; 0 {        return ErrInsufficientFunds    }    intrGas := IntrinsicGas(tx.Data(), tx.To() == nil, pool.homestead)    // å¦‚æœäº¤æ˜“æ˜¯ä¸€ä¸ªåˆçº¦åˆ›å»ºæˆ–è€…è°ƒç”¨. é‚£ä¹ˆçœ‹çœ‹æ˜¯å¦æœ‰è¶³å¤Ÿçš„ åˆå§‹Gas.    if tx.Gas().Cmp(intrGas) &lt; 0 {        return ErrIntrinsicGas    }    return nil}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-eth-downloaderæºç åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-downloader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth-downloader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>downloaderä¸»è¦è´Ÿè´£åŒºå—é“¾æœ€å¼€å§‹çš„åŒæ­¥å·¥ä½œï¼Œå½“å‰çš„åŒæ­¥æœ‰ä¸¤ç§æ¨¡å¼ï¼Œä¸€ç§æ˜¯ä¼ ç»Ÿçš„fullmode,è¿™ç§æ¨¡å¼é€šè¿‡ä¸‹è½½åŒºå—å¤´ï¼Œå’ŒåŒºå—ä½“æ¥æ„å»ºåŒºå—é“¾ï¼ŒåŒæ­¥çš„è¿‡ç¨‹å°±å’Œæ™®é€šçš„åŒºå—æ’å…¥çš„è¿‡ç¨‹ä¸€æ ·ï¼ŒåŒ…æ‹¬åŒºå—å¤´çš„éªŒè¯ï¼Œäº¤æ˜“çš„éªŒè¯ï¼Œäº¤æ˜“æ‰§è¡Œï¼Œè´¦æˆ·çŠ¶æ€çš„æ”¹å˜ç­‰æ“ä½œï¼Œè¿™å…¶å®æ˜¯ä¸€ä¸ªæ¯”è¾ƒæ¶ˆè€—CPUå’Œç£ç›˜çš„ä¸€ä¸ªè¿‡ç¨‹ã€‚ å¦ä¸€ç§æ¨¡å¼å°±æ˜¯ å¿«é€ŸåŒæ­¥çš„fast syncæ¨¡å¼ï¼Œ è¿™ç§æ¨¡å¼æœ‰ä¸“é—¨çš„æ–‡æ¡£æ¥æè¿°ã€‚è¯·å‚è€ƒfast syncçš„æ–‡æ¡£ã€‚ç®€å•çš„è¯´ fast syncçš„æ¨¡å¼ä¼šä¸‹è½½åŒºå—å¤´ï¼ŒåŒºå—ä½“å’Œæ”¶æ®ï¼Œ æ’å…¥çš„è¿‡ç¨‹ä¸ä¼šæ‰§è¡Œäº¤æ˜“ï¼Œç„¶ååœ¨ä¸€ä¸ªåŒºå—é«˜åº¦(æœ€é«˜çš„åŒºå—é«˜åº¦ - 1024)çš„æ—¶å€™åŒæ­¥æ‰€æœ‰çš„è´¦æˆ·çŠ¶æ€ï¼Œåé¢çš„1024ä¸ªåŒºå—ä¼šé‡‡ç”¨fullmodeçš„æ–¹å¼æ¥æ„å»ºã€‚ è¿™ç§æ¨¡å¼ä¼šåŠ åŒºå—çš„æ’å…¥æ—¶é—´ï¼ŒåŒæ—¶ä¸ä¼šäº§ç”Ÿå¤§é‡çš„å†å²çš„è´¦æˆ·ä¿¡æ¯ã€‚ä¼šç›¸å¯¹èŠ‚çº¦ç£ç›˜ï¼Œ ä½†æ˜¯å¯¹äºç½‘ç»œçš„æ¶ˆè€—ä¼šæ›´é«˜ã€‚ å› ä¸ºéœ€è¦ä¸‹è½½æ”¶æ®å’ŒçŠ¶æ€ã€‚</p><h2 id="downloader-æ•°æ®ç»“æ„"><a href="#downloader-æ•°æ®ç»“æ„" class="headerlink" title="downloader æ•°æ®ç»“æ„"></a>downloader æ•°æ®ç»“æ„</h2><pre><code>type Downloader struct {    mode SyncMode       // Synchronisation mode defining the strategy used (per sync cycle)    mux  *event.TypeMux // Event multiplexer to announce sync operation events    // queue å¯¹è±¡ç”¨æ¥è°ƒåº¦ åŒºå—å¤´ï¼Œäº¤æ˜“ï¼Œå’Œæ”¶æ®çš„ä¸‹è½½ï¼Œä»¥åŠä¸‹è½½å®Œä¹‹åçš„ç»„è£…    queue   *queue   // Scheduler for selecting the hashes to download    // å¯¹ç«¯çš„é›†åˆ    peers   *peerSet // Set of active peers from which download can proceed    stateDB ethdb.Database    // fast sync ä¸­çš„ Pivot pointåŒºå—çš„å¤´    fsPivotLock  *types.Header // Pivot header on critical section entry (cannot change between retries)    fsPivotFails uint32        // Number of subsequent fast sync failures in the critical section    // ä¸‹è½½çš„å¾€è¿”æ—¶å»¶    rttEstimate   uint64 // Round trip time to target for download requests    rttConfidence uint64 // Confidence in the estimated RTT (unit: millionths to allow atomic ops)  ä¼°è®¡RTTçš„ä¿¡å¿ƒ(å•ä½ï¼šå…è®¸åŸå­æ“ä½œçš„ç™¾ä¸‡åˆ†ä¹‹ä¸€)    // Statistics ç»Ÿè®¡ä¿¡æ¯ï¼Œ     syncStatsChainOrigin uint64 // Origin block number where syncing started at    syncStatsChainHeight uint64 // Highest block number known when syncing started    syncStatsState       stateSyncStats    syncStatsLock        sync.RWMutex // Lock protecting the sync stats fields    lightchain LightChain    blockchain BlockChain    // Callbacks    dropPeer peerDropFn // Drops a peer for misbehaving    // Status    synchroniseMock func(id string, hash common.Hash) error // Replacement for synchronise during testing    synchronising   int32    notified        int32    // Channels    headerCh      chan dataPack        // [eth/62] Channel receiving inbound block headers  headerçš„è¾“å…¥é€šé“ï¼Œä»ç½‘ç»œä¸‹è½½çš„headerä¼šè¢«é€åˆ°è¿™ä¸ªé€šé“    bodyCh        chan dataPack        // [eth/62] Channel receiving inbound block bodies   bodiesçš„è¾“å…¥é€šé“ï¼Œä»ç½‘ç»œä¸‹è½½çš„bodiesä¼šè¢«é€åˆ°è¿™ä¸ªé€šé“    receiptCh     chan dataPack        // [eth/63] Channel receiving inbound receipts       receiptsçš„è¾“å…¥é€šé“ï¼Œä»ç½‘ç»œä¸‹è½½çš„receiptsä¼šè¢«é€åˆ°è¿™ä¸ªé€šé“    bodyWakeCh    chan bool            // [eth/62] Channel to signal the block body fetcher of new tasks    ç”¨æ¥ä¼ è¾“body fetcheræ–°ä»»åŠ¡çš„é€šé“    receiptWakeCh chan bool            // [eth/63] Channel to signal the receipt fetcher of new tasks       ç”¨æ¥ä¼ è¾“receipt fetcher æ–°ä»»åŠ¡çš„é€šé“    headerProcCh  chan []*types.Header // [eth/62] Channel to feed the header processor new tasks        é€šé“ä¸ºheaderå¤„ç†è€…æä¾›æ–°çš„ä»»åŠ¡    // for stateFetcher    stateSyncStart chan *stateSync   //ç”¨æ¥å¯åŠ¨æ–°çš„ state fetcher    trackStateReq  chan *stateReq     // TODO    stateCh        chan dataPack // [eth/63] Channel receiving inbound node state data       stateçš„è¾“å…¥é€šé“ï¼Œä»ç½‘ç»œä¸‹è½½çš„stateä¼šè¢«é€åˆ°è¿™ä¸ªé€šé“                    // Cancellation and termination    cancelPeer string        // Identifier of the peer currently being used as the master (cancel on drop)    cancelCh   chan struct{} // Channel to cancel mid-flight syncs    cancelLock sync.RWMutex  // Lock to protect the cancel channel and peer in delivers    quitCh   chan struct{} // Quit channel to signal termination    quitLock sync.RWMutex  // Lock to prevent double closes    // Testing hooks    syncInitHook     func(uint64, uint64)  // Method to call upon initiating a new sync run    bodyFetchHook    func([]*types.Header) // Method to call upon starting a block body fetch    receiptFetchHook func([]*types.Header) // Method to call upon starting a receipt fetch    chainInsertHook  func([]*fetchResult)  // Method to call upon inserting a chain of blocks (possibly in multiple invocations)}</code></pre><p>æ„é€ æ–¹æ³•</p><pre><code>// New creates a new downloader to fetch hashes and blocks from remote peers.func New(mode SyncMode, stateDb ethdb.Database, mux *event.TypeMux, chain BlockChain, lightchain LightChain, dropPeer peerDropFn) *Downloader {    if lightchain == nil {        lightchain = chain    }    dl := &amp;Downloader{        mode:           mode,        stateDB:        stateDb,        mux:            mux,        queue:          newQueue(),        peers:          newPeerSet(),        rttEstimate:    uint64(rttMaxEstimate),        rttConfidence:  uint64(1000000),        blockchain:     chain,        lightchain:     lightchain,        dropPeer:       dropPeer,        headerCh:       make(chan dataPack, 1),        bodyCh:         make(chan dataPack, 1),        receiptCh:      make(chan dataPack, 1),        bodyWakeCh:     make(chan bool, 1),        receiptWakeCh:  make(chan bool, 1),        headerProcCh:   make(chan []*types.Header, 1),        quitCh:         make(chan struct{}),        stateCh:        make(chan dataPack),        stateSyncStart: make(chan *stateSync),        trackStateReq:  make(chan *stateReq),    }    go dl.qosTuner()  //ç®€å• ä¸»è¦ç”¨æ¥è®¡ç®—rttEstimateå’ŒrttConfidence    go dl.stateFetcher() //å¯åŠ¨stateFetcherçš„ä»»åŠ¡ç›‘å¬ï¼Œä½†æ˜¯è¿™ä¸ªæ—¶å€™è¿˜æ²¡æœ‰ç”Ÿæˆstate fetcherçš„ä»»åŠ¡ã€‚    return dl}</code></pre><h2 id="åŒæ­¥ä¸‹è½½"><a href="#åŒæ­¥ä¸‹è½½" class="headerlink" title="åŒæ­¥ä¸‹è½½"></a>åŒæ­¥ä¸‹è½½</h2><p>Synchroniseè¯•å›¾å’Œä¸€ä¸ªpeeræ¥åŒæ­¥ï¼Œå¦‚æœåŒæ­¥è¿‡ç¨‹ä¸­é‡åˆ°ä¸€äº›é”™è¯¯ï¼Œé‚£ä¹ˆä¼šåˆ é™¤æ‰Peerã€‚ç„¶åä¼šè¢«é‡è¯•ã€‚</p><pre><code>// Synchronise tries to sync up our local block chain with a remote peer, both// adding various sanity checks as well as wrapping it with various log entries.func (d *Downloader) Synchronise(id string, head common.Hash, td *big.Int, mode SyncMode) error {    err := d.synchronise(id, head, td, mode)    switch err {    case nil:    case errBusy:    case errTimeout, errBadPeer, errStallingPeer,        errEmptyHeaderSet, errPeersUnavailable, errTooOld,        errInvalidAncestor, errInvalidChain:        log.Warn("Synchronisation failed, dropping peer", "peer", id, "err", err)        d.dropPeer(id)    default:        log.Warn("Synchronisation failed, retrying", "err", err)    }    return err}</code></pre><p>synchronise</p><pre><code>// synchronise will select the peer and use it for synchronising. If an empty string is given// it will use the best peer possible and synchronize if it's TD is higher than our own. If any of the// checks fail an error will be returned. This method is synchronousfunc (d *Downloader) synchronise(id string, hash common.Hash, td *big.Int, mode SyncMode) error {    // Mock out the synchronisation if testing    if d.synchroniseMock != nil {        return d.synchroniseMock(id, hash)    }    // Make sure only one goroutine is ever allowed past this point at once    // è¿™ä¸ªæ–¹æ³•åŒæ—¶åªèƒ½è¿è¡Œä¸€ä¸ªï¼Œ æ£€æŸ¥æ˜¯å¦æ­£åœ¨è¿è¡Œã€‚    if !atomic.CompareAndSwapInt32(&amp;d.synchronising, 0, 1) {        return errBusy    }    defer atomic.StoreInt32(&amp;d.synchronising, 0)    // Post a user notification of the sync (only once per session)    if atomic.CompareAndSwapInt32(&amp;d.notified, 0, 1) {        log.Info("Block synchronisation started")    }    // Reset the queue, peer set and wake channels to clean any internal leftover state    // é‡ç½®queueå’Œpeerçš„çŠ¶æ€ã€‚    d.queue.Reset()    d.peers.Reset()    // æ¸…ç©ºd.bodyWakeCh, d.receiptWakeCh    for _, ch := range []chan bool{d.bodyWakeCh, d.receiptWakeCh} {        select {        case &lt;-ch:        default:        }    }    // æ¸…ç©ºd.headerCh, d.bodyCh, d.receiptCh    for _, ch := range []chan dataPack{d.headerCh, d.bodyCh, d.receiptCh} {        for empty := false; !empty; {            select {            case &lt;-ch:            default:                empty = true            }        }    }    // æ¸…ç©ºheaderProcCh    for empty := false; !empty; {        select {        case &lt;-d.headerProcCh:        default:            empty = true        }    }    // Create cancel channel for aborting mid-flight and mark the master peer    d.cancelLock.Lock()    d.cancelCh = make(chan struct{})    d.cancelPeer = id    d.cancelLock.Unlock()    defer d.Cancel() // No matter what, we can't leave the cancel channel open    // Set the requested sync mode, unless it's forbidden    d.mode = mode    if d.mode == FastSync &amp;&amp; atomic.LoadUint32(&amp;d.fsPivotFails) &gt;= fsCriticalTrials {        d.mode = FullSync    }    // Retrieve the origin peer and initiate the downloading process    p := d.peers.Peer(id)    if p == nil {        return errUnknownPeer    }    return d.syncWithPeer(p, hash, td)}</code></pre><p>syncWithPeer</p><pre><code>// syncWithPeer starts a block synchronization based on the hash chain from the// specified peer and head hash.func (d *Downloader) syncWithPeer(p *peerConnection, hash common.Hash, td *big.Int) (err error) {    ...    // Look up the sync boundaries: the common ancestor and the target block    // ä½¿ç”¨hashæŒ‡æ¥è·å–åŒºå—å¤´ï¼Œè¿™ä¸ªæ–¹æ³•é‡Œé¢ä¼šè®¿é—®ç½‘ç»œ    latest, err := d.fetchHeight(p)    if err != nil {        return err    }    height := latest.Number.Uint64()    // findAncestorè¯•å›¾æ¥è·å–å¤§å®¶å…±åŒçš„ç¥–å…ˆï¼Œä»¥ä¾¿æ‰¾åˆ°ä¸€ä¸ªå¼€å§‹åŒæ­¥çš„ç‚¹ã€‚    origin, err := d.findAncestor(p, height)    if err != nil {        return err    }    d.syncStatsLock.Lock()    if d.syncStatsChainHeight &lt;= origin || d.syncStatsChainOrigin &gt; origin {        d.syncStatsChainOrigin = origin    }    d.syncStatsChainHeight = height    d.syncStatsLock.Unlock()    // Initiate the sync using a concurrent header and content retrieval algorithm    pivot := uint64(0)    switch d.mode {    case LightSync:        pivot = height    case FastSync:        // Calculate the new fast/slow sync pivot point        // å¦‚æœpivotè¿™ä¸ªç‚¹æ²¡æœ‰è¢«é”å®šã€‚        if d.fsPivotLock == nil {            pivotOffset, err := rand.Int(rand.Reader, big.NewInt(int64(fsPivotInterval)))            if err != nil {                panic(fmt.Sprintf("Failed to access crypto random source: %v", err))            }            if height &gt; uint64(fsMinFullBlocks)+pivotOffset.Uint64() {                pivot = height - uint64(fsMinFullBlocks) - pivotOffset.Uint64()            }        } else { // å¦‚è¿‡è¿™ä¸ªç‚¹å·²ç»è¢«é”å®šäº†ã€‚é‚£ä¹ˆå°±ä½¿ç”¨è¿™ä¸ªç‚¹            // Pivot point locked in, use this and do not pick a new one!            pivot = d.fsPivotLock.Number.Uint64()        }        // If the point is below the origin, move origin back to ensure state download        if pivot &lt; origin {            if pivot &gt; 0 {                origin = pivot - 1            } else {                origin = 0            }        }        log.Debug("Fast syncing until pivot block", "pivot", pivot)    }    d.queue.Prepare(origin+1, d.mode, pivot, latest)    if d.syncInitHook != nil {        d.syncInitHook(origin, height)    }    // å¯åŠ¨å‡ ä¸ªfetcher åˆ†åˆ«è´Ÿè´£header,bodies,receipts,å¤„ç†headers    fetchers := []func() error{        func() error { return d.fetchHeaders(p, origin+1) }, // Headers are always retrieved        func() error { return d.fetchBodies(origin + 1) },   // Bodies are retrieved during normal and fast sync        func() error { return d.fetchReceipts(origin + 1) }, // Receipts are retrieved during fast sync        func() error { return d.processHeaders(origin+1, td) },    }    if d.mode == FastSync {  //æ ¹æ®æ¨¡å¼çš„ä¸åŒï¼Œå¢åŠ æ–°çš„å¤„ç†é€»è¾‘        fetchers = append(fetchers, func() error { return d.processFastSyncContent(latest) })    } else if d.mode == FullSync {        fetchers = append(fetchers, d.processFullSyncContent)    }    err = d.spawnSync(fetchers)    if err != nil &amp;&amp; d.mode == FastSync &amp;&amp; d.fsPivotLock != nil {        // If sync failed in the critical section, bump the fail counter.        atomic.AddUint32(&amp;d.fsPivotFails, 1)    }    return err}</code></pre><p>spawnSyncç»™æ¯ä¸ªfetcherå¯åŠ¨ä¸€ä¸ªgoroutine, ç„¶åé˜»å¡çš„ç­‰å¾…fetcherå‡ºé”™ã€‚ </p><pre><code>// spawnSync runs d.process and all given fetcher functions to completion in// separate goroutines, returning the first error that appears.func (d *Downloader) spawnSync(fetchers []func() error) error {    var wg sync.WaitGroup    errc := make(chan error, len(fetchers))    wg.Add(len(fetchers))    for _, fn := range fetchers {        fn := fn        go func() { defer wg.Done(); errc &lt;- fn() }()    }    // Wait for the first error, then terminate the others.    var err error    for i := 0; i &lt; len(fetchers); i++ {        if i == len(fetchers)-1 {            // Close the queue when all fetchers have exited.            // This will cause the block processor to end when            // it has processed the queue.            d.queue.Close()        }        if err = &lt;-errc; err != nil {            break        }    }    d.queue.Close()    d.Cancel()    wg.Wait()    return err}</code></pre><h2 id="headersçš„å¤„ç†"><a href="#headersçš„å¤„ç†" class="headerlink" title="headersçš„å¤„ç†"></a>headersçš„å¤„ç†</h2><p>fetchHeadersæ–¹æ³•ç”¨æ¥è·å–headerã€‚ ç„¶åæ ¹æ®è·å–çš„headerå»è·å–bodyå’Œreceiptç­‰ä¿¡æ¯ã€‚</p><pre><code>// fetchHeaders keeps retrieving headers concurrently from the number// requested, until no more are returned, potentially throttling on the way. To// facilitate concurrency but still protect against malicious nodes sending bad// headers, we construct a header chain skeleton using the "origin" peer we are// syncing with, and fill in the missing headers using anyone else. Headers from// other peers are only accepted if they map cleanly to the skeleton. If no one// can fill in the skeleton - not even the origin peer - it's assumed invalid and// the origin is dropped.fetchHeadersä¸æ–­çš„é‡å¤è¿™æ ·çš„æ“ä½œï¼Œå‘é€headerè¯·æ±‚ï¼Œç­‰å¾…æ‰€æœ‰çš„è¿”å›ã€‚ç›´åˆ°å®Œæˆæ‰€æœ‰çš„headerè¯·æ±‚ã€‚ ä¸ºäº†æé«˜å¹¶å‘æ€§ï¼ŒåŒæ—¶ä»ç„¶èƒ½å¤Ÿé˜²æ­¢æ¶æ„èŠ‚ç‚¹å‘é€é”™è¯¯çš„headerï¼Œæˆ‘ä»¬ä½¿ç”¨æˆ‘ä»¬æ­£åœ¨åŒæ­¥çš„â€œoriginâ€peeræ„é€ ä¸€ä¸ªå¤´æ–‡ä»¶é“¾éª¨æ¶ï¼Œå¹¶ä½¿ç”¨å…¶ä»–äººå¡«å……ç¼ºå¤±çš„headerã€‚ å…¶ä»–peerçš„headeråªæœ‰åœ¨å¹²å‡€åœ°æ˜ å°„åˆ°éª¨æ¶ä¸Šæ—¶æ‰è¢«æ¥å—ã€‚ å¦‚æœæ²¡æœ‰äººèƒ½å¤Ÿå¡«å……éª¨æ¶ - ç”šè‡³origin peerä¹Ÿä¸èƒ½å¡«å…… - å®ƒè¢«è®¤ä¸ºæ˜¯æ— æ•ˆçš„ï¼Œå¹¶ä¸”origin peerä¹Ÿè¢«ä¸¢å¼ƒã€‚func (d *Downloader) fetchHeaders(p *peerConnection, from uint64) error {    p.log.Debug("Directing header downloads", "origin", from)    defer p.log.Debug("Header download terminated")    // Create a timeout timer, and the associated header fetcher    skeleton := true            // Skeleton assembly phase or finishing up    request := time.Now()       // time of the last skeleton fetch request    timeout := time.NewTimer(0) // timer to dump a non-responsive active peer    &lt;-timeout.C                 // timeout channel should be initially empty    defer timeout.Stop()    var ttl time.Duration    getHeaders := func(from uint64) {        request = time.Now()        ttl = d.requestTTL()        timeout.Reset(ttl)        if skeleton { //å¡«å……éª¨æ¶            p.log.Trace("Fetching skeleton headers", "count", MaxHeaderFetch, "from", from)            go p.peer.RequestHeadersByNumber(from+uint64(MaxHeaderFetch)-1, MaxSkeletonSize, MaxHeaderFetch-1, false)        } else { // ç›´æ¥è¯·æ±‚            p.log.Trace("Fetching full headers", "count", MaxHeaderFetch, "from", from)            go p.peer.RequestHeadersByNumber(from, MaxHeaderFetch, 0, false)        }    }    // Start pulling the header chain skeleton until all is done    getHeaders(from)    for {        select {        case &lt;-d.cancelCh:            return errCancelHeaderFetch        case packet := &lt;-d.headerCh: //ç½‘ç»œä¸Šè¿”å›çš„headerä¼šæŠ•é€’åˆ°headerChè¿™ä¸ªé€šé“            // Make sure the active peer is giving us the skeleton headers            if packet.PeerId() != p.id {                log.Debug("Received skeleton from incorrect peer", "peer", packet.PeerId())                break            }            headerReqTimer.UpdateSince(request)            timeout.Stop()            // If the skeleton's finished, pull any remaining head headers directly from the origin            if packet.Items() == 0 &amp;&amp; skeleton {                skeleton = false                getHeaders(from)                continue            }            // If no more headers are inbound, notify the content fetchers and return            // å¦‚æœæ²¡æœ‰æ›´å¤šçš„è¿”å›äº†ã€‚ é‚£ä¹ˆå‘Šè¯‰headerProcChé€šé“            if packet.Items() == 0 {                p.log.Debug("No more headers available")                select {                case d.headerProcCh &lt;- nil:                    return nil                case &lt;-d.cancelCh:                    return errCancelHeaderFetch                }            }            headers := packet.(*headerPack).headers            // If we received a skeleton batch, resolve internals concurrently            if skeleton { // å¦‚æœæ˜¯éœ€è¦å¡«å……éª¨æ¶ï¼Œé‚£ä¹ˆåœ¨è¿™ä¸ªæ–¹æ³•é‡Œé¢å¡«å……å¥½                filled, proced, err := d.fillHeaderSkeleton(from, headers)                if err != nil {                    p.log.Debug("Skeleton chain invalid", "err", err)                    return errInvalidChain                }                headers = filled[proced:]                // procedä»£è¡¨å·²ç»å¤„ç†å®Œäº†å¤šå°‘ä¸ªäº†ã€‚  æ‰€ä»¥åªéœ€è¦proced:åé¢çš„headersäº†                from += uint64(proced)            }            // Insert all the new headers and fetch the next batch            if len(headers) &gt; 0 {                p.log.Trace("Scheduling new headers", "count", len(headers), "from", from)                //æŠ•é€’åˆ°headerProcCh ç„¶åç»§ç»­å¾ªç¯ã€‚                select {                case d.headerProcCh &lt;- headers:                case &lt;-d.cancelCh:                    return errCancelHeaderFetch                }                from += uint64(len(headers))            }            getHeaders(from)        case &lt;-timeout.C:            // Header retrieval timed out, consider the peer bad and drop            p.log.Debug("Header request timed out", "elapsed", ttl)            headerTimeoutMeter.Mark(1)            d.dropPeer(p.id)            // Finish the sync gracefully instead of dumping the gathered data though            for _, ch := range []chan bool{d.bodyWakeCh, d.receiptWakeCh} {                select {                case ch &lt;- false:                case &lt;-d.cancelCh:                }            }            select {            case d.headerProcCh &lt;- nil:            case &lt;-d.cancelCh:            }            return errBadPeer        }    }}</code></pre><p>processHeadersæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä»headerProcChé€šé“æ¥è·å–headerã€‚å¹¶æŠŠè·å–åˆ°çš„headerä¸¢å…¥åˆ°queueæ¥è¿›è¡Œè°ƒåº¦ï¼Œè¿™æ ·body fetcheræˆ–è€…æ˜¯receipt fetcherå°±å¯ä»¥é¢†å–åˆ°fetchä»»åŠ¡ã€‚</p><pre><code>// processHeaders takes batches of retrieved headers from an input channel and// keeps processing and scheduling them into the header chain and downloader's// queue until the stream ends or a failure occurs.// processHeadersæ‰¹é‡çš„è·å–headersï¼Œ å¤„ç†ä»–ä»¬ï¼Œå¹¶é€šè¿‡downloaderçš„queueå¯¹è±¡æ¥è°ƒåº¦ä»–ä»¬ã€‚ ç›´åˆ°é”™è¯¯å‘ç”Ÿæˆ–è€…å¤„ç†ç»“æŸã€‚func (d *Downloader) processHeaders(origin uint64, td *big.Int) error {    // Calculate the pivoting point for switching from fast to slow sync    pivot := d.queue.FastSyncPivot()    // Keep a count of uncertain headers to roll back    // rollback ç”¨æ¥å¤„ç†è¿™ç§é€»è¾‘ï¼Œå¦‚æœæŸä¸ªç‚¹å¤±è´¥äº†ã€‚é‚£ä¹ˆä¹‹å‰æ’å…¥çš„2048ä¸ªèŠ‚ç‚¹éƒ½è¦å›æ»šã€‚å› ä¸ºå®‰å…¨æ€§è¾¾ä¸åˆ°è¦æ±‚ï¼Œ å¯ä»¥è¯¦ç»†å‚è€ƒfast syncçš„æ–‡æ¡£ã€‚    rollback := []*types.Header{}    defer func() { // è¿™ä¸ªå‡½æ•°ç”¨æ¥é”™è¯¯é€€å‡ºçš„æ—¶å€™è¿›è¡Œå›æ»šã€‚ TODO        if len(rollback) &gt; 0 {            // Flatten the headers and roll them back            hashes := make([]common.Hash, len(rollback))            for i, header := range rollback {                hashes[i] = header.Hash()            }            lastHeader, lastFastBlock, lastBlock := d.lightchain.CurrentHeader().Number, common.Big0, common.Big0            if d.mode != LightSync {                lastFastBlock = d.blockchain.CurrentFastBlock().Number()                lastBlock = d.blockchain.CurrentBlock().Number()            }            d.lightchain.Rollback(hashes)            curFastBlock, curBlock := common.Big0, common.Big0            if d.mode != LightSync {                curFastBlock = d.blockchain.CurrentFastBlock().Number()                curBlock = d.blockchain.CurrentBlock().Number()            }            log.Warn("Rolled back headers", "count", len(hashes),                "header", fmt.Sprintf("%d-&gt;%d", lastHeader, d.lightchain.CurrentHeader().Number),                "fast", fmt.Sprintf("%d-&gt;%d", lastFastBlock, curFastBlock),                "block", fmt.Sprintf("%d-&gt;%d", lastBlock, curBlock))            // If we're already past the pivot point, this could be an attack, thread carefully            if rollback[len(rollback)-1].Number.Uint64() &gt; pivot {                // If we didn't ever fail, lock in the pivot header (must! not! change!)                if atomic.LoadUint32(&amp;d.fsPivotFails) == 0 {                    for _, header := range rollback {                        if header.Number.Uint64() == pivot {                            log.Warn("Fast-sync pivot locked in", "number", pivot, "hash", header.Hash())                            d.fsPivotLock = header                        }                    }                }            }        }    }()    // Wait for batches of headers to process    gotHeaders := false    for {        select {        case &lt;-d.cancelCh:            return errCancelHeaderProcessing        case headers := &lt;-d.headerProcCh:            // Terminate header processing if we synced up            if len(headers) == 0 { //å¤„ç†å®Œæˆ                // Notify everyone that headers are fully processed                for _, ch := range []chan bool{d.bodyWakeCh, d.receiptWakeCh} {                    select {                    case ch &lt;- false:                    case &lt;-d.cancelCh:                    }                }                // If no headers were retrieved at all, the peer violated it's TD promise that it had a                // better chain compared to ours. The only exception is if it's promised blocks were                // already imported by other means (e.g. fecher):                //                // R &lt;remote peer&gt;, L &lt;local node&gt;: Both at block 10                // R: Mine block 11, and propagate it to L                // L: Queue block 11 for import                // L: Notice that R's head and TD increased compared to ours, start sync                // L: Import of block 11 finishes                // L: Sync begins, and finds common ancestor at 11                // L: Request new headers up from 11 (R's TD was higher, it must have something)                // R: Nothing to give                if d.mode != LightSync { // å¯¹æ–¹çš„TDæ¯”æˆ‘ä»¬å¤§ï¼Œä½†æ˜¯æ²¡æœ‰è·å–åˆ°ä»»ä½•ä¸œè¥¿ã€‚ é‚£ä¹ˆè®¤ä¸ºå¯¹æ–¹æ˜¯é”™è¯¯çš„å¯¹æ–¹ã€‚ ä¼šæ–­å¼€å’Œå¯¹æ–¹çš„è”ç³»                    if !gotHeaders &amp;&amp; td.Cmp(d.blockchain.GetTdByHash(d.blockchain.CurrentBlock().Hash())) &gt; 0 {                        return errStallingPeer                    }                }                // If fast or light syncing, ensure promised headers are indeed delivered. This is                // needed to detect scenarios where an attacker feeds a bad pivot and then bails out                // of delivering the post-pivot blocks that would flag the invalid content.                //                // This check cannot be executed "as is" for full imports, since blocks may still be                // queued for processing when the header download completes. However, as long as the                // peer gave us something useful, we're already happy/progressed (above check).                if d.mode == FastSync || d.mode == LightSync {                    if td.Cmp(d.lightchain.GetTdByHash(d.lightchain.CurrentHeader().Hash())) &gt; 0 {                        return errStallingPeer                    }                }                // Disable any rollback and return                rollback = nil                return nil            }            // Otherwise split the chunk of headers into batches and process them            gotHeaders = true            for len(headers) &gt; 0 {                // Terminate if something failed in between processing chunks                select {                case &lt;-d.cancelCh:                    return errCancelHeaderProcessing                default:                }                // Select the next chunk of headers to import                limit := maxHeadersProcess                if limit &gt; len(headers) {                    limit = len(headers)                }                chunk := headers[:limit]                // In case of header only syncing, validate the chunk immediately                if d.mode == FastSync || d.mode == LightSync { //å¦‚æœæ˜¯å¿«é€ŸåŒæ­¥æ¨¡å¼ï¼Œæˆ–è€…æ˜¯è½»é‡çº§åŒæ­¥æ¨¡å¼(åªä¸‹è½½åŒºå—å¤´)                    // Collect the yet unknown headers to mark them as uncertain                    unknown := make([]*types.Header, 0, len(headers))                    for _, header := range chunk {                        if !d.lightchain.HasHeader(header.Hash(), header.Number.Uint64()) {                            unknown = append(unknown, header)                        }                    }                    // If we're importing pure headers, verify based on their recentness                    // æ¯éš”å¤šå°‘ä¸ªåŒºå—éªŒè¯ä¸€æ¬¡                    frequency := fsHeaderCheckFrequency                    if chunk[len(chunk)-1].Number.Uint64()+uint64(fsHeaderForceVerify) &gt; pivot {                        frequency = 1                    }                    // lightchainé»˜è®¤æ˜¯ç­‰äºchainçš„ã€‚ æ’å…¥åŒºå—å¤´ã€‚å¦‚æœå¤±è´¥é‚£ä¹ˆéœ€è¦å›æ»šã€‚                    if n, err := d.lightchain.InsertHeaderChain(chunk, frequency); err != nil {                        // If some headers were inserted, add them too to the rollback list                        if n &gt; 0 {                            rollback = append(rollback, chunk[:n]...)                        }                        log.Debug("Invalid header encountered", "number", chunk[n].Number, "hash", chunk[n].Hash(), "err", err)                        return errInvalidChain                    }                    // All verifications passed, store newly found uncertain headers                    rollback = append(rollback, unknown...)                    if len(rollback) &gt; fsHeaderSafetyNet {                        rollback = append(rollback[:0], rollback[len(rollback)-fsHeaderSafetyNet:]...)                    }                }                // If we're fast syncing and just pulled in the pivot, make sure it's the one locked in                if d.mode == FastSync &amp;&amp; d.fsPivotLock != nil &amp;&amp; chunk[0].Number.Uint64() &lt;= pivot &amp;&amp; chunk[len(chunk)-1].Number.Uint64() &gt;= pivot { //å¦‚æœPivotLock,æ£€æŸ¥ä¸€ä¸‹Hashæ˜¯å¦ç›¸åŒã€‚                    if pivot := chunk[int(pivot-chunk[0].Number.Uint64())]; pivot.Hash() != d.fsPivotLock.Hash() {                        log.Warn("Pivot doesn't match locked in one", "remoteNumber", pivot.Number, "remoteHash", pivot.Hash(), "localNumber", d.fsPivotLock.Number, "localHash", d.fsPivotLock.Hash())                        return errInvalidChain                    }                }                // Unless we're doing light chains, schedule the headers for associated content retrieval                // å¦‚æœæˆ‘ä»¬å¤„ç†å®Œè½»é‡çº§é“¾ã€‚ è°ƒåº¦headeræ¥è¿›è¡Œç›¸å…³æ•°æ®çš„è·å–ã€‚bodyï¼Œreceipts                if d.mode == FullSync || d.mode == FastSync {                    // If we've reached the allowed number of pending headers, stall a bit                    // å¦‚æœå½“å‰queueçš„å®¹é‡å®¹çº³ä¸ä¸‹äº†ã€‚é‚£ä¹ˆç­‰å¾…ã€‚                    for d.queue.PendingBlocks() &gt;= maxQueuedHeaders || d.queue.PendingReceipts() &gt;= maxQueuedHeaders {                        select {                        case &lt;-d.cancelCh:                            return errCancelHeaderProcessing                        case &lt;-time.After(time.Second):                        }                    }                    // Otherwise insert the headers for content retrieval                    // è°ƒç”¨Queueè¿›è¡Œè°ƒåº¦ï¼Œä¸‹è½½bodyå’Œreceipts                    inserts := d.queue.Schedule(chunk, origin)                    if len(inserts) != len(chunk) {                        log.Debug("Stale headers")                        return errBadPeer                    }                }                headers = headers[limit:]                origin += uint64(limit)            }            // Signal the content downloaders of the availablility of new tasks            // ç»™é€šé“d.bodyWakeCh, d.receiptWakeChå‘é€æ¶ˆæ¯ï¼Œå”¤é†’å¤„ç†çº¿ç¨‹ã€‚            for _, ch := range []chan bool{d.bodyWakeCh, d.receiptWakeCh} {                select {                case ch &lt;- true:                default:                }            }        }    }}</code></pre><h2 id="bodieså¤„ç†"><a href="#bodieså¤„ç†" class="headerlink" title="bodieså¤„ç†"></a>bodieså¤„ç†</h2><p>fetchBodieså‡½æ•°å®šä¹‰äº†ä¸€äº›é—­åŒ…å‡½æ•°ï¼Œç„¶åè°ƒç”¨äº†fetchPartså‡½æ•°</p><pre><code>// fetchBodies iteratively downloads the scheduled block bodies, taking any// available peers, reserving a chunk of blocks for each, waiting for delivery// and also periodically checking for timeouts.// fetchBodies æŒç»­çš„ä¸‹è½½åŒºå—ä½“ï¼Œä¸­é—´ä¼šä½¿ç”¨åˆ°ä»»ä½•å¯ä»¥ç”¨çš„é“¾æ¥ï¼Œä¸ºæ¯ä¸€ä¸ªé“¾æ¥ä¿ç•™ä¸€éƒ¨åˆ†çš„åŒºå—ä½“ï¼Œç­‰å¾…åŒºå—è¢«äº¤ä»˜ï¼Œå¹¶å®šæœŸçš„æ£€æŸ¥æ˜¯å¦è¶…æ—¶ã€‚func (d *Downloader) fetchBodies(from uint64) error {    log.Debug("Downloading block bodies", "origin", from)    var (        deliver = func(packet dataPack) (int, error) { //ä¸‹è½½å®Œçš„åŒºå—ä½“çš„äº¤ä»˜å‡½æ•°            pack := packet.(*bodyPack)            return d.queue.DeliverBodies(pack.peerId, pack.transactions, pack.uncles)        }        expire   = func() map[string]int { return d.queue.ExpireBodies(d.requestTTL()) }  //è¶…æ—¶        fetch    = func(p *peerConnection, req *fetchRequest) error { return p.FetchBodies(req) }  // fetchå‡½æ•°        capacity = func(p *peerConnection) int { return p.BlockCapacity(d.requestRTT()) } // å¯¹ç«¯çš„ååé‡        setIdle  = func(p *peerConnection, accepted int) { p.SetBodiesIdle(accepted) } // è®¾ç½®peerä¸ºidle    )    err := d.fetchParts(errCancelBodyFetch, d.bodyCh, deliver, d.bodyWakeCh, expire,        d.queue.PendingBlocks, d.queue.InFlightBlocks, d.queue.ShouldThrottleBlocks, d.queue.ReserveBodies,        d.bodyFetchHook, fetch, d.queue.CancelBodies, capacity, d.peers.BodyIdlePeers, setIdle, "bodies")    log.Debug("Block body download terminated", "err", err)    return err}</code></pre><p>fetchParts</p><pre><code>// fetchParts iteratively downloads scheduled block parts, taking any available// peers, reserving a chunk of fetch requests for each, waiting for delivery and// also periodically checking for timeouts.// fetchPartsè¿­ä»£åœ°ä¸‹è½½é¢„å®šçš„å—éƒ¨åˆ†ï¼Œå–å¾—ä»»ä½•å¯ç”¨çš„å¯¹ç­‰ä½“ï¼Œä¸ºæ¯ä¸ªéƒ¨åˆ†é¢„ç•™å¤§é‡çš„æå–è¯·æ±‚ï¼Œç­‰å¾…äº¤ä»˜å¹¶ä¸”è¿˜å®šæœŸæ£€æŸ¥è¶…æ—¶ã€‚// As the scheduling/timeout logic mostly is the same for all downloaded data// types, this method is used by each for data gathering and is instrumented with// various callbacks to handle the slight differences between processing them.// ç”±äºè°ƒåº¦/è¶…æ—¶é€»è¾‘å¯¹äºæ‰€æœ‰ä¸‹è½½çš„æ•°æ®ç±»å‹å¤§éƒ¨åˆ†æ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥è¿™ä¸ªæ–¹æ³•è¢«ç”¨äºä¸åŒçš„åŒºå—ç±»å‹çš„ä¸‹è½½ï¼Œå¹¶ä¸”ç”¨å„ç§å›è°ƒå‡½æ•°æ¥å¤„ç†å®ƒä»¬ä¹‹é—´çš„ç»†å¾®å·®åˆ«ã€‚// The instrumentation parameters://  - errCancel:   error type to return if the fetch operation is cancelled (mostly makes logging nicer) å¦‚æœfetchæ“ä½œè¢«å–æ¶ˆï¼Œä¼šåœ¨è¿™ä¸ªé€šé“ä¸Šå‘é€æ•°æ®//  - deliveryCh:  channel from which to retrieve downloaded data packets (merged from all concurrent peers) æ•°æ®è¢«ä¸‹è½½å®ŒæˆåæŠ•é€’çš„ç›®çš„åœ°//  - deliver:     processing callback to deliver data packets into type specific download queues (usually within `queue`) å¤„ç†å®Œæˆåæ•°æ®è¢«æŠ•é€’åˆ°å“ªä¸ªé˜Ÿåˆ—//  - wakeCh:      notification channel for waking the fetcher when new tasks are available (or sync completed) ç”¨æ¥é€šçŸ¥fetcher æ–°çš„ä»»åŠ¡åˆ°æ¥ï¼Œæˆ–è€…æ˜¯åŒæ­¥å®Œæˆ//  - expire:      task callback method to abort requests that took too long and return the faulty peers (traffic shaping)  å› ä¸ºè¶…æ—¶æ¥ç»ˆæ­¢è¯·æ±‚çš„å›è°ƒå‡½æ•°ã€‚//  - pending:     task callback for the number of requests still needing download (detect completion/non-completability) è¿˜éœ€è¦ä¸‹è½½çš„ä»»åŠ¡çš„æ•°é‡ã€‚//  - inFlight:    task callback for the number of in-progress requests (wait for all active downloads to finish) æ­£åœ¨å¤„ç†è¿‡ç¨‹ä¸­çš„è¯·æ±‚æ•°é‡//  - throttle:    task callback to check if the processing queue is full and activate throttling (bound memory use) ç”¨æ¥æ£€æŸ¥å¤„ç†é˜Ÿåˆ—æ˜¯å¦æ»¡çš„å›è°ƒå‡½æ•°ã€‚//  - reserve:     task callback to reserve new download tasks to a particular peer (also signals partial completions)  ç”¨æ¥ä¸ºæŸä¸ªpeeræ¥é¢„å®šä»»åŠ¡çš„å›è°ƒå‡½æ•°//  - fetchHook:   tester callback to notify of new tasks being initiated (allows testing the scheduling logic) //  - fetch:       network callback to actually send a particular download request to a physical remote peer //å‘é€ç½‘ç»œè¯·æ±‚çš„å›è°ƒå‡½æ•°//  - cancel:      task callback to abort an in-flight download request and allow rescheduling it (in case of lost peer)  ç”¨æ¥å–æ¶ˆæ­£åœ¨å¤„ç†çš„ä»»åŠ¡çš„å›è°ƒå‡½æ•°//  - capacity:    network callback to retrieve the estimated type-specific bandwidth capacity of a peer (traffic shaping) ç½‘ç»œå®¹é‡æˆ–è€…æ˜¯å¸¦å®½ã€‚//  - idle:        network callback to retrieve the currently (type specific) idle peers that can be assigned tasks  peeræ˜¯å¦ç©ºé—²çš„å›è°ƒå‡½æ•°//  - setIdle:     network callback to set a peer back to idle and update its estimated capacity (traffic shaping)  è®¾ç½®peerä¸ºç©ºé—²çš„å›è°ƒå‡½æ•°//  - kind:        textual label of the type being downloaded to display in log mesages   ä¸‹è½½ç±»å‹ï¼Œç”¨äºæ—¥å¿—func (d *Downloader) fetchParts(errCancel error, deliveryCh chan dataPack, deliver func(dataPack) (int, error), wakeCh chan bool,    expire func() map[string]int, pending func() int, inFlight func() bool, throttle func() bool, reserve func(*peerConnection, int) (*fetchRequest, bool, error),    fetchHook func([]*types.Header), fetch func(*peerConnection, *fetchRequest) error, cancel func(*fetchRequest), capacity func(*peerConnection) int,    idle func() ([]*peerConnection, int), setIdle func(*peerConnection, int), kind string) error {    // Create a ticker to detect expired retrieval tasks    ticker := time.NewTicker(100 * time.Millisecond)    defer ticker.Stop()    update := make(chan struct{}, 1)    // Prepare the queue and fetch block parts until the block header fetcher's done    finished := false    for {        select {        case &lt;-d.cancelCh:            return errCancel        case packet := &lt;-deliveryCh:            // If the peer was previously banned and failed to deliver it's pack            // in a reasonable time frame, ignore it's message.            // å¦‚æœpeeråœ¨ä¹‹å‰è¢«ç¦æ­¢è€Œä¸”æ²¡æœ‰åœ¨åˆé€‚çš„æ—¶é—´deliverå®ƒçš„æ•°æ®ï¼Œé‚£ä¹ˆå¿½ç•¥è¿™ä¸ªæ•°æ®            if peer := d.peers.Peer(packet.PeerId()); peer != nil {                // Deliver the received chunk of data and check chain validity                accepted, err := deliver(packet)                if err == errInvalidChain {                    return err                }                // Unless a peer delivered something completely else than requested (usually                // caused by a timed out request which came through in the end), set it to                // idle. If the delivery's stale, the peer should have already been idled.                if err != errStaleDelivery {                    setIdle(peer, accepted)                }                // Issue a log to the user to see what's going on                switch {                case err == nil &amp;&amp; packet.Items() == 0:                    peer.log.Trace("Requested data not delivered", "type", kind)                case err == nil:                    peer.log.Trace("Delivered new batch of data", "type", kind, "count", packet.Stats())                default:                    peer.log.Trace("Failed to deliver retrieved data", "type", kind, "err", err)                }            }            // Blocks assembled, try to update the progress            select {            case update &lt;- struct{}{}:            default:            }        case cont := &lt;-wakeCh:            // The header fetcher sent a continuation flag, check if it's done            // å½“æ‰€æœ‰çš„ä»»åŠ¡å®Œæˆçš„æ—¶å€™ä¼šå†™å…¥è¿™ä¸ªé˜Ÿåˆ—ã€‚            if !cont {                finished = true            }            // Headers arrive, try to update the progress            select {            case update &lt;- struct{}{}:            default:            }        case &lt;-ticker.C:            // Sanity check update the progress            select {            case update &lt;- struct{}{}:            default:            }        case &lt;-update:            // Short circuit if we lost all our peers            if d.peers.Len() == 0 {                return errNoPeers            }            // Check for fetch request timeouts and demote the responsible peers            for pid, fails := range expire() {                if peer := d.peers.Peer(pid); peer != nil {                    // If a lot of retrieval elements expired, we might have overestimated the remote peer or perhaps                    // ourselves. Only reset to minimal throughput but don't drop just yet. If even the minimal times                    // out that sync wise we need to get rid of the peer.                    //å¦‚æœå¾ˆå¤šæ£€ç´¢å…ƒç´ è¿‡æœŸï¼Œæˆ‘ä»¬å¯èƒ½é«˜ä¼°äº†è¿œç¨‹å¯¹è±¡æˆ–è€…æˆ‘ä»¬è‡ªå·±ã€‚ åªèƒ½é‡ç½®ä¸ºæœ€å°çš„ååé‡ï¼Œä½†ä¸è¦ä¸¢å¼ƒã€‚ å¦‚æœå³ä½¿æœ€å°çš„åŒæ­¥ä»»ç„¶è¶…æ—¶ï¼Œæˆ‘ä»¬éœ€è¦åˆ é™¤peerã€‚                    // The reason the minimum threshold is 2 is because the downloader tries to estimate the bandwidth                    // and latency of a peer separately, which requires pushing the measures capacity a bit and seeing                    // how response times reacts, to it always requests one more than the minimum (i.e. min 2).                    // æœ€å°é˜ˆå€¼ä¸º2çš„åŸå› æ˜¯å› ä¸ºä¸‹è½½å™¨è¯•å›¾åˆ†åˆ«ä¼°è®¡å¯¹ç­‰ä½“çš„å¸¦å®½å’Œç­‰å¾…æ—¶é—´ï¼Œè¿™éœ€è¦ç¨å¾®æ¨åŠ¨æµ‹é‡å®¹é‡å¹¶ä¸”çœ‹åˆ°å“åº”æ—¶é—´å¦‚ä½•ååº”ï¼Œæ€»æ˜¯è¦æ±‚æ¯”æœ€å°å€¼ï¼ˆå³ï¼Œæœ€å°å€¼2ï¼‰ã€‚                    if fails &gt; 2 {                        peer.log.Trace("Data delivery timed out", "type", kind)                        setIdle(peer, 0)                    } else {                        peer.log.Debug("Stalling delivery, dropping", "type", kind)                        d.dropPeer(pid)                    }                }            }            // If there's nothing more to fetch, wait or terminate            // ä»»åŠ¡å…¨éƒ¨å®Œæˆã€‚ é‚£ä¹ˆé€€å‡º            if pending() == 0 { //å¦‚æœæ²¡æœ‰ç­‰å¾…åˆ†é…çš„ä»»åŠ¡ï¼Œ é‚£ä¹ˆbreakã€‚ä¸ç”¨æ‰§è¡Œä¸‹é¢çš„ä»£ç äº†ã€‚                if !inFlight() &amp;&amp; finished {                    log.Debug("Data fetching completed", "type", kind)                    return nil                }                break            }            // Send a download request to all idle peers, until throttled            progressed, throttled, running := false, false, inFlight()            idles, total := idle()            for _, peer := range idles {                // Short circuit if throttling activated                if throttle() {                    throttled = true                    break                }                // Short circuit if there is no more available task.                if pending() == 0 {                    break                }                // Reserve a chunk of fetches for a peer. A nil can mean either that                // no more headers are available, or that the peer is known not to                // have them.                // ä¸ºæŸä¸ªpeerè¯·æ±‚åˆ†é…ä»»åŠ¡ã€‚                request, progress, err := reserve(peer, capacity(peer))                if err != nil {                    return err                }                if progress {                    progressed = true                }                if request == nil {                    continue                }                if request.From &gt; 0 {                    peer.log.Trace("Requesting new batch of data", "type", kind, "from", request.From)                } else if len(request.Headers) &gt; 0 {                    peer.log.Trace("Requesting new batch of data", "type", kind, "count", len(request.Headers), "from", request.Headers[0].Number)                } else {                    peer.log.Trace("Requesting new batch of data", "type", kind, "count", len(request.Hashes))                }                // Fetch the chunk and make sure any errors return the hashes to the queue                if fetchHook != nil {                    fetchHook(request.Headers)                }                if err := fetch(peer, request); err != nil {                    // Although we could try and make an attempt to fix this, this error really                    // means that we've double allocated a fetch task to a peer. If that is the                    // case, the internal state of the downloader and the queue is very wrong so                    // better hard crash and note the error instead of silently accumulating into                    // a much bigger issue.                    panic(fmt.Sprintf("%v: %s fetch assignment failed", peer, kind))                }                running = true            }            // Make sure that we have peers available for fetching. If all peers have been tried            // and all failed throw an error            if !progressed &amp;&amp; !throttled &amp;&amp; !running &amp;&amp; len(idles) == total &amp;&amp; pending() &gt; 0 {                return errPeersUnavailable            }        }    }}</code></pre><h2 id="receiptçš„å¤„ç†"><a href="#receiptçš„å¤„ç†" class="headerlink" title="receiptçš„å¤„ç†"></a>receiptçš„å¤„ç†</h2><p>receiptçš„å¤„ç†å’Œbodyç±»ä¼¼ã€‚</p><pre><code>// fetchReceipts iteratively downloads the scheduled block receipts, taking any// available peers, reserving a chunk of receipts for each, waiting for delivery// and also periodically checking for timeouts.func (d *Downloader) fetchReceipts(from uint64) error {    log.Debug("Downloading transaction receipts", "origin", from)    var (        deliver = func(packet dataPack) (int, error) {            pack := packet.(*receiptPack)            return d.queue.DeliverReceipts(pack.peerId, pack.receipts)        }        expire   = func() map[string]int { return d.queue.ExpireReceipts(d.requestTTL()) }        fetch    = func(p *peerConnection, req *fetchRequest) error { return p.FetchReceipts(req) }        capacity = func(p *peerConnection) int { return p.ReceiptCapacity(d.requestRTT()) }        setIdle  = func(p *peerConnection, accepted int) { p.SetReceiptsIdle(accepted) }    )    err := d.fetchParts(errCancelReceiptFetch, d.receiptCh, deliver, d.receiptWakeCh, expire,        d.queue.PendingReceipts, d.queue.InFlightReceipts, d.queue.ShouldThrottleReceipts, d.queue.ReserveReceipts,        d.receiptFetchHook, fetch, d.queue.CancelReceipts, capacity, d.peers.ReceiptIdlePeers, setIdle, "receipts")    log.Debug("Transaction receipt download terminated", "err", err)    return err}</code></pre><h2 id="processFastSyncContent-å’Œ-processFullSyncContent"><a href="#processFastSyncContent-å’Œ-processFullSyncContent" class="headerlink" title="processFastSyncContent å’Œ processFullSyncContent"></a>processFastSyncContent å’Œ processFullSyncContent</h2><pre><code>// processFastSyncContent takes fetch results from the queue and writes them to the// database. It also controls the synchronisation of state nodes of the pivot block.func (d *Downloader) processFastSyncContent(latest *types.Header) error {    // Start syncing state of the reported head block.    // This should get us most of the state of the pivot block.    // å¯åŠ¨çŠ¶æ€åŒæ­¥    stateSync := d.syncState(latest.Root)    defer stateSync.Cancel()    go func() {        if err := stateSync.Wait(); err != nil {            d.queue.Close() // wake up WaitResults        }    }()    pivot := d.queue.FastSyncPivot()    for {        results := d.queue.WaitResults() // ç­‰å¾…é˜Ÿåˆ—è¾“å‡ºå¤„ç†å®Œæˆçš„åŒºå—        if len(results) == 0 {            return stateSync.Cancel()        }        if d.chainInsertHook != nil {            d.chainInsertHook(results)        }        P, beforeP, afterP := splitAroundPivot(pivot, results)        // æ’å…¥fast syncçš„æ•°æ®        if err := d.commitFastSyncData(beforeP, stateSync); err != nil {            return err        }        if P != nil {            // å¦‚æœå·²ç»è¾¾åˆ°äº† pivot point é‚£ä¹ˆç­‰å¾…çŠ¶æ€åŒæ­¥å®Œæˆï¼Œ            stateSync.Cancel()            if err := d.commitPivotBlock(P); err != nil {                return err            }        }        // å¯¹äºpivot point ä¹‹åçš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œéƒ½éœ€è¦æŒ‰ç…§å®Œå…¨çš„å¤„ç†ã€‚        if err := d.importBlockResults(afterP); err != nil {            return err        }    }}</code></pre><p>processFullSyncContent,æ¯”è¾ƒç®€å•ã€‚ ä»é˜Ÿåˆ—é‡Œé¢è·å–åŒºå—ç„¶åæ’å…¥ã€‚</p><pre><code>// processFullSyncContent takes fetch results from the queue and imports them into the chain.func (d *Downloader) processFullSyncContent() error {    for {        results := d.queue.WaitResults()        if len(results) == 0 {            return nil        }        if d.chainInsertHook != nil {            d.chainInsertHook(results)        }        if err := d.importBlockResults(results); err != nil {            return err        }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-ethä»¥å¤ªåŠåè®®åˆ†æ</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>nodeä¸­çš„æœåŠ¡çš„å®šä¹‰ï¼Œ ethå…¶å®å°±æ˜¯å®ç°äº†ä¸€ä¸ªæœåŠ¡ã€‚</p><pre><code>type Service interface {    // Protocols retrieves the P2P protocols the service wishes to start.    Protocols() []p2p.Protocol    // APIs retrieves the list of RPC descriptors the service provides    APIs() []rpc.API    // Start is called after all services have been constructed and the networking    // layer was also initialized to spawn any goroutines required by the service.    Start(server *p2p.Server) error    // Stop terminates all goroutines belonging to the service, blocking until they    // are all terminated.    Stop() error}</code></pre><p>go ethereum çš„ethç›®å½•æ˜¯ä»¥å¤ªåŠæœåŠ¡çš„å®ç°ã€‚ ä»¥å¤ªåŠåè®®æ˜¯é€šè¿‡nodeçš„Registeræ–¹æ³•æ³¨å…¥çš„ã€‚</p><pre><code>// RegisterEthService adds an Ethereum client to the stack.func RegisterEthService(stack *node.Node, cfg *eth.Config) {    var err error    if cfg.SyncMode == downloader.LightSync {        err = stack.Register(func(ctx *node.ServiceContext) (node.Service, error) {            return les.New(ctx, cfg)        })    } else {        err = stack.Register(func(ctx *node.ServiceContext) (node.Service, error) {            fullNode, err := eth.New(ctx, cfg)            if fullNode != nil &amp;&amp; cfg.LightServ &gt; 0 {                ls, _ := les.NewLesServer(fullNode, cfg)                fullNode.AddLesServer(ls)            }            return fullNode, err        })    }    if err != nil {        Fatalf("Failed to register the Ethereum service: %v", err)    }}</code></pre><p>ä»¥å¤ªåŠåè®®çš„æ•°æ®ç»“æ„</p><pre><code>// Ethereum implements the Ethereum full node service.type Ethereum struct {    config      *Config                    é…ç½®    chainConfig *params.ChainConfig        é“¾é…ç½®    // Channel for shutting down the service    shutdownChan  chan bool    // Channel for shutting down the ethereum    stopDbUpgrade func() error // stop chain db sequential key upgrade    // Handlers    txPool          *core.TxPool            äº¤æ˜“æ±     blockchain      *core.BlockChain        åŒºå—é“¾    protocolManager *ProtocolManager        åè®®ç®¡ç†    lesServer       LesServer                è½»é‡çº§å®¢æˆ·ç«¯æœåŠ¡å™¨    // DB interfaces    chainDb ethdb.Database // Block chain database    åŒºå—é“¾æ•°æ®åº“    eventMux       *event.TypeMux    engine         consensus.Engine                ä¸€è‡´æ€§å¼•æ“ã€‚ åº”è¯¥æ˜¯Powéƒ¨åˆ†    accountManager *accounts.Manager            è´¦å·ç®¡ç†    bloomRequests chan chan *bloombits.Retrieval // Channel receiving bloom data retrieval requests    æ¥æ”¶bloomè¿‡æ»¤å™¨æ•°æ®è¯·æ±‚çš„é€šé“    bloomIndexer  *core.ChainIndexer             // Bloom indexer operating during block imports  //åœ¨åŒºå—importçš„æ—¶å€™æ‰§è¡ŒBloom indexeræ“ä½œ æš‚æ—¶ä¸æ¸…æ¥šæ˜¯ä»€ä¹ˆ    ApiBackend *EthApiBackend        //æä¾›ç»™RPCæœåŠ¡ä½¿ç”¨çš„APIåç«¯    miner     *miner.Miner            //çŸ¿å·¥    gasPrice  *big.Int                //èŠ‚ç‚¹æ¥æ”¶çš„gasPriceçš„æœ€å°å€¼ã€‚ æ¯”è¿™ä¸ªå€¼æ›´å°çš„äº¤æ˜“ä¼šè¢«æœ¬èŠ‚ç‚¹æ‹’ç»    etherbase common.Address        //çŸ¿å·¥åœ°å€    networkId     uint64            //ç½‘ç»œID  testnetæ˜¯0 mainnetæ˜¯1     netRPCService *ethapi.PublicNetAPI    //RPCçš„æœåŠ¡    lock sync.RWMutex // Protects the variadic fields (e.g. gas price and etherbase)}</code></pre><p>ä»¥å¤ªåŠåè®®çš„åˆ›å»ºNew. æš‚æ—¶å…ˆä¸æ¶‰åŠcoreçš„å†…å®¹ã€‚ åªæ˜¯å¤§æ¦‚ä»‹ç»ä¸€ä¸‹ã€‚ coreé‡Œé¢çš„å†…å®¹åç»­ä¼šåˆ†æã€‚</p><pre><code>// New creates a new Ethereum object (including the// initialisation of the common Ethereum object)func New(ctx *node.ServiceContext, config *Config) (*Ethereum, error) {    if config.SyncMode == downloader.LightSync {        return nil, errors.New("can't run eth.Ethereum in light sync mode, use les.LightEthereum")    }    if !config.SyncMode.IsValid() {        return nil, fmt.Errorf("invalid sync mode %d", config.SyncMode)    }    // åˆ›å»ºleveldbã€‚ æ‰“å¼€æˆ–è€…æ–°å»º chaindataç›®å½•    chainDb, err := CreateDB(ctx, config, "chaindata")    if err != nil {        return nil, err    }    // æ•°æ®åº“æ ¼å¼å‡çº§    stopDbUpgrade := upgradeDeduplicateData(chainDb)    // è®¾ç½®åˆ›ä¸–åŒºå—ã€‚ å¦‚æœæ•°æ®åº“é‡Œé¢å·²ç»æœ‰åˆ›ä¸–åŒºå—é‚£ä¹ˆä»æ•°æ®åº“é‡Œé¢å–å‡º(ç§é“¾)ã€‚æˆ–è€…æ˜¯ä»ä»£ç é‡Œé¢è·å–é»˜è®¤å€¼ã€‚    chainConfig, genesisHash, genesisErr := core.SetupGenesisBlock(chainDb, config.Genesis)    if _, ok := genesisErr.(*params.ConfigCompatError); genesisErr != nil &amp;&amp; !ok {        return nil, genesisErr    }    log.Info("Initialised chain configuration", "config", chainConfig)    eth := &amp;Ethereum{        config:         config,        chainDb:        chainDb,        chainConfig:    chainConfig,        eventMux:       ctx.EventMux,        accountManager: ctx.AccountManager,        engine:         CreateConsensusEngine(ctx, config, chainConfig, chainDb), // ä¸€è‡´æ€§å¼•æ“ã€‚ è¿™é‡Œæˆ‘ç†è§£æ˜¯Pow        shutdownChan:   make(chan bool),        stopDbUpgrade:  stopDbUpgrade,        networkId:      config.NetworkId,  // ç½‘ç»œIDç”¨æ¥åŒºåˆ«ç½‘è·¯ã€‚ æµ‹è¯•ç½‘ç»œæ˜¯0.ä¸»ç½‘æ˜¯1        gasPrice:       config.GasPrice,   // å¯ä»¥é€šè¿‡é…ç½® --gasprice å®¢æˆ·ç«¯æ¥çº³çš„äº¤æ˜“çš„gaspriceæœ€å°å€¼ã€‚å¦‚æœå°äºè¿™ä¸ªå€¼é‚£ä¹ˆä¼šè¢«èŠ‚ç‚¹ä¸¢å¼ƒã€‚         etherbase:      config.Etherbase,  //æŒ–çŸ¿çš„å—ç›Šè€…        bloomRequests:  make(chan chan *bloombits.Retrieval),  //bloomçš„è¯·æ±‚        bloomIndexer:   NewBloomIndexer(chainDb, params.BloomBitsBlocks),    }    log.Info("Initialising Ethereum protocol", "versions", ProtocolVersions, "network", config.NetworkId)    if !config.SkipBcVersionCheck { // æ£€æŸ¥æ•°æ®åº“é‡Œé¢å­˜å‚¨çš„BlockChainVersionå’Œå®¢æˆ·ç«¯çš„BlockChainVersionçš„ç‰ˆæœ¬æ˜¯å¦ä¸€è‡´        bcVersion := core.GetBlockChainVersion(chainDb)        if bcVersion != core.BlockChainVersion &amp;&amp; bcVersion != 0 {            return nil, fmt.Errorf("Blockchain DB version mismatch (%d / %d). Run geth upgradedb.\n", bcVersion, core.BlockChainVersion)        }        core.WriteBlockChainVersion(chainDb, core.BlockChainVersion)    }    vmConfig := vm.Config{EnablePreimageRecording: config.EnablePreimageRecording}    // ä½¿ç”¨æ•°æ®åº“åˆ›å»ºäº†åŒºå—é“¾    eth.blockchain, err = core.NewBlockChain(chainDb, eth.chainConfig, eth.engine, vmConfig)    if err != nil {        return nil, err    }    // Rewind the chain in case of an incompatible config upgrade.    if compat, ok := genesisErr.(*params.ConfigCompatError); ok {        log.Warn("Rewinding chain to upgrade configuration", "err", compat)        eth.blockchain.SetHead(compat.RewindTo)        core.WriteChainConfig(chainDb, genesisHash, chainConfig)    }    // bloomIndexer æš‚æ—¶ä¸çŸ¥é“æ˜¯ä»€ä¹ˆä¸œè¥¿ è¿™é‡Œé¢æ¶‰åŠå¾—ä¹Ÿä¸æ˜¯å¾ˆå¤šã€‚ æš‚æ—¶å…ˆä¸ç®¡äº†    eth.bloomIndexer.Start(eth.blockchain.CurrentHeader(), eth.blockchain.SubscribeChainEvent)    if config.TxPool.Journal != "" {        config.TxPool.Journal = ctx.ResolvePath(config.TxPool.Journal)    }    // åˆ›å»ºäº¤æ˜“æ± ã€‚ ç”¨æ¥å­˜å‚¨æœ¬åœ°æˆ–è€…åœ¨ç½‘ç»œä¸Šæ¥æ”¶åˆ°çš„äº¤æ˜“ã€‚    eth.txPool = core.NewTxPool(config.TxPool, eth.chainConfig, eth.blockchain)    // åˆ›å»ºåè®®ç®¡ç†å™¨    if eth.protocolManager, err = NewProtocolManager(eth.chainConfig, config.SyncMode, config.NetworkId, eth.eventMux, eth.txPool, eth.engine, eth.blockchain, chainDb); err != nil {        return nil, err    }    // åˆ›å»ºçŸ¿å·¥    eth.miner = miner.New(eth, eth.chainConfig, eth.EventMux(), eth.engine)    eth.miner.SetExtra(makeExtraData(config.ExtraData))    // ApiBackend ç”¨äºç»™RPCè°ƒç”¨æä¾›åç«¯æ”¯æŒ    eth.ApiBackend = &amp;EthApiBackend{eth, nil}    // gpoParams GPO Gas Price Oracle çš„ç¼©å†™ã€‚ GasPriceé¢„æµ‹ã€‚ é€šè¿‡æœ€è¿‘çš„äº¤æ˜“æ¥é¢„æµ‹å½“å‰çš„GasPriceçš„å€¼ã€‚è¿™ä¸ªå€¼å¯ä»¥ä½œä¸ºä¹‹åå‘é€äº¤æ˜“çš„è´¹ç”¨çš„å‚è€ƒã€‚    gpoParams := config.GPO    if gpoParams.Default == nil {        gpoParams.Default = config.GasPrice    }    eth.ApiBackend.gpo = gasprice.NewOracle(eth.ApiBackend, gpoParams)    return eth, nil}</code></pre><p>ApiBackend å®šä¹‰åœ¨ api_backend.goæ–‡ä»¶ä¸­ã€‚ å°è£…äº†ä¸€äº›å‡½æ•°ã€‚</p><pre><code>// EthApiBackend implements ethapi.Backend for full nodestype EthApiBackend struct {    eth *Ethereum    gpo *gasprice.Oracle}func (b *EthApiBackend) SetHead(number uint64) {    b.eth.protocolManager.downloader.Cancel()    b.eth.blockchain.SetHead(number)}</code></pre><p>Newæ–¹æ³•ä¸­é™¤äº†coreä¸­çš„ä¸€äº›æ–¹æ³•ï¼Œ æœ‰ä¸€ä¸ªProtocolManagerçš„å¯¹è±¡åœ¨ä»¥å¤ªåŠåè®®ä¸­æ¯”è¾ƒé‡è¦ï¼Œ ä»¥å¤ªåŠæœ¬æ¥æ˜¯ä¸€ä¸ªåè®®ã€‚ProtocolManagerä¸­åˆå¯ä»¥ç®¡ç†å¤šä¸ªä»¥å¤ªåŠçš„å­åè®®ã€‚</p><pre><code>// NewProtocolManager returns a new ethereum sub protocol manager. The Ethereum sub protocol manages peers capable// with the ethereum network.func NewProtocolManager(config *params.ChainConfig, mode downloader.SyncMode, networkId uint64, mux *event.TypeMux, txpool txPool, engine consensus.Engine, blockchain *core.BlockChain, chaindb ethdb.Database) (*ProtocolManager, error) {    // Create the protocol manager with the base fields    manager := &amp;ProtocolManager{        networkId:   networkId,        eventMux:    mux,        txpool:      txpool,        blockchain:  blockchain,        chaindb:     chaindb,        chainconfig: config,        peers:       newPeerSet(),        newPeerCh:   make(chan *peer),        noMorePeers: make(chan struct{}),        txsyncCh:    make(chan *txsync),        quitSync:    make(chan struct{}),    }    // Figure out whether to allow fast sync or not    if mode == downloader.FastSync &amp;&amp; blockchain.CurrentBlock().NumberU64() &gt; 0 {        log.Warn("Blockchain not empty, fast sync disabled")        mode = downloader.FullSync    }    if mode == downloader.FastSync {        manager.fastSync = uint32(1)    }    // Initiate a sub-protocol for every implemented version we can handle    manager.SubProtocols = make([]p2p.Protocol, 0, len(ProtocolVersions))    for i, version := range ProtocolVersions {        // Skip protocol version if incompatible with the mode of operation        if mode == downloader.FastSync &amp;&amp; version &lt; eth63 {            continue        }        // Compatible; initialise the sub-protocol        version := version // Closure for the run        manager.SubProtocols = append(manager.SubProtocols, p2p.Protocol{            Name:    ProtocolName,            Version: version,            Length:  ProtocolLengths[i],            // è¿˜è®°å¾—p2pé‡Œé¢çš„Protocolä¹ˆã€‚ p2pçš„peerè¿æ¥æˆåŠŸä¹‹åä¼šè°ƒç”¨Runæ–¹æ³•            Run: func(p *p2p.Peer, rw p2p.MsgReadWriter) error {                peer := manager.newPeer(int(version), p, rw)                select {                case manager.newPeerCh &lt;- peer:                    manager.wg.Add(1)                    defer manager.wg.Done()                    return manager.handle(peer)                case &lt;-manager.quitSync:                    return p2p.DiscQuitting                }            },            NodeInfo: func() interface{} {                return manager.NodeInfo()            },            PeerInfo: func(id discover.NodeID) interface{} {                if p := manager.peers.Peer(fmt.Sprintf("%x", id[:8])); p != nil {                    return p.Info()                }                return nil            },        })    }    if len(manager.SubProtocols) == 0 {        return nil, errIncompatibleConfig    }    // Construct the different synchronisation mechanisms    // downloaderæ˜¯è´Ÿè´£ä»å…¶ä»–çš„peeræ¥åŒæ­¥è‡ªèº«æ•°æ®ã€‚    // downloaderæ˜¯å…¨é“¾åŒæ­¥å·¥å…·    manager.downloader = downloader.New(mode, chaindb, manager.eventMux, blockchain, nil, manager.removePeer)    // validator æ˜¯ä½¿ç”¨ä¸€è‡´æ€§å¼•æ“æ¥éªŒè¯åŒºå—å¤´çš„å‡½æ•°    validator := func(header *types.Header) error {        return engine.VerifyHeader(blockchain, header, true)    }    // è¿”å›åŒºå—é«˜åº¦çš„å‡½æ•°    heighter := func() uint64 {        return blockchain.CurrentBlock().NumberU64()    }    // å¦‚æœfast syncå¼€å¯äº†ã€‚ é‚£ä¹ˆä¸ä¼šè°ƒç”¨inserterã€‚    inserter := func(blocks types.Blocks) (int, error) {        // If fast sync is running, deny importing weird blocks        if atomic.LoadUint32(&amp;manager.fastSync) == 1 {            log.Warn("Discarded bad propagated block", "number", blocks[0].Number(), "hash", blocks[0].Hash())            return 0, nil        }        // è®¾ç½®å¼€å§‹æ¥æ”¶äº¤æ˜“        atomic.StoreUint32(&amp;manager.acceptTxs, 1) // Mark initial sync done on any fetcher import        // æ’å…¥åŒºå—        return manager.blockchain.InsertChain(blocks)    }    // ç”Ÿæˆä¸€ä¸ªfetcher     // Fetcherè´Ÿè´£ç§¯ç´¯æ¥è‡ªå„ä¸ªpeerçš„åŒºå—é€šçŸ¥å¹¶å®‰æ’è¿›è¡Œæ£€ç´¢ã€‚    manager.fetcher = fetcher.New(blockchain.GetBlockByHash, validator, manager.BroadcastBlock, heighter, inserter, manager.removePeer)    return manager, nil}</code></pre><p>æœåŠ¡çš„APIs()æ–¹æ³•ä¼šè¿”å›æœåŠ¡æš´éœ²çš„RPCæ–¹æ³•ã€‚</p><pre><code>// APIs returns the collection of RPC services the ethereum package offers.// NOTE, some of these services probably need to be moved to somewhere else.func (s *Ethereum) APIs() []rpc.API {    apis := ethapi.GetAPIs(s.ApiBackend)    // Append any APIs exposed explicitly by the consensus engine    apis = append(apis, s.engine.APIs(s.BlockChain())...)    // Append all the local APIs and return    return append(apis, []rpc.API{        {            Namespace: "eth",            Version:   "1.0",            Service:   NewPublicEthereumAPI(s),            Public:    true,        },        ...        , {            Namespace: "net",            Version:   "1.0",            Service:   s.netRPCService,            Public:    true,        },    }...)}</code></pre><p>æœåŠ¡çš„Protocolsæ–¹æ³•ä¼šè¿”å›æœåŠ¡æä¾›äº†é‚£äº›p2pçš„Protocolã€‚ è¿”å›åè®®ç®¡ç†å™¨é‡Œé¢çš„æ‰€æœ‰SubProtocols. å¦‚æœæœ‰lesServeré‚£ä¹ˆè¿˜æä¾›lesServerçš„Protocolã€‚å¯ä»¥çœ‹åˆ°ã€‚æ‰€æœ‰çš„ç½‘ç»œåŠŸèƒ½éƒ½æ˜¯é€šè¿‡Protocolçš„æ–¹å¼æä¾›å‡ºæ¥çš„ã€‚</p><pre><code>// Protocols implements node.Service, returning all the currently configured// network protocols to start.func (s *Ethereum) Protocols() []p2p.Protocol {    if s.lesServer == nil {        return s.protocolManager.SubProtocols    }    return append(s.protocolManager.SubProtocols, s.lesServer.Protocols()...)}</code></pre><p>EthereumæœåŠ¡åœ¨åˆ›å»ºä¹‹åï¼Œä¼šè¢«è°ƒç”¨æœåŠ¡çš„Startæ–¹æ³•ã€‚ä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹Startæ–¹æ³•</p><pre><code>// Start implements node.Service, starting all internal goroutines needed by the// Ethereum protocol implementation.func (s *Ethereum) Start(srvr *p2p.Server) error {    // Start the bloom bits servicing goroutines    // å¯åŠ¨å¸ƒéš†è¿‡æ»¤å™¨è¯·æ±‚å¤„ç†çš„goroutine TODO    s.startBloomHandlers()    // Start the RPC service    // åˆ›å»ºç½‘ç»œçš„API net    s.netRPCService = ethapi.NewPublicNetAPI(srvr, s.NetVersion())    // Figure out a max peers count based on the server limits    maxPeers := srvr.MaxPeers    if s.config.LightServ &gt; 0 {        maxPeers -= s.config.LightPeers        if maxPeers &lt; srvr.MaxPeers/2 {            maxPeers = srvr.MaxPeers / 2        }    }    // Start the networking layer and the light server if requested    // å¯åŠ¨åè®®ç®¡ç†å™¨    s.protocolManager.Start(maxPeers)    if s.lesServer != nil {        // å¦‚æœlesServerä¸ä¸ºnil å¯åŠ¨å®ƒã€‚        s.lesServer.Start(srvr)    }    return nil}</code></pre><p>åè®®ç®¡ç†å™¨çš„æ•°æ®ç»“æ„</p><pre><code>type ProtocolManager struct {    networkId uint64    fastSync  uint32 // Flag whether fast sync is enabled (gets disabled if we already have blocks)    acceptTxs uint32 // Flag whether we're considered synchronised (enables transaction processing)    txpool      txPool    blockchain  *core.BlockChain    chaindb     ethdb.Database    chainconfig *params.ChainConfig    maxPeers    int    downloader *downloader.Downloader    fetcher    *fetcher.Fetcher    peers      *peerSet    SubProtocols []p2p.Protocol    eventMux      *event.TypeMux    txCh          chan core.TxPreEvent    txSub         event.Subscription    minedBlockSub *event.TypeMuxSubscription    // channels for fetcher, syncer, txsyncLoop    newPeerCh   chan *peer    txsyncCh    chan *txsync    quitSync    chan struct{}    noMorePeers chan struct{}    // wait group is used for graceful shutdowns during downloading    // and processing    wg sync.WaitGroup}</code></pre><p>åè®®ç®¡ç†å™¨çš„Startæ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•é‡Œé¢å¯åŠ¨äº†å¤§é‡çš„goroutineç”¨æ¥å¤„ç†å„ç§äº‹åŠ¡ï¼Œå¯ä»¥æ¨æµ‹ï¼Œè¿™ä¸ªç±»åº”è¯¥æ˜¯ä»¥å¤ªåŠæœåŠ¡çš„ä¸»è¦å®ç°ç±»ã€‚</p><pre><code>func (pm *ProtocolManager) Start(maxPeers int) {    pm.maxPeers = maxPeers        // broadcast transactions    // å¹¿æ’­äº¤æ˜“çš„é€šé“ã€‚ txChä¼šä½œä¸ºtxpoolçš„TxPreEventè®¢é˜…é€šé“ã€‚txpoolæœ‰äº†è¿™ç§æ¶ˆæ¯ä¼šé€šçŸ¥ç»™è¿™ä¸ªtxChã€‚ å¹¿æ’­äº¤æ˜“çš„goroutineä¼šæŠŠè¿™ä¸ªæ¶ˆæ¯å¹¿æ’­å‡ºå»ã€‚    pm.txCh = make(chan core.TxPreEvent, txChanSize)    // è®¢é˜…çš„å›æ‰§    pm.txSub = pm.txpool.SubscribeTxPreEvent(pm.txCh)    // å¯åŠ¨å¹¿æ’­çš„goroutine    go pm.txBroadcastLoop()    // broadcast mined blocks    // è®¢é˜…æŒ–çŸ¿æ¶ˆæ¯ã€‚å½“æ–°çš„Blockè¢«æŒ–å‡ºæ¥çš„æ—¶å€™ä¼šäº§ç”Ÿæ¶ˆæ¯ã€‚ è¿™ä¸ªè®¢é˜…å’Œä¸Šé¢çš„é‚£ä¸ªè®¢é˜…é‡‡ç”¨äº†ä¸¤ç§ä¸åŒçš„æ¨¡å¼ï¼Œè¿™ç§æ˜¯æ ‡è®°ä¸ºDeprecatedçš„è®¢é˜…æ–¹å¼ã€‚    pm.minedBlockSub = pm.eventMux.Subscribe(core.NewMinedBlockEvent{})    // æŒ–çŸ¿å¹¿æ’­ goroutine å½“æŒ–å‡ºæ¥çš„æ—¶å€™éœ€è¦å°½å¿«çš„å¹¿æ’­åˆ°ç½‘ç»œä¸Šé¢å»ã€‚    go pm.minedBroadcastLoop()    // start sync handlers    // åŒæ­¥å™¨è´Ÿè´£å‘¨æœŸæ€§åœ°ä¸ç½‘ç»œåŒæ­¥ï¼Œä¸‹è½½æ•£åˆ—å’Œå—ä»¥åŠå¤„ç†é€šçŸ¥å¤„ç†ç¨‹åºã€‚    go pm.syncer()    // txsyncLoopè´Ÿè´£æ¯ä¸ªæ–°è¿æ¥çš„åˆå§‹äº‹åŠ¡åŒæ­¥ã€‚ å½“æ–°çš„peerå‡ºç°æ—¶ï¼Œæˆ‘ä»¬è½¬å‘æ‰€æœ‰å½“å‰å¾…å¤„ç†çš„äº‹åŠ¡ã€‚ ä¸ºäº†æœ€å°åŒ–å‡ºå£å¸¦å®½ä½¿ç”¨ï¼Œæˆ‘ä»¬ä¸€æ¬¡åªå‘é€ä¸€ä¸ªå°åŒ…ã€‚    go pm.txsyncLoop()}</code></pre><p>å½“p2pçš„serverå¯åŠ¨çš„æ—¶å€™ï¼Œä¼šä¸»åŠ¨çš„æ‰¾èŠ‚ç‚¹å»è¿æ¥ï¼Œæˆ–è€…è¢«å…¶ä»–çš„èŠ‚ç‚¹è¿æ¥ã€‚ è¿æ¥çš„è¿‡ç¨‹æ˜¯é¦–å…ˆè¿›è¡ŒåŠ å¯†ä¿¡é“çš„æ¡æ‰‹ï¼Œç„¶åè¿›è¡Œåè®®çš„æ¡æ‰‹ã€‚ æœ€åä¸ºæ¯ä¸ªåè®®å¯åŠ¨goroutine æ‰§è¡ŒRunæ–¹æ³•æ¥æŠŠæ§åˆ¶äº¤ç»™æœ€ç»ˆçš„åè®®ã€‚ è¿™ä¸ªrunæ–¹æ³•é¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ªpeerå¯¹è±¡ï¼Œç„¶åè°ƒç”¨äº†handleæ–¹æ³•æ¥å¤„ç†è¿™ä¸ªpeer</p><pre><code>Run: func(p *p2p.Peer, rw p2p.MsgReadWriter) error {                    peer := manager.newPeer(int(version), p, rw)                    select {                    case manager.newPeerCh &lt;- peer:  //æŠŠpeerå‘é€åˆ°newPeerChé€šé“                        manager.wg.Add(1)                        defer manager.wg.Done()                        return manager.handle(peer)  // è°ƒç”¨handloæ–¹æ³•                    case &lt;-manager.quitSync:                        return p2p.DiscQuitting                    }                },</code></pre><p>handleæ–¹æ³•,</p><pre><code>// handle is the callback invoked to manage the life cycle of an eth peer. When// this function terminates, the peer is disconnected.// handleæ˜¯ä¸€ä¸ªå›è°ƒæ–¹æ³•ï¼Œç”¨æ¥ç®¡ç†ethçš„peerçš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚ å½“è¿™ä¸ªæ–¹æ³•é€€å‡ºçš„æ—¶å€™ï¼Œpeerçš„è¿æ¥ä¹Ÿä¼šæ–­å¼€ã€‚func (pm *ProtocolManager) handle(p *peer) error {    if pm.peers.Len() &gt;= pm.maxPeers {        return p2p.DiscTooManyPeers    }    p.Log().Debug("Ethereum peer connected", "name", p.Name())    // Execute the Ethereum handshake    td, head, genesis := pm.blockchain.Status()    // tdæ˜¯total difficult, headæ˜¯å½“å‰çš„åŒºå—å¤´ï¼Œgenesisæ˜¯åˆ›ä¸–åŒºå—çš„ä¿¡æ¯ã€‚ åªæœ‰åˆ›ä¸–åŒºå—ç›¸åŒæ‰èƒ½æ¡æ‰‹æˆåŠŸã€‚    if err := p.Handshake(pm.networkId, td, head, genesis); err != nil {        p.Log().Debug("Ethereum handshake failed", "err", err)        return err    }    if rw, ok := p.rw.(*meteredMsgReadWriter); ok {        rw.Init(p.version)    }    // Register the peer locally    // æŠŠpeeræ³¨å†Œåˆ°æœ¬åœ°    if err := pm.peers.Register(p); err != nil {        p.Log().Error("Ethereum peer registration failed", "err", err)        return err    }    defer pm.removePeer(p.id)    // Register the peer in the downloader. If the downloader considers it banned, we disconnect    // æŠŠpeeræ³¨å†Œç»™downloader. å¦‚æœdownloaderè®¤ä¸ºè¿™ä¸ªpeerè¢«ç¦ï¼Œé‚£ä¹ˆæ–­å¼€è¿æ¥ã€‚    if err := pm.downloader.RegisterPeer(p.id, p.version, p); err != nil {        return err    }    // Propagate existing transactions. new transactions appearing    // after this will be sent via broadcasts.    // æŠŠå½“å‰pendingçš„äº¤æ˜“å‘é€ç»™å¯¹æ–¹ï¼Œè¿™ä¸ªåªåœ¨è¿æ¥åˆšå»ºç«‹çš„æ—¶å€™å‘ç”Ÿ    pm.syncTransactions(p)    // If we're DAO hard-fork aware, validate any remote peer with regard to the hard-fork    // éªŒè¯peerçš„DAOç¡¬åˆ†å‰    if daoBlock := pm.chainconfig.DAOForkBlock; daoBlock != nil {        // Request the peer's DAO fork header for extra-data validation        if err := p.RequestHeadersByNumber(daoBlock.Uint64(), 1, 0, false); err != nil {            return err        }        // Start a timer to disconnect if the peer doesn't reply in time        // å¦‚æœ15ç§’å†…æ²¡æœ‰æ¥æ”¶åˆ°å›åº”ã€‚é‚£ä¹ˆæ–­å¼€è¿æ¥ã€‚        p.forkDrop = time.AfterFunc(daoChallengeTimeout, func() {            p.Log().Debug("Timed out DAO fork-check, dropping")            pm.removePeer(p.id)        })        // Make sure it's cleaned up if the peer dies off        defer func() {            if p.forkDrop != nil {                p.forkDrop.Stop()                p.forkDrop = nil            }        }()    }    // main loop. handle incoming messages.    // ä¸»å¾ªç¯ã€‚ å¤„ç†è¿›å…¥çš„æ¶ˆæ¯ã€‚    for {        if err := pm.handleMsg(p); err != nil {            p.Log().Debug("Ethereum message handling failed", "err", err)            return err        }    }}</code></pre><p>Handshake</p><pre><code>// Handshake executes the eth protocol handshake, negotiating version number,// network IDs, difficulties, head and genesis blocks.func (p *peer) Handshake(network uint64, td *big.Int, head common.Hash, genesis common.Hash) error {    // Send out own handshake in a new thread    // errorçš„channelçš„å¤§å°æ˜¯2ï¼Œ å°±æ˜¯ä¸ºäº†ä¸€æ¬¡æ€§å¤„ç†ä¸‹é¢çš„ä¸¤ä¸ªgoroutineæ–¹æ³•    errc := make(chan error, 2)    var status statusData // safe to read after two values have been received from errc    go func() {        errc &lt;- p2p.Send(p.rw, StatusMsg, &amp;statusData{            ProtocolVersion: uint32(p.version),            NetworkId:       network,            TD:              td,            CurrentBlock:    head,            GenesisBlock:    genesis,        })    }()    go func() {        errc &lt;- p.readStatus(network, &amp;status, genesis)    }()    timeout := time.NewTimer(handshakeTimeout)    defer timeout.Stop()    // å¦‚æœæ¥æ”¶åˆ°ä»»ä½•ä¸€ä¸ªé”™è¯¯(å‘é€ï¼Œæ¥æ”¶),æˆ–è€…æ˜¯è¶…æ—¶ï¼Œ é‚£ä¹ˆå°±æ–­å¼€è¿æ¥ã€‚    for i := 0; i &lt; 2; i++ {        select {        case err := &lt;-errc:            if err != nil {                return err            }        case &lt;-timeout.C:            return p2p.DiscReadTimeout        }    }    p.td, p.head = status.TD, status.CurrentBlock    return nil}</code></pre><p>readStatusï¼Œæ£€æŸ¥å¯¹ç«¯è¿”å›çš„å„ç§æƒ…å†µï¼Œ</p><pre><code>func (p *peer) readStatus(network uint64, status *statusData, genesis common.Hash) (err error) {    msg, err := p.rw.ReadMsg()    if err != nil {        return err    }    if msg.Code != StatusMsg {        return errResp(ErrNoStatusMsg, "first msg has code %x (!= %x)", msg.Code, StatusMsg)    }    if msg.Size &gt; ProtocolMaxMsgSize {        return errResp(ErrMsgTooLarge, "%v &gt; %v", msg.Size, ProtocolMaxMsgSize)    }    // Decode the handshake and make sure everything matches    if err := msg.Decode(&amp;status); err != nil {        return errResp(ErrDecode, "msg %v: %v", msg, err)    }    if status.GenesisBlock != genesis {        return errResp(ErrGenesisBlockMismatch, "%x (!= %x)", status.GenesisBlock[:8], genesis[:8])    }    if status.NetworkId != network {        return errResp(ErrNetworkIdMismatch, "%d (!= %d)", status.NetworkId, network)    }    if int(status.ProtocolVersion) != p.version {        return errResp(ErrProtocolVersionMismatch, "%d (!= %d)", status.ProtocolVersion, p.version)    }    return nil}</code></pre><p>Register ç®€å•çš„æŠŠpeeråŠ å…¥åˆ°è‡ªå·±çš„peersçš„map</p><pre><code>// Register injects a new peer into the working set, or returns an error if the// peer is already known.func (ps *peerSet) Register(p *peer) error {    ps.lock.Lock()    defer ps.lock.Unlock()    if ps.closed {        return errClosed    }    if _, ok := ps.peers[p.id]; ok {        return errAlreadyRegistered    }    ps.peers[p.id] = p    return nil}</code></pre><p>ç»è¿‡ä¸€ç³»åˆ—çš„æ£€æŸ¥å’Œæ¡æ‰‹ä¹‹åï¼Œ å¾ªç¯çš„è°ƒç”¨äº†handleMsgæ–¹æ³•æ¥å¤„ç†äº‹ä»¶å¾ªç¯ã€‚ è¿™ä¸ªæ–¹æ³•å¾ˆé•¿ï¼Œä¸»è¦æ˜¯å¤„ç†æ¥æ”¶åˆ°å„ç§æ¶ˆæ¯ä¹‹åçš„åº”å¯¹æªæ–½ã€‚</p><pre><code>// handleMsg is invoked whenever an inbound message is received from a remote// peer. The remote connection is turn down upon returning any error.func (pm *ProtocolManager) handleMsg(p *peer) error {    // Read the next message from the remote peer, and ensure it's fully consumed    msg, err := p.rw.ReadMsg()    if err != nil {        return err    }    if msg.Size &gt; ProtocolMaxMsgSize {        return errResp(ErrMsgTooLarge, "%v &gt; %v", msg.Size, ProtocolMaxMsgSize)    }    defer msg.Discard()    // Handle the message depending on its contents    switch {    case msg.Code == StatusMsg:        // Status messages should never arrive after the handshake        // StatusMsgåº”è¯¥åœ¨HandleShakeé˜¶æ®µæ¥æ”¶åˆ°ã€‚ ç»è¿‡äº†HandleShakeä¹‹åæ˜¯ä¸åº”è¯¥æ¥æ”¶åˆ°è¿™ç§æ¶ˆæ¯çš„ã€‚        return errResp(ErrExtraStatusMsg, "uncontrolled status message")    // Block header query, collect the requested headers and reply    // æ¥æ”¶åˆ°è¯·æ±‚åŒºå—å¤´çš„æ¶ˆæ¯ï¼Œ ä¼šæ ¹æ®è¯·æ±‚è¿”å›åŒºå—å¤´ä¿¡æ¯ã€‚    case msg.Code == GetBlockHeadersMsg:        // Decode the complex header query        var query getBlockHeadersData        if err := msg.Decode(&amp;query); err != nil {            return errResp(ErrDecode, "%v: %v", msg, err)        }        hashMode := query.Origin.Hash != (common.Hash{})        // Gather headers until the fetch or network limits is reached        var (            bytes   common.StorageSize            headers []*types.Header            unknown bool        )        for !unknown &amp;&amp; len(headers) &lt; int(query.Amount) &amp;&amp; bytes &lt; softResponseLimit &amp;&amp; len(headers) &lt; downloader.MaxHeaderFetch {            // Retrieve the next header satisfying the query            var origin *types.Header            if hashMode {                origin = pm.blockchain.GetHeaderByHash(query.Origin.Hash)            } else {                origin = pm.blockchain.GetHeaderByNumber(query.Origin.Number)            }            if origin == nil {                break            }            number := origin.Number.Uint64()            headers = append(headers, origin)            bytes += estHeaderRlpSize            // Advance to the next header of the query            switch {            case query.Origin.Hash != (common.Hash{}) &amp;&amp; query.Reverse:                // Hash based traversal towards the genesis block                // ä»HashæŒ‡å®šçš„å¼€å§‹æœåˆ›ä¸–åŒºå—ç§»åŠ¨ã€‚ ä¹Ÿå°±æ˜¯åå‘ç§»åŠ¨ã€‚  é€šè¿‡hashæŸ¥æ‰¾                for i := 0; i &lt; int(query.Skip)+1; i++ {                    if header := pm.blockchain.GetHeader(query.Origin.Hash, number); header != nil {// é€šè¿‡hashå’Œnumberè·å–å‰ä¸€ä¸ªåŒºå—å¤´                                            query.Origin.Hash = header.ParentHash                        number--                    } else {                        unknown = true                        break //breakæ˜¯è·³å‡ºswitchã€‚ unknowç”¨æ¥è·³å‡ºå¾ªç¯ã€‚                    }                }            case query.Origin.Hash != (common.Hash{}) &amp;&amp; !query.Reverse:                // Hash based traversal towards the leaf block                // é€šè¿‡hashæ¥æŸ¥æ‰¾                var (                    current = origin.Number.Uint64()                    next    = current + query.Skip + 1                )                if next &lt;= current { //æ­£å‘ï¼Œ ä½†æ˜¯nextæ¯”å½“å‰è¿˜å°ï¼Œé˜²å¤‡æ•´æ•°æº¢å‡ºæ”»å‡»ã€‚                    infos, _ := json.MarshalIndent(p.Peer.Info(), "", "  ")                    p.Log().Warn("GetBlockHeaders skip overflow attack", "current", current, "skip", query.Skip, "next", next, "attacker", infos)                    unknown = true                } else {                    if header := pm.blockchain.GetHeaderByNumber(next); header != nil {                        if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash {                            // å¦‚æœå¯ä»¥æ‰¾åˆ°è¿™ä¸ªheaderï¼Œè€Œä¸”è¿™ä¸ªheaderå’Œoriginåœ¨åŒä¸€ä¸ªé“¾ä¸Šã€‚                            query.Origin.Hash = header.Hash()                        } else {                            unknown = true                        }                    } else {                        unknown = true                    }                }            case query.Reverse:        // é€šè¿‡numberæŸ¥æ‰¾                // Number based traversal towards the genesis block                //  query.Origin.Hash == (common.Hash{})                 if query.Origin.Number &gt;= query.Skip+1 {                    query.Origin.Number -= (query.Skip + 1)                } else {                    unknown = true                }            case !query.Reverse:     //é€šè¿‡numberæŸ¥æ‰¾                // Number based traversal towards the leaf block                query.Origin.Number += (query.Skip + 1)            }        }        return p.SendBlockHeaders(headers)    case msg.Code == BlockHeadersMsg: //æ¥æ”¶åˆ°äº†GetBlockHeadersMsgçš„å›ç­”ã€‚        // A batch of headers arrived to one of our previous requests        var headers []*types.Header        if err := msg.Decode(&amp;headers); err != nil {            return errResp(ErrDecode, "msg %v: %v", msg, err)        }        // If no headers were received, but we're expending a DAO fork check, maybe it's that        // å¦‚æœå¯¹ç«¯æ²¡æœ‰è¿”å›ä»»ä½•çš„headers,è€Œä¸”forkDropä¸ä¸ºç©ºï¼Œé‚£ä¹ˆåº”è¯¥æ˜¯æˆ‘ä»¬çš„DAOæ£€æŸ¥çš„è¯·æ±‚ï¼Œæˆ‘ä»¬ä¹‹å‰åœ¨HandShakeå‘é€äº†DAO headerçš„è¯·æ±‚ã€‚        if len(headers) == 0 &amp;&amp; p.forkDrop != nil {            // Possibly an empty reply to the fork header checks, sanity check TDs            verifyDAO := true            // If we already have a DAO header, we can check the peer's TD against it. If            // the peer's ahead of this, it too must have a reply to the DAO check            if daoHeader := pm.blockchain.GetHeaderByNumber(pm.chainconfig.DAOForkBlock.Uint64()); daoHeader != nil {                if _, td := p.Head(); td.Cmp(pm.blockchain.GetTd(daoHeader.Hash(), daoHeader.Number.Uint64())) &gt;= 0 {                    //è¿™ä¸ªæ—¶å€™æ£€æŸ¥å¯¹ç«¯çš„total difficult æ˜¯å¦å·²ç»è¶…è¿‡äº†DAOåˆ†å‰åŒºå—çš„tdå€¼ï¼Œ å¦‚æœè¶…è¿‡äº†ï¼Œè¯´æ˜å¯¹ç«¯åº”è¯¥å­˜åœ¨è¿™ä¸ªåŒºå—å¤´ï¼Œ ä½†æ˜¯è¿”å›çš„ç©ºç™½çš„ï¼Œé‚£ä¹ˆè¿™é‡ŒéªŒè¯å¤±è´¥ã€‚ è¿™é‡Œä»€ä¹ˆéƒ½æ²¡æœ‰åšã€‚ å¦‚æœå¯¹ç«¯è¿˜ä¸å‘é€ï¼Œé‚£ä¹ˆä¼šè¢«è¶…æ—¶é€€å‡ºã€‚                    verifyDAO = false                }            }            // If we're seemingly on the same chain, disable the drop timer            if verifyDAO { // å¦‚æœéªŒè¯æˆåŠŸï¼Œé‚£ä¹ˆåˆ é™¤æ‰è®¡æ—¶å™¨ï¼Œç„¶åè¿”å›ã€‚                p.Log().Debug("Seems to be on the same side of the DAO fork")                p.forkDrop.Stop()                p.forkDrop = nil                return nil            }        }        // Filter out any explicitly requested headers, deliver the rest to the downloader        // è¿‡æ»¤å‡ºä»»ä½•éå¸¸æ˜ç¡®çš„è¯·æ±‚ï¼Œ ç„¶åæŠŠå‰©ä¸‹çš„æŠ•é€’ç»™downloader        // å¦‚æœé•¿åº¦æ˜¯1 é‚£ä¹ˆfilterä¸ºtrue        filter := len(headers) == 1        if filter {            // If it's a potential DAO fork check, validate against the rules            if p.forkDrop != nil &amp;&amp; pm.chainconfig.DAOForkBlock.Cmp(headers[0].Number) == 0 {  //DAOæ£€æŸ¥                // Disable the fork drop timer                p.forkDrop.Stop()                p.forkDrop = nil                // Validate the header and either drop the peer or continue                if err := misc.VerifyDAOHeaderExtraData(pm.chainconfig, headers[0]); err != nil {                    p.Log().Debug("Verified to be on the other side of the DAO fork, dropping")                    return err                }                p.Log().Debug("Verified to be on the same side of the DAO fork")                return nil            }            // Irrelevant of the fork checks, send the header to the fetcher just in case            // å¦‚æœä¸æ˜¯DAOçš„è¯·æ±‚ï¼Œäº¤ç»™è¿‡æ»¤å™¨è¿›è¡Œè¿‡æ»¤ã€‚è¿‡æ»¤å™¨ä¼šè¿”å›éœ€è¦ç»§ç»­å¤„ç†çš„headersï¼Œè¿™äº›headersä¼šè¢«äº¤ç»™downloaderè¿›è¡Œåˆ†å‘ã€‚            headers = pm.fetcher.FilterHeaders(p.id, headers, time.Now())        }        if len(headers) &gt; 0 || !filter {            err := pm.downloader.DeliverHeaders(p.id, headers)            if err != nil {                log.Debug("Failed to deliver headers", "err", err)            }        }    case msg.Code == GetBlockBodiesMsg:        //  Block Bodyçš„è¯·æ±‚ è¿™ä¸ªæ¯”è¾ƒç®€å•ã€‚ ä»blockchainé‡Œé¢è·å–bodyè¿”å›å°±è¡Œã€‚        // Decode the retrieval message        msgStream := rlp.NewStream(msg.Payload, uint64(msg.Size))        if _, err := msgStream.List(); err != nil {            return err        }        // Gather blocks until the fetch or network limits is reached        var (            hash   common.Hash            bytes  int            bodies []rlp.RawValue        )        for bytes &lt; softResponseLimit &amp;&amp; len(bodies) &lt; downloader.MaxBlockFetch {            // Retrieve the hash of the next block            if err := msgStream.Decode(&amp;hash); err == rlp.EOL {                break            } else if err != nil {                return errResp(ErrDecode, "msg %v: %v", msg, err)            }            // Retrieve the requested block body, stopping if enough was found            if data := pm.blockchain.GetBodyRLP(hash); len(data) != 0 {                bodies = append(bodies, data)                bytes += len(data)            }        }        return p.SendBlockBodiesRLP(bodies)    case msg.Code == BlockBodiesMsg:        // A batch of block bodies arrived to one of our previous requests        var request blockBodiesData        if err := msg.Decode(&amp;request); err != nil {            return errResp(ErrDecode, "msg %v: %v", msg, err)        }        // Deliver them all to the downloader for queuing        trasactions := make([][]*types.Transaction, len(request))        uncles := make([][]*types.Header, len(request))        for i, body := range request {            trasactions[i] = body.Transactions            uncles[i] = body.Uncles        }        // Filter out any explicitly requested bodies, deliver the rest to the downloader        // è¿‡æ»¤æ‰ä»»ä½•æ˜¾ç¤ºçš„è¯·æ±‚ï¼Œ å‰©ä¸‹çš„äº¤ç»™downloader        filter := len(trasactions) &gt; 0 || len(uncles) &gt; 0        if filter {            trasactions, uncles = pm.fetcher.FilterBodies(p.id, trasactions, uncles, time.Now())        }        if len(trasactions) &gt; 0 || len(uncles) &gt; 0 || !filter {            err := pm.downloader.DeliverBodies(p.id, trasactions, uncles)            if err != nil {                log.Debug("Failed to deliver bodies", "err", err)            }        }    case p.version &gt;= eth63 &amp;&amp; msg.Code == GetNodeDataMsg:        // å¯¹ç«¯çš„ç‰ˆæœ¬æ˜¯eth63 è€Œä¸”æ˜¯è¯·æ±‚NodeData        // Decode the retrieval message        msgStream := rlp.NewStream(msg.Payload, uint64(msg.Size))        if _, err := msgStream.List(); err != nil {            return err        }        // Gather state data until the fetch or network limits is reached        var (            hash  common.Hash            bytes int            data  [][]byte        )        for bytes &lt; softResponseLimit &amp;&amp; len(data) &lt; downloader.MaxStateFetch {            // Retrieve the hash of the next state entry            if err := msgStream.Decode(&amp;hash); err == rlp.EOL {                break            } else if err != nil {                return errResp(ErrDecode, "msg %v: %v", msg, err)            }            // Retrieve the requested state entry, stopping if enough was found            // è¯·æ±‚çš„ä»»ä½•hashå€¼éƒ½ä¼šè¿”å›ç»™å¯¹æ–¹ã€‚             if entry, err := pm.chaindb.Get(hash.Bytes()); err == nil {                data = append(data, entry)                bytes += len(entry)            }        }        return p.SendNodeData(data)    case p.version &gt;= eth63 &amp;&amp; msg.Code == NodeDataMsg:        // A batch of node state data arrived to one of our previous requests        var data [][]byte        if err := msg.Decode(&amp;data); err != nil {            return errResp(ErrDecode, "msg %v: %v", msg, err)        }        // Deliver all to the downloader        // æ•°æ®äº¤ç»™downloader        if err := pm.downloader.DeliverNodeData(p.id, data); err != nil {            log.Debug("Failed to deliver node state data", "err", err)        }    case p.version &gt;= eth63 &amp;&amp; msg.Code == GetReceiptsMsg:        // è¯·æ±‚æ”¶æ®        // Decode the retrieval message        msgStream := rlp.NewStream(msg.Payload, uint64(msg.Size))        if _, err := msgStream.List(); err != nil {            return err        }        // Gather state data until the fetch or network limits is reached        var (            hash     common.Hash            bytes    int            receipts []rlp.RawValue        )        for bytes &lt; softResponseLimit &amp;&amp; len(receipts) &lt; downloader.MaxReceiptFetch {            // Retrieve the hash of the next block            if err := msgStream.Decode(&amp;hash); err == rlp.EOL {                break            } else if err != nil {                return errResp(ErrDecode, "msg %v: %v", msg, err)            }            // Retrieve the requested block's receipts, skipping if unknown to us            results := core.GetBlockReceipts(pm.chaindb, hash, core.GetBlockNumber(pm.chaindb, hash))            if results == nil {                if header := pm.blockchain.GetHeaderByHash(hash); header == nil || header.ReceiptHash != types.EmptyRootHash {                    continue                }            }            // If known, encode and queue for response packet            if encoded, err := rlp.EncodeToBytes(results); err != nil {                log.Error("Failed to encode receipt", "err", err)            } else {                receipts = append(receipts, encoded)                bytes += len(encoded)            }        }        return p.SendReceiptsRLP(receipts)    case p.version &gt;= eth63 &amp;&amp; msg.Code == ReceiptsMsg:        // A batch of receipts arrived to one of our previous requests        var receipts [][]*types.Receipt        if err := msg.Decode(&amp;receipts); err != nil {            return errResp(ErrDecode, "msg %v: %v", msg, err)        }        // Deliver all to the downloader        if err := pm.downloader.DeliverReceipts(p.id, receipts); err != nil {            log.Debug("Failed to deliver receipts", "err", err)        }    case msg.Code == NewBlockHashesMsg:        // æ¥æ”¶åˆ°BlockHashesMsgæ¶ˆæ¯        var announces newBlockHashesData        if err := msg.Decode(&amp;announces); err != nil {            return errResp(ErrDecode, "%v: %v", msg, err)        }        // Mark the hashes as present at the remote node        for _, block := range announces {            p.MarkBlock(block.Hash)        }        // Schedule all the unknown hashes for retrieval        unknown := make(newBlockHashesData, 0, len(announces))        for _, block := range announces {            if !pm.blockchain.HasBlock(block.Hash, block.Number) {                unknown = append(unknown, block)            }        }        for _, block := range unknown {            // é€šçŸ¥fetcheræœ‰ä¸€ä¸ªæ½œåœ¨çš„blockéœ€è¦ä¸‹è½½            pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies)        }    case msg.Code == NewBlockMsg:        // Retrieve and decode the propagated block        var request newBlockData        if err := msg.Decode(&amp;request); err != nil {            return errResp(ErrDecode, "%v: %v", msg, err)        }        request.Block.ReceivedAt = msg.ReceivedAt        request.Block.ReceivedFrom = p        // Mark the peer as owning the block and schedule it for import        p.MarkBlock(request.Block.Hash())        pm.fetcher.Enqueue(p.id, request.Block)        // Assuming the block is importable by the peer, but possibly not yet done so,        // calculate the head hash and TD that the peer truly must have.        var (            trueHead = request.Block.ParentHash()            trueTD   = new(big.Int).Sub(request.TD, request.Block.Difficulty())        )        // Update the peers total difficulty if better than the previous        if _, td := p.Head(); trueTD.Cmp(td) &gt; 0 {            // å¦‚æœpeerçš„çœŸå®çš„TDå’Œheadå’Œæˆ‘ä»¬è¿™è¾¹è®°è½½çš„ä¸åŒï¼Œ è®¾ç½®peerçœŸå®çš„headå’Œtdï¼Œ            p.SetHead(trueHead, trueTD)            // Schedule a sync if above ours. Note, this will not fire a sync for a gap of            // a singe block (as the true TD is below the propagated block), however this            // scenario should easily be covered by the fetcher.            // å¦‚æœçœŸå®çš„TDæ¯”æˆ‘ä»¬çš„TDå¤§ï¼Œé‚£ä¹ˆè¯·æ±‚å’Œè¿™ä¸ªpeeråŒæ­¥ã€‚            currentBlock := pm.blockchain.CurrentBlock()            if trueTD.Cmp(pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())) &gt; 0 {                go pm.synchronise(p)            }        }    case msg.Code == TxMsg:        // Transactions arrived, make sure we have a valid and fresh chain to handle them        // äº¤æ˜“ä¿¡æ¯è¿”å›ã€‚ åœ¨æˆ‘ä»¬æ²¡ç”¨åŒæ­¥å®Œæˆä¹‹å‰ä¸ä¼šæ¥æ”¶äº¤æ˜“ä¿¡æ¯ã€‚        if atomic.LoadUint32(&amp;pm.acceptTxs) == 0 {            break        }        // Transactions can be processed, parse all of them and deliver to the pool        var txs []*types.Transaction        if err := msg.Decode(&amp;txs); err != nil {            return errResp(ErrDecode, "msg %v: %v", msg, err)        }        for i, tx := range txs {            // Validate and mark the remote transaction            if tx == nil {                return errResp(ErrDecode, "transaction %d is nil", i)            }            p.MarkTransaction(tx.Hash())        }        // æ·»åŠ åˆ°txpool        pm.txpool.AddRemotes(txs)    default:        return errResp(ErrInvalidMsgCode, "%v", msg.Code)    }    return nil}</code></pre><p>å‡ ç§åŒæ­¥synchronise, ä¹‹å‰å‘ç°å¯¹æ–¹çš„èŠ‚ç‚¹æ¯”è‡ªå·±èŠ‚ç‚¹è¦æ›´æ–°çš„æ—¶å€™ä¼šè°ƒç”¨è¿™ä¸ªæ–¹æ³•synchroniseï¼Œ</p><pre><code>// synchronise tries to sync up our local block chain with a remote peer.// synchronise å°è¯• è®©æœ¬åœ°åŒºå—é“¾è·Ÿè¿œç«¯åŒæ­¥ã€‚func (pm *ProtocolManager) synchronise(peer *peer) {    // Short circuit if no peers are available    if peer == nil {        return    }    // Make sure the peer's TD is higher than our own    currentBlock := pm.blockchain.CurrentBlock()    td := pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())    pHead, pTd := peer.Head()    if pTd.Cmp(td) &lt;= 0 {        return    }    // Otherwise try to sync with the downloader    mode := downloader.FullSync    if atomic.LoadUint32(&amp;pm.fastSync) == 1 { //å¦‚æœæ˜¾å¼ç”³æ˜æ˜¯fast        // Fast sync was explicitly requested, and explicitly granted        mode = downloader.FastSync    } else if currentBlock.NumberU64() == 0 &amp;&amp; pm.blockchain.CurrentFastBlock().NumberU64() &gt; 0 {  //å¦‚æœæ•°æ®åº“æ˜¯ç©ºç™½çš„        // The database seems empty as the current block is the genesis. Yet the fast        // block is ahead, so fast sync was enabled for this node at a certain point.        // The only scenario where this can happen is if the user manually (or via a        // bad block) rolled back a fast sync node below the sync point. In this case        // however it's safe to reenable fast sync.        atomic.StoreUint32(&amp;pm.fastSync, 1)        mode = downloader.FastSync    }    // Run the sync cycle, and disable fast sync if we've went past the pivot block    err := pm.downloader.Synchronise(peer.id, pHead, pTd, mode)    if atomic.LoadUint32(&amp;pm.fastSync) == 1 {        // Disable fast sync if we indeed have something in our chain        if pm.blockchain.CurrentBlock().NumberU64() &gt; 0 {            log.Info("Fast sync complete, auto disabling")            atomic.StoreUint32(&amp;pm.fastSync, 0)        }    }    if err != nil {        return    }    atomic.StoreUint32(&amp;pm.acceptTxs, 1) // Mark initial sync done    // åŒæ­¥å®Œæˆ å¼€å§‹æ¥æ”¶äº¤æ˜“ã€‚    if head := pm.blockchain.CurrentBlock(); head.NumberU64() &gt; 0 {        // We've completed a sync cycle, notify all peers of new state. This path is        // essential in star-topology networks where a gateway node needs to notify        // all its out-of-date peers of the availability of a new block. This failure        // scenario will most often crop up in private and hackathon networks with        // degenerate connectivity, but it should be healthy for the mainnet too to        // more reliably update peers or the local TD state.        // æˆ‘ä»¬å‘Šè¯‰æ‰€æœ‰çš„peeræˆ‘ä»¬çš„çŠ¶æ€ã€‚        go pm.BroadcastBlock(head, false)    }}</code></pre><p>äº¤æ˜“å¹¿æ’­ã€‚txBroadcastLoop åœ¨startçš„æ—¶å€™å¯åŠ¨çš„goroutineã€‚  txChåœ¨txpoolæ¥æ”¶åˆ°ä¸€æ¡åˆæ³•çš„äº¤æ˜“çš„æ—¶å€™ä¼šå¾€è¿™ä¸ªä¸Šé¢å†™å…¥äº‹ä»¶ã€‚ ç„¶åæŠŠäº¤æ˜“å¹¿æ’­ç»™æ‰€æœ‰çš„peers</p><pre><code>func (self *ProtocolManager) txBroadcastLoop() {    for {        select {        case event := &lt;-self.txCh:            self.BroadcastTx(event.Tx.Hash(), event.Tx)        // Err() channel will be closed when unsubscribing.        case &lt;-self.txSub.Err():            return        }    }}</code></pre><p>æŒ–çŸ¿å¹¿æ’­ã€‚å½“æ”¶åˆ°è®¢é˜…çš„äº‹ä»¶çš„æ—¶å€™æŠŠæ–°æŒ–åˆ°çš„çŸ¿å¹¿æ’­å‡ºå»ã€‚</p><pre><code>// Mined broadcast loopfunc (self *ProtocolManager) minedBroadcastLoop() {    // automatically stops if unsubscribe    for obj := range self.minedBlockSub.Chan() {        switch ev := obj.Data.(type) {        case core.NewMinedBlockEvent:            self.BroadcastBlock(ev.Block, true)  // First propagate block to peers            self.BroadcastBlock(ev.Block, false) // Only then announce to the rest        }    }}</code></pre><p>syncerè´Ÿè´£å®šæœŸå’Œç½‘ç»œåŒæ­¥ï¼Œ</p><pre><code>// syncer is responsible for periodically synchronising with the network, both// downloading hashes and blocks as well as handling the announcement handler.//åŒæ­¥å™¨è´Ÿè´£å‘¨æœŸæ€§åœ°ä¸ç½‘ç»œåŒæ­¥ï¼Œä¸‹è½½æ•£åˆ—å’Œå—ä»¥åŠå¤„ç†é€šçŸ¥å¤„ç†ç¨‹åºã€‚func (pm *ProtocolManager) syncer() {    // Start and ensure cleanup of sync mechanisms    pm.fetcher.Start()    defer pm.fetcher.Stop()    defer pm.downloader.Terminate()    // Wait for different events to fire synchronisation operations    forceSync := time.NewTicker(forceSyncCycle)    defer forceSync.Stop()    for {        select {        case &lt;-pm.newPeerCh: //å½“æœ‰æ–°çš„Peerå¢åŠ çš„æ—¶å€™ ä¼šåŒæ­¥ã€‚ è¿™ä¸ªæ—¶å€™è¿˜å¯èƒ½è§¦å‘åŒºå—å¹¿æ’­ã€‚            // Make sure we have peers to select from, then sync            if pm.peers.Len() &lt; minDesiredPeerCount {                break            }            go pm.synchronise(pm.peers.BestPeer())        case &lt;-forceSync.C:            // å®šæ—¶è§¦å‘ 10ç§’ä¸€æ¬¡            // Force a sync even if not enough peers are present            // BestPeer() é€‰æ‹©æ€»éš¾åº¦æœ€å¤§çš„èŠ‚ç‚¹ã€‚            go pm.synchronise(pm.peers.BestPeer())        case &lt;-pm.noMorePeers: // é€€å‡ºä¿¡å·            return        }    }}</code></pre><p>txsyncLoopè´Ÿè´£æŠŠpendingçš„äº¤æ˜“å‘é€ç»™æ–°å»ºç«‹çš„è¿æ¥ã€‚</p><pre><code>// txsyncLoop takes care of the initial transaction sync for each new// connection. When a new peer appears, we relay all currently pending// transactions. In order to minimise egress bandwidth usage, we send// the transactions in small packs to one peer at a time.txsyncLoopè´Ÿè´£æ¯ä¸ªæ–°è¿æ¥çš„åˆå§‹äº‹åŠ¡åŒæ­¥ã€‚ å½“æ–°çš„å¯¹ç­‰ä½“å‡ºç°æ—¶ï¼Œæˆ‘ä»¬è½¬å‘æ‰€æœ‰å½“å‰å¾…å¤„ç†çš„äº‹åŠ¡ã€‚ ä¸ºäº†æœ€å°åŒ–å‡ºå£å¸¦å®½ä½¿ç”¨ï¼Œæˆ‘ä»¬ä¸€æ¬¡å°†ä¸€ä¸ªå°åŒ…ä¸­çš„äº‹åŠ¡å‘é€ç»™ä¸€ä¸ªå¯¹ç­‰ä½“ã€‚func (pm *ProtocolManager) txsyncLoop() {    var (        pending = make(map[discover.NodeID]*txsync)        sending = false               // whether a send is active        pack    = new(txsync)         // the pack that is being sent        done    = make(chan error, 1) // result of the send    )    // send starts a sending a pack of transactions from the sync.    send := func(s *txsync) {        // Fill pack with transactions up to the target size.        size := common.StorageSize(0)        pack.p = s.p        pack.txs = pack.txs[:0]        for i := 0; i &lt; len(s.txs) &amp;&amp; size &lt; txsyncPackSize; i++ {            pack.txs = append(pack.txs, s.txs[i])            size += s.txs[i].Size()        }        // Remove the transactions that will be sent.        s.txs = s.txs[:copy(s.txs, s.txs[len(pack.txs):])]        if len(s.txs) == 0 {            delete(pending, s.p.ID())        }        // Send the pack in the background.        s.p.Log().Trace("Sending batch of transactions", "count", len(pack.txs), "bytes", size)        sending = true        go func() { done &lt;- pack.p.SendTransactions(pack.txs) }()    }    // pick chooses the next pending sync.    // éšæœºæŒ‘é€‰ä¸€ä¸ªtxsyncæ¥å‘é€ã€‚    pick := func() *txsync {        if len(pending) == 0 {            return nil        }        n := rand.Intn(len(pending)) + 1        for _, s := range pending {            if n--; n == 0 {                return s            }        }        return nil    }    for {        select {        case s := &lt;-pm.txsyncCh: //ä»è¿™é‡Œæ¥æ”¶txsyncChæ¶ˆæ¯ã€‚            pending[s.p.ID()] = s            if !sending {                send(s)            }        case err := &lt;-done:            sending = false            // Stop tracking peers that cause send failures.            if err != nil {                pack.p.Log().Debug("Transaction send failed", "err", err)                delete(pending, pack.p.ID())            }            // Schedule the next send.            if s := pick(); s != nil {                send(s)            }        case &lt;-pm.quitSync:            return        }    }}</code></pre><p>txsyncChé˜Ÿåˆ—çš„ç”Ÿäº§è€…ï¼ŒsyncTransactionsæ˜¯åœ¨handleæ–¹æ³•é‡Œé¢è°ƒç”¨çš„ã€‚ åœ¨æ–°é“¾æ¥åˆšåˆšåˆ›å»ºçš„æ—¶å€™ä¼šè¢«è°ƒç”¨ä¸€æ¬¡ã€‚</p><pre><code>// syncTransactions starts sending all currently pending transactions to the given peer.func (pm *ProtocolManager) syncTransactions(p *peer) {    var txs types.Transactions    pending, _ := pm.txpool.Pending()    for _, batch := range pending {        txs = append(txs, batch...)    }    if len(txs) == 0 {        return    }    select {    case pm.txsyncCh &lt;- &amp;txsync{p, txs}:    case &lt;-pm.quitSync:    }}</code></pre><p>æ€»ç»“ä¸€ä¸‹ã€‚ æˆ‘ä»¬ç°åœ¨çš„ä¸€äº›å¤§çš„æµç¨‹ã€‚</p><p>åŒºå—åŒæ­¥</p><ol><li>å¦‚æœæ˜¯è‡ªå·±æŒ–çš„çŸ¿ã€‚é€šè¿‡goroutine minedBroadcastLoop()æ¥è¿›è¡Œå¹¿æ’­ã€‚</li><li>å¦‚æœæ˜¯æ¥æ”¶åˆ°å…¶ä»–äººçš„åŒºå—å¹¿æ’­ï¼Œ(NewBlockHashesMsg/NewBlockMsg),æ˜¯å¦fetcherä¼šé€šçŸ¥çš„peerï¼Ÿ TODO</li><li>goroutine syncer()ä¸­ä¼šå®šæ—¶çš„åŒBestPeer()æ¥åŒæ­¥ä¿¡æ¯ã€‚</li></ol><p>äº¤æ˜“åŒæ­¥</p><ol><li>æ–°å»ºç«‹è¿æ¥ã€‚ æŠŠpendingçš„äº¤æ˜“å‘é€ç»™ä»–ã€‚</li><li>æœ¬åœ°å‘é€äº†ä¸€ä¸ªäº¤æ˜“ï¼Œæˆ–è€…æ˜¯æ¥æ”¶åˆ°åˆ«äººå‘æ¥çš„äº¤æ˜“ä¿¡æ¯ã€‚ txpoolä¼šäº§ç”Ÿä¸€æ¡æ¶ˆæ¯ï¼Œæ¶ˆæ¯è¢«ä¼ é€’åˆ°txChé€šé“ã€‚ ç„¶åè¢«goroutine txBroadcastLoop()å¤„ç†ï¼Œ å‘é€ç»™å…¶ä»–ä¸çŸ¥é“è¿™ä¸ªäº¤æ˜“çš„peerã€‚</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-mineræŒ–çŸ¿éƒ¨åˆ†æºç åˆ†æCPUæŒ–çŸ¿</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-miner%E6%8C%96%E7%9F%BF%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90CPU%E6%8C%96%E7%9F%BF/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-miner%E6%8C%96%E7%9F%BF%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90CPU%E6%8C%96%E7%9F%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h2><p>agent æ˜¯å…·ä½“æ‰§è¡ŒæŒ–çŸ¿çš„å¯¹è±¡ã€‚ å®ƒæ‰§è¡Œçš„æµç¨‹å°±æ˜¯ï¼Œæ¥å—è®¡ç®—å¥½äº†çš„åŒºå—å¤´ï¼Œ è®¡ç®—mixhashå’Œnonceï¼Œ æŠŠæŒ–çŸ¿å¥½çš„åŒºå—å¤´è¿”å›ã€‚</p><p>æ„é€ CpuAgent, ä¸€èˆ¬æƒ…å†µä¸‹ä¸ä¼šä½¿ç”¨CPUæ¥è¿›è¡ŒæŒ–çŸ¿ï¼Œä¸€èˆ¬æ¥è¯´æŒ–çŸ¿éƒ½æ˜¯ä½¿ç”¨çš„ä¸“é—¨çš„GPUè¿›è¡ŒæŒ–çŸ¿ï¼Œ GPUæŒ–çŸ¿çš„ä»£ç ä¸ä¼šåœ¨è¿™é‡Œä½“ç°ã€‚</p><pre><code>type CpuAgent struct {    mu sync.Mutex    workCh        chan *Work       // æ¥å—æŒ–çŸ¿ä»»åŠ¡çš„é€šé“    stop          chan struct{}    quitCurrentOp chan struct{}    returnCh      chan&lt;- *Result   // æŒ–çŸ¿å®Œæˆåçš„è¿”å›channel    chain  consensus.ChainReader // è·å–åŒºå—é“¾çš„ä¿¡æ¯    engine consensus.Engine      // ä¸€è‡´æ€§å¼•æ“ï¼Œè¿™é‡ŒæŒ‡çš„æ˜¯Powå¼•æ“    isMining int32 // isMining indicates whether the agent is currently mining}func NewCpuAgent(chain consensus.ChainReader, engine consensus.Engine) *CpuAgent {    miner := &amp;CpuAgent{        chain:  chain,        engine: engine,        stop:   make(chan struct{}, 1),        workCh: make(chan *Work, 1),    }    return miner}</code></pre><p>è®¾ç½®è¿”å›å€¼channelå’Œå¾—åˆ°Workçš„channelï¼Œ æ–¹ä¾¿å¤–ç•Œä¼ å€¼å’Œå¾—åˆ°è¿”å›ä¿¡æ¯ã€‚</p><pre><code>func (self *CpuAgent) Work() chan&lt;- *Work            { return self.workCh }func (self *CpuAgent) SetReturnCh(ch chan&lt;- *Result) { self.returnCh = ch }</code></pre><p>å¯åŠ¨å’Œæ¶ˆæ¯å¾ªç¯ï¼Œå¦‚æœå·²ç»å¯åŠ¨æŒ–çŸ¿ï¼Œé‚£ä¹ˆç›´æ¥é€€å‡ºï¼Œ å¦åˆ™å¯åŠ¨update è¿™ä¸ªgoroutine<br>update ä»workChæ¥å—ä»»åŠ¡ï¼Œè¿›è¡ŒæŒ–çŸ¿ï¼Œæˆ–è€…æ˜¯æ¥å—é€€å‡ºä¿¡æ¯ï¼Œé€€å‡ºã€‚</p><pre><code>func (self *CpuAgent) Start() {    if !atomic.CompareAndSwapInt32(&amp;self.isMining, 0, 1) {        return // agent already started    }    go self.update()}func (self *CpuAgent) update() {out:    for {        select {        case work := &lt;-self.workCh:            self.mu.Lock()            if self.quitCurrentOp != nil {                close(self.quitCurrentOp)            }            self.quitCurrentOp = make(chan struct{})            go self.mine(work, self.quitCurrentOp)            self.mu.Unlock()        case &lt;-self.stop:            self.mu.Lock()            if self.quitCurrentOp != nil {                close(self.quitCurrentOp)                self.quitCurrentOp = nil            }            self.mu.Unlock()            break out        }    }}</code></pre><p>mine, æŒ–çŸ¿ï¼Œè°ƒç”¨ä¸€è‡´æ€§å¼•æ“è¿›è¡ŒæŒ–çŸ¿ï¼Œ å¦‚æœæŒ–çŸ¿æˆåŠŸï¼ŒæŠŠæ¶ˆæ¯å‘é€åˆ°returnChä¸Šé¢ã€‚</p><pre><code>func (self *CpuAgent) mine(work *Work, stop &lt;-chan struct{}) {    if result, err := self.engine.Seal(self.chain, work.Block, stop); result != nil {        log.Info("Successfully sealed new block", "number", result.Number(), "hash", result.Hash())        self.returnCh &lt;- &amp;Result{work, result}    } else {        if err != nil {            log.Warn("Block sealing failed", "err", err)        }        self.returnCh &lt;- nil    }}</code></pre><p>GetHashRateï¼Œ è¿™ä¸ªå‡½æ•°è¿”å›å½“å‰çš„HashRateã€‚</p><pre><code>func (self *CpuAgent) GetHashRate() int64 {    if pow, ok := self.engine.(consensus.PoW); ok {        return int64(pow.Hashrate())    }    return 0}</code></pre><h2 id="remote-agent"><a href="#remote-agent" class="headerlink" title="remote_agent"></a>remote_agent</h2><p>remote_agent æä¾›äº†ä¸€å¥—RPCæ¥å£ï¼Œå¯ä»¥å®ç°è¿œç¨‹çŸ¿å·¥è¿›è¡Œé‡‡çŸ¿çš„åŠŸèƒ½ã€‚ æ¯”å¦‚æˆ‘æœ‰ä¸€ä¸ªçŸ¿æœºï¼ŒçŸ¿æœºå†…éƒ¨æ²¡æœ‰è¿è¡Œä»¥å¤ªåŠèŠ‚ç‚¹ï¼ŒçŸ¿æœºé¦–å…ˆä»remote_agentè·å–å½“å‰çš„ä»»åŠ¡ï¼Œç„¶åè¿›è¡ŒæŒ–çŸ¿è®¡ç®—ï¼Œå½“æŒ–çŸ¿å®Œæˆåï¼Œæäº¤è®¡ç®—ç»“æœï¼Œå®ŒæˆæŒ–çŸ¿ã€‚ </p><p>æ•°æ®ç»“æ„å’Œæ„é€ </p><pre><code>type RemoteAgent struct {    mu sync.Mutex    quitCh   chan struct{}    workCh   chan *Work          // æ¥å—ä»»åŠ¡    returnCh chan&lt;- *Result        // ç»“æœè¿”å›    chain       consensus.ChainReader    engine      consensus.Engine    currentWork *Work    //å½“å‰çš„ä»»åŠ¡    work        map[common.Hash]*Work // å½“å‰è¿˜æ²¡æœ‰æäº¤çš„ä»»åŠ¡ï¼Œæ­£åœ¨è®¡ç®—    hashrateMu sync.RWMutex    hashrate   map[common.Hash]hashrate  // æ­£åœ¨è®¡ç®—çš„ä»»åŠ¡çš„hashrate    running int32 // running indicates whether the agent is active. Call atomically}func NewRemoteAgent(chain consensus.ChainReader, engine consensus.Engine) *RemoteAgent {    return &amp;RemoteAgent{        chain:    chain,        engine:   engine,        work:     make(map[common.Hash]*Work),        hashrate: make(map[common.Hash]hashrate),    }}</code></pre><p>å¯åŠ¨å’Œåœæ­¢</p><pre><code>func (a *RemoteAgent) Start() {    if !atomic.CompareAndSwapInt32(&amp;a.running, 0, 1) {        return    }    a.quitCh = make(chan struct{})    a.workCh = make(chan *Work, 1)    go a.loop(a.workCh, a.quitCh)}func (a *RemoteAgent) Stop() {    if !atomic.CompareAndSwapInt32(&amp;a.running, 1, 0) {        return    }    close(a.quitCh)    close(a.workCh)}</code></pre><p>å¾—åˆ°è¾“å…¥è¾“å‡ºçš„channelï¼Œè¿™ä¸ªå’Œagent.goä¸€æ ·ã€‚</p><pre><code>func (a *RemoteAgent) Work() chan&lt;- *Work {    return a.workCh}func (a *RemoteAgent) SetReturnCh(returnCh chan&lt;- *Result) {    a.returnCh = returnCh}</code></pre><p>loopæ–¹æ³•,å’Œagent.goé‡Œé¢åšçš„å·¥ä½œæ¯”è¾ƒç±»ä¼¼ï¼Œ å½“æ¥æ”¶åˆ°ä»»åŠ¡çš„æ—¶å€™ï¼Œå°±å­˜æ”¾åœ¨currentWorkå­—æ®µé‡Œé¢ã€‚ å¦‚æœ84ç§’è¿˜æ²¡æœ‰å®Œæˆä¸€ä¸ªå·¥ä½œï¼Œé‚£ä¹ˆå°±åˆ é™¤è¿™ä¸ªå·¥ä½œï¼Œ å¦‚æœ10ç§’æ²¡æœ‰æ”¶åˆ°hashrateçš„æŠ¥å‘Šï¼Œé‚£ä¹ˆåˆ é™¤è¿™ä¸ªè¿½è¸ª/ã€‚</p><pre><code>// loop monitors mining events on the work and quit channels, updating the internal// state of the rmeote miner until a termination is requested.//// Note, the reason the work and quit channels are passed as parameters is because// RemoteAgent.Start() constantly recreates these channels, so the loop code cannot// assume data stability in these member fields.func (a *RemoteAgent) loop(workCh chan *Work, quitCh chan struct{}) {    ticker := time.NewTicker(5 * time.Second)    defer ticker.Stop()    for {        select {        case &lt;-quitCh:            return        case work := &lt;-workCh:            a.mu.Lock()            a.currentWork = work            a.mu.Unlock()        case &lt;-ticker.C:            // cleanup            a.mu.Lock()            for hash, work := range a.work {                if time.Since(work.createdAt) &gt; 7*(12*time.Second) {                    delete(a.work, hash)                }            }            a.mu.Unlock()            a.hashrateMu.Lock()            for id, hashrate := range a.hashrate {                if time.Since(hashrate.ping) &gt; 10*time.Second {                    delete(a.hashrate, id)                }            }            a.hashrateMu.Unlock()        }    }}</code></pre><p>GetWorkï¼Œè¿™ä¸ªæ–¹æ³•ç”±è¿œç¨‹çŸ¿å·¥è°ƒç”¨ï¼Œè·å–å½“å‰çš„æŒ–çŸ¿ä»»åŠ¡ã€‚</p><pre><code>func (a *RemoteAgent) GetWork() ([3]string, error) {    a.mu.Lock()    defer a.mu.Unlock()    var res [3]string    if a.currentWork != nil {        block := a.currentWork.Block        res[0] = block.HashNoNonce().Hex()        seedHash := ethash.SeedHash(block.NumberU64())        res[1] = common.BytesToHash(seedHash).Hex()        // Calculate the "target" to be returned to the external miner        n := big.NewInt(1)        n.Lsh(n, 255)        n.Div(n, block.Difficulty())        n.Lsh(n, 1)        res[2] = common.BytesToHash(n.Bytes()).Hex()        a.work[block.HashNoNonce()] = a.currentWork        return res, nil    }    return res, errors.New("No work available yet, don't panic.")}</code></pre><p>SubmitWork, è¿œç¨‹çŸ¿å·¥ä¼šè°ƒç”¨è¿™ä¸ªæ–¹æ³•æäº¤æŒ–çŸ¿çš„ç»“æœã€‚ å¯¹ç»“æœè¿›è¡ŒéªŒè¯ä¹‹åæäº¤åˆ°returnCh</p><pre><code>// SubmitWork tries to inject a pow solution into the remote agent, returning// whether the solution was accepted or not (not can be both a bad pow as well as// any other error, like no work pending).func (a *RemoteAgent) SubmitWork(nonce types.BlockNonce, mixDigest, hash common.Hash) bool {    a.mu.Lock()    defer a.mu.Unlock()    // Make sure the work submitted is present    work := a.work[hash]    if work == nil {        log.Info("Work submitted but none pending", "hash", hash)        return false    }    // Make sure the Engine solutions is indeed valid    result := work.Block.Header()    result.Nonce = nonce    result.MixDigest = mixDigest    if err := a.engine.VerifySeal(a.chain, result); err != nil {        log.Warn("Invalid proof-of-work submitted", "hash", hash, "err", err)        return false    }    block := work.Block.WithSeal(result)    // Solutions seems to be valid, return to the miner and notify acceptance    a.returnCh &lt;- &amp;Result{work, block}    delete(a.work, hash)    return true}</code></pre><p>SubmitHashrate, æäº¤hashç®—åŠ›</p><pre><code>func (a *RemoteAgent) SubmitHashrate(id common.Hash, rate uint64) {    a.hashrateMu.Lock()    defer a.hashrateMu.Unlock()    a.hashrate[id] = hashrate{time.Now(), rate}}</code></pre><h2 id="unconfirmed"><a href="#unconfirmed" class="headerlink" title="unconfirmed"></a>unconfirmed</h2><p>unconfirmedæ˜¯ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œç”¨æ¥è·Ÿè¸ªç”¨æˆ·æœ¬åœ°çš„æŒ–çŸ¿ä¿¡æ¯çš„ï¼Œæ¯”å¦‚æŒ–å‡ºäº†ä¸€ä¸ªå—ï¼Œé‚£ä¹ˆç­‰å¾…è¶³å¤Ÿçš„åç»­åŒºå—ç¡®è®¤ä¹‹å(5ä¸ª)ï¼Œå†æŸ¥çœ‹æœ¬åœ°æŒ–çŸ¿çš„åŒºå—æ˜¯å¦åŒ…å«åœ¨è§„èŒƒçš„åŒºå—é“¾å†…éƒ¨ã€‚</p><p>æ•°æ®ç»“æ„</p><pre><code>// headerRetriever is used by the unconfirmed block set to verify whether a previously// mined block is part of the canonical chain or not.// headerRetrieverç”±æœªç¡®è®¤çš„å—ç»„ä½¿ç”¨ï¼Œä»¥éªŒè¯å…ˆå‰æŒ–æ˜çš„å—æ˜¯å¦æ˜¯è§„èŒƒé“¾çš„ä¸€éƒ¨åˆ†ã€‚type headerRetriever interface {    // GetHeaderByNumber retrieves the canonical header associated with a block number.    GetHeaderByNumber(number uint64) *types.Header}// unconfirmedBlock is a small collection of metadata about a locally mined block// that is placed into a unconfirmed set for canonical chain inclusion tracking.// unconfirmedBlock æ˜¯æœ¬åœ°æŒ–æ˜åŒºå—çš„ä¸€ä¸ªå°çš„å…ƒæ•°æ®çš„é›†åˆï¼Œç”¨æ¥æ”¾å…¥æœªç¡®è®¤çš„é›†åˆç”¨æ¥è¿½è¸ªæœ¬åœ°æŒ–æ˜çš„åŒºå—æ˜¯å¦è¢«åŒ…å«è¿›å…¥è§„èŒƒçš„åŒºå—é“¾type unconfirmedBlock struct {    index uint64    hash  common.Hash}// unconfirmedBlocks implements a data structure to maintain locally mined blocks// have have not yet reached enough maturity to guarantee chain inclusion. It is// used by the miner to provide logs to the user when a previously mined block// has a high enough guarantee to not be reorged out of te canonical chain.    // unconfirmedBlocks å®ç°äº†ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œç”¨æ¥ç®¡ç†æœ¬åœ°æŒ–æ˜çš„åŒºå—ï¼Œè¿™äº›åŒºå—è¿˜æ²¡æœ‰è¾¾åˆ°è¶³å¤Ÿçš„ä¿¡ä»»åº¦æ¥è¯æ˜ä»–ä»¬å·²ç»è¢«è§„èŒƒçš„åŒºå—é“¾æ¥å—ã€‚ å®ƒç”¨æ¥ç»™çŸ¿å·¥æä¾›ä¿¡æ¯ï¼Œä»¥ä¾¿ä»–ä»¬äº†è§£ä»–ä»¬ä¹‹å‰æŒ–åˆ°çš„åŒºå—æ˜¯å¦è¢«åŒ…å«è¿›å…¥äº†è§„èŒƒçš„åŒºå—é“¾ã€‚type unconfirmedBlocks struct {    chain  headerRetriever // Blockchain to verify canonical status through éœ€è¦éªŒè¯çš„åŒºå—é“¾ ç”¨è¿™ä¸ªæ¥å£æ¥è·å–å½“å‰çš„è§„èŒƒçš„åŒºå—å¤´ä¿¡æ¯    depth  uint            // Depth after which to discard previous blocks ç»è¿‡å¤šå°‘ä¸ªåŒºå—ä¹‹åä¸¢å¼ƒä¹‹å‰çš„åŒºå—    blocks *ring.Ring      // Block infos to allow canonical chain cross checks // åŒºå—ä¿¡æ¯ï¼Œä»¥å…è®¸è§„èŒƒé“¾äº¤å‰æ£€æŸ¥    lock   sync.RWMutex    // Protects the fields from concurrent access}// newUnconfirmedBlocks returns new data structure to track currently unconfirmed blocks.func newUnconfirmedBlocks(chain headerRetriever, depth uint) *unconfirmedBlocks {    return &amp;unconfirmedBlocks{        chain: chain,        depth: depth,    }}</code></pre><p>æ’å…¥è·Ÿè¸ªåŒºå—, å½“çŸ¿å·¥æŒ–åˆ°ä¸€ä¸ªåŒºå—çš„æ—¶å€™è°ƒç”¨ï¼Œ indexæ˜¯åŒºå—çš„é«˜åº¦ï¼Œ hashæ˜¯åŒºå—çš„hashå€¼ã€‚</p><pre><code>// Insert adds a new block to the set of unconfirmed ones.func (set *unconfirmedBlocks) Insert(index uint64, hash common.Hash) {    // If a new block was mined locally, shift out any old enough blocks    // å¦‚æœä¸€ä¸ªæœ¬åœ°çš„åŒºå—æŒ–åˆ°äº†ï¼Œé‚£ä¹ˆç§»å‡ºå·²ç»è¶…è¿‡depthçš„åŒºå—    set.Shift(index)    // Create the new item as its own ring    // å¾ªç¯é˜Ÿåˆ—çš„æ“ä½œã€‚    item := ring.New(1)    item.Value = &amp;unconfirmedBlock{        index: index,        hash:  hash,    }    // Set as the initial ring or append to the end    set.lock.Lock()    defer set.lock.Unlock()    if set.blocks == nil {        set.blocks = item    } else {        // ç§»åŠ¨åˆ°å¾ªç¯é˜Ÿåˆ—çš„æœ€åä¸€ä¸ªå…ƒç´ æ’å…¥item        set.blocks.Move(-1).Link(item)    }    // Display a log for the user to notify of a new mined block unconfirmed    log.Info("ğŸ”¨ mined potential block", "number", index, "hash", hash)}</code></pre><p>Shiftæ–¹æ³•ä¼šåˆ é™¤é‚£äº›indexè¶…è¿‡ä¼ å…¥çš„index-depthçš„åŒºå—ï¼Œå¹¶æ£€æŸ¥ä»–ä»¬æ˜¯å¦åœ¨è§„èŒƒçš„åŒºå—é“¾ä¸­ã€‚</p><pre><code>// Shift drops all unconfirmed blocks from the set which exceed the unconfirmed sets depth// allowance, checking them against the canonical chain for inclusion or staleness// report.func (set *unconfirmedBlocks) Shift(height uint64) {    set.lock.Lock()    defer set.lock.Unlock()    for set.blocks != nil {        // Retrieve the next unconfirmed block and abort if too fresh        // å› ä¸ºblocksä¸­çš„åŒºå—éƒ½æ˜¯æŒ‰é¡ºåºæ’åˆ—çš„ã€‚æ’åœ¨æœ€å¼€å§‹çš„è‚¯å®šæ˜¯æœ€è€çš„åŒºå—ã€‚        // æ‰€ä»¥æ¯æ¬¡åªéœ€è¦æ£€æŸ¥æœ€å¼€å§‹çš„é‚£ä¸ªåŒºå—ï¼Œå¦‚æœå¤„ç†å®Œäº†ï¼Œå°±ä»å¾ªç¯é˜Ÿåˆ—é‡Œé¢æ‘˜é™¤ã€‚        next := set.blocks.Value.(*unconfirmedBlock)        if next.index+uint64(set.depth) &gt; height { // å¦‚æœè¶³å¤Ÿè€äº†ã€‚            break        }        // Block seems to exceed depth allowance, check for canonical status        // æŸ¥è¯¢ é‚£ä¸ªåŒºå—é«˜åº¦çš„åŒºå—å¤´        header := set.chain.GetHeaderByNumber(next.index)        switch {        case header == nil:            log.Warn("Failed to retrieve header of mined block", "number", next.index, "hash", next.hash)        case header.Hash() == next.hash: // å¦‚æœåŒºå—å¤´å°±ç­‰äºæˆ‘ä»¬è‡ªå·±ï¼Œ            log.Info("ğŸ”— block reached canonical chain", "number", next.index, "hash", next.hash)        default: // å¦åˆ™è¯´æ˜æˆ‘ä»¬åœ¨ä¾§é“¾ä¸Šé¢ã€‚            log.Info("â‘‚ block  became a side fork", "number", next.index, "hash", next.hash)        }        // Drop the block out of the ring        // ä»å¾ªç¯é˜Ÿåˆ—åˆ é™¤        if set.blocks.Value == set.blocks.Next().Value {            // å¦‚æœå½“å‰çš„å€¼å°±ç­‰äºæˆ‘ä»¬è‡ªå·±ï¼Œè¯´æ˜åªæœ‰å¾ªç¯é˜Ÿåˆ—åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆè®¾ç½®æœªnil            set.blocks = nil        } else {            // å¦åˆ™ç§»åŠ¨åˆ°æœ€åï¼Œç„¶ååˆ é™¤ä¸€ä¸ªï¼Œå†ç§»åŠ¨åˆ°æœ€å‰ã€‚            set.blocks = set.blocks.Move(-1)            set.blocks.Unlink(1)            set.blocks = set.blocks.Move(1)        }    }}</code></pre><h2 id="worker-go"><a href="#worker-go" class="headerlink" title="worker.go"></a>worker.go</h2><p>worker å†…éƒ¨åŒ…å«äº†å¾ˆå¤šagentï¼Œå¯ä»¥åŒ…å«ä¹‹å‰æåˆ°çš„agentå’Œremote_agentã€‚ workeråŒæ—¶è´Ÿè´£æ„å»ºåŒºå—å’Œå¯¹è±¡ã€‚åŒæ—¶æŠŠä»»åŠ¡æä¾›ç»™agentã€‚</p><p>æ•°æ®ç»“æ„ï¼š</p><p>Agentæ¥å£</p><pre><code>// Agent can register themself with the workertype Agent interface {    Work() chan&lt;- *Work    SetReturnCh(chan&lt;- *Result)    Stop()    Start()    GetHashRate() int64}</code></pre><p>Workç»“æ„ï¼ŒWorkå­˜å‚¨äº†å·¥ä½œè€…çš„å½“æ—¶çš„ç¯å¢ƒï¼Œå¹¶ä¸”æŒæœ‰æ‰€æœ‰çš„æš‚æ—¶çš„çŠ¶æ€ä¿¡æ¯ã€‚</p><pre><code>// Work is the workers current environment and holds// all of the current state informationtype Work struct {    config *params.ChainConfig    signer types.Signer            // ç­¾åè€…    state     *state.StateDB // apply state changes here çŠ¶æ€æ•°æ®åº“    ancestors *set.Set       // ancestor set (used for checking uncle parent validity)  ç¥–å…ˆé›†åˆï¼Œç”¨æ¥æ£€æŸ¥ç¥–å…ˆæ˜¯å¦æœ‰æ•ˆ    family    *set.Set       // family set (used for checking uncle invalidity) å®¶æ—é›†åˆï¼Œç”¨æ¥æ£€æŸ¥ç¥–å…ˆçš„æ— æ•ˆæ€§    uncles    *set.Set       // uncle set  unclesé›†åˆ    tcount    int            // tx count in cycle è¿™ä¸ªå‘¨æœŸçš„äº¤æ˜“æ•°é‡    Block *types.Block // the new block  //æ–°çš„åŒºå—    header   *types.Header            // åŒºå—å¤´    txs      []*types.Transaction   // äº¤æ˜“    receipts []*types.Receipt          // æ”¶æ®    createdAt time.Time             // åˆ›å»ºæ—¶é—´}type Result struct {  //ç»“æœ    Work  *Work    Block *types.Block}</code></pre><p>worker</p><pre><code>// worker is the main object which takes care of applying messages to the new state// å·¥ä½œè€…æ˜¯è´Ÿè´£å°†æ¶ˆæ¯åº”ç”¨åˆ°æ–°çŠ¶æ€çš„ä¸»è¦å¯¹è±¡type worker struct {    config *params.ChainConfig    engine consensus.Engine    mu sync.Mutex    // update loop    mux          *event.TypeMux    txCh         chan core.TxPreEvent        // ç”¨æ¥æ¥å—txPoolé‡Œé¢çš„äº¤æ˜“çš„é€šé“    txSub        event.Subscription            // ç”¨æ¥æ¥å—txPoolé‡Œé¢çš„äº¤æ˜“çš„è®¢é˜…å™¨    chainHeadCh  chan core.ChainHeadEvent    // ç”¨æ¥æ¥å—åŒºå—å¤´çš„é€šé“    chainHeadSub event.Subscription    chainSideCh  chan core.ChainSideEvent    // ç”¨æ¥æ¥å—ä¸€ä¸ªåŒºå—é“¾ä»è§„èŒƒåŒºå—é“¾ç§»å‡ºçš„é€šé“    chainSideSub event.Subscription    wg           sync.WaitGroup    agents map[Agent]struct{}                // æ‰€æœ‰çš„agent    recv   chan *Result                        // agentä¼šæŠŠç»“æœå‘é€åˆ°è¿™ä¸ªé€šé“    eth     Backend                            // ethçš„åè®®    chain   *core.BlockChain                // åŒºå—é“¾    proc    core.Validator                    // åŒºå—é“¾éªŒè¯å™¨    chainDb ethdb.Database                    // åŒºå—é“¾æ•°æ®åº“    coinbase common.Address                    // æŒ–çŸ¿è€…çš„åœ°å€    extra    []byte                            //         snapshotMu    sync.RWMutex                // å¿«ç…§ RWMutexï¼ˆå¿«ç…§è¯»å†™é”ï¼‰    snapshotBlock *types.Block                // å¿«ç…§ Block    snapshotState *state.StateDB                // å¿«ç…§ StateDB        currentMu sync.Mutex    current   *Work    uncleMu        sync.Mutex    possibleUncles map[common.Hash]*types.Block    //å¯èƒ½çš„å”çˆ¶èŠ‚ç‚¹    unconfirmed *unconfirmedBlocks // set of locally mined blocks pending canonicalness confirmations    // atomic status counters    mining int32    atWork int32}</code></pre><p>æ„é€ </p><pre><code>func newWorker(config *params.ChainConfig, engine consensus.Engine, coinbase common.Address, eth Backend, mux *event.TypeMux) *worker {    worker := &amp;worker{        config:         config,        engine:         engine,        eth:            eth,        mux:            mux,        txCh:           make(chan core.TxPreEvent, txChanSize), // 4096        chainHeadCh:    make(chan core.ChainHeadEvent, chainHeadChanSize), // 10        chainSideCh:    make(chan core.ChainSideEvent, chainSideChanSize), // 10        chainDb:        eth.ChainDb(),        recv:           make(chan *Result, resultQueueSize), // 10        chain:          eth.BlockChain(),        proc:           eth.BlockChain().Validator(),        possibleUncles: make(map[common.Hash]*types.Block),        coinbase:       coinbase,        agents:         make(map[Agent]struct{}),        unconfirmed:    newUnconfirmedBlocks(eth.BlockChain(), miningLogAtDepth),    }    // Subscribe TxPreEvent for tx pool    worker.txSub = eth.TxPool().SubscribeTxPreEvent(worker.txCh)    // Subscribe events for blockchain    worker.chainHeadSub = eth.BlockChain().SubscribeChainHeadEvent(worker.chainHeadCh)    worker.chainSideSub = eth.BlockChain().SubscribeChainSideEvent(worker.chainSideCh)    go worker.update()    go worker.wait()    worker.commitNewWork()    return worker}</code></pre><p>update</p><pre><code>func (self *worker) update() {    defer self.txSub.Unsubscribe()    defer self.chainHeadSub.Unsubscribe()    defer self.chainSideSub.Unsubscribe()    for {        // A real event arrived, process interesting content        select {        // Handle ChainHeadEvent å½“æ¥æ”¶åˆ°ä¸€ä¸ªåŒºå—å¤´çš„ä¿¡æ¯çš„æ—¶å€™ï¼Œé©¬ä¸Šå¼€å¯æŒ–çŸ¿æœåŠ¡ã€‚        case &lt;-self.chainHeadCh:            self.commitNewWork()        // Handle ChainSideEvent æ¥æ”¶ä¸åœ¨è§„èŒƒçš„åŒºå—é“¾çš„åŒºå—ï¼ŒåŠ å…¥åˆ°æ½œåœ¨çš„å”çˆ¶é›†åˆ        case ev := &lt;-self.chainSideCh:            self.uncleMu.Lock()            self.possibleUncles[ev.Block.Hash()] = ev.Block            self.uncleMu.Unlock()        // Handle TxPreEvent æ¥æ”¶åˆ°txPoolé‡Œé¢çš„äº¤æ˜“ä¿¡æ¯çš„æ—¶å€™ã€‚        case ev := &lt;-self.txCh:            // Apply transaction to the pending state if we're not mining            // å¦‚æœå½“å‰æ²¡æœ‰æŒ–çŸ¿ï¼Œ é‚£ä¹ˆæŠŠäº¤æ˜“åº”ç”¨åˆ°å½“å‰çš„çŠ¶æ€ä¸Šï¼Œä»¥ä¾¿é©¬ä¸Šå¼€å¯æŒ–çŸ¿ä»»åŠ¡ã€‚            if atomic.LoadInt32(&amp;self.mining) == 0 {                self.currentMu.Lock()                acc, _ := types.Sender(self.current.signer, ev.Tx)                txs := map[common.Address]types.Transactions{acc: {ev.Tx}}                txset := types.NewTransactionsByPriceAndNonce(self.current.signer, txs)                self.current.commitTransactions(self.mux, txset, self.chain, self.coinbase)                self.currentMu.Unlock()            }        // System stopped        case &lt;-self.txSub.Err():            return        case &lt;-self.chainHeadSub.Err():            return        case &lt;-self.chainSideSub.Err():            return        }    }}</code></pre><p>commitNewWork æäº¤æ–°çš„ä»»åŠ¡</p><pre><code>func (self *worker) commitNewWork() {    self.mu.Lock()    defer self.mu.Unlock()    self.uncleMu.Lock()    defer self.uncleMu.Unlock()    self.currentMu.Lock()    defer self.currentMu.Unlock()    tstart := time.Now()    parent := self.chain.CurrentBlock()    tstamp := tstart.Unix()    if parent.Time().Cmp(new(big.Int).SetInt64(tstamp)) &gt;= 0 { // ä¸èƒ½å‡ºç°æ¯”parentçš„æ—¶é—´è¿˜å°‘çš„æƒ…å†µ        tstamp = parent.Time().Int64() + 1    }    // this will ensure we're not going off too far in the future    // æˆ‘ä»¬çš„æ—¶é—´ä¸è¦è¶…è¿‡ç°åœ¨çš„æ—¶é—´å¤ªè¿œï¼Œ é‚£ä¹ˆç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œ     // æ„Ÿè§‰è¿™ä¸ªåŠŸèƒ½å®Œå…¨æ˜¯ä¸ºäº†æµ‹è¯•å®ç°çš„ï¼Œ å¦‚æœæ˜¯çœŸå®çš„æŒ–çŸ¿ç¨‹åºï¼Œåº”è¯¥ä¸ä¼šç­‰å¾…ã€‚    if now := time.Now().Unix(); tstamp &gt; now+1 {        wait := time.Duration(tstamp-now) * time.Second        log.Info("Mining too far in the future", "wait", common.PrettyDuration(wait))        time.Sleep(wait)    }    num := parent.Number()    header := &amp;types.Header{        ParentHash: parent.Hash(),        Number:     num.Add(num, common.Big1),        GasLimit:   core.CalcGasLimit(parent),        GasUsed:    new(big.Int),        Extra:      self.extra,        Time:       big.NewInt(tstamp),    }    // Only set the coinbase if we are mining (avoid spurious block rewards)    // åªæœ‰å½“æˆ‘ä»¬æŒ–çŸ¿çš„æ—¶å€™æ‰è®¾ç½®coinbase(é¿å…è™šå‡çš„å—å¥–åŠ±ï¼Ÿ TODO æ²¡æ‡‚)    if atomic.LoadInt32(&amp;self.mining) == 1 {        header.Coinbase = self.coinbase    }    if err := self.engine.Prepare(self.chain, header); err != nil {        log.Error("Failed to prepare header for mining", "err", err)        return    }    // If we are care about TheDAO hard-fork check whether to override the extra-data or not    // æ ¹æ®æˆ‘ä»¬æ˜¯å¦å…³å¿ƒDAOç¡¬åˆ†å‰æ¥å†³å®šæ˜¯å¦è¦†ç›–é¢å¤–çš„æ•°æ®ã€‚    if daoBlock := self.config.DAOForkBlock; daoBlock != nil {        // Check whether the block is among the fork extra-override range        // æ£€æŸ¥åŒºå—æ˜¯å¦åœ¨ DAOç¡¬åˆ†å‰çš„èŒƒå›´å†…   [daoblock,daoblock+limit]        limit := new(big.Int).Add(daoBlock, params.DAOForkExtraRange)        if header.Number.Cmp(daoBlock) &gt;= 0 &amp;&amp; header.Number.Cmp(limit) &lt; 0 {            // Depending whether we support or oppose the fork, override differently            if self.config.DAOForkSupport { // å¦‚æœæˆ‘ä»¬æ”¯æŒDAO é‚£ä¹ˆè®¾ç½®ä¿ç•™çš„é¢å¤–çš„æ•°æ®                header.Extra = common.CopyBytes(params.DAOForkBlockExtra)            } else if bytes.Equal(header.Extra, params.DAOForkBlockExtra) {                header.Extra = []byte{} // If miner opposes, don't let it use the reserved extra-data // å¦åˆ™ä¸ä½¿ç”¨ä¿ç•™çš„é¢å¤–æ•°æ®            }        }    }    // Could potentially happen if starting to mine in an odd state.    err := self.makeCurrent(parent, header) // ç”¨æ–°çš„åŒºå—å¤´æ¥è®¾ç½®å½“å‰çš„çŠ¶æ€    if err != nil {        log.Error("Failed to create mining context", "err", err)        return    }    // Create the current work task and check any fork transitions needed    work := self.current    if self.config.DAOForkSupport &amp;&amp; self.config.DAOForkBlock != nil &amp;&amp; self.config.DAOForkBlock.Cmp(header.Number) == 0 {        misc.ApplyDAOHardFork(work.state)  // æŠŠDAOé‡Œé¢çš„èµ„é‡‘è½¬ç§»åˆ°æŒ‡å®šçš„è´¦æˆ·ã€‚    }    pending, err := self.eth.TxPool().Pending() //å¾—åˆ°é˜»å¡çš„èµ„é‡‘    if err != nil {        log.Error("Failed to fetch pending transactions", "err", err)        return    }    // åˆ›å»ºäº¤æ˜“ã€‚ è¿™ä¸ªæ–¹æ³•åç»­ä»‹ç»    txs := types.NewTransactionsByPriceAndNonce(self.current.signer, pending)    // æäº¤äº¤æ˜“ è¿™ä¸ªæ–¹æ³•åç»­ä»‹ç»        work.commitTransactions(self.mux, txs, self.chain, self.coinbase)    // compute uncles for the new block.    var (        uncles    []*types.Header        badUncles []common.Hash    )    for hash, uncle := range self.possibleUncles {        if len(uncles) == 2 {            break        }        if err := self.commitUncle(work, uncle.Header()); err != nil {            log.Trace("Bad uncle found and will be removed", "hash", hash)            log.Trace(fmt.Sprint(uncle))            badUncles = append(badUncles, hash)        } else {            log.Debug("Committing new uncle to block", "hash", hash)            uncles = append(uncles, uncle.Header())        }    }    for _, hash := range badUncles {        delete(self.possibleUncles, hash)    }    // Create the new block to seal with the consensus engine    // ä½¿ç”¨ç»™å®šçš„çŠ¶æ€æ¥åˆ›å»ºæ–°çš„åŒºå—ï¼ŒFinalizeä¼šè¿›è¡ŒåŒºå—å¥–åŠ±ç­‰æ“ä½œ    if work.Block, err = self.engine.Finalize(self.chain, header, work.state, work.txs, uncles, work.receipts); err != nil {        log.Error("Failed to finalize block for sealing", "err", err)        return    }    // We only care about logging if we're actually mining.    //     if atomic.LoadInt32(&amp;self.mining) == 1 {        log.Info("Commit new mining work", "number", work.Block.Number(), "txs", work.tcount, "uncles", len(uncles), "elapsed", common.PrettyDuration(time.Since(tstart)))        self.unconfirmed.Shift(work.Block.NumberU64() - 1)    }    self.push(work)}</code></pre><p>pushæ–¹æ³•ï¼Œå¦‚æœæˆ‘ä»¬æ²¡æœ‰åœ¨æŒ–çŸ¿ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›ï¼Œå¦åˆ™æŠŠä»»åŠ¡é€ç»™æ¯ä¸€ä¸ªagent</p><pre><code>// push sends a new work task to currently live miner agents.func (self *worker) push(work *Work) {    if atomic.LoadInt32(&amp;self.mining) != 1 {        return    }    for agent := range self.agents {        atomic.AddInt32(&amp;self.atWork, 1)        if ch := agent.Work(); ch != nil {            ch &lt;- work        }    }}</code></pre><p>makeCurrentï¼Œæœªå½“å‰çš„å‘¨æœŸåˆ›å»ºä¸€ä¸ªæ–°çš„ç¯å¢ƒã€‚</p><pre><code>// makeCurrent creates a new environment for the current cycle.// func (self *worker) makeCurrent(parent *types.Block, header *types.Header) error {    state, err := self.chain.StateAt(parent.Root())    if err != nil {        return err    }    work := &amp;Work{        config:    self.config,        signer:    types.NewEIP155Signer(self.config.ChainId),        state:     state,        ancestors: set.New(),        family:    set.New(),        uncles:    set.New(),        header:    header,        createdAt: time.Now(),    }    // when 08 is processed ancestors contain 07 (quick block)    for _, ancestor := range self.chain.GetBlocksFromHash(parent.Hash(), 7) {        for _, uncle := range ancestor.Uncles() {            work.family.Add(uncle.Hash())        }        work.family.Add(ancestor.Hash())        work.ancestors.Add(ancestor.Hash())    }    // Keep track of transactions which return errors so they can be removed    work.tcount = 0    self.current = work    return nil}</code></pre><p>commitTransactions</p><pre><code>func (env *Work) commitTransactions(mux *event.TypeMux, txs *types.TransactionsByPriceAndNonce, bc *core.BlockChain, coinbase common.Address) {    // ç”±äºæ˜¯æ‰“åŒ…æ–°çš„åŒºå—ä¸­äº¤æ˜“ï¼Œæ‰€ä»¥å°†æ€» gasPool åˆå§‹åŒ–ä¸º env.header.GasLimit    if env.gasPool == nil {        env.gasPool = new(core.GasPool).AddGas(env.header.GasLimit)    }    var coalescedLogs []*types.Log    for {        // If we don't have enough gas for any further transactions then we're done        // å¦‚æœå½“å‰åŒºå—ä¸­æ‰€æœ‰ Gas æ¶ˆè€—å·²ç»ä½¿ç”¨å®Œï¼Œåˆ™é€€å‡ºæ‰“åŒ…äº¤æ˜“        if env.gasPool.Gas() &lt; params.TxGas {            log.Trace("Not enough gas for further transactions", "have", env.gasPool, "want", params.TxGas)            break        }                        // Retrieve the next transaction and abort if all done        // æ£€ç´¢ä¸‹ä¸€ç¬”äº¤æ˜“ï¼Œå¦‚æœäº¤æ˜“é›†åˆä¸ºç©ºåˆ™é€€å‡º commit        tx := txs.Peek()        if tx == nil {            break        }        // Error may be ignored here. The error has already been checked        // during transaction acceptance is the transaction pool.        //        // We use the eip155 signer regardless of the current hf.        from, _ := types.Sender(env.signer, tx)        // Check whether the tx is replay protected. If we're not in the EIP155 hf        // phase, start ignoring the sender until we do.        // è¯·å‚è€ƒ https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md        // DAOäº‹ä»¶å‘ç”Ÿåï¼Œä»¥å¤ªåŠåˆ†è£‚ä¸ºETHå’ŒETC,å› ä¸ºä¸¤ä¸ªé“¾ä¸Šçš„ä¸œè¥¿ä¸€æ‘¸ä¸€æ ·ï¼Œæ‰€ä»¥åœ¨ETC        // ä¸Šé¢å‘ç”Ÿçš„äº¤æ˜“å¯ä»¥æ‹¿åˆ°ETHä¸Šé¢è¿›è¡Œé‡æ”¾ï¼Œ åä¹‹äº¦ç„¶ã€‚ æ‰€ä»¥Vitalikæå‡ºäº†EIP155æ¥é¿å…è¿™ç§æƒ…å†µã€‚        if tx.Protected() &amp;&amp; !env.config.IsEIP155(env.header.Number) {            log.Trace("Ignoring reply protected transaction", "hash", tx.Hash(), "eip155", env.config.EIP155Block)            txs.Pop()            continue        }        // Start executing the transaction        env.state.Prepare(tx.Hash(), common.Hash{}, env.tcount)        // æ‰§è¡Œäº¤æ˜“        err, logs := env.commitTransaction(tx, bc, coinbase, gp)        switch err {        case core.ErrGasLimitReached:            // Pop the current out-of-gas transaction without shifting in the next from the account            // å¼¹å‡ºæ•´ä¸ªè´¦æˆ·çš„æ‰€æœ‰äº¤æ˜“ï¼Œ ä¸å¤„ç†ç”¨æˆ·çš„ä¸‹ä¸€ä¸ªäº¤æ˜“ã€‚            log.Trace("Gas limit exceeded for current block", "sender", from)            txs.Pop()        case core.ErrNonceTooLow:            // New head notification data race between the transaction pool and miner, shift            // ç§»åŠ¨åˆ°ç”¨æˆ·çš„ä¸‹ä¸€ä¸ªäº¤æ˜“            log.Trace("Skipping transaction with low nonce", "sender", from, "nonce", tx.Nonce())            txs.Shift()        case core.ErrNonceTooHigh:            // Reorg notification data race between the transaction pool and miner, skip account =            // è·³è¿‡è¿™ä¸ªè´¦æˆ·            log.Trace("Skipping account with hight nonce", "sender", from, "nonce", tx.Nonce())            txs.Pop()        case nil:            // Everything ok, collect the logs and shift in the next transaction from the same account            coalescedLogs = append(coalescedLogs, logs...)            env.tcount++            txs.Shift()        default:            // Strange error, discard the transaction and get the next in line (note, the            // nonce-too-high clause will prevent us from executing in vain).            // å…¶ä»–å¥‡æ€ªçš„é”™è¯¯ï¼Œè·³è¿‡è¿™ä¸ªäº¤æ˜“ã€‚            log.Debug("Transaction failed, account skipped", "hash", tx.Hash(), "err", err)            txs.Shift()        }    }    if len(coalescedLogs) &gt; 0 || env.tcount &gt; 0 {        // make a copy, the state caches the logs and these logs get "upgraded" from pending to mined        // logs by filling in the block hash when the block was mined by the local miner. This can        // cause a race condition if a log was "upgraded" before the PendingLogsEvent is processed.        // å› ä¸ºéœ€è¦æŠŠlogå‘é€å‡ºå»ï¼Œè€Œè¿™è¾¹åœ¨æŒ–çŸ¿å®Œæˆåéœ€è¦å¯¹logè¿›è¡Œä¿®æ”¹ï¼Œæ‰€ä»¥æ‹·è´ä¸€ä»½å‘é€å‡ºå»ï¼Œé¿å…äº‰ç”¨ã€‚        cpy := make([]*types.Log, len(coalescedLogs))        for i, l := range coalescedLogs {            cpy[i] = new(types.Log)            *cpy[i] = *l        }        go func(logs []*types.Log, tcount int) {            if len(logs) &gt; 0 {                mux.Post(core.PendingLogsEvent{Logs: logs})            }            if tcount &gt; 0 {                mux.Post(core.PendingStateEvent{})            }        }(cpy, env.tcount)    }}</code></pre><p>commitTransactionæ‰§è¡ŒApplyTransaction</p><pre><code>func (env *Work) commitTransaction(tx *types.Transaction, bc *core.BlockChain, coinbase common.Address, gp *core.GasPool) (error, []*types.Log) {    snap := env.state.Snapshot()    receipt, _, err := core.ApplyTransaction(env.config, bc, &amp;coinbase, gp, env.state, env.header, tx, env.header.GasUsed, vm.Config{})    if err != nil {        env.state.RevertToSnapshot(snap)        return err, nil    }    env.txs = append(env.txs, tx)    env.receipts = append(env.receipts, receipt)    return nil, receipt.Logs}</code></pre><p>waitå‡½æ•°ç”¨æ¥æ¥å—æŒ–çŸ¿çš„ç»“æœç„¶åå†™å…¥æœ¬åœ°åŒºå—é“¾ï¼ŒåŒæ—¶é€šè¿‡ethåè®®å¹¿æ’­å‡ºå»ã€‚</p><pre><code>func (self *worker) wait() {    for {        mustCommitNewWork := true        for result := range self.recv {            atomic.AddInt32(&amp;self.atWork, -1)            if result == nil {                continue            }            block := result.Block            work := result.Work            // Update the block hash in all logs since it is now available and not when the            // receipt/log of individual transactions were created.            for _, r := range work.receipts {                for _, l := range r.Logs {                    l.BlockHash = block.Hash()                }            }            for _, log := range work.state.Logs() {                log.BlockHash = block.Hash()            }            stat, err := self.chain.WriteBlockAndState(block, work.receipts, work.state)            if err != nil {                log.Error("Failed writing block to chain", "err", err)                continue            }            // check if canon block and write transactions            if stat == core.CanonStatTy { // è¯´æ˜å·²ç»æ’å…¥åˆ°è§„èŒƒçš„åŒºå—é“¾                // implicit by posting ChainHeadEvent                // å› ä¸ºè¿™ç§çŠ¶æ€ä¸‹ï¼Œä¼šå‘é€ChainHeadEventï¼Œä¼šè§¦å‘ä¸Šé¢çš„updateé‡Œé¢çš„ä»£ç ï¼Œè¿™éƒ¨åˆ†ä»£ç ä¼šcommitNewWorkï¼Œæ‰€ä»¥åœ¨è¿™é‡Œå°±ä¸éœ€è¦commitäº†ã€‚                mustCommitNewWork = false            }                // Broadcast the block and announce chain insertion event            // å¹¿æ’­åŒºå—ï¼Œå¹¶ä¸”ç”³æ˜åŒºå—é“¾æ’å…¥äº‹ä»¶ã€‚            self.mux.Post(core.NewMinedBlockEvent{Block: block})            var (                events []interface{}                logs   = work.state.Logs()            )            events = append(events, core.ChainEvent{Block: block, Hash: block.Hash(), Logs: logs})            if stat == core.CanonStatTy {                events = append(events, core.ChainHeadEvent{Block: block})            }            self.chain.PostChainEvents(events, logs)            // Insert the block into the set of pending ones to wait for confirmations            // æ’å…¥æœ¬åœ°è·Ÿè¸ªåˆ—è¡¨ï¼Œ æŸ¥çœ‹åç»­çš„ç¡®è®¤çŠ¶æ€ã€‚            self.unconfirmed.Insert(block.NumberU64(), block.Hash())            if mustCommitNewWork { // TODO ?                 self.commitNewWork()            }        }    }}</code></pre><h2 id="miner"><a href="#miner" class="headerlink" title="miner"></a>miner</h2><p>minerç”¨æ¥å¯¹workerè¿›è¡Œç®¡ç†ï¼Œ è®¢é˜…å¤–éƒ¨äº‹ä»¶ï¼Œæ§åˆ¶workerçš„å¯åŠ¨å’Œåœæ­¢ã€‚</p><p>æ•°æ®ç»“æ„</p><pre><code>// Backend wraps all methods required for mining.type Backend interface {    AccountManager() *accounts.Manager    BlockChain() *core.BlockChain    TxPool() *core.TxPool    ChainDb() ethdb.Database}// Miner creates blocks and searches for proof-of-work values.type Miner struct {    mux *event.TypeMux    worker *worker    coinbase common.Address    mining   int32    eth      Backend    engine   consensus.Engine    canStart    int32 // can start indicates whether we can start the mining operation    shouldStart int32 // should start indicates whether we should start after sync}</code></pre><p>æ„é€ , åˆ›å»ºäº†ä¸€ä¸ªCPU agent å¯åŠ¨äº†minerçš„update goroutine</p><pre><code>func New(eth Backend, config *params.ChainConfig, mux *event.TypeMux, engine consensus.Engine) *Miner {    miner := &amp;Miner{        eth:      eth,        mux:      mux,        engine:   engine,        worker:   newWorker(config, engine, common.Address{}, eth, mux),        canStart: 1,    }    miner.Register(NewCpuAgent(eth.BlockChain(), engine))    go miner.update()    return miner}</code></pre><p>updateè®¢é˜…äº†downloaderçš„äº‹ä»¶ï¼Œ æ³¨æ„è¿™ä¸ªgoroutineæ˜¯ä¸€ä¸ªä¸€æ¬¡æ€§çš„å¾ªç¯ï¼Œ åªè¦æ¥æ”¶åˆ°ä¸€æ¬¡downloaderçš„downloader.DoneEventæˆ–è€… downloader.FailedEventäº‹ä»¶ï¼Œ å°±ä¼šè®¾ç½®canStartä¸º1. å¹¶é€€å‡ºå¾ªç¯ï¼Œ è¿™æ˜¯ä¸ºäº†é¿å…é»‘å®¢æ¶æ„çš„ DOSæ”»å‡»ï¼Œè®©ä½ ä¸æ–­çš„å¤„äºå¼‚å¸¸çŠ¶æ€</p><pre><code>// update keeps track of the downloader events. Please be aware that this is a one shot type of update loop.// It's entered once and as soon as `Done` or `Failed` has been broadcasted the events are unregistered and// the loop is exited. This to prevent a major security vuln where external parties can DOS you with blocks// and halt your mining operation for as long as the DOS continues.func (self *Miner) update() {    events := self.mux.Subscribe(downloader.StartEvent{}, downloader.DoneEvent{}, downloader.FailedEvent{})out:    for ev := range events.Chan() {        switch ev.Data.(type) {        case downloader.StartEvent:            atomic.StoreInt32(&amp;self.canStart, 0)            if self.Mining() {                self.Stop()                atomic.StoreInt32(&amp;self.shouldStart, 1)                log.Info("Mining aborted due to sync")            }        case downloader.DoneEvent, downloader.FailedEvent:            shouldStart := atomic.LoadInt32(&amp;self.shouldStart) == 1            atomic.StoreInt32(&amp;self.canStart, 1)            atomic.StoreInt32(&amp;self.shouldStart, 0)            if shouldStart {                self.Start(self.coinbase)            }            // unsubscribe. we're only interested in this event once            events.Unsubscribe()            // stop immediately and ignore all further pending events            break out        }    }}</code></pre><p>Start</p><pre><code>func (self *Miner) Start(coinbase common.Address) {    atomic.StoreInt32(&amp;self.shouldStart, 1)  // shouldStart æ˜¯æ˜¯å¦åº”è¯¥å¯åŠ¨    self.worker.setEtherbase(coinbase)             self.coinbase = coinbase    if atomic.LoadInt32(&amp;self.canStart) == 0 {  // canStartæ˜¯å¦èƒ½å¤Ÿå¯åŠ¨ï¼Œ        log.Info("Network syncing, will start miner afterwards")        return    }    atomic.StoreInt32(&amp;self.mining, 1)    log.Info("Starting mining operation")    self.worker.start()  // å¯åŠ¨worker å¼€å§‹æŒ–çŸ¿    self.worker.commitNewWork()  //æäº¤æ–°çš„æŒ–çŸ¿ä»»åŠ¡ã€‚}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ä»¥å¤ªåŠæºç åˆ†æ-RLPæºç åˆ†æ</title>
      <link href="/2021/04/14/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-RLP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/04/14/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-RLP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ç‰ˆæœ¬è¯´æ˜"><a href="#ç‰ˆæœ¬è¯´æ˜" class="headerlink" title="ç‰ˆæœ¬è¯´æ˜"></a>ç‰ˆæœ¬è¯´æ˜</h1><p>æºç åˆ†æä½¿ç”¨çš„ç‰ˆæœ¬ä¸ºï¼š<a href="https://github.com/ethereum/go-ethereum/tree/v1.10.3">v1.10.3</a></p><h1 id="RLPæºç è§£æ"><a href="#RLPæºç è§£æ" class="headerlink" title="RLPæºç è§£æ"></a>RLPæºç è§£æ</h1><h2 id="ä¸€ã€ä»‹ç»RLP"><a href="#ä¸€ã€ä»‹ç»RLP" class="headerlink" title="ä¸€ã€ä»‹ç»RLP"></a>ä¸€ã€ä»‹ç»RLP</h2><p>RLPæ˜¯Recursive Length Prefixçš„ç®€å†™ã€‚æ˜¯ä»¥å¤ªåŠä¸­çš„åºåˆ—åŒ–æ–¹æ³•ï¼Œä»¥å¤ªåŠçš„æ‰€æœ‰å¯¹è±¡éƒ½ä¼šä½¿ç”¨RLPæ–¹æ³•åºåˆ—åŒ–ä¸ºå­—èŠ‚æ•°ç»„ã€‚è¿™é‡Œæˆ‘å¸Œæœ›å…ˆä»é»„çš®ä¹¦æ¥å½¢å¼åŒ–ä¸Šäº†è§£RLPæ–¹æ³•ï¼Œ ç„¶åé€šè¿‡ä»£ç æ¥åˆ†æå®é™…çš„å®ç°ã€‚<br>RLPæŠŠæ‰€æœ‰çš„æ•°æ®çœ‹æˆä¸¤ç±»æ•°æ®çš„ç»„åˆï¼Œ ä¸€ç±»æ˜¯å­—èŠ‚æ•°ç»„ï¼Œ ä¸€ç±»æ˜¯ç±»ä¼¼äºListçš„æ•°æ®ç»“æ„ã€‚ æˆ‘ç†è§£è¿™ä¸¤ç±»åŸºæœ¬åŒ…å«äº†æ‰€æœ‰çš„æ•°æ®ç»“æ„ã€‚ æ¯”å¦‚ç”¨å¾—æ¯”è¾ƒå¤šçš„structã€‚ å¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªå¾ˆå¤šä¸åŒç±»å‹çš„å­—æ®µç»„æˆçš„List</p><h2 id="äºŒã€åˆ†æRLPæºæ–‡ä»¶"><a href="#äºŒã€åˆ†æRLPæºæ–‡ä»¶" class="headerlink" title="äºŒã€åˆ†æRLPæºæ–‡ä»¶"></a>äºŒã€åˆ†æRLPæºæ–‡ä»¶</h2><p><img src="https://img-blog.csdnimg.cn/20210612115632564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>RLPçš„æºç ä¸æ˜¯å¾ˆå¤šï¼š</p><pre><code>decode.go            è§£ç å™¨ï¼ŒæŠŠRLPæ•°æ®è§£ç ä¸ºgoçš„æ•°æ®ç»“æ„decode_tail_test.go        è§£ç å™¨æµ‹è¯•ä»£ç decode_test.go            è§£ç å™¨æµ‹è¯•ä»£ç     doc.go                æ–‡æ¡£ä»£ç encode.go            ç¼–ç å™¨ï¼ŒæŠŠGOçš„æ•°æ®ç»“æ„åºåˆ—åŒ–ä¸ºå­—èŠ‚æ•°ç»„encode_test.go            ç¼–ç å™¨æµ‹è¯•encode_example_test.goraw.go                æœªè§£ç çš„RLPæ•°æ®raw_test.gosafe.go     å¹¶æœªä½¿ç”¨typecache.go            ç±»å‹ç¼“å­˜ï¼Œ ç±»å‹ç¼“å­˜è®°å½•äº†ç±»å‹-&gt;(ç¼–ç å™¨|è§£ç å™¨)çš„å†…å®¹unsafe.go</code></pre><h3 id="1-æ ¹æ®ç±»å‹æ‰¾åˆ°å¯¹åº”çš„ç¼–ç å™¨å’Œè§£ç å™¨ï¼štypecache-go"><a href="#1-æ ¹æ®ç±»å‹æ‰¾åˆ°å¯¹åº”çš„ç¼–ç å™¨å’Œè§£ç å™¨ï¼štypecache-go" class="headerlink" title="1.  æ ¹æ®ç±»å‹æ‰¾åˆ°å¯¹åº”çš„ç¼–ç å™¨å’Œè§£ç å™¨ï¼štypecache.go"></a>1.  æ ¹æ®ç±»å‹æ‰¾åˆ°å¯¹åº”çš„ç¼–ç å™¨å’Œè§£ç å™¨ï¼štypecache.go</h3><p>åœ¨C++æˆ–è€…Javaç­‰æ”¯æŒé‡è½½çš„è¯­è¨€ä¸­ï¼Œ å¯ä»¥é€šè¿‡ä¸åŒçš„ç±»å‹é‡è½½åŒä¸€ä¸ªå‡½æ•°åç§°æ¥å®ç°æ–¹æ³•é’ˆå¯¹ä¸åŒç±»å‹çš„åˆ†æ´¾,æ¯”å¦‚ï¼Œ ä¹Ÿå¯ä»¥é€šè¿‡æ³›å‹æ¥å®ç°å‡½æ•°çš„åˆ†æ´¾ã€‚ä½†æ˜¯GOè¯­è¨€æœ¬èº«ä¸æ”¯æŒé‡è½½ï¼Œ ä¹Ÿæ²¡æœ‰æ³›å‹ï¼Œæ‰€ä»¥å‡½æ•°çš„åˆ†æ´¾å°±éœ€è¦è‡ªå·±å®ç°äº†ã€‚ typecache.goä¸»è¦æ˜¯å®ç°è¿™ä¸ªç›®çš„ï¼Œ é€šè¿‡è‡ªèº«çš„ç±»å‹æ¥å¿«é€Ÿçš„æ‰¾åˆ°è‡ªå·±çš„ç¼–ç å™¨å‡½æ•°å’Œè§£ç å™¨å‡½æ•°ã€‚</p><p>æˆ‘ä»¬é¦–å…ˆçœ‹çœ‹æ ¸å¿ƒæ•°æ®ç»“æ„</p><pre><code class="go">type typeCache struct {    cur atomic.Value    // This lock synchronizes writers.    mu   sync.Mutex    next map[typekey]*typeinfo}// typekey is the key of a type in typeCache. It includes the struct tags because// they might generate a different decoder.type typekey struct {    reflect.Type    tags}//å­˜å‚¨äº†ç¼–ç å™¨å’Œè§£ç å™¨å‡½æ•°// typeinfo is an entry in the type cache.type typeinfo struct {    decoder    decoder    decoderErr error // error from makeDecoder    writer     writer    writerErr  error // error from makeWriter}</code></pre><p>æ ¸å¿ƒæ•°æ®ç»“æ„å°±æ˜¯typeCacheè¿™ä¸ªMapï¼Œ Mapçš„keyæ˜¯ç±»å‹ï¼Œvalueæ˜¯å¯¹åº”çš„ç¼–ç å’Œè§£ç å™¨ã€‚</p><p>ä¸‹é¢æ˜¯ç”¨æˆ·å¦‚ä½•è·å–ç¼–ç å™¨å’Œè§£ç å™¨çš„å‡½æ•°</p><pre><code class="go">// è§£ç å‡½æ•°func cachedDecoder(typ reflect.Type) (decoder, error) {    info := theTC.info(typ)    return info.decoder, info.decoderErr}// ç¼–ç å‡½æ•°func cachedWriter(typ reflect.Type) (writer, error) {    info := theTC.info(typ)    return info.writer, info.writerErr}func (c *typeCache) info(typ reflect.Type) *typeinfo {    key := typekey{Type: typ}    if info := c.cur.Load().(map[typekey]*typeinfo)[key]; info != nil {        return info    }    // Not in the cache, need to generate info for this type.    return c.generate(typ, tags{})}func (c *typeCache) generate(typ reflect.Type, tags tags) *typeinfo {    c.mu.Lock()    defer c.mu.Unlock()    cur := c.cur.Load().(map[typekey]*typeinfo)    if info := cur[typekey{typ, tags}]; info != nil {        return info    }    // Copy cur to next.    c.next = make(map[typekey]*typeinfo, len(cur)+1)    for k, v := range cur {        c.next[k] = v    }    // Generate.    info := c.infoWhileGenerating(typ, tags)    // next -&gt; cur    c.cur.Store(c.next)    c.next = nil    return info}func (c *typeCache) infoWhileGenerating(typ reflect.Type, tags tags) *typeinfo {    key := typekey{typ, tags}    if info := c.next[key]; info != nil {        return info    }    // Put a dummy value into the cache before generating.    // If the generator tries to lookup itself, it will get    // the dummy value and won't call itself recursively.    info := new(typeinfo)    c.next[key] = info    info.generate(typ, tags)    return info}</code></pre><p>å¯¹äºç»“æ„ä½“ç±»å‹çš„å¤„ç†è¿˜æ˜¯æŒºæœ‰æ„æ€çš„ï¼Œè€Œä¸”è¿™éƒ¨åˆ†è¯¦ç»†çš„å¤„ç†é€»è¾‘åœ¨é»„çš®ä¹¦ä¸Šé¢ä¹Ÿæ˜¯æ‰¾ä¸åˆ°çš„ã€‚</p><pre><code class="go">type field struct {    index    int    info     *typeinfo    optional bool}// structFields resolves the typeinfo of all public fields in a struct type.func structFields(typ reflect.Type) (fields []field, err error) {    var (        lastPublic  = lastPublicField(typ)        anyOptional = false    )    for i := 0; i &lt; typ.NumField(); i++ {        if f := typ.Field(i); f.PkgPath == "" { // exported            tags, err := parseStructTag(typ, i, lastPublic)            if err != nil {                return nil, err            }            // Skip rlp:"-" fields.            if tags.ignored {                continue            }            // If any field has the "optional" tag, subsequent fields must also have it.            if tags.optional || tags.tail {                anyOptional = true            } else if anyOptional {                return nil, fmt.Errorf(`rlp: struct field %v.%s needs "optional" tag`, typ, f.Name)            }            info := theTC.infoWhileGenerating(f.Type, tags)            fields = append(fields, field{i, info, tags.optional})        }    }    return fields, nil}// anyOptionalFields returns the index of the first field with "optional" tag.func firstOptionalField(fields []field) int {    for i, f := range fields {        if f.optional {            return i        }    }    return len(fields)}</code></pre><h3 id="2-ç¼–ç å™¨ï¼šencode-go"><a href="#2-ç¼–ç å™¨ï¼šencode-go" class="headerlink" title="2. ç¼–ç å™¨ï¼šencode.go"></a>2. ç¼–ç å™¨ï¼šencode.go</h3><p>é¦–å…ˆå®šä¹‰äº†ç©ºå­—ç¬¦ä¸²å’Œç©ºListçš„å€¼ï¼Œåˆ†åˆ«æ˜¯ 0x80å’Œ0xC0ã€‚ æ³¨æ„ï¼Œæ•´å½¢çš„0å€¼çš„å¯¹åº”å€¼ä¹Ÿæ˜¯0x80ã€‚è¿™ä¸ªåœ¨é»„çš®ä¹¦ä¸Šé¢æ˜¯æ²¡æœ‰çœ‹åˆ°æœ‰å®šä¹‰çš„ã€‚ ç„¶åå®šä¹‰äº†ä¸€ä¸ªæ¥å£ç±»å‹ç»™åˆ«çš„ç±»å‹å®ç° EncodeRLP</p><pre><code class="go">var (    // Common encoded values.    // These are useful when implementing EncodeRLP.    EmptyString = []byte{0x80}    EmptyList   = []byte{0xC0})// Encoder is implemented by types that require custom// encoding rules or want to encode private fields.type Encoder interface {    // EncodeRLP should write the RLP encoding of its receiver to w.    // If the implementation is a pointer method, it may also be    // called for nil pointers.    //    // Implementations should generate valid RLP. The data written is    // not verified at the moment, but a future version might. It is    // recommended to write only a single value but writing multiple    // values or no value at all is also permitted.    EncodeRLP(io.Writer) error}</code></pre><p>ç„¶åå®šä¹‰äº†ä¸€ä¸ªæœ€é‡è¦çš„æ–¹æ³•ï¼Œ å¤§éƒ¨åˆ†çš„EncodeRLPæ–¹æ³•éƒ½æ˜¯ç›´æ¥è°ƒç”¨äº†è¿™ä¸ªæ–¹æ³•Encodeæ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•é¦–å…ˆè·å–äº†ä¸€ä¸ªencbufå¯¹è±¡ã€‚ ç„¶åè°ƒç”¨è¿™ä¸ªå¯¹è±¡çš„encodeæ–¹æ³•ã€‚encodeæ–¹æ³•ä¸­ï¼Œé¦–å…ˆè·å–äº†å¯¹è±¡çš„åå°„ç±»å‹ï¼Œæ ¹æ®åå°„ç±»å‹è·å–å®ƒçš„ç¼–ç å™¨ï¼Œç„¶åè°ƒç”¨ç¼–ç å™¨çš„writeræ–¹æ³•ã€‚ è¿™ä¸ªå°±è·Ÿä¸Šé¢è°ˆåˆ°çš„typecacheè”ç³»åˆ°ä¸€èµ·äº†ã€‚</p><pre><code class="go">func Encode(w io.Writer, val interface{}) error {    if outer, ok := w.(*encbuf); ok {        // Encode was called by some type's EncodeRLP.        // Avoid copying by writing to the outer encbuf directly.        return outer.encode(val)    }    eb := encbufPool.Get().(*encbuf)    defer encbufPool.Put(eb)    eb.reset()    if err := eb.encode(val); err != nil {        return err    }    return eb.toWriter(w)}func (w *encbuf) encode(val interface{}) error {    rval := reflect.ValueOf(val)    ti, err := cachedTypeInfo(rval.Type(), tags{})    if err != nil {        return err    }    return ti.writer(rval, w)}</code></pre><p>encbufçš„ä»‹ç»<br>encbufæ˜¯encode bufferçš„ç®€å†™(æˆ‘çŒœçš„)ã€‚encbufå‡ºç°åœ¨Encodeæ–¹æ³•ï¼Œå’Œå¾ˆå¤šWriteræ–¹æ³•ä¸­ã€‚é¡¾åæ€ä¹‰ï¼Œè¿™ä¸ªæ˜¯åœ¨encodeçš„è¿‡ç¨‹ä¸­å……å½“bufferçš„ä½œç”¨ã€‚ä¸‹é¢å…ˆçœ‹çœ‹encbufçš„å®šä¹‰ã€‚</p><pre><code class="go">type encbuf struct {    str     []byte      // string data, contains everything except list headers    lheads  []*listhead // all list headers    lhsize  int         // sum of sizes of all encoded list headers    sizebuf []byte      // 9-byte auxiliary buffer for uint encoding}type listhead struct {    offset int // index of this header in string data    size   int // total size of encoded data (including list headers)}</code></pre><p>ä»æ³¨é‡Šå¯ä»¥çœ‹åˆ°ï¼Œ strå­—æ®µåŒ…å«äº†æ‰€æœ‰çš„å†…å®¹ï¼Œé™¤äº†åˆ—è¡¨çš„å¤´éƒ¨ã€‚ åˆ—è¡¨çš„å¤´éƒ¨è®°å½•åœ¨lheadså­—æ®µä¸­ã€‚ lhsizeå­—æ®µè®°å½•äº†lheadsçš„é•¿åº¦ï¼Œ sizebufæ˜¯9ä¸ªå­—èŠ‚å¤§å°çš„è¾…åŠ©bufferï¼Œä¸“é—¨ç”¨æ¥å¤„ç†uintçš„ç¼–ç çš„ã€‚ listheadç”±ä¸¤ä¸ªå­—æ®µç»„æˆï¼Œ offsetå­—æ®µè®°å½•äº†åˆ—è¡¨æ•°æ®åœ¨strå­—æ®µçš„å“ªä¸ªä½ç½®ï¼Œ sizeå­—æ®µè®°å½•äº†åŒ…å«åˆ—è¡¨å¤´çš„ç¼–ç åçš„æ•°æ®çš„æ€»é•¿åº¦ã€‚å¯ä»¥çœ‹åˆ°ä¸‹é¢çš„å›¾ã€‚</p><p><img src="https://img-blog.csdnimg.cn/20210614111346666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70"></p><p>å¯¹äºæ™®é€šçš„ç±»å‹ï¼Œæ¯”å¦‚å­—ç¬¦ä¸²ï¼Œæ•´å½¢ï¼Œboolå‹ç­‰æ•°æ®ï¼Œå°±æ˜¯ç›´æ¥å¾€strå­—æ®µé‡Œé¢å¡«å……å°±è¡Œäº†ã€‚ ä½†æ˜¯å¯¹äºç»“æ„ä½“ç±»å‹çš„å¤„ç†ï¼Œ å°±éœ€è¦ç‰¹æ®Šçš„å¤„ç†æ–¹å¼äº†ã€‚å¯ä»¥çœ‹çœ‹ä¸Šé¢æåˆ°è¿‡çš„makeStructWriteræ–¹æ³•ã€‚</p><pre><code class="go">func makeStructWriter(typ reflect.Type) (writer, error) {        fields, err := structFields(typ)        if err != nil {        return nil, err    }    for _, f := range fields {        if f.info.writerErr != nil {            return nil, structFieldError{typ, f.index, f.info.writerErr}        }    }    var writer writer    firstOptionalField := firstOptionalField(fields)    if firstOptionalField == len(fields) {        // This is the writer function for structs without any optional fields.        writer = func(val reflect.Value, w *encbuf) error {            lh := w.list()            for _, f := range fields {                if err := f.info.writer(val.Field(f.index), w); err != nil {                    return err                }            }            w.listEnd(lh)            return nil        }    } else {        // If there are any "optional" fields, the writer needs to perform additional        // checks to determine the output list length.        writer = func(val reflect.Value, w *encbuf) error {            lastField := len(fields) - 1            for ; lastField &gt;= firstOptionalField; lastField-- {                if !val.Field(fields[lastField].index).IsZero() {                    break                }            }            lh := w.list()            for i := 0; i &lt;= lastField; i++ {                if err := fields[i].info.writer(val.Field(fields[i].index), w); err != nil {                    return err                }            }            w.listEnd(lh)            return nil        }    }    return writer, nil}</code></pre><p>å¯ä»¥çœ‹åˆ°ä¸Šé¢çš„ä»£ç ä¸­ä½“ç°äº†å¤„ç†ç»“æ„ä½“æ•°æ®çš„ç‰¹æ®Šå¤„ç†æ–¹æ³•ï¼Œå°±æ˜¯é¦–å…ˆè°ƒç”¨w.list()æ–¹æ³•ï¼Œå¤„ç†å®Œæ¯•ä¹‹åå†è°ƒç”¨listEnd(lh)æ–¹æ³•ã€‚ é‡‡ç”¨è¿™ç§æ–¹å¼çš„åŸå› æ˜¯æˆ‘ä»¬åœ¨åˆšå¼€å§‹å¤„ç†ç»“æ„ä½“çš„æ—¶å€™ï¼Œå¹¶ä¸çŸ¥é“å¤„ç†åçš„ç»“æ„ä½“çš„é•¿åº¦æœ‰å¤šé•¿ï¼Œå› ä¸ºéœ€è¦æ ¹æ®ç»“æ„ä½“çš„é•¿åº¦æ¥å†³å®šå¤´çš„å¤„ç†æ–¹å¼(å›å¿†ä¸€ä¸‹é»„çš®ä¹¦é‡Œé¢ç»“æ„ä½“çš„å¤„ç†æ–¹å¼)ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨å¤„ç†å‰è®°å½•å¥½strçš„ä½ç½®ï¼Œç„¶åå¼€å§‹å¤„ç†æ¯ä¸ªå­—æ®µï¼Œå¤„ç†å®Œä¹‹ååœ¨çœ‹ä¸€ä¸‹strçš„æ•°æ®å¢åŠ äº†å¤šå°‘å°±çŸ¥é“å¤„ç†åçš„ç»“æ„ä½“é•¿åº¦æœ‰å¤šé•¿äº†ã€‚</p><pre><code class="go">// list adds a new list header to the header stack. It returns the index// of the header. The caller must call listEnd with this index after encoding// the content of the list.func (w *encbuf) list() int {    w.lheads = append(w.lheads, listhead{offset: len(w.str), size: w.lhsize})    return len(w.lheads) - 1}func (w *encbuf) listEnd(index int) {    lh := &amp;w.lheads[index]    lh.size = w.size() - lh.offset - lh.size    if lh.size &lt; 56 {        w.lhsize++ // length encoded into kind tag    } else {        w.lhsize += 1 + intsize(uint64(lh.size))    }}func (w *encbuf) size() int {    return len(w.str) + w.lhsize}</code></pre><p>ç„¶åæˆ‘ä»¬å¯ä»¥çœ‹çœ‹encbufæœ€åçš„å¤„ç†é€»è¾‘ï¼Œä¼šå¯¹listheadè¿›è¡Œå¤„ç†ï¼Œç»„è£…æˆå®Œæ•´çš„RLPæ•°æ®</p><pre><code class="go">func (w *encbuf) toBytes() []byte {    out := make([]byte, w.size())    strpos := 0    pos := 0    for _, head := range w.lheads {        // write string data before header        n := copy(out[pos:], w.str[strpos:head.offset])        pos += n        strpos += n        // write the header        enc := head.encode(out[pos:])        pos += len(enc)    }    // copy string data after the last list header    copy(out[pos:], w.str[strpos:])    return out}</code></pre><p>writerä»‹ç»<br>å‰©ä¸‹çš„æµç¨‹å…¶å®æ¯”è¾ƒç®€å•äº†ã€‚ å°±æ˜¯æ ¹æ®é»„çš®ä¹¦é’ˆæŠŠæ¯ç§ä¸åŒçš„æ•°æ®å¡«å……åˆ°encbufé‡Œé¢å»ã€‚</p><pre><code class="go">func writeBool(val reflect.Value, w *encbuf) error {    if val.Bool() {        w.str = append(w.str, 0x01)    } else {        w.str = append(w.str, 0x80)    }    return nil}func writeString(val reflect.Value, w *encbuf) error {    s := val.String()    if len(s) == 1 &amp;&amp; s[0] &lt;= 0x7f {        // fits single byte, no string header        w.str = append(w.str, s[0])    } else {        w.encodeStringHeader(len(s))        w.str = append(w.str, s...)    }    return nil}</code></pre><h3 id="3-è§£ç å™¨ï¼šdecode-go"><a href="#3-è§£ç å™¨ï¼šdecode-go" class="headerlink" title="3. è§£ç å™¨ï¼šdecode.go"></a>3. è§£ç å™¨ï¼šdecode.go</h3><p>è§£ç å™¨çš„å¤§è‡´æµç¨‹å’Œç¼–ç å™¨å·®ä¸å¤šï¼Œç†è§£äº†ç¼–ç å™¨çš„å¤§è‡´æµç¨‹ï¼Œä¹Ÿå°±çŸ¥é“äº†è§£ç å™¨çš„å¤§è‡´æµç¨‹ã€‚</p><pre><code class="go">// Decode decodes a value and stores the result in the value pointed// to by val. Please see the documentation for the Decode function// to learn about the decoding rules.func (s *Stream) Decode(val interface{}) error {    if val == nil {        return errDecodeIntoNil    }    rval := reflect.ValueOf(val)    rtyp := rval.Type()    if rtyp.Kind() != reflect.Ptr {        return errNoPointer    }    if rval.IsNil() {        return errDecodeIntoNil    }    decoder, err := cachedDecoder(rtyp.Elem())    if err != nil {        return err    }    err = decoder(s, rval.Elem())    if decErr, ok := err.(*decodeError); ok &amp;&amp; len(decErr.ctx) &gt; 0 {        // Add decode target type to error so context has more meaning.        decErr.ctx = append(decErr.ctx, fmt.Sprint("(", rtyp.Elem(), ")"))    }    return err}func cachedDecoder(typ reflect.Type) (decoder, error) {    info := theTC.info(typ)    return info.decoder, info.decoderErr}func makeDecoder(typ reflect.Type, tags tags) (dec decoder, err error) {    kind := typ.Kind()    switch {    case typ == rawValueType:        return decodeRawValue, nil    case typ.AssignableTo(reflect.PtrTo(bigInt)):        return decodeBigInt, nil    case typ.AssignableTo(bigInt):        return decodeBigIntNoPtr, nil    case kind == reflect.Ptr:        return makePtrDecoder(typ, tags)    case reflect.PtrTo(typ).Implements(decoderInterface):        return decodeDecoder, nil    case isUint(kind):        return decodeUint, nil    case kind == reflect.Bool:        return decodeBool, nil    case kind == reflect.String:        return decodeString, nil    case kind == reflect.Slice || kind == reflect.Array:        return makeListDecoder(typ, tags)    case kind == reflect.Struct:        return makeStructDecoder(typ)    case kind == reflect.Interface:        return decodeInterface, nil    default:        return nil, fmt.Errorf("rlp: type %v is not RLP-serializable", typ)    }}</code></pre><p>æˆ‘ä»¬åŒæ ·é€šè¿‡ç»“æ„ä½“ç±»å‹çš„è§£ç è¿‡ç¨‹æ¥æŸ¥çœ‹å…·ä½“çš„è§£ç è¿‡ç¨‹ã€‚è·Ÿç¼–ç è¿‡ç¨‹å·®ä¸å¤šï¼Œé¦–å…ˆé€šè¿‡structFieldsè·å–éœ€è¦è§£ç çš„æ‰€æœ‰å­—æ®µï¼Œç„¶åæ¯ä¸ªå­—æ®µè¿›è¡Œè§£ç ã€‚ è·Ÿç¼–ç è¿‡ç¨‹å·®ä¸å¤šæœ‰ä¸€ä¸ªList()å’ŒListEnd()çš„æ“ä½œï¼Œä¸è¿‡è¿™é‡Œçš„å¤„ç†æµç¨‹å’Œç¼–ç è¿‡ç¨‹ä¸ä¸€æ ·ï¼Œåç»­ç« èŠ‚ä¼šè¯¦ç»†ä»‹ç»ã€‚</p><pre><code class="go">func makeStructDecoder(typ reflect.Type) (decoder, error) {    fields, err := structFields(typ)    if err != nil {        return nil, err    }    for _, f := range fields {        if f.info.decoderErr != nil {            return nil, structFieldError{typ, f.index, f.info.decoderErr}        }    }    dec := func(s *Stream, val reflect.Value) (err error) {        if _, err := s.List(); err != nil {            return wrapStreamError(err, typ)        }        for i, f := range fields {            err := f.info.decoder(s, val.Field(f.index))            if err == EOL {                if f.optional {                    // The field is optional, so reaching the end of the list before                    // reaching the last field is acceptable. All remaining undecoded                    // fields are zeroed.                    zeroFields(val, fields[i:])                    break                }                return &amp;decodeError{msg: "too few elements", typ: typ}            } else if err != nil {                return addErrorContext(err, "."+typ.Field(f.index).Name)            }        }        return wrapStreamError(s.ListEnd(), typ)    }    return dec, nil}</code></pre><p>ä¸‹é¢åœ¨çœ‹å­—ç¬¦ä¸²çš„è§£ç è¿‡ç¨‹ï¼Œå› ä¸ºä¸åŒé•¿åº¦çš„å­—ç¬¦ä¸²æœ‰ä¸åŒæ–¹å¼çš„ç¼–ç ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å‰ç¼€çš„ä¸åŒæ¥è·å–å­—ç¬¦ä¸²çš„ç±»å‹ï¼Œ è¿™é‡Œæˆ‘ä»¬é€šè¿‡s.Kind()æ–¹æ³•è·å–å½“å‰éœ€è¦è§£æçš„ç±»å‹å’Œé•¿åº¦ï¼Œå¦‚æœæ˜¯Byteç±»å‹ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›Byteçš„å€¼ï¼Œ å¦‚æœæ˜¯Stringç±»å‹é‚£ä¹ˆè¯»å–æŒ‡å®šé•¿åº¦çš„å€¼ç„¶åè¿”å›ã€‚ è¿™å°±æ˜¯kind()æ–¹æ³•çš„ç”¨é€”ã€‚</p><pre><code class="go">// Bytes reads an RLP string and returns its contents as a byte slice.// If the input does not contain an RLP string, the returned// error will be ErrExpectedString.func (s *Stream) Bytes() ([]byte, error) {    kind, size, err := s.Kind()    if err != nil {        return nil, err    }    switch kind {    case Byte:        s.kind = -1 // rearm Kind        return []byte{s.byteval}, nil    case String:        b := make([]byte, size)        if err = s.readFull(b); err != nil {            return nil, err        }        if size == 1 &amp;&amp; b[0] &lt; 128 {            return nil, ErrCanonSize        }        return b, nil    default:        return nil, ErrExpectedString    }}</code></pre><h3 id="4-Stream-ç»“æ„åˆ†æ"><a href="#4-Stream-ç»“æ„åˆ†æ" class="headerlink" title="4. Stream ç»“æ„åˆ†æ"></a>4. Stream ç»“æ„åˆ†æ</h3><p>è§£ç å™¨çš„å…¶ä»–ä»£ç å’Œç¼–ç å™¨çš„ç»“æ„å·®ä¸å¤šï¼Œ ä½†æ˜¯æœ‰ä¸€ä¸ªç‰¹æ®Šçš„ç»“æ„æ˜¯ç¼–ç å™¨é‡Œé¢æ²¡æœ‰çš„ã€‚é‚£å°±æ˜¯Streamã€‚ è¿™ä¸ªæ˜¯ç”¨æ¥è¯»å–ç”¨æµå¼çš„æ–¹å¼æ¥è§£ç RLPçš„ä¸€ä¸ªè¾…åŠ©ç±»ã€‚ å‰é¢æˆ‘ä»¬è®²åˆ°äº†å¤§è‡´çš„è§£ç æµç¨‹å°±æ˜¯é¦–å…ˆé€šè¿‡Kind()æ–¹æ³•è·å–éœ€è¦è§£ç çš„å¯¹è±¡çš„ç±»å‹å’Œé•¿åº¦,ç„¶åæ ¹æ®é•¿åº¦å’Œç±»å‹è¿›è¡Œæ•°æ®çš„è§£ç ã€‚ é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•å¤„ç†ç»“æ„ä½“çš„å­—æ®µåˆæ˜¯ç»“æ„ä½“çš„æ•°æ®å‘¢ï¼Œ å›å¿†æˆ‘ä»¬å¯¹ç»“æ„ä½“è¿›è¡Œå¤„ç†çš„æ—¶å€™ï¼Œé¦–å…ˆè°ƒç”¨s.List()æ–¹æ³•ï¼Œç„¶åå¯¹æ¯ä¸ªå­—æ®µè¿›è¡Œè§£ç ï¼Œæœ€åè°ƒç”¨s.EndList()æ–¹æ³•ã€‚ æŠ€å·§å°±åœ¨è¿™ä¸¤ä¸ªæ–¹æ³•é‡Œé¢ï¼Œ ä¸‹é¢æˆ‘ä»¬çœ‹çœ‹è¿™ä¸¤ä¸ªæ–¹æ³•ã€‚</p><pre><code class="go">// Stream can be used for piecemeal decoding of an input stream. This// is useful if the input is very large or if the decoding rules for a// type depend on the input structure. Stream does not keep an// internal buffer. After decoding a value, the input reader will be// positioned just before the type information for the next value.//// When decoding a list and the input position reaches the declared// length of the list, all operations will return error EOL.// The end of the list must be acknowledged using ListEnd to continue// reading the enclosing list.//// Stream is not safe for concurrent use.type Stream struct {    r ByteReader    remaining uint64   // number of bytes remaining to be read from r    size      uint64   // size of value ahead    kinderr   error    // error from last readKind    stack     []uint64 // list sizes    uintbuf   [8]byte  // auxiliary buffer for integer decoding    kind      Kind     // kind of value ahead    byteval   byte     // value of single byte in type tag    limited   bool     // true if input limit is in effect}</code></pre><p>Streamçš„Listæ–¹æ³•ï¼Œå½“è°ƒç”¨Listæ–¹æ³•çš„æ—¶å€™ã€‚æˆ‘ä»¬å…ˆè°ƒç”¨Kindæ–¹æ³•è·å–ç±»å‹å’Œé•¿åº¦ï¼Œå¦‚æœç±»å‹ä¸åŒ¹é…é‚£ä¹ˆå°±æŠ›å‡ºé”™è¯¯ï¼Œç„¶åæˆ‘ä»¬æŠŠä¸€ä¸ªlistposå¯¹è±¡å‹å…¥åˆ°å †æ ˆï¼Œè¿™ä¸ªå¯¹è±¡æ˜¯å…³é”®ã€‚ è¿™ä¸ªå¯¹è±¡çš„poså­—æ®µè®°å½•äº†å½“å‰è¿™ä¸ªlistå·²ç»è¯»å–äº†å¤šå°‘å­—èŠ‚çš„æ•°æ®ï¼Œ æ‰€ä»¥åˆšå¼€å§‹çš„æ—¶å€™è‚¯å®šæ˜¯0. sizeå­—æ®µè®°å½•äº†è¿™ä¸ªlistå¯¹è±¡ä¸€å…±éœ€è¦è¯»å–å¤šå°‘å­—èŠ‚æ•°æ®ã€‚è¿™æ ·æˆ‘åœ¨å¤„ç†åç»­çš„æ¯ä¸€ä¸ªå­—æ®µçš„æ—¶å€™ï¼Œæ¯è¯»å–ä¸€äº›å­—èŠ‚ï¼Œå°±ä¼šå¢åŠ posè¿™ä¸ªå­—æ®µçš„å€¼ï¼Œå¤„ç†åˆ°æœ€åä¼šå¯¹æ¯”poså­—æ®µå’Œsizeå­—æ®µæ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœä¸ç›¸ç­‰ï¼Œé‚£ä¹ˆä¼šæŠ›å‡ºå¼‚å¸¸ã€‚</p><pre><code class="go">// List starts decoding an RLP list. If the input does not contain a// list, the returned error will be ErrExpectedList. When the list's// end has been reached, any Stream operation will return EOL.func (s *Stream) List() (size uint64, err error) {    kind, size, err := s.Kind()    if err != nil {        return 0, err    }    if kind != List {        return 0, ErrExpectedList    }    // Remove size of inner list from outer list before pushing the new size    // onto the stack. This ensures that the remaining outer list size will    // be correct after the matching call to ListEnd.    if inList, limit := s.listLimit(); inList {        s.stack[len(s.stack)-1] = limit - size    }    s.stack = append(s.stack, size)    s.kind = -1    s.size = 0    return size, nil}</code></pre><p>Streamçš„ListEndæ–¹æ³•ï¼Œå¦‚æœå½“å‰è¯»å–çš„æ•°æ®æ•°é‡posä¸ç­‰äºå£°æ˜çš„æ•°æ®é•¿åº¦sizeï¼ŒæŠ›å‡ºå¼‚å¸¸ï¼Œç„¶åå¯¹å †æ ˆè¿›è¡Œpopæ“ä½œï¼Œå¦‚æœå½“å‰å †æ ˆä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå°±åœ¨å †æ ˆçš„æ ˆé¡¶çš„posåŠ ä¸Šå½“å‰å¤„ç†å®Œæ¯•çš„æ•°æ®é•¿åº¦(ç”¨æ¥å¤„ç†è¿™ç§æƒ…å†µâ€“ç»“æ„ä½“çš„å­—æ®µåˆæ˜¯ç»“æ„ä½“ï¼Œ è¿™ç§é€’å½’çš„ç»“æ„)</p><pre><code class="go">// ListEnd returns to the enclosing list.// The input reader must be positioned at the end of a list.func (s *Stream) ListEnd() error {    // Ensure that no more data is remaining in the current list.    if inList, listLimit := s.listLimit(); !inList {        return errNotInList    } else if listLimit &gt; 0 {        return errNotAtEOL    }    s.stack = s.stack[:len(s.stack)-1] // pop    s.kind = -1    s.size = 0    return nil}</code></pre><h1 id="å‚è€ƒèµ„æ–™åœ°å€"><a href="#å‚è€ƒèµ„æ–™åœ°å€" class="headerlink" title="å‚è€ƒèµ„æ–™åœ°å€"></a>å‚è€ƒèµ„æ–™åœ°å€</h1><ul><li><a href="https://ethereum.org/en/whitepaper">ä»¥å¤ªåŠç™½çš®ä¹¦</a></li><li><a href="https://ethereum.github.io/yellowpaper/paper.pdf">ä»¥å¤ªåŠé»„çš®ä¹¦ï¼ˆè‹±æ–‡ç‰ˆï¼‰</a></li><li><a href="https://github.com/wanshan1024/ethereum_yellowpaper/blob/master/ethereum_yellow_paper_cn.pdf">ä»¥å¤ªåŠé»„çš®ä¹¦ï¼ˆä¸­æ–‡ç‰ˆï¼‰</a></li><li><a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis">åˆ†æå‚è€ƒèµ„æ–™</a></li><li><a href="https://segmentfault.com/a/1190000016050921">åšå®¢å‚è€ƒèµ„æ–™</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntuå®‰è£…Redis</title>
      <link href="/1900/01/01/other/Ubuntu%E5%AE%89%E8%A3%85Redis/"/>
      <url>/1900/01/01/other/Ubuntu%E5%AE%89%E8%A3%85Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntuå®‰è£…Redis"><a href="#Ubuntuå®‰è£…Redis" class="headerlink" title="Ubuntuå®‰è£…Redis"></a>Ubuntuå®‰è£…Redis</h1><h2 id="ä¸€ã€å‰ææ¡ä»¶"><a href="#ä¸€ã€å‰ææ¡ä»¶" class="headerlink" title="ä¸€ã€å‰ææ¡ä»¶"></a>ä¸€ã€å‰ææ¡ä»¶</h2><p>éœ€è¦è¿æ¥äº’è”ç½‘ï¼Œç„¶åæ‰§è¡Œsudo apt-get updateæ›´æ–°è½¯ä»¶åŒ…</p><h2 id="äºŒã€æ‰§è¡Œå®‰è£…å‘½ä»¤"><a href="#äºŒã€æ‰§è¡Œå®‰è£…å‘½ä»¤" class="headerlink" title="äºŒã€æ‰§è¡Œå®‰è£…å‘½ä»¤"></a>äºŒã€æ‰§è¡Œå®‰è£…å‘½ä»¤</h2><p>sudo  apt-get install redis-server æ‰§è¡Œåå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬è¾“å…¥y ç¡®è®¤å®‰è£…å¹¶ä½¿ç”¨ç©ºé—´</p><p><img src="https://img-blog.csdnimg.cn/20200809101003516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>æ¥ä¸‹æ¥ä¼šæ‰§è¡Œå®Œæˆï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åŒ…æ‹¬redisçš„ç‰ˆæœ¬ä¿¡æ¯ç­‰ï¼Œæ‰§è¡Œservice  redis status å¯ä»¥æŸ¥çœ‹redisæœåŠ¡çš„çŠ¶æ€ä¸ºrunningï¼Œè¯´æ˜å®‰è£…å®Œæˆç³»ç»Ÿè‡ªåŠ¨å¯åŠ¨äº†æœåŠ¡<br><img src="https://img-blog.csdnimg.cn/2020080910101782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h2 id="ä¸‰ã€é…ç½®redisæœåŠ¡"><a href="#ä¸‰ã€é…ç½®redisæœåŠ¡" class="headerlink" title="ä¸‰ã€é…ç½®redisæœåŠ¡"></a>ä¸‰ã€é…ç½®redisæœåŠ¡</h2><p>3.1ï¼šå¼€å¯è¿œç¨‹è¿æ¥<br>æ‰¾åˆ°/etc/redis/redis.confæ–‡ä»¶ä¿®æ”¹å¦‚ä¸‹:</p><p>æ³¨é‡Šæ‰  127.0.0.1   #bind 127.0.0.1ï¼Œå¦‚æœä¸éœ€è¦è¿œç¨‹è¿æ¥redisåˆ™ä¸éœ€è¦è¿™ä¸ªæ“ä½œ<br><img src="https://img-blog.csdnimg.cn/20200809101128860.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>3.2ï¼šè®¾ç½®å¯†ç <br>æ‰¾åˆ°/etc/redis/redis.confæ–‡ä»¶ä¿®æ”¹å¦‚ä¸‹:</p><p>æ·»åŠ   requirepass kingredisï¼ˆå¯†ç è®¾ç½®ä¸ºkingredisï¼‰</p><p><img src="https://img-blog.csdnimg.cn/20200809101317268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><h2 id="å››ã€æµ‹è¯•redisæœåŠ¡ï¼ˆå¯é€‰ï¼‰"><a href="#å››ã€æµ‹è¯•redisæœåŠ¡ï¼ˆå¯é€‰ï¼‰" class="headerlink" title="å››ã€æµ‹è¯•redisæœåŠ¡ï¼ˆå¯é€‰ï¼‰"></a>å››ã€æµ‹è¯•redisæœåŠ¡ï¼ˆå¯é€‰ï¼‰</h2><p>æ­¥éª¤ä¸‰çš„æ“ä½œå®Œæˆåï¼Œé‡å¯redisæœåŠ¡</p><pre><code>$ redis-server       # å¯åŠ¨æœåŠ¡$ redis-cli          # å¯åŠ¨å®¢æˆ·ç«¯$ redis-cli shutdown # å…³é—­æœåŠ¡</code></pre><p>å¦‚æœå‡ºç°ä»¥ä¸Šå‘½ä»¤æ— æ³•å…³é—­redis-serverçš„æƒ…å†µä¸‹è§£å†³åŠæ³•å¦‚ä¸‹ï¼š</p><p>ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å¯åŠ¨é‡å¯å’Œå…³é—­</p><p>$ /etc/init.d/redis-server stop     # åœæ­¢<br>$ /etc/init.d/redis-server start    # å¯åŠ¨<br>$ /etc/init.d/redis-server restart  # é‡å¯<br>æˆ‘çš„å®‰è£…æƒ…å†µæ˜¯é»˜è®¤å®‰è£…åä¿æŠ¤æ¨¡å¼å’Œåå°å¯åŠ¨æ¨¡å¼å‡ä¸ºå¼€å¯çŠ¶æ€ï¼Œæ ¹æ®éœ€è¦é…ç½®ä¸ºå…³é—­ã€‚<br>æŸ¥çœ‹ä¸‹é¢çš„ç®€å•é…ç½®ã€‚<br><img src="https://img-blog.csdnimg.cn/20200809103047400.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><p>4.1ï¼šæµ‹è¯•å¯†ç è®¾ç½®æˆåŠŸ</p><p>æ‰§è¡Œredis-cliå‘½ä»¤æ‰“å¼€rediså®¢æˆ·ç«¯  setæ“ä½œ    çš„æ—¶å€™è¦æ±‚è¾“å…¥å¯†ç ï¼Œè¯´æ˜å¯†ç è®¾ç½®æˆåŠŸï¼Œæ‰§è¡Œauth å¯†ç éªŒè¯å¯†ç åï¼Œå¯ä»¥æ‰§è¡Œsetæ“ä½œ<br>auth ä½ çš„å¯†ç </p><p>4.2ï¼šæµ‹è¯•è¿œç¨‹ç™»å½•</p><p>ä½¿ç”¨Redisè¿æ¥å·¥å…·è¿›è¡Œè¿œç¨‹è¿æ¥ï¼Œä¾‹å¦‚ä½¿ç”¨RedisInsight(<a href="https://redis.com/redis-enterprise/redis-insight">ç‚¹æˆ‘ä¸‹è½½</a>)</p>]]></content>
      
      
      
        <tags>
            
            <tag> éƒ¨ç½²æ–‡æ¡£ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockeræ“ä½œFabricå¸¸ç”¨å‘½ä»¤</title>
      <link href="/1900/01/01/blockchain/fabric/Docker%E6%93%8D%E4%BD%9CFabric%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/1900/01/01/blockchain/fabric/Docker%E6%93%8D%E4%BD%9CFabric%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Enter password to read.">    <label for="pass">Enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> éƒ¨ç½²æ–‡æ¡£ </tag>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>åŸºäºåŒºå—é“¾çš„æ¡£æ¡ˆåˆ†å‘ç³»ç»Ÿä»‹ç»</title>
      <link href="/1900/01/01/blockchain/fabric/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%A1%A3%E6%A1%88%E5%88%86%E5%8F%91%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/"/>
      <url>/1900/01/01/blockchain/fabric/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%A1%A3%E6%A1%88%E5%88%86%E5%8F%91%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>æ¨èä½¿ç”¨äº‘æœåŠ¡å™¨:</strong><br><a href="https://curl.qcloud.com/uAWpwwiE">ã€è…¾è®¯äº‘ã€‘è½»é‡æ–°ç”¨æˆ·ä¸Šäº‘ç¦åˆ©ï¼Œ2æ ¸2G4M ä½è‡³ 50 å…ƒ/å¹´ èµ·ï¼Œ æŠ“ä½ä¸Šäº‘å¥½æ—¶æœºï¼</a></p></blockquote><blockquote><p><strong>è§£å†³é—®é¢˜æ­¥éª¤:</strong><br>é‡åˆ°é—®é¢˜è¯·å…ˆçœ‹æ–‡ç« æœ€åçš„å¸¸è§é—®é¢˜ä»¥åŠè¯„è®ºåŒº<br>æ— æ³•è§£å†³å¯ä»¥å…ˆç™¾åº¦/è°·æ­Œå°è¯•è§£å†³<br>ä¾æ—§æ— æ³•è§£å†³å¯ä»¥å°†é—®é¢˜é›†ä¸­æ±‡æ€»è”ç³»æˆ‘ï¼Œå¹¶åœ¨æœ€åé€šè¿‡è¯„è®ºæ–¹å¼è®°å½•åˆ°å¯¹åº”æ–‡ç« ä»¥ä¾¿ä»–äººæŸ¥çœ‹</p></blockquote><h2 id="ä¸€ã€å‰è¨€"><a href="#ä¸€ã€å‰è¨€" class="headerlink" title="ä¸€ã€å‰è¨€"></a>ä¸€ã€å‰è¨€</h2><p>æœ‰å¾ˆå¤šåŒå­¦ä¹Ÿéœ€è¦æ­å»ºè¿™ä¸ªç³»ç»Ÿå¸Œæœ›æˆ‘èƒ½å¸®ä»–ä»¬æ­å»ºï¼Œä½†æ˜¯æˆ‘ç¡®å®å¤ªå¿™äº†ï¼ˆæ‰“å·¥äººçš„æ— å¥ˆï¼‰ï¼Œæ‰€ä»¥åªèƒ½æŠ›ç –å¼•ç‰å°½æˆ‘æ‰€èƒ½æä¾›æ€è·¯å§ã€‚</p><p>è¿™ç¯‡åšå®¢æ˜¯æˆ‘å¯¹â€åŸºäºåŒºå—é“¾çš„æ¡£æ¡ˆåˆ†å‘ç®¡ç†ç³»ç»Ÿâ€é¡¹ç›®çš„æ€»ç»“ï¼š</p><p>â€œåŸºäºåŒºå—é“¾çš„æ¡£æ¡ˆåˆ†å‘ç®¡ç†ç³»ç»Ÿâ€œæ¼”ç¤ºè§†é¢‘ï¼š<a href="https://www.bilibili.com/video/bv13y4y137kF">https://www.bilibili.com/video/bv13y4y137kF</a></p><p>FabricåŒºå—é“¾ç¯å¢ƒé—®é¢˜ã€ä»£ç å¯åŠ¨æŠ¥é”™é—®é¢˜æˆ‘å¯ä»¥æä¾›å¸®åŠ©ï¼Œå…¶ä»–çš„SpringBootç›¸å…³é—®é¢˜ã€ä»£ç æ”¹é€ é—®é¢˜ã€æ™ºèƒ½åˆçº¦ç¼–å†™é—®é¢˜ç­‰è¯·ç™¾åº¦æˆ–æŸ¥çœ‹æˆ‘èµ é€çš„è§†é¢‘è¯¾ç¨‹ã€‚</p><h2 id="äºŒã€åŸç†å’Œæ¶‰åŠæŠ€æœ¯ç‚¹"><a href="#äºŒã€åŸç†å’Œæ¶‰åŠæŠ€æœ¯ç‚¹" class="headerlink" title="äºŒã€åŸç†å’Œæ¶‰åŠæŠ€æœ¯ç‚¹"></a>äºŒã€åŸç†å’Œæ¶‰åŠæŠ€æœ¯ç‚¹</h2><h3 id="1-åŸç†"><a href="#1-åŸç†" class="headerlink" title="1. åŸç†"></a>1. åŸç†</h3><p>ä¸‰å±‚æ¶æ„ï¼š</p><ul><li>åŒºå—é“¾ç½‘ç»œï¼šå­˜æ”¾æ•°æ®ï¼Œä½¿ç”¨Fabricæ­å»ºã€‚æ‰€ä»¥åœ¨è¿è¡Œè¿‡ç¨‹ä¸­éœ€è¦ä¿è¯è™šæ‹Ÿæœºä¸­çš„Fabricç½‘ç»œä¸€ç›´å¯åŠ¨</li><li>ç¼“å­˜å±‚ï¼šRedisï¼Œå°†å¸¸ç”¨çš„æ•°æ®å­˜äºRedisï¼Œä»¥æ­¤åŠ å¿«æŸ¥è¯¢é€Ÿåº¦</li><li>DAPPï¼šä½¿ç”¨Javaå¼€å‘ï¼Œå‰åç«¯ä½¿ç”¨æŠ€æœ¯ä¸ºSpringBootã€Thymeleafã€<a href="https://startbootstrap.com/theme/sb-admin-2">SB-Admin2</a> ,åœ¨Javaä»£ç ä¸­é€šè¿‡FabricSDKä¸Fabricç½‘ç»œè¿›è¡Œäº¤äº’ï¼ˆè§¦å‘é“¾ç ç­‰ï¼‰</li></ul><h3 id="2-æŠ€æœ¯ç‚¹"><a href="#2-æŠ€æœ¯ç‚¹" class="headerlink" title="2. æŠ€æœ¯ç‚¹"></a>2. æŠ€æœ¯ç‚¹</h3><ul><li>ã€å¿…é¡»ã€‘Linuxï¼šæ­å»ºFabricç½‘ç»œéœ€è¦ä½¿ç”¨Linuxå‘½ä»¤</li><li>ã€éå¿…é¡»ã€‘JavaWebã€SpringBootã€Thymeleafã€HTMLã€CSSã€JSï¼šå¦‚æœä¸éœ€è¦ä¿®æ”¹ä»£ç é‚£ä¹ˆåªéœ€è¦äº†è§£SpringBootå¯åŠ¨æ–¹å¼å³å¯ï¼Œéœ€è¦ä¿®æ”¹ä»£ç æœ€å¥½ç†Ÿæ‚‰è¿™äº›</li><li>ã€éå¿…é¡»ã€‘Goï¼šFabricçš„æ™ºèƒ½åˆçº¦è¿è¡Œåœ¨å®¹å™¨ä¸­ï¼Œå¯ä»¥ä½¿ç”¨Goã€Javaã€Node.jsè¯­è¨€å¼€å‘ã€‚å¦‚æœéœ€è¦é‡æ–°å¼€å‘åˆçº¦éœ€è¦ä¼šç”¨Goï¼Œç®€å•çœ‹çœ‹æ•™ç¨‹å°±å¯ä»¥</li><li>ã€éå¿…é¡»ã€‘åŒºå—é“¾åŸºç¡€ã€Fabric</li><li>ã€éå¿…é¡»ã€‘Dockerï¼šFabricç½‘ç»œåœ¨Dockerä¸­è¿è¡Œ</li><li>ã€éå¿…é¡»ã€‘Redisï¼šæ­å»ºèµ·æ¥å³å¯</li></ul><p>è¯´æ˜ï¼šä»¥ä¸ŠæŠ€æœ¯å¹¶ä¸æ˜¯è¦æ±‚éƒ½æŒæ¡ï¼Œåªæ˜¯è¯´æŒæ¡çš„è¶Šå¥½åšèµ·æ¥å¯èƒ½è¶Šå®¹æ˜“ã€‚</p><h2 id="ä¸‰ã€ç¯å¢ƒä»‹ç»"><a href="#ä¸‰ã€ç¯å¢ƒä»‹ç»" class="headerlink" title="ä¸‰ã€ç¯å¢ƒä»‹ç»"></a>ä¸‰ã€ç¯å¢ƒä»‹ç»</h2><h3 id="1-ç¡¬ä»¶ç¯å¢ƒ"><a href="#1-ç¡¬ä»¶ç¯å¢ƒ" class="headerlink" title="1. ç¡¬ä»¶ç¯å¢ƒ"></a>1. ç¡¬ä»¶ç¯å¢ƒ</h3><ul><li>Ubuntu16.04æœåŠ¡å™¨ï¼ˆç‰ˆæœ¬è¦æ±‚ä¸å¿…é¡»ï¼Œ18.04ã€20.04äº¦å¯ï¼‰</li></ul><h3 id="2-è½¯ä»¶ç¯å¢ƒ"><a href="#2-è½¯ä»¶ç¯å¢ƒ" class="headerlink" title="2. è½¯ä»¶ç¯å¢ƒ"></a>2. è½¯ä»¶ç¯å¢ƒ</h3><ul><li>Fabricï¼šFabric<font color="red"><strong>1.4.0</strong></font>ä½œä¸ºåŒºå—é“¾æ¡†æ¶</li><li>Javaï¼šè¿è¡ŒSpringBooté¡¹ç›®</li><li>Mavenï¼šé¡¹ç›®ä½¿ç”¨Mavenä»“åº“</li><li>Redisã€Redis Desktop Manager</li><li>XShellï¼šä¸Ubuntuè¿æ¥ä½¿ç”¨</li><li>XFTPï¼šä¸Ubuntuä¼ è¾“æ–‡ä»¶ä½¿ç”¨</li><li>IntelliJ IDEAï¼šä»£ç ç¼–è¾‘å™¨</li></ul><h2 id="å››ã€ç¯å¢ƒæ­å»ºæ­¥éª¤å’Œç¨‹åºä½¿ç”¨æ–¹å¼"><a href="#å››ã€ç¯å¢ƒæ­å»ºæ­¥éª¤å’Œç¨‹åºä½¿ç”¨æ–¹å¼" class="headerlink" title="å››ã€ç¯å¢ƒæ­å»ºæ­¥éª¤å’Œç¨‹åºä½¿ç”¨æ–¹å¼"></a>å››ã€ç¯å¢ƒæ­å»ºæ­¥éª¤å’Œç¨‹åºä½¿ç”¨æ–¹å¼</h2><p><font color="red"><strong>åœ¨è¿›è¡Œæ­¤æ­¥éª¤ä¹‹å‰æœ€å¥½å…ˆçœ‹è§†é¢‘è¯¾ç¨‹</strong></font></p><h3 id="1-Ubuntuä¸Šå‡†å¤‡åŸºç¡€ç¯å¢ƒ"><a href="#1-Ubuntuä¸Šå‡†å¤‡åŸºç¡€ç¯å¢ƒ" class="headerlink" title="1. Ubuntuä¸Šå‡†å¤‡åŸºç¡€ç¯å¢ƒ"></a>1. Ubuntuä¸Šå‡†å¤‡åŸºç¡€ç¯å¢ƒ</h3><ul><li>Ubuntuç³»ç»Ÿï¼šå®‰è£…VMwareè™šæ‹Ÿæœºå’ŒUbuntu16.04 64ä½ç³»ç»Ÿï¼ˆæˆ–18.04ã€20.04ï¼‰</li><li>Fabricç½‘ç»œï¼šæ­å»ºFabricå•æœºå¹¶è¿è¡Œå¯åŠ¨ï¼ˆé‡éš¾ç‚¹ï¼Œå¤šæœºéƒ¨ç½²æ›´åˆé€‚ï¼Œå› ä¸ºåŒºå—é“¾ä¸è¯¥æ˜¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä½œä¸ºå­¦ä¹ ä¸€ä¸ªèŠ‚ç‚¹å¤Ÿäº†ï¼‰ã€‚å‚è€ƒåšå®¢ï¼š<a href="/1900/01/01/blockchain/fabric/%E9%83%A8%E7%BD%B2Fabric-v1-4-0%E2%80%94%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2/" title="æ­å»ºFabricç¯å¢ƒå¹¶å¯åŠ¨">æ­å»ºFabricç¯å¢ƒå¹¶å¯åŠ¨</a></li><li>Redisç¯å¢ƒï¼šæ­å»ºè¿‡ç¨‹å‚è€ƒåšå®¢ï¼š<a href="/1900/01/01/other/Ubuntu%E5%AE%89%E8%A3%85Redis/" title="Ubuntuå®‰è£…Redis">Ubuntuå®‰è£…Redis</a></li></ul><h3 id="2-ä»£ç è¿è¡Œæœºå™¨ä¸Šå‡†å¤‡å¼€å‘ç¯å¢ƒ"><a href="#2-ä»£ç è¿è¡Œæœºå™¨ä¸Šå‡†å¤‡å¼€å‘ç¯å¢ƒ" class="headerlink" title="2. ä»£ç è¿è¡Œæœºå™¨ä¸Šå‡†å¤‡å¼€å‘ç¯å¢ƒ"></a>2. ä»£ç è¿è¡Œæœºå™¨ä¸Šå‡†å¤‡å¼€å‘ç¯å¢ƒ</h3><ul><li>IntelliJ IDEAï¼šè¿è¡Œä»£ç çš„ç¼–è¾‘å™¨</li><li>XShellï¼šè¿œç¨‹è¿æ¥Ubuntu</li><li>XFTPï¼šä¸Ubuntuè¿›è¡Œæ–‡ä»¶ä¼ è¾“</li><li>Javaç¯å¢ƒï¼šåœ¨è¿è¡Œä»£ç çš„æœºå™¨ä¸Šå®‰è£…JDK<font color="red"><strong>1.8</strong></font></li><li>Mavenç¯å¢ƒï¼šåœ¨è¿è¡Œä»£ç çš„æœºå™¨ä¸Šå®‰è£…Mavenï¼ŒåŒæ—¶<font color="red">é…ç½®ä½¿ç”¨å›½å†…æº</font></li></ul><h3 id="3-å¯åŠ¨ç¨‹åº"><a href="#3-å¯åŠ¨ç¨‹åº" class="headerlink" title="3. å¯åŠ¨ç¨‹åº"></a>3. å¯åŠ¨ç¨‹åº</h3><p>i) å‡†å¤‡è¯ä¹¦æ–‡ä»¶</p><p><font color="red">ä½¿ç”¨rootç”¨æˆ·</font>å°†åŒºå—é“¾æœåŠ¡å™¨ä¸Šçš„è¯ä¹¦æ–‡ä»¶copyåˆ°æœ¬åœ°é¡¹ç›®ä¸­ä»¥ä¾¿ä½¿ç”¨ï¼š<br>ä»<code>/home/ubuntu/gopath/src/github.com/hyperledger/fabric-samples/first-network/crypto-config</code><br>å¤åˆ¶åˆ°ï¼š<code>src/main/resources/file/fabric/crypto-config</code>ç›®å½•</p><p>ii) é…ç½®host</p><p>ä¿®æ”¹ä»£ç æ‰€åœ¨æœºå™¨ï¼ˆä¸æ˜¯Fabricæ‰€åœ¨æœºå™¨ï¼‰çš„hostæ˜ å°„åŒºå—é“¾ç½‘ç»œçš„åŸŸåexample.com</p><pre><code class="bash"># 192.168.31.131 ä¸ºæ­å»ºåŒºå—é“¾çš„æœåŠ¡å™¨çš„åœ°å€ï¼Œéœ€è¦æ ¹æ®å®é™…æƒ…å†µä¿®æ”¹192.168.31.131      orderer.example.com peer0.org1.example.com peer1.org1.example.com peer0.org2.example.com peer1.org2.example.com</code></pre><p>iii) æ£€æŸ¥RedisçŠ¶æ€</p><p>æ‰§è¡Œservice redis status å¯ä»¥æŸ¥çœ‹redisæœåŠ¡çš„çŠ¶æ€ä¸ºrunningï¼Œè¯´æ˜å®‰è£…å®Œæˆç³»ç»Ÿè‡ªåŠ¨å¯åŠ¨äº†æœåŠ¡ã€‚å¦åˆ™æ‰§è¡Œå‘½ä»¤<code>/etc/init.d/redis-server start</code></p><p>iv) ä¿®æ”¹Javaé…ç½®æ–‡ä»¶</p><ul><li>æŒ‰ç€æ³¨é‡Šä¿®æ”¹æ–‡ä»¶ï¼š</li></ul><p><code>src/main/java/com/springboot/config/PathConf.java</code>çš„<code>org1KeyFileName</code>å’Œ<code>org2KeyFileName</code></p><ul><li>ä¿®æ”¹<code>src/main/resources/application.yml</code>æ–‡ä»¶ä¸­çš„TODOæ³¨é‡Šéƒ¨åˆ†ï¼ˆredisè´¦å·å’Œå¯†ç ï¼‰</li></ul><p>v) å¯åŠ¨ä»£ç </p><p>è¿™é‡Œæå‰çœ‹ä¸€ä¸‹SpringBoot+Mavené¡¹ç›®å¦‚ä½•å¯åŠ¨ï¼Œæ±‚æ±‚é¡¹ç›®å¯åŠ¨é—®é¢˜å°±åˆ«å†é—®æˆ‘äº†ï½</p><ul><li>æ‰“å¼€ys-file-manageæ–‡ä»¶å¤¹ï¼Œé¡¹ç›®ç»“æ„ï¼š</li></ul><p><img src="/../images/fabric/image-20220320144055288.png" alt="image-20220320144055288"></p><ul><li><p>å°†pom.xmlæ·»åŠ åˆ°mavené¡¹ç›®ç„¶åç‚¹å‡»åˆ·æ–°æŒ‰é’®å¯¼å…¥ä¾èµ–åŒ…ï¼ˆå¦‚æœå·²æ“ä½œå¿½ç•¥è¯¥æ­¥éª¤ï¼‰</p><p><img src="/../images/fabric/image-20220320144304432.png" alt="image-20220320144304432"></p><p><img src="/../images/fabric/image-20220320144719203.png" alt="image-20220320144719203"></p></li><li><p>è¿è¡Œ<code>src/main/java/com/springboot/SpringBootFileManageApplication.java</code>ä»£ç å¯åŠ¨æœåŠ¡</p></li></ul><p><img src="/../images/fabric/springboot-startup.png" alt="image-20220317172522948"></p><p>vi) å®‰è£…ã€å®ä¾‹åŒ–é“¾ç </p><p>å¦‚æœä¿®æ”¹äº†æ™ºèƒ½åˆçº¦ä¸å¯ä½¿ç”¨æ­¤æ–¹å¼éƒ¨ç½²ï¼Œè¯·ä½¿ç”¨å‘½ä»¤è¡Œæ–¹å¼ï¼š<a href="/1900/01/01/blockchain/fabric/Docker%E6%93%8D%E4%BD%9CFabric%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Dockeræ“ä½œFabricå¸¸ç”¨å‘½ä»¤">Dockeræ“ä½œFabricå¸¸ç”¨å‘½ä»¤</a></p><p>é“¾æ¥ï¼š<a href="http://localhost:8089/FileManage/admin/chaincodeView">http://localhost:8089/FileManage/admin/chaincodeView</a></p><p><img src="/../images/fabric/image-20220328192236825.png" alt="image-20220328192236825"></p><p>ä¾æ¬¡è¾“å…¥é“¾ç åå’Œé“¾ç ç‰ˆæœ¬ï¼Œç„¶åä¾æ¬¡ç‚¹å‡»å®‰è£…åˆçº¦ã€å®ä¾‹åŒ–åˆçº¦ç­‰å¾…å¼¹çª—è¿”å›æç¤ºç»“æœ</p><p>vii) æ³¨å†Œç³»ç»Ÿç®¡ç†å‘˜</p><p>é“¾æ¥ï¼š<a href="http://localhost:8089/FileManage/admin/insertAdminInfoView">http://localhost:8089/FileManage/admin/insertAdminInfoView</a></p><p>æ³¨å†ŒæˆåŠŸåä¼šè¿”å›ç™»é™†IDï¼Œä½¿ç”¨æ­¤IDä½œä¸ºç”¨æˆ·åï¼Œè®¾ç½®çš„å¯†ç ä½œä¸ºç™»é™†å¯†ç è¿›è¡Œç™»å½•</p><p>æç¤ºï¼šä»£ç å¥å£®æ€§ä¸å¼ºï¼Œæ‰€ä»¥æœ€å¥½æ‰€æœ‰è¾“å…¥æ¡†éƒ½è¦è¾“å…¥å†…å®¹ï¼Œå¦åˆ™å¯èƒ½ä¼šæœ‰æƒ³ä¸åˆ°çš„bug</p><p>æ¡£æ¡ˆç®¡ç†å‘˜ç™»å½•åœ°å€ï¼š<a href="http://localhost:8089/FileManage/admin/adminLoginView">http://localhost:8089/FileManage/admin/adminLoginView</a></p><h2 id="äº”ã€éƒ¨åˆ†ä»£ç ä»‹ç»"><a href="#äº”ã€éƒ¨åˆ†ä»£ç ä»‹ç»" class="headerlink" title="äº”ã€éƒ¨åˆ†ä»£ç ä»‹ç»"></a>äº”ã€éƒ¨åˆ†ä»£ç ä»‹ç»</h2><h3 id="1-ä½¿ç”¨Fabric-Java-SDKè¿æ¥åŒºå—é“¾"><a href="#1-ä½¿ç”¨Fabric-Java-SDKè¿æ¥åŒºå—é“¾" class="headerlink" title="1. ä½¿ç”¨Fabric-Java SDKè¿æ¥åŒºå—é“¾"></a>1. ä½¿ç”¨Fabric-Java SDKè¿æ¥åŒºå—é“¾</h3><p>å‚è€ƒåšå®¢ï¼š<a href="/1900/01/01/blockchain/fabric/%E5%8C%BA%E5%9D%97%E9%93%BEFabric-sdk-java%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4/" title="å¦‚ä½•ä½¿ç”¨SDKè¿æ¥åŒºå—é“¾ç½‘ç»œ">å¦‚ä½•ä½¿ç”¨SDKè¿æ¥åŒºå—é“¾ç½‘ç»œ</a> </p><p>å‚è€ƒä»£ç ï¼š<a href="https://gitee.com/hbuzzs/FabricSDK/tree/master">Fabric-Java SDKä»£ç </a></p><h3 id="2-ç¼–å†™å¹¶éƒ¨ç½²æ™ºèƒ½åˆçº¦"><a href="#2-ç¼–å†™å¹¶éƒ¨ç½²æ™ºèƒ½åˆçº¦" class="headerlink" title="2. ç¼–å†™å¹¶éƒ¨ç½²æ™ºèƒ½åˆçº¦"></a>2. ç¼–å†™å¹¶éƒ¨ç½²æ™ºèƒ½åˆçº¦</h3><p>Goå¼€å‘æ™ºèƒ½åˆçº¦ï¼š<a href="https://gitee.com/hbuzzs/FileManageChainCode">æ™ºèƒ½åˆçº¦ä»£ç </a></p><h2 id="å…­ã€å¸¸è§é—®é¢˜"><a href="#å…­ã€å¸¸è§é—®é¢˜" class="headerlink" title="å…­ã€å¸¸è§é—®é¢˜"></a>å…­ã€å¸¸è§é—®é¢˜</h2><h3 id="1-æ³¨æ„è¦åˆ›å»ºè¶…çº§ç®¡ç†å‘˜è´¦å·ï¼Œå¦åˆ™æ— æ³•ç™»é™†"><a href="#1-æ³¨æ„è¦åˆ›å»ºè¶…çº§ç®¡ç†å‘˜è´¦å·ï¼Œå¦åˆ™æ— æ³•ç™»é™†" class="headerlink" title="1. æ³¨æ„è¦åˆ›å»ºè¶…çº§ç®¡ç†å‘˜è´¦å·ï¼Œå¦åˆ™æ— æ³•ç™»é™†"></a>1. æ³¨æ„è¦åˆ›å»ºè¶…çº§ç®¡ç†å‘˜è´¦å·ï¼Œå¦åˆ™æ— æ³•ç™»é™†</h3><p>æ³¨å†Œç³»ç»Ÿç®¡ç†å‘˜ï¼ˆè¶…çº§ç®¡ç†å‘˜ï¼‰é“¾æ¥ï¼š<a href="http://localhost:8089/FileManage/admin/insertAdminInfoView">http://localhost:8089/FileManage/admin/insertAdminInfoView</a></p><h3 id="2-ä½¿ç”¨XShellæˆ–XFTPè¿æ¥Ubuntuå¤±è´¥"><a href="#2-ä½¿ç”¨XShellæˆ–XFTPè¿æ¥Ubuntuå¤±è´¥" class="headerlink" title="2. ä½¿ç”¨XShellæˆ–XFTPè¿æ¥Ubuntuå¤±è´¥"></a>2. ä½¿ç”¨XShellæˆ–XFTPè¿æ¥Ubuntuå¤±è´¥</h3><p>å¯èƒ½åŸå› ï¼š</p><ul><li>è¿œç¨‹è¿æ¥IPé”™è¯¯</li><li>è¿œç¨‹è¿æ¥å¯†ç é”™è¯¯</li><li>è¿œç¨‹è¿æ¥ç«¯å£é”™è¯¯ï¼Œåº”ä½¿ç”¨22</li><li>Ubuntuä¸Šæ²¡æœ‰å®‰è£…SSHæœåŠ¡<pre><code class="shell"># é¦–å…ˆåœ¨æœåŠ¡å™¨ä¸Šå®‰è£…sshçš„æœåŠ¡å™¨ç«¯sudo apt-get install openssh-server# å¯åŠ¨ssh-server/etc/init.d/ssh restart# ç¡®è®¤ssh-serverå·²ç»æ­£å¸¸å·¥ä½œnetstat -tlp# çœ‹åˆ° tcp6 0 0 *:ssh *:* LISTEN - è¾“å‡ºè¯´æ˜ssh-serverå·²ç»åœ¨è¿è¡Œäº†</code></pre></li><li>Ubuntuæ²¡æœ‰å…è®¸ç™»å½•ç”¨æˆ·è¿œç¨‹ç™»å½•ï¼ˆä¾‹å¦‚æœªå…è®¸rootè¿œç¨‹ç™»å½•ï¼‰<pre><code class="shell"># ç¼–è¾‘/etc/ssh/sshd_configæ–‡ä»¶ï¼›sudo vim /etc/ssh/sshd_config# æ‰¾åˆ°é…ç½®å‚æ•°ï¼šPermitRootLogin å°†è¯¥å‚æ•°åé¢çš„å€¼ä¿®æ”¹ä¸ºyeså³å¯ï¼›# æŒ‰â€œescé”®â€ :wq  å›è½¦ï¼Œ  ä¿å­˜é€€å‡ºï¼›# ç»™rootç”¨æˆ·è®¾ç½®å¯†ç ï¼›sudo passwd root# è¾“å…¥ä¸¤éå¯†ç ï¼›ï¼ˆç»™rootç”¨æˆ·è®¾ç½®äº†å¯†ç åï¼Œå°±å·²ç»å¯ä»¥ä½¿ç”¨rootç”¨æˆ·ç™»é™†åˆ°ç³»ç»Ÿä¸­äº†ï¼‰# é‡å¯sshæœåŠ¡sudo  systemctl  restart  ssh</code></pre></li></ul><h3 id="3-æç¤ºè¯ä¹¦è®¤è¯å¤±è´¥"><a href="#3-æç¤ºè¯ä¹¦è®¤è¯å¤±è´¥" class="headerlink" title="3. æç¤ºè¯ä¹¦è®¤è¯å¤±è´¥"></a>3. æç¤ºè¯ä¹¦è®¤è¯å¤±è´¥</h3><p>æ£€æŸ¥Fabricä¸­çš„è¯ä¹¦æ–‡ä»¶å’Œä»£ç ä¸­çš„è¯ä¹¦æ–‡ä»¶æ˜¯å¦ä¸€è‡´</p><h3 id="4-Redisè¿æ¥å¼‚å¸¸"><a href="#4-Redisè¿æ¥å¼‚å¸¸" class="headerlink" title="4. Redisè¿æ¥å¼‚å¸¸"></a>4. Redisè¿æ¥å¼‚å¸¸</h3><p><img src="/../images/fabric/image-20220328191741714.png" alt="image-20220328191741714"></p><p>å¯èƒ½åŸå› ï¼š</p><ul><li>ä»£ç æ‰€åœ¨æœºå™¨æ˜¯å¦ä¸å¯ä»¥è¿æ¥åˆ°Redisï¼ˆå¯ä»¥pingå‘½ä»¤æµ‹è¯•ï¼‰</li><li>ä»£ç é…ç½®æ–‡ä»¶ä¸­çš„Redisçš„IPå’Œå¯†ç ä¸æ­£ç¡®</li><li>Redisæ²¡æœ‰å¼€å¯è¿œç¨‹è¿æ¥ï¼ˆæ­å»ºRedisåšå®¢ä¸­æœ‰ç›¸å…³ä»‹ç»ï¼‰</li><li>Redisæ²¡æœ‰è®¾ç½®å¯†ç </li></ul><h3 id="5-ä½¿ç”¨XFTPæ‹·è´æ–‡ä»¶ä¸å®Œæ•´ï¼Œç¼ºå°‘å¯†é’¥æ–‡ä»¶"><a href="#5-ä½¿ç”¨XFTPæ‹·è´æ–‡ä»¶ä¸å®Œæ•´ï¼Œç¼ºå°‘å¯†é’¥æ–‡ä»¶" class="headerlink" title="5. ä½¿ç”¨XFTPæ‹·è´æ–‡ä»¶ä¸å®Œæ•´ï¼Œç¼ºå°‘å¯†é’¥æ–‡ä»¶"></a>5. ä½¿ç”¨XFTPæ‹·è´æ–‡ä»¶ä¸å®Œæ•´ï¼Œç¼ºå°‘å¯†é’¥æ–‡ä»¶</h3><p>å¯èƒ½åŸå› ï¼šæœªä½¿ç”¨rootç”¨æˆ·ä¼ è¾“æ–‡ä»¶ï¼Œå¯†é’¥æ–‡ä»¶æ˜¯rootç”¨æˆ·æ‰å¯ä»¥ä¼ è¾“çš„ã€‚</p><h3 id="6-é¡¹ç›®å¯åŠ¨åå®‰è£…é“¾ç æŠ¥é”™"><a href="#6-é¡¹ç›®å¯åŠ¨åå®‰è£…é“¾ç æŠ¥é”™" class="headerlink" title="6. é¡¹ç›®å¯åŠ¨åå®‰è£…é“¾ç æŠ¥é”™"></a>6. é¡¹ç›®å¯åŠ¨åå®‰è£…é“¾ç æŠ¥é”™</h3><p><img src="/../images/fabric/image-20220429193102060.png" alt="image-20220429193102060"></p><p>å¯èƒ½åŸå› ï¼š</p><ul><li>æ–‡ä»¶è¯ä¹¦è·¯å¾„ä¸æ­£ç¡®ï¼Œæ˜¯å¦ä¿®æ”¹äº†<code>src/main/java/com/springboot/config/PathConf.java</code>çš„<code>org1KeyFileName</code>å’Œ<code>org2KeyFileName</code></li><li>æ£€æŸ¥é¡¹ç›®ç»“æ„æ˜¯å¦å¦‚ä¸‹ï¼š<img src="/../images/fabric/image-20220320144055288.png" alt="image-20220320144055288"></li></ul><p>å¦‚æœä¸¤ç§å¯èƒ½éƒ½ä¸æ˜¯ï¼Œé‚£ä¹ˆæ£€æŸ¥ä¸€ä¸‹é‚£ä¸ªè·¯å¾„æœ‰æ²¡æœ‰é‚£ä¸ªæ–‡ä»¶ï¼š</p><p><img src="/../images/fabric/image-20220429193457444.png" alt="image-20220429193457444"></p><h3 id="7-ä¸Fabricç½‘ç»œè¿æ¥è¶…æ—¶"><a href="#7-ä¸Fabricç½‘ç»œè¿æ¥è¶…æ—¶" class="headerlink" title="7. ä¸Fabricç½‘ç»œè¿æ¥è¶…æ—¶"></a>7. ä¸Fabricç½‘ç»œè¿æ¥è¶…æ—¶</h3><p><img src="/../images/fabric/image-20220429220100251.png" alt="image-20220429220100251"></p><p>å¯èƒ½åŸå› ï¼šFabricç½‘ç»œæ‰€åœ¨æœºå™¨æ€§èƒ½è¾ƒå·®ï¼Œè¿æ¥å¤±è´¥ï¼Œé‡è¯•æˆ–æé«˜Fabricæœºå™¨é…ç½®</p>]]></content>
      
      
      
        <tags>
            
            <tag> éƒ¨ç½²æ–‡æ¡£ </tag>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu16.04å®‰è£…éƒ¨ç½²Fabric v1.4.0 â€” å•æœºéƒ¨ç½²</title>
      <link href="/1900/01/01/blockchain/fabric/%E9%83%A8%E7%BD%B2Fabric-v1-4-0%E2%80%94%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2/"/>
      <url>/1900/01/01/blockchain/fabric/%E9%83%A8%E7%BD%B2Fabric-v1-4-0%E2%80%94%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Enter password to read.">    <label for="pass">Enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> éƒ¨ç½²æ–‡æ¡£ </tag>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric-SDK-Javaçš„ä½¿ç”¨æ­¥éª¤</title>
      <link href="/1900/01/01/blockchain/fabric/%E5%8C%BA%E5%9D%97%E9%93%BEFabric-sdk-java%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4/"/>
      <url>/1900/01/01/blockchain/fabric/%E5%8C%BA%E5%9D%97%E9%93%BEFabric-sdk-java%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Enter password to read.">    <label for="pass">Enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> éƒ¨ç½²æ–‡æ¡£ </tag>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
