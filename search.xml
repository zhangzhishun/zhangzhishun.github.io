<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Solidity学习</title>
      <link href="/2022/05/17/blockchain/ethereum/solidity/Solidity%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/17/blockchain/ethereum/solidity/Solidity%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="/2022/05/05/blockchain/ethereum/solidity/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86)/" title="Solidity学习笔记(基础部分)">Solidity学习笔记(基础部分)</a></li><li><a href="/2022/05/10/blockchain/ethereum/solidity/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%BA%94%E7%94%A8%E9%83%A8%E5%88%86)/" title="Solidity学习笔记(应用部分)">Solidity学习笔记(应用部分)</a></li><li><a href="/2022/05/17/blockchain/ethereum/solidity/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E6%94%BB%E5%87%BB)/" title="Solidity学习笔记(攻击)">Solidity学习笔记(攻击)</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NFT源码分析</title>
      <link href="/2022/05/17/blockchain/nft/NFT%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/05/17/blockchain/nft/NFT%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="0xcert-目录"><a href="#0xcert-目录" class="headerlink" title="0xcert 目录"></a>0xcert 目录</h1><ul><li><a href="/2022/02/26/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-0xcert-ERC721%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="NFT框架-0xcert-ERC721源码分析">NFT框架-0xcert-ERC721源码分析</a></li></ul><h1 id="Openzepplin-目录"><a href="#Openzepplin-目录" class="headerlink" title="Openzepplin 目录"></a>Openzepplin 目录</h1><ul><li><a href="/2022/05/01/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelin%E5%90%88%E7%BA%A6%E6%BA%90%E7%A0%81%E4%BB%8B%E7%BB%8D/" title="NFT框架-OpenZeppelin合约源码介绍">NFT框架-OpenZeppelin合约源码介绍</a></li><li><a href="/2022/05/10/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelinERC20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="NFT框架-OpenZeppelinERC20源码分析">NFT框架-OpenZeppelinERC20源码分析</a></li><li><a href="/2022/05/15/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelinERC721%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="NFT框架-OpenZeppelinERC721源码分析">NFT框架-OpenZeppelinERC721源码分析</a></li><li><a href="/2022/05/20/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelinERC1155%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="NFT框架-OpenZeppelinERC1155源码分析">NFT框架-OpenZeppelinERC1155源码分析</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> NFT </tag>
            
            <tag> OpenZeppelin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPFS and Friends: A Qualitative Comparison of Next Generation Peer-to-Peer Data Networks</title>
      <link href="/2022/04/28/distributed_storage/IPFS%20and%20Friends:%20A%20Qualitative%20Comparison%20of%20Next%20Generation%20Peer-to-Peer%20Data%20Networks/"/>
      <url>/2022/04/28/distributed_storage/IPFS%20and%20Friends:%20A%20Qualitative%20Comparison%20of%20Next%20Generation%20Peer-to-Peer%20Data%20Networks/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在本文中，我们将对下一代数据网络进行技术概述。我们使用选定的数据网络来介绍一般概念和强调新的发展。具体来说，我们提供了IPFS的更深层次的概述，以及Swarm、Hypercore Protocol、SAFE、Storj和Arweave的总体概述。我们确定常见的构建模块，并提供定性比较。从概述中，我们得出了未来关于数据网络的挑战和研究目标。</p><h2 id="I-概述"><a href="#I-概述" class="headerlink" title="I. 概述"></a>I. 概述</h2><p>集中式控制和治理会导致数据孤岛，这可能会影响可访问性、可用性和机密性。例如，数据访问可能会受到审查。与此同时，数据孤岛为数据泄露和数据出售提供了一个有价值的目标，这可能会危及安全和隐私。一般来说，用户会失去自己的控制权，并将其委托给云提供商。</p><p>打破数据竖井和减少信任假设的一个方向是点对点数据网络。这个术语概括了建立在点对点(P2P)网络之上的一系列数据存储方法，包括数据存储、复制、分发和交换等方面。作为典型的P2P网络，对等点可以直接交互，建立覆盖网络，共享资源，并可以做出自治的本地决策。因此，P2P数据网络努力共同管理和共享存储。虽然P2P网络的主要目标和原则在过去二十年中没有改变，但P2P网络随着时间的推移不断发展，提高了可用性和功能。在图1中，我们展示了从第一代到下一代数据网络的发展。</p><p><img src="/images/distributed_storage/image-20220428142211126.png" alt="image-20220428142211126"></p><p>图1 下一代P2P数据网络的先驱技术</p><h3 id="A-第一代数据网络"><a href="#A-第一代数据网络" class="headerlink" title="A. 第一代数据网络"></a>A. 第一代数据网络</h3><p>还有许多不同的旧P2P网络也可以归类为数据网络。1999年随着音频文件共享网络Napster的出现，P2P技术开始流行起来，紧随其后的是Gnutella，它可以共享所有类型的文件。Napster和Gnutella标志着P2P网络的开始，随后出现了许多专注于特定应用领域或新颖网络结构的P2P网络。例如Freenet实现了匿名存储和检索。Chord， CAN和Pastry提供了维护结构化覆盖网络拓扑的协议。特别是BitTorrent受到了用户和研究社区的广泛关注。BitTorrent引入了激励机制来实现帕累托效率，试图提高网络利用率，实现更高水平的鲁棒性。我们认为Napster、Gnutella、Freenet、BitTorrent等网络是第一代P2P数据网络，主要关注文件共享。</p><p>Androutsellis Theotokis和Spinellis提供了P2P内容分发技术的2004年发展概况——提供了对上一代技术的广泛概述。以前的其他工作也提供了对上一代的更仔细的研究，更密切地关注特定的P2P数据网络(例如，FreeNet和Past)或一般的分布式文件系统(例如，Google FS和Hadoop Distributed FS)。</p><p>P2P技术的进步和第一代数据网络的普及，影响了分布式文件系统和内容分发技术的领域。这种趋势也属于一般的数据网络，特别是P2P数据网络。</p><h3 id="B-Transistion阶段"><a href="#B-Transistion阶段" class="headerlink" title="B. Transistion阶段"></a>B. Transistion阶段</h3><p>在P2P文件共享系统中似乎缺失的一个组件是改善文件的长期存储和可用性的方法。随着2008年比特币的引入，P2P思想，特别是联合数据复制得到了新的关注。分布式分类账技术在分布式系统中提供可用性、完整性和复杂的容错能力。特别是，加密货币显示了其在去中心化环境中作为货币激励机制的潜力。这些以及其他的趋势和发展，例如Kademlia和信息中心网络，导致了我们称之为下一代P2P数据网络的发明。</p><h3 id="C-下一代数据网络"><a href="#C-下一代数据网络" class="headerlink" title="C.下一代数据网络"></a>C.下一代数据网络</h3><p>从2014年IPFS的引入开始，我们将下一代数据网络定义为分散共享和存储数据的系统和概念，这是在过去十年中出现的。我们提供下一代P2P数据网络的技术概述。与现有文献相比，我们提供了下一代数据网络，即P2P数据网络的比较概述。我们主要关注独立于区块链的使用的存储和内容共享。<br>在本文中，我们将展示这些新系统是如何构建的，它们如何利用从以前的系统中获得的知识，以及过去十年中新的发展和进步。我们确定这些系统的构建模块、相似性和趋势。虽然有些系统本身是其他应用程序的构建块，例如去中心化应用程序(DApps)，但我们主要关注系统的两个方面:内容分发和分布式存储。此外，我们还提供了激励机制的见解，用于检索或存储文件，或两者兼而有之。由于许多新的数据网络被开发，我们不能提供所有数据网络的全面概述。相反，我们将重点关注几个精选的系统，它们具有复杂或独特的机制、不同的用例以及不同程度的内容和用户隐私。我们的概述侧重于概念和实现细节的抽象，以提取一般的见解。然而，应该指出的是，由于正在进行的开发，系统很容易发生变化。我们的调查论文使用了广泛的来源，包括同行评议的论文、白皮书以及文档、规范和源代码。<br>具体来说，我们关注IPFS、Swarm、Hypercore Protocol、SAFE、Storj和Arweave。特别是IPFS(InterPlanetary File System, IPFS)作为区块链的存储层已经得到了广泛的应用，并成为了一系列研究的对象。此外，我们将这些系统的概述放在前面的系统和研究方向，即BitTorrent、信息中心网络和区块链。通过对比先驱系统，我们概述了数据网络的演变，并能够深入讨论下一代的进展。<br>在此基础上，我们提取了P2P数据网络的构建块和一些独特的方面。虽然所有的系统都允许分布式内容共享和存储，但它们似乎只关注其中的一个方面。也就是说，每个系统的目标都是服务于具有不同需求和关注点的略有不同的目的。这导致了在网络组织、文件查找、分散程度、冗余和隐私方面的不同设计决策。例如，Storj的目标是分布式云存储，而Hypercore协议则专注于分布式大型数据集。同样，IPFS的目标是取代web的客户端-服务器结构，因此需要比BitTorrent更关注数据查找，因为BitTorrent主要是每个文件都位于自己的覆盖网络中。同时，我们在构建数据网络的方法上发现了许多相似之处，例如，使用Kademlia来构建网络或寻找对等点，将文件分割成块，或激励不同的任务来增加功能。<br>其他关于下一代数据网络的研究尤其关注与区块链的交互。Huang等人主要涵盖了IPFS和Swarm, Benisi等人讨论了这些技术，更侧重于区块链方面。Casino等人仔细研究了去中心化存储的不变性及其后果和可能的威胁。然而，由于可伸缩性或延迟问题，一些数据网络明确决定不使用区块链。因此，在我们的调查论文中，我们对数据网络采取了更广泛的视角，着眼于区块链以外的数据网络的设计决策。<br>Naik和Keshavamurthy对最近的P2P网络给出了一个更普遍的观点。他们描述了下一个层次的P2P网络，像BitTorrent和Chord这样的经典网络的演变，并讨论了动荡下的性能方面。值得注意的是，他们对下一级网络的定义与我们的下一代网络的定义不同，因为他们将IPFS定义为“经典的P2P网络”。相反，我们认为，P2P数据网络是随着时间的推移而演变的，融合了新建立的领域的想法，例如，明确的激励机制。</p><h2 id="II-技术介绍"><a href="#II-技术介绍" class="headerlink" title="II. 技术介绍"></a>II. 技术介绍</h2><p>自P2P数据网络首次出现以来，已经过去了20多年。在此期间，这项技术不断发展，并影响了新网络的发展。我们观察到，基本上有三个“时代”的P2P数据网络:它开始于1999-2002年的P2P文件共享和网络，如BitTorrent和Kademlia，我们认为这是第一代。这个时代之后是一个“过渡阶段”，以信息为中心的网络和加密货币等新想法出现了。大约自2014年IPFS的发明以来，我们看到了新一代P2P数据网络的发展。为了更好地理解和欣赏这些影响，我们介绍了奠定基础的重要“先驱”技术，即BitTorrent、Kademlia、Information-Centric Networking、Self-Certifying Names和区块链。</p><h3 id="A-BitTorrent"><a href="#A-BitTorrent" class="headerlink" title="A. BitTorrent"></a>A. BitTorrent</h3><p>BitTorrent协议[6]是一种P2P文件共享协议。它有一个激励结构来控制下载行为，试图实现资源的公平消耗。BitTorrent的目标是提供一种比使用单一服务器更有效的方式来分发文件。这是通过在每次下载时复制文件这一事实实现的，从而使文件分发具有自伸缩性(self-scalable)。<br>文件以种子形式交换。一般来说，每个种子是一个P2P覆盖网络负责一个文件。为了用BitTorrent协议交换文件，需要创建一个.torrent类型的文件，其中包含文件的元数据和一个跟踪器(tracker)。也可以在一个.torrent文件中定义多个文件。种子文件需要被提供，例如，在网络服务器上，文件可以被共享。跟踪器作为种子的引导节点。具有完整文件的对等点称为种子点。仍然没有命中数据块的节点被称为leechers。leecher请求数据块，并同时作为已经下载的块的下载点。<br>BitTorrent如何处理文件的概念概述见图2。角色和他们的交互如下:一个对等体获得.torrent文件，联系.torrent文件中列出的tracker 𝑇，获得一个对等体列表，连接到对等体，成为一个leecher。在图中，对等体𝑆0作为文件的种子，而对等体𝐿𝑖代表请求不同块的leecher。如.torrent文件所示，该文件被分割为𝑐𝑗块。当leecher成功地获得了所有的块后，它就变成了一颗新的种子。Seed𝑆0和leechers为文件建立了torrent网络。其他文件分布在不同的种子网络与可能不同的对等。</p><p><img src="/images/distributed_storage/image-20220428145010491.png" alt="image-20220428145010491">除了集中呈现的跟踪器，还有无跟踪的种子(trackerless torrents)。在无跟踪torrent中，种子是通过一个分布式哈希表(DHT)找到的。客户端从torrent文件中获取密钥，DHT返回可用的torrent对等点列表。BitTorrent客户端可以使用预先确定的节点或由torrent文件提供的节点来引导DHT。<br>使BitTorrent独一无二(可能是成功的)的特性是明确激励对等点交换数据，这是在文件共享策略中最稀有的部分首先和tit-for-tat实现的。最稀有的部分首先描述了BitTorrent的区块选择。它确保了块重叠的最小化，使文件交换对于节点变动更加健壮。最好选择网络中最不常见的块进行下载。针锋相对描述了带宽资源分配机制。在BitTorrent对等点决定谁他们上传数据基于下载的数据从对等点。这应该防止leecher只下载而不提供任何资源给别人。<br>BitTorrent得到了很好的研究，并证明了它的时间考验。尽管它已经很老了，但仍有数百万人在积极地使用[45]来共享文件，并为较新的点对点文件分发系统提供了一个榜样。此外，BitTorrent基金会和Tron基金会开发了BitTorrent Token (BTT)，作为基于区块链的激励层，以增加文件的可用性和持久性。新的激励结构通过收购数据扩大了针锋相对的竞争。报价数据(bid data)决定了对等端为持续服务满足的BTT/byte速率。作为支付的交换，对端被解除阻塞并有资格接收数据。令牌的交换由支付通道处理。</p><h3 id="B-Kademlia"><a href="#B-Kademlia" class="headerlink" title="B. Kademlia"></a>B. Kademlia</h3><p>从今天的角度来看，Kademlia可能是使用最广泛的DHT。正如我们稍后将看到的，大多数P2P数据网络都以某种方式构建在Kademlia之上。Kademlia还影响了P2P文件交换协议，如BitTorrent，它通过使用基于Kademlia的DHT支持无跟踪的torrent。<br>一般来说，Kademlia可以被归类为结构化的覆盖网络，它规定了如何构造和维护P2P网络。为此，对等体被分配一个身份，这个身份决定了它的位置，进而决定了它的邻居。对于邻居选择，使用异或度量。异或度规的优点是它是对称的和单向的。根据它们的XOR距离，节点被分类为𝑘-buckets。bucket被排列成二叉树，其中最短的前缀决定了bucket。如果一个新节点属于一个包含𝑘个节点(包括它自己)的桶，那么这个桶将被分成更小的桶，否则这个新节点将被丢弃。具有8位标识符的示例性Kademlia树如图3所示。</p><p><img src="/images/distributed_storage/image-20220428145024512.png" alt="image-20220428145024512"></p><h3 id="C-Information-Centric-Networking"><a href="#C-Information-Centric-Networking" class="headerlink" title="C. Information-Centric Networking"></a>C. Information-Centric Networking</h3><p>另一个值得一提的前身是信息中心网络(ICN)。尽管ICN不是一个P2P数据网络，但它的一些想法和概念至少与某些数据网络相似。与P2P数据网络不同，ICN提出改变网络层。包的路由和流应该从点对点位置搜索更改为直接从网络请求内容。举个例子，让我们假设我们想要检索一些数据，例如，一个网站，并且我们知道这个网站在example.com是可用的。首先，我们通过DNS请求站点主机的位置，即IP地址。然后，我们建立一个连接来检索网站。在ICN中，我们将直接请求数据，而不会寻址数据所在的主机。任何存储网站的节点都可以立即提供数据。<br>Jacobson等人提出了以内容为中心的网络，其中这些内容请求是interest packet。内容的所有者可以直接用包含该内容的数据包回答感兴趣的数据包。这就需要在基础设施级别上实现流量控制、路由和安全的其他机制。对interest packet进行广播，对数据感兴趣的对等体可以共享资源。目前有多个处理ICN的项目，例如命名数据网络(NDN)。对于Ntorrent，Mastorakis等人提出了一个NDN的扩展，在NDN中实现了一个类似bittorrent的机制。关于ICN的更多一般信息可在中找到。由于数据网络以内容为中心的性质，它们可以被广泛地解释为ICN的覆盖实现。</p><h3 id="D-Self-Certifying-Names"><a href="#D-Self-Certifying-Names" class="headerlink" title="D .Self-Certifying Names"></a>D .Self-Certifying Names</h3><p>从以主机为中心的通信到以内容为中心的通信的变化引入了新的安全问题。此外，当缓存成为网络的主要特征时，需要考虑特定的威胁，例如缓存中毒或针对缓存的拒绝服务攻击。更广泛地说，ICN的安全问题一般包括内容认证、授权和访问控制以及隐私。<br>目前，安全研究的主要焦点在于认证。由于缓存的广泛使用，数据提供者不再一定是对象的原始源(数据所有者)。这需要使接收者能够评估对象的有效性(完整性)、来源(内容来源)和相关性的机制。<br>确保有效性和相关性的一种方法是自我认证名称。可以使用散列指针(或更通用的内容散列)来引用内容，从而启用自认证名称。文件的内容被用作加密哈希函数的输入，例如SHA-3。得到的摘要可以用来识别内容，客户机可以在本地验证文件的完整性。哈希函数的加密特性，最重要的是预图像和抗碰撞，确保没有人可以在不改变摘要的情况下替换或修改输入数据。在这种情况下，名称提供了完整性和相关性，但是，谁负责验证对象，例如，客户端和/或中间端，仍然是值得怀疑的。此外，自我证明的名称本身不能提供出处或证明物体的来源。加密签名可以保证对象来源的真实性，但需要公钥基础设施或信任网络来验证签名。虽然这允许验证对象来源的真实性，但仍然可能发送格式不正确的对象，因此需要确保完整性的机制。通过缓存的内容的寿命需要谨慎的密钥管理，以防止加密凭据被破坏。<br>访问控制也有类似的问题:一旦数据发布，就很难限制访问或撤销发布。加密可能会限制访问，但可能需要带外密钥分发。关于ICN的安全、隐私、访问控制和其他挑战的进一步见解见[53,54]。</p><h3 id="E-区块链"><a href="#E-区块链" class="headerlink" title="E. 区块链"></a>E. 区块链</h3><p>2008年比特币的引入为分布式应用提供了新的可能性。比特币是一种巧妙而复杂的组合，它结合了来自链接时间领域的各种想法——加密、数字现金、P2P网络、拜占庭容错和密码学。比特币带来的关键创新之一是一种开放的共识算法，它可以积极激励同行遵守规则。因此，它使用了在这个过程中生成的硬币的概念，即挖矿。<br>虽然术语区块链通常指整个系统及其协议，但它也指类似于哈希链或哈希树的特定数据结构。也就是说，区块链使用加密散列对链接到其前任的块进行排序。这种链接的数据结构确保了区块链数据(例如事务)的完整性。区块链的一致性由共识算法保证，例如比特币中的Nakamoto共识。有关比特币和区块链的更多细节，请参阅。<br>由于区块链受到诸如可伸缩性等问题的困扰，人们开发了不同的设计来缓解这些问题。不同的设计开辟了一个新的类别，称为分布式分类账技术(DLT)。dlt提供分布式、拜占庭式容错、不可变和有序的日志。不幸的是，由于一系列的可扩展性问题和链上存储容量有限，纯粹基于DLT的数据网络的可行性有限[57,58]。此外，在被设计为交换和价值存储媒介的区块链(即比特币等加密货币)中存储大量数据会导致高额的交易费用。然而，dlt的研究和开发表明了基于区块链的数据网络的可行性，例如Arweave(参见第4 - e节)。<br>然而，一般来说，允许去中心化支付的加密货币可以作为一种激励结构在P2P数据网络中使用。正如我们将在下文中阐述的，这种激励结构可以增加数据网络的健壮性和可用性，从而解决前几代人的弱点。</p><h2 id="III-INTERPLANETARY-FILE-SYSTEM-IPFS"><a href="#III-INTERPLANETARY-FILE-SYSTEM-IPFS" class="headerlink" title="III. INTERPLANETARY FILE SYSTEM (IPFS)"></a>III. INTERPLANETARY FILE SYSTEM (IPFS)</h2><h2 id="IV-RELATED-P2P-DATA-NETWORKS"><a href="#IV-RELATED-P2P-DATA-NETWORKS" class="headerlink" title="IV. RELATED P2P DATA NETWORKS"></a>IV. RELATED P2P DATA NETWORKS</h2><h3 id="A-Swarm"><a href="#A-Swarm" class="headerlink" title="A. Swarm"></a>A. Swarm</h3><p>Swarm是一个由以太坊基金会开发的用于存储和交付内容的P2P分布式平台。它通过不允许任何删除，以及上传和忘记属性来抵抗审查。群是为以太坊构建的，因此在某些方面依赖并共享以太坊的设计方面。Swarm的目标是为web3栈提供去中心化的存储和流媒体功能，这是一个用于共享互动内容的去中心化的、抵制审查的环境。以太坊基金会将Swarm设想为“世界计算机的硬盘”。<br>与IPFS类似的是Swarm使用基于内容的寻址。与IPFS相反的是Swarm中基于内容的寻址也决定了存储位置。为了确保可用性，群控引入了职责范围。责任区域是节点的近邻。责任区域中的节点应该提供块冗余。通过版本控制支持可变性，保持文件的每个版本。提要、专门构造和寻址的块以及以太坊名称服务(ENS)用于查找变异文件。ENS是以太坊改进提案137中定义的标准。它提供了将地址转换为人类可读名称的能力。与IPNS不同，ENS是作为以太坊区块链上的智能合约来实现的。</p><p>图6是云计算的概念概述，我们继续使用作者和审稿人之间交换的调查论文作为运行例子。Swarm会将一个文件分割，也就是将调查分成一些块，这些块被安排在一个所谓的Swarm hash中。Swarm哈希是排列在Merkle树中的块的组合，其中叶节点代表输入数据，中间节点是子节点的引用组合。得到的数据块被上传到网络。群采用Kademlia拓扑结构，邻居由它们的标识距离决定。需要注意的是，除了桶的连接外，Swarm还依赖于一个最近的邻居集合，即该邻居的剩余节点。一个邻居基本上是包含至少三个其他对等节点的桶数量最少的桶。这个最近的邻居集负责复制，并且不一定是对称的。例如，在图6中，𝑁3的最近邻居是𝑁2，𝑁1和𝑁0，而𝑁12的邻居是𝑁8，𝑁9，𝑁10和𝑁11(参见图3)。上传的块被中继，存储和复制在最近的地址。要检索调查，必须使用群根哈希。网络根据内容地址转发请求。</p><p><img src="/images/distributed_storage/image-20220428151148330.png" alt="image-20220428151148330"></p><p>为了保证确保节点行为，Swarm提供了一个激励层。其激励机制基于SWAP、SWEAR和SWINDLE。SWAP (SWarm Accounting Proto- col)处理节点间数据交换的均衡。各节点维护本地计费信息。对等点基本上是在没有利息的情况下从服务节点购买一大块。区块的价格可以在同行之间协商。请求会被处理到某个不平衡的阈值，即块被不平衡地处理，债务变得过高。在达到第一个阈值后，节点希望得到债务的结清以进行进一步的服务。如果达到第二个阈值，则由于未清偿债务，节点断开连接。债务可以用支票结算，支票可以被理解为一种简单的单向支付渠道。SWarm Enforcement And Registration (SWEAR)和Secured With INsurance Deposit Litigation And Escrow (SWINDLE)将确保内容的持久性。此外，Swarm的激励机制有邮票，它提供了一种机制来防止垃圾上传，也提供了一种彩票机制来激励块的持续存储。<br>邮票可通过智能合约批量获取。邮票被附在上传的区块上，并由邮票所有者签名。这可以作为上传区块的付款凭证。只能通过中继或存储节点监控戳记的使用情况。这允许重复使用/过度使用邮票。为了减少过度使用戳记的风险，戳记只用于某些前缀冲突，将戳记限制为特定存储区域中的块。<br>邮票被用于抽奖。彩票为块提供了价值，以防止块的早期删除。通过抽签，存储节点可以获得邮票的部分初始成本。在彩票中选择一个地址区域。临近区域的节点可以申请奖励。通过应用，节点可以证明该区域内块的所有权。节点定义了存储块的价格。在证明拥有这些块之后，拥有最便宜奖品的节点获得奖励。讨论:群提供了复杂的激励概念。与依赖区块链交易相比，用支票结算不平衡检索提供了一种更快、更便宜的结算差异的方法。与彩票一起发行的邮票为储存大块的数据提供了额外的激励。此外，虽然上传内容需要花费成本，但节点可以通过主动为参与者提供块来赚取成本。然而，邮票可以将用户链接到上传的内容。虽然群集提供了一定程度的发送者匿名性，但上传的匿名性可能会限制可用的内容。<br>考虑到分布式块不可变存储(DISC)所确定的存储位置，网络可能面临存储问题。提要可以在网络中提供用户定义的空间，以恢复提要和固定的形式，可能能够减轻这些缺点。<br>总的来说，Swarm显然依赖于以太坊生态系统。虽然这有利于激励结构，但由于以太坊发展积极，用户基础广泛，这也需要用户对以太坊的依赖。虽然有这么庞大的潜在用户群，但对用例或Swarm机制的研究却很少。Swarm和以太坊的连接可能是缺乏研究的一个原因，因为Swarm似乎没有IPFS那么完整，而以太坊本身仍然保留着许多研究机会。</p><h3 id="B-Hypercore-Protocol-Dat"><a href="#B-Hypercore-Protocol-Dat" class="headerlink" title="B. Hypercore Protocol/Dat"></a>B. Hypercore Protocol/Dat</h3><p>Hypercore Protocol(以前的Dat Protocol)支持类似Git的内容和元数据的增量版本。Hypercore协议由多个子组件组成。严格地说，Hypercore是子组件之一，为了简单起见，我们使用这个术语来泛指Hypercore协议。在Hypercore中，数据存储在一个类似于BitTorrent结构的目录中，每个目录处理自己的网络。该协议支持不同的存储模式，每个节点可以决定目录中的哪些数据以及需要存储哪些版本的数据。此外，该协议支持订阅目录中所有/任何文件的实时更改。协议中的所有通信都是加密的。为了查找和读取数据，需要知道一个特定的读键。<br>该协议旨在共享大量可变数据。创建该协议的动机是为了防止科学文献的链接腐烂和内容漂移。该协议只允许随机访问部分数据。<br>Hypercore可以理解为共享一个文件夹。可以对文件夹中的文件进行修改、添加和删除操作。这也包括并允许可变文件。<br>Hypercore的概念概述如图7所示。对于对等发现，Hypercore使用Hyperswarm，一种基于Kademlia的DHT。如果作者想使用Hypercore协议共享调查结果，需要创建Hypercore并添加调查结果。要想被超perswarm发现，就必须加入超perswarm覆盖网络。通过共享公钥𝐾𝑃𝑢𝑏，审阅者可以计算发现密钥𝐾𝐷，并在找到对等点并加入数据网络后解密消息。一旦另一个覆盖网络加入，非结构化的志愿者网络就可以共享数据，调查可以被检索。<br>讨论:Hypercore允许通过交换公钥来共享数据。可以获取特定版本和特定区域的数据。这使得它变得简单，特别是对于大型数据集，并且允许可变数据。该协议专注于共享文件集合，这扩大了协议的可用性。<br>由于加密和发现密钥，该协议确保了机密性。公钥允许计算发现密钥，但不可能逆转公钥。这将阻止其他人读取数据。Hypercore的一个缺点是缺乏公钥以外的其他身份验证机制，这阻止了额外的细粒度访问控制。此外，它仍然泄漏元数据，因为发现密钥只是一个假名。<br>Hypercore没有复制数据的激励机制，数据的持久性依赖于参与者。利用或分析Hypercore/Dat的研究很少。虽然该协议似乎开发得很好，而且可用，但研究似乎侧重于IPFS。</p><h3 id="C-Secure-Access-For-Everyone-SAFE"><a href="#C-Secure-Access-For-Everyone-SAFE" class="headerlink" title="C. Secure Access For Everyone(SAFE)"></a>C. Secure Access For Everyone(SAFE)</h3><p>人人安全访问(SAFE)网络[17,81]被设计为一个完全自主的分散数据和通信网络。甚至认证也遵循自我认证[82]机制，它不依赖于任何集中组件。SAFE的主要目标是提供一个网络，每个人都可以加入并使用它来存储、查看和发布数据，而不会在机器上留下他们活动的痕迹。这将允许参与者以较低的迫害风险发布内容。<br>SAFE支持三种不同的数据类型:Map、Sequence和Blob。数据可以进一步分为公共数据和私有数据。Map和sequence是无冲突的复制数据类型，这对于确保可变数据的一致性很重要。Blob用于不可变数据。SAFE网络中的所有数据都是加密的，包括公共数据。使用的加密算法是自加密[83]，使用文件本身对文件进行加密。也就是说，一个文件被分割成至少三个固定大小的块。每个块使用前一个块的散列和加密，即𝑛−1，其中𝑛是当前块。之后，加密的块会被原始块的串接哈希值混淆。对于SAFE，混淆后的块存储在网络中。对于解密，在加密过程中会创建一个数据映射。数据映射包含关于文件的信息，并将模糊块的散列映射到真实块的散列。对于公共数据，解密密钥由网络提供。私人数据可以删除，而公共数据应该是永久的。因此，可变数据只能是私有的。名称解析系统允许人类可读的地址来检索数据。<br>网络本身是根据基于卡德米利亚的DHT由异或地址组织的。此外，网络被分成几个部分。当一个新的保险库想要加入网络时，新的保险库需要证明它可以提供所需的资源，然后被随机分配一个XOR地址，从而分配给一个节。这些部分是动态维护的。根据网络中保险库的数量，分区并将保险库重新分配到新的分区。对于长得太小的节，可以通过获取新节点或请求重新定位节点来平衡节的大小。更改section会增加保险库的节点年龄。节点年龄是信任的衡量标准，可以失去，然后必须重新赢得。在一个section中，只有一定数量的节点可以做出决策，即长者。长者是该区域中最古老的节点。由长老投票决定是否接受分区内的事件，经一定人数的长老同意并集体签字后生效。网络段中的事件是，例如，加入/离开一个节点或存储一个块。长者的真实性由SectionProofChain保证，SectionProofChain包含长者的群组签名，是证明一个区段有效性的公钥序列。每当长者组发生变化时，序列就会更新和签名。<br>SAFE网络的概念概述如图8所示。考虑到我们正在运行的示例，调查被划分为自加密的块，并用于生成数据地图。在完成自我认证过程后，向网络发送一个PUT请求。当负责存储块的区域中的长者同意后，数据就被存储。下载文件时，需要数据图。数据映射用于GET请求，以获取经过模糊处理的加密块。下载公共数据不需要认证。在获得这些块之后，可以在数据映射的帮助下重新创建文件。<br>在SAFE网络中，存储数据需要使用该网络自身的货币，即Safecoin。客户的安全币平衡由客户经理监控，并在外管局的共识机制的帮助下被批准/拒绝。节点可以通过耕种(即向请求者提供内容)赚取Safecoin。<br>讨论:自我认证、自我加密和网络组织给了用户对其数据的高度控制。中心组件的缺失减少了单点故障。此外，隐私和在一定程度上匿名是SAFE网络的关键特征。网络中仅存储数据时需要鉴权。检索数据通过客户端选择的代理进行中介，该代理提供了匿名通信。Safecoin旨在提供一个激励层，确保网络的可用性和可靠性。<br>Paul等人[84]在2014年首次对SAFE进行了安全分析，涉及机密性、完整性和可用性以及可能的攻击。2015年，Jacob等人[85]从真实性、完整性、保密性、可用性和匿名性等方面分析了网络的安全性。作者解释了如何利用自我认证和去中心化特性来揭示单个实体的个人数据。</p><h3 id="D-Storj"><a href="#D-Storj" class="headerlink" title="D. Storj"></a>D. Storj</h3><p>Storj[18]是一个P2P存储网络。下面我们引用的是3.0版本。它专注于数据的高持久性、低延迟以及存储数据的高安全性和私密性。支持对通信、文件位置和文件进行端到端加密。为了文件的高持久性或换句话说，文件在网络中更好的可用性，Storj使用了擦除码。此外，低带宽消耗也是设计的主要目标之一。该协议假设对象大小为4𝑀𝐵或更多，虽然支持较小的对象大小，但存储过程的效率可能较低。在Storj中，去中心化被解释为没有一个操作者单独负责系统的操作。在一个分散的系统中，信任和拜占庭式的失败假设是重要的。Storj假设没有利他的，总是表现良好的节点，大多数理性节点，只有在盈利时表现出恶意，还有少数拜占庭式恶意节点。<br>Storj的目标是成为去中心化的云存储。Storj Labs Inc.希望为集中式存储提供商提供另一种选择。为此，Storj提供了与Amazon S3应用程序编程接口的兼容性，以提高总体接受度并简化新用户的迁移。由于Storj提供了云存储，用户可以存储和检索数据，以及删除、移动和复制数据。<br>Storj网络由三种节点类型组成:卫星节点、存储节点和上行节点。卫星节点管理文件的存储过程和维护。对元数据甚至文件路径的加密增加了对元数据的额外保护。上行节点是终端用户，需要存储和访问文件。存储节点用于存储数据。存储和上行节点选择与哪些卫星节点合作。这导致了一个类似于BitTorrent的网络，其中卫星成为中心部分。<br>Storj的概念概述如图9所示。为了上传调查论文，作者需要将其分割成片段，然后对片段进行加密。作者要求卫星存储一个片段。卫星检查存储节点的容量并返回足够的候选存储列表。然后，片段被分割成条状，这些条状被擦除编码并排列成片段。然后，这些片段被并行上传至存储节点。</p><p>对于擦除编码，Storj使用Reed-Solomon擦除码[86]。对于erasure code，数据编码为(𝑘，𝑛)erasure code。这意味着，一个对象被编码为𝑛片段，以这种方式只需要𝑘片段就可以重新创建对象。Storj为每个对象选择四个值:𝑘、𝑚、𝑜和𝑛。𝑘表示重建数据所需的最小块数，𝑚是用于修复的缓冲区，𝑜是用于churn的缓冲区，𝑛是总块数。与多次存储数据块相比，Erasure code提供了更高的冗余，开销更小。此外，由于检索文件只需要𝑘片段，因此可以减少文件可用前的延迟。<br>上传完成后，一个包含片段元数据的指针(例如片段的哈希值、存储位置、擦除编码方案)被返回给卫星。对每个部分重复这个步骤，最后一个部分包含关于调查的额外元数据。如需下载调查报告，请提供各部分的指针。这些片段是由存储节点并行请求的。一旦收集到足够多的片段，就可以阅读调查报告了。<br>为了保证理性节点之间的合作，Storj提供了激励机制。奖励系统奖励存储节点存储和提供内容。通过审计和声誉系统对节点进行监控和评估。Storj的一个目标是低延迟，从而避免依赖区块链的激励机制。<br>讨论:与其他P2P数据网络相比，Storj使用了一些独特的概念。特别是，Amazon S3的兼容性可能会促进Storj成为去中心化的存储系统。擦除码增加了存储文件的开销，但在检索文件时，只需要下载必要数量的片段。通过擦除码的存储去中心化，以及足够的存储节点选择和声誉系统的帮助，增加了对数据泄露的保护。<br>卫星节点是网络的重要组成部分，并对网络进行分区，因为在一颗卫星上可用的文件在另一颗卫星上不可用。这促进了卫星形式的集中化。虽然由于加密，卫星无法与可能的第三方共享元数据，但仍然有可能泄露访问模式。<br>虽然已经部署了Storj，并且确实可以使用，但关于该主题的应用程序和研究相当少。De Figueiredo等人[87]分析了Storj网络，并将卫星节点识别为拒绝服务攻击的可能向量。他们修改了存储节点连接处理的实现，在测试环境中成功拿下了一个卫星节点，使得支付和文件检索在一段时间内无法实现。但是，生产系统应该能够抵抗这种攻击。另一项研究也显示了对数据网络的另一种攻击。Zhang等人[88]指出，在Storj v2.0中，可以将未加密的数据上传到存储节点，用于框架存储节点的所有者。尽管如此，Storj提供了隐私保障、弹性、可获取的元数据或每个人都可以部署不同节点的可能性，这些都可以为云存储提供有价值的见解。</p><h3 id="E-Arweave"><a href="#E-Arweave" class="headerlink" title="E. Arweave"></a>E. Arweave</h3><p>Arweave协议[19]利用了一种类似区块链的结构(称为blockweave)，为永久的链上数据存储以及存储支付提供了一种机制。在块组织中，一个块指向直接前一个块和召回块，召回块是基于前一个块的信息确定地选择的。虽然编织是不可改变的，并提供了对其数据的审查阻力，但每个节点都可以决定拒绝接受内容。通过足够多的节点拒绝内容可以防止包含不需要的内容。<br>Arweave使用了一种类似于BitTorrent的“tit-for-tat”的协议Wildfire来为同行排名。通过Wildfire，每个节点维护一个节点列表，并根据节点的响应能力(如响应请求或发送事务)进行评分和排名。这个分数基本上是由最近请求的平均每秒接收字节数决定的。级别高(因此性能最好)的对等点首先并行地接收消息，然后依次接收其余的消息。定期修剪连接到低等级对等体的连接。这激励节点自身高度响应，以尽可能快的速度接收消息。优化节点的资源利用率，减少通信时间。<br>Arweave的核心是基于区块链的网络。虽然野火引入了一个有利于某些连接的排名，但它仍然是一个非结构化的P2P网络。图10给出了Arweave的概念概述以及如何归档/检索文件。为了在Arweave中存档调查论文，有必要将交易发送到网络上。对等点通过将该交易包含在一个块中来确认该交易。如果有人想要阅读调查，网络被要求。如果一个对等点存储了包含调查的块，它可以被返回，调查可以被读取。</p><p><img src="/images/distributed_storage/image-20220428173237462.png" alt="image-20220428173237462">Arweave的目标是提供数据的永久存储，以一种不可变的方式保存和时间戳信息。数据存储在区块组织的链上，因此，是不可变的，只有通过分叉组织才能移除。blockweave为永久网络提供了去中心化存储。<br>blockweave及其数据的存储和维护通过Arweave的加密货币:Arweave代币来确保。代币用于奖励矿工和支付发送交易。<br>讨论:Arweave协议在类似区块链的结构上提供链上存储。这使得存储具有与区块链类似的优点和缺点。Arweave提供时间戳、透明度、激励机制和不可变存储。数据是通过提供匿名数据作者的事务存储的。<br>区块链最大的问题之一是可扩展性。Arweave试图通过区块阴影(一种类似于紧凑块的机制，在比特币改进提案152[89]中有解释)和野火(用于快速块传播，减少分叉概率)来减少这些问题。此外，使用块哈希列表和钱包列表可以降低初始参与成本。在2.0版本中，Arweave引入了一个硬分叉来提高可伸缩性，将数据与事务分离。在事务中不包括数据，而是包括数据的Merkle根。这提高了事务传播速度，因为转发事务不再需要数据。<br>由于存在伪随机召回块，为了使挖掘收益最大化，节点被激励存储大量的块。这增加了数据的复制。然而，并不是每个节点都必须存储每个块或内容，每个节点根据内容过滤器为自己决定存储哪些数据。请求内容可能会变得复杂，因为节点是随机请求的，希望它们存储内容。<br>对Arweave的直接研究很少。然而，这可以解释为新兴的基于区块链的协议的广泛范围和区块链的研究至少可以部分应用于Arweave。</p><h3 id="F-Honorable-Mentions-and-Related-Concepts"><a href="#F-Honorable-Mentions-and-Related-Concepts" class="headerlink" title="F. Honorable Mentions and Related Concepts"></a>F. Honorable Mentions and Related Concepts</h3><p>在我们对选定的P2P数据网络的详细概述之后，我们提供了有关当前一代P2P数据网络的其他系统和概念的其他文献。特别是，一些论文概念为P2P内容共享提供了不同的、复杂的想法。<br>Sia[90]的目标是成为去中心化的云存储平台。一个文件被分割成多个块，这些块被加密，然后通过擦除编码存储在多个存储节点上。块的位置存储为元数据。Sia使用区块链来激励数据的存储和检索。数据存储的条件和持续时间在存储合同中是固定的。数据所有者负责文件运行状况。<br>OSN (Open Storage Network)[91]是一个用于传输和共享研究数据的分布式网络。它可以与专注于大量研究数据的分布式云服务相媲美。数据存储在中央监控和维护的吊舱中。这些OSN吊舱是专门配置的服务器机架，需要高带宽互联网连接。想要为这个网络做出贡献的机构可以安置豆荚。因此，研究人员可以在OSN网络中存储和共享他们的研究数据。OSN吊舱的连接性应保证数据的快速访问。数据可以与选定的参与者共享，也可以通过开放获取。对pods的集中管理和严格的条件将OSN与现有的其他数据网络区分开来，分散和任意参与是这些数据网络的一个关键特征。<br>Fukumitsu等人[92]提出了一种点对点类型的存储系统，在该系统中，即使是重构所存储文件所需的元数据也存储在网络中，可以通过ID、密码和时间戳来检索。作者假设一个非结构化的P2P网络，其中每个节点可以提供不同的服务。节点定期广播有关自身的必要信息，例如提供的服务及其IP地址。该方案的一个重要组成部分是存储在区块链上的存储节点列表。存储节点列表是随机选取的提供存储服务的节点列表。数据按部分存储，存储过程分为两个阶段:存储用户数据和存储重构用户数据所需的数据。用户数据被加密，分成部分，存储在当前可用的存储节点中选择的节点上。可以使用恢复键请求部件。为了重构用户数据，需要解密密钥、存储节点对和恢复密钥。因此，需要将数据复制到其他节点。用户创建ID、密码对，并选择存储列表。数据通过ID、密码和存储列表的散列进行加密。存储节点是从存储列表中确定选择的。部件的恢复键是存储列表的散列和块索引的散列，即ID和密码。该方案允许获取数据，而无需将信息存储在用户设备上。<br>Jia等人[93]提出了一种实现健忘RAM隐藏数据访问模式的机制——oblvp2p。虽然作者提到他们的机制适用于其他点对点系统，但他们关注的是带有跟踪器的类似BitTorrent的系统。<br>Qian等人[94]提出了Garlic Cast，一种改善覆盖网络中匿名性的机制。对等点不直接请求和搜索内容。相反，对等体搜索代理，代理交换和请求内容。对等体及其代理之间的消息是通过安全增强的信息分散算法(IDA)交换的。rda是一种擦除编码形式，其中𝑘的𝑛片段足以重建对象。安全增强的IDA首先对消息进行加密，使用𝑘-threshold IDA将消息和密钥分割为𝑛片段，然后发送cloves，即包含密钥和消息片段的消息。通过随机游走发现代理:丁香被发送给它的邻居，请求对等点作为一个具有随机丁香序列号的代理，每个邻居随机转发丁香，并维护继承者和前任的状态。具有两个具有相同序列号的丁香的对等体可以恢复请求，如果它自愿成为对等体，它将返回一个回复给请求者。<br>其他论文概念利用区块链进行访问控制，并存储数据位置，而不是作为激励机制的补充，如Blockstack[95]，它在区块链上维护元数据，并依赖外部数据存储来实际存储数据。也有使用分布式账本技术进行访问控制的概念。<br>Calypso[96]，它使用基于跳链的身份和访问管理，允许可审计的数据共享。然而，这些系统和仅集中于通过区块链出售数据的系统不在本次调查的范围之内。</p><h2 id="V-DISCUSSION-OF-BUILDING-BLOCKS"><a href="#V-DISCUSSION-OF-BUILDING-BLOCKS" class="headerlink" title="V. DISCUSSION OF BUILDING BLOCKS"></a>V. DISCUSSION OF BUILDING BLOCKS</h2><p><img src="/images/distributed_storage/image-20220428171303982.png" alt="image-20220428171303982"></p><h3 id="A-Performance"><a href="#A-Performance" class="headerlink" title="A. Performance"></a>A. Performance</h3><p>系统性能的研究已经成为一些研究者所追求的研究方向。通过模拟或测试来调查性能、读/写时间、存储开销、文件查找、抗churn阻力，可以用来识别新的用例，并巩固一个系统可能取代集中式系统的断言。IPFS开发人员开发了“Testground”[103]，用于大规模测试和基准测试P2P系统。从这个意义上说，Testground的性能及其对真实系统的复制能力也是一个值得研究的领域。也有其他分析IPFS性能的研究，如读写时延[28,31]，使用IPFS集群进行物联网数据共享[29]，改进系统[30,36]，或分析网络[34,35,37]。Heinisuo等人[32]表明，由于高网络流量消耗电池，IPFS需要改进才能在移动设备上使用。关于IPFS竞争对手的研究还很缺乏。此外，Naik和Keshavamurthy[41]关注的主题是P2P网络的流失。此外，考虑到研究数据的增加，需要研究在Tera-和Petabytes范围内建立大型单一数据集的数据网络的可行性。</p><h3 id="B-Confidentiality-and-Access-Control"><a href="#B-Confidentiality-and-Access-Control" class="headerlink" title="B. Confidentiality and Access Control"></a>B. Confidentiality and Access Control</h3><p>过去和现在的数据网络提供了一些机密性和访问控制，但这些系统是为公共数据而不是为私有数据设计的。需要研究节点在存储数据时所获得的知识。这不仅涉及数据内容的信息，还涉及元数据(如访问模式)。现有的访问控制系统的安全性有待进一步研究。有研究建议使用区块链进行访问控制[22 - 25,64]，但区块链的不变性使得这对于私人和个人数据来说存在问题。关于私有数据的另一个方面是删除数据。虽然防止删除数据有助于抵制审查，但删除个人、恶意或非法数据的可能性可能提高对数据网络的接受程度。例如，Politou等人[102]提出了一种IPFS中删除内容的机制。调查和改进现有系统可以增加对数据网络的信任。增强对机密性的信任和防止未经授权的访问可以打开这些系统来存储私人和个人数据。</p><h3 id="C-Security"><a href="#C-Security" class="headerlink" title="C. Security"></a>C. Security</h3><p>对于安全研究来说，这一领域的工作通常是在发现和修复新的漏洞之间反复进行。此外，研究还涉及利用P2P数据网络与恶意软件交换数据的恶意活动<br>在安全漏洞方面，Prünster等人[33]披露了对IPFS的eclipse攻击，De Figueiredo等人[87]披露了对Storj的测试网络的拒绝服务攻击。此外，不仅需要研究已知的攻击向量，还需要研究新的攻击向量的存在。例如，Storj承认存在“Honest Geppetto”攻击的可能性，即攻击者(诚实地)长时间地操作许多存储节点，有效地控制大部分存储能力。这种控制允许将数据作为“人质”或一般地取下数据，使数据网络无法操作。另一个例子是Frameup[88]，其中未加密的数据存储在存储节点上，这可能会导致法律问题。存储任意数据也可能给存储设备带来风险。安全是研究领域，我们观察IPFS以外的研究。</p><h3 id="D-Anonymity"><a href="#D-Anonymity" class="headerlink" title="D. Anonymity"></a>D. Anonymity</h3><p>除涉及数据安全和隐私的机密性外，保护个人隐私是另一个相关的方面;特别是匿名性，它描述的是无法在一群个体中识别一个个体，即不可链接性[104]。<br>在匿名方面，数据网络中可以保护各种实体:内容创建者、存储节点和请求内容的用户。在上一代数据网络中，特别是Freenet[2]和GNUnet[105]着重于保护不同实体的身份。Balduf等人[70]已经表明，IPFS通过监控数据请求识别内容请求者，从而继续存在隐私问题。<br>由于激励机制和由此产生的个人指控，很难保证匿名，因为至少需要假名。一旦使用了激励机制，有关请求者的信息就得到了。记录交易的分布式分类账，例如Filecoin、Ethereum Swarm、Arweave，可以揭示额外的信息，因此参与者是匿名的。当一个中心组件授权请求和处理激励时，例如Storj中的卫星节点，请求者、存储节点和中心组件相互认识。在激励请求的情况下，显示请求节点和存储节点。请求者的身份可以通过转发策略或代理(如Swarm、SAFE)部分地得到保护。<br>第一代有像Freenet这样的系统，旨在匿名和抵制审查。这一代的匿名性似乎落后于第一代。尽管使用mixnet或Tor进行匿名通信取得了进展[106]，但还没有数据网络提供强匿名性。总之，提供的匿名保证和进一步的增强需要调查。这包括匿名实用程序的权衡和对不同攻击者模型的分析。匿名不仅对保护个人隐私很重要，而且对保证声称的抵制审查也很重要。如果可以很容易地推断出存储节点的身份，那么即使网络保护不被删除，执法部门也有可能执行<br>审查。这是一个值得关注的问题，特别是对于像Swarm这样的系统，存储块的位置是预先确定的，节点身份是与以太坊假名相连的</p><h3 id="E-Naming"><a href="#E-Naming" class="headerlink" title="E. Naming"></a>E. Naming</h3><p>命名，特别是在分布式系统中提供人类可读的名称，是一个已知的挑战。Zooko ‘s Triangle[107]捕捉到了这个问题及其邻近的挑战。它描述了构建分布式命名空间的困难，分布式命名空间是分布式的(没有中央权威)、安全的(清晰的解析)和人类可读的。<br>在所有系统中，数据的寻址要么缺乏分布性(基于跟踪器的BitTorrent和Storj)，要么缺乏人类可读性(无跟踪器的BitTorrent、Hypercore、IPFS、Swarm和SAFE)。BitTorrent是一个很好的例子，跟踪器是一个中央权威，在无跟踪的BitTorrent的情况下，人类可读的种子是用不太可读的信息哈希(种子的哈希)解决的。在Storj的3.0版本中，卫星是一个中心组件。<br>缺乏可读性是自认证数据的结果，其中数据决定了数据的地址或名称。数据变更后，地址也随之变更。因此，通过不同的机制(独立于内容的命名)来支持人类的可读性。Hy- percore是一个例外。在Hypercore中，数据组被绑定到公钥，并且通过版本控制来保护组内的可变性。<br>提供人类可读性的一个解决方案是名称解析。名称解析允许将密钥映射到自我认证的内容。名称解析可以提供人类的可读性，并提供对文件版本控制的支持。然而，由于更新值的可能性和传播的延迟，即使密钥是唯一的，人们也会认为安全性被破坏了。名称解析独立于Zooko ‘s Triangle，宣布内容，并给出模棱两可的字符串含义，应该只用于公共数据，除非名称解析提供访问控制。<br>为此，IPFS、Swarm和SAFE提供了某种命名服务。实际上，IPFS提供了两种命名服务:IPNS和DNSLink，用于不同的目的。IPNS用于将公钥的哈希映射到IPFS CID，允许可变数据。DNSLink使用DNS TXT记录实现域名到IPFS地址的映射。<br>Swarm还提供了两种命名系统:single-owner chunk和ENS[79]。单所有者块提供了基于所有者和标识符的数据标识，提供了一个安全的、非人类可读的键和一个可更新的值。以太坊名称系统类似于DNS，其中一条记录被映射到一个地址。<br>Swartz[108]认为，基于区块链的名称服务提供了Zooko三角形的所有三个属性。任何人都可以在提供去中心化的区块链上注册名称，名称可以是任何提供人类可读性的名称，而防篡改分类帐确保提供安全性的唯一名称。根据这一论点，像Name- coin、Blockstack[95]和ENS这样的系统被开发出来，它们采用了基于区块链的名称系统的思想。虽然这些系统的存在，除了带有ENS的群系统，似乎没有一个系统能解决Zooko的三角形问题。然而，由于缺乏交易最终性和可能的区块链分叉，可以认为基于区块链的系统违反了强大的安全方面，只提供最终安全性。</p><h2 id="VII-CONCLUSION-AND-LESSONS-LEARNED"><a href="#VII-CONCLUSION-AND-LESSONS-LEARNED" class="headerlink" title="VII. CONCLUSION AND LESSONS LEARNED"></a>VII. CONCLUSION AND LESSONS LEARNED</h2><p>第一代P2P数据网络告诉我们，P2P驱动的文件交换是可行的，并且有一些主要的优势，例如，自扩展性。这项技术持续存在的另一个指标是BitTorrent的持续存在和广泛的用户基础。然而，第一代也教会了我们弱点，例如，缺乏长期可用性。下一代数据网络建立在上一代数据网络的基础上并加以改进，利用技术进步和概念来解决弱点。</p><p>在这篇调查论文中，我们研究了新兴的新一代P2P数据网络。特别地，我们调查了新的发展和技术构件。从我们的定性比较中，我们可以得出结论，除了覆盖结构之外，各种数据网络在文件管理、可用性和激励方面探索了不同的解决方案。最值得注意的是，显性激励机制，如使用加密货币或某种代币，似乎无处不在，以确保长期可用性和参与者的参与。我们还看到了不同的度量方法，以确保在面对拒绝服务攻击或超越激励机制的流失时的可用性，即复制、擦除码，甚至两者的结合。此外，由于许多系统在分布式体系结构中结合了命名服务和内容寻址，它们有可能像Zooko的三角形那样协调人类的可读性、安全性和分散性等系统属性。<br>现在一个重要的开放任务是调查和评估各种构建块。特别是，激励机制的设计是出了名的困难。在某种程度上，我们可以将P2P数据网络的不同部署视为一个大型现场测试，在那里我们可以观察某些设计决策的影响。总的来说，无论是作为其他应用的基础，还是作为研究对象本身，P2P数据网络已经成为研究议程的一部分。<br>然而，许多挑战和开放的研究问题仍然存在，例如，调查匿名性，参与者的隐私和访问控制，开放P2P数据网络到更广泛的可能的用例。因此，我们相信新一代的P2P数据网络为未来的研究提供了许多令人兴奋的机会。</p><p>推荐阅读：</p><ol><li><a href="https://www.youtube.com/watch?v=jp0bF9Qu2Jw">Vol 075 别再问我什么叫 BT 种子</a></li><li>原论文链接：<a href="https://ieeexplore.ieee.org/abstract/document/9684521">https://ieeexplore.ieee.org/abstract/document/9684521</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Ubuntu20.04搭建单机Fabric2.3.0Raft共识测试网络</title>
      <link href="/2022/04/17/blockchain/fabric/%E5%9F%BA%E4%BA%8ERaft%E5%85%B1%E8%AF%86%E6%90%AD%E5%BB%BA%E5%8D%95%E6%9C%BAFabric2.3%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/04/17/blockchain/fabric/%E5%9F%BA%E4%BA%8ERaft%E5%85%B1%E8%AF%86%E6%90%AD%E5%BB%BA%E5%8D%95%E6%9C%BAFabric2.3%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="zhangzhishun">    <label for="pass">zhangzhishun</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 部署文档 </tag>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arweave – 一种类区块链的区块编织结构（Lightpaper）</title>
      <link href="/2022/04/12/blockchain/arweave/Arweave_%E4%B8%80%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%8C%BA%E5%9D%97%E7%BC%96%E7%BB%87%E7%BB%93%E6%9E%84(Lightpaper)/"/>
      <url>/2022/04/12/blockchain/arweave/Arweave_%E4%B8%80%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%8C%BA%E5%9D%97%E7%BC%96%E7%BB%87%E7%BB%93%E6%9E%84(Lightpaper)/</url>
      
        <content type="html"><![CDATA[<p>转载：<a href="http://ipfsdrop.com/docs/whitepaper/arweave-lightpaper/">http://ipfsdrop.com/docs/whitepaper/arweave-lightpaper/</a></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>经典的区块链在数据存储方面存在几个众所周知的主要问题。这些问题需要将新的第三方协议集成到现有区块链的上层，因为费用太高，无法进行链上存储。因此，对于经典的区块链来说，访问内容始终会产生成本，而且内容永远不会永久存储­。随着对数据存储的需求呈指数增长，对可扩展的分布式低成本数据存储协议的需求是必要的。</p><p>在这项工作中，我们介绍Arweave——一种类区块链的区块编织结构。区块编织是一个平台­，致力于首次以经济高效的方式提供可扩展的链上存储。随着系统中存储的数据量的增加，达成共识所需的哈希值减少，从而降低了存储数据的成本。该协议现有的REST API使得在区块编织上层构建去中心化的应用程序­十分简单，反映了Arweave对开发者社区的关注及其推动采用新兴和新颖协议的能力。</p><p>在本文中，我们还介绍了新颖的概念­诸如「区块阴影（block-shadowing）」——一种灵活的交易区块分配算法——­改进了其他区块链的现有“分片”技术­优化网络拓扑，并带来新的共识机制，称为访问证明（Proof of Access）。</p><h2 id="1-导语（Introduction）"><a href="#1-导语（Introduction）" class="headerlink" title="1. 导语（Introduction）"></a>1. 导语（Introduction）</h2><p>在这个信息时代，我们常常屈服于一种幻想，即信息被读取­可用，它永远不会被更改或丢失。从根本上讲这是不正确的[7]。在互联网上，我们建立了一个巨大的去中心化信息传播系统­信息，我们还没有建立一个对应的­永久知识存储系统。现代历史有非常多的例子——­从图书馆和档案馆的大火[9，10，3，8]到专制国家的书籍燃烧（焚书坑儒）[12，11]，重要信息的构建和丢失。当我们在互联网上查询信息时­，我们依赖于被允许访问被集中存储的该数据。­拥有此信息的服务器的访问­所有者可以随时撤消该许可。同样，由于在Internet上提供信息需要支付服务器费用和维护费用，因此当资金不足时，网站通常会轻易地消失。</p><p>更进一步，许多政府正在采取越来越多的步骤来审查和删除对互联网上政治敏感信息的访问[13、5、4]。与媒体和新闻机构一样，我们曾经拥有实体和不可撤销的副本，现在我们­单纯地访问信息，然后将其丢弃。随着时间的推移，媒体组织更新其文章的内容已变得司空见惯。虽然这提供了一些­与以前的系统相比，它具有许多优点，最显着的是，它可以传播有关展开情况的实时更新，还可以使重要的上下文丢失或变得模糊。</p><h2 id="2-背景（Background）"><a href="#2-背景（Background）" class="headerlink" title="2. 背景（Background）"></a>2. 背景（Background）</h2><p>所有区块链创新都站在巨人的肩膀上，包括比特币本身，数据结构交响曲，分布式网络工作和密码学。我们也试图扩大空间，解决现有区块链网络的特定缺点，即存储，并采用一种新颖的交易速度方法。如今，大多数区块链技术都坚持认为，“全节点”必须维护整个区块链的副本以验证未来的交易，而使之成为可能的Merkle数据结构本身就是一项了不起的壮举，并增加了无与伦比的安全性，我们认为围绕此过程的一些性能增强可以减轻整个节点的同步负担，在第4节中介绍了解决块，节点和钱包同步的几种技术。</p><p>当涉及到存储数据时，完整的区块链要求可能甚至是现有区块链技术的障碍。在以太坊（一种去中心化的世界计算机）的情况下，使用其本机令牌的存储成本令人难以置信。 Arweave的主要动机是以与以太坊中表示的方式相同的方式实现永久，不变的存储。但是，高昂的费用使这种存储变得越来越不切实际。虽然可以在以太坊上存储数据，但是由于数据存储成本，先前的尝试是不切实际的。</p><p>其他区块链技术专注于改善节点之间的共识算法，特别是Stellar Lumens和APo和Neo等dPos架构。尽管这可以提高事务处理速度，但存储负担仍然是许多此类网络将面临的长期障碍。通过首先专注于解决存储问题，我们体验了一些性能增强功能，这些性能增强功能可用于促进高吞吐量货币交易。</p><h2 id="3-激励（Motivation）"><a href="#3-激励（Motivation）" class="headerlink" title="3. 激励（Motivation）"></a>3. 激励（Motivation）</h2><p>我们已经设计并实现了一个区块链网络，其中永久性的低成本存储已成为现实。将存储访问权纳入共识，并结合新颖的交易捆绑方法和任意大小的块，可创建高吞吐量的加密货币，该加密货币将比其他加密货币（如比特币[10]和以太坊[12]）有所改善。过去，档案（互联网或其他方式）通常由单个机构（甚至是个人）维护，因此容易受到两种主要形式的操纵。首先是通过在文档存储过程中修改文档[2]。第二个问题是，文档在进入存储之前可能已经被伪造或修改过[1]。例如，许多归因于苏格拉底的作品被认为是他的门徒们写的[6]。 Arweave解决了这两个问题。一旦将文档存储在组织上，就将其与组织上的每个其他块加密链接。这确保了任何尝试更改文档内容的尝试都会被网络检测到并拒绝。以这种方式，不可能破坏组织上的信息。 Arweave是Internet上可浏览的姊妹网络，可提供Internet迫切需要但目前缺乏的长期，永久数据存储功能。</p><p>Arweave系统的关键组件旨在让开发人员轻松构建与网络数据交互，创建和使用的应用程序。这些使用与语言无关的REST API构建的应用程序将充当网络中侦听网络的节点。这些应用程序的功能将是广泛而多样的，从分散和不变的社交网络到讨论网站和新闻聚合器。为了向编织提交信息，将需要少量令牌。这些代币将用于支付矿工在维护组织和网络方面的工作，以及抑制垃圾邮件的传播。这代表了对典型集中式存储系统的极大改进。同样，它使个人有能力确保自己关心的信息能够长期存在。随着网络和文档将增强令牌的价值，维持织法的动机也会增加。随着这些影响的加剧，我们期望Arweave代币将成为信息时代的宝贵资产。与大量重要文件密不可分且内在联系。</p><h2 id="4-技术（Technology）"><a href="#4-技术（Technology）" class="headerlink" title="4. 技术（Technology）"></a>4. 技术（Technology）</h2><p>Arweave建立在四项核心技术的基础上，这些技术可以共同在新的区块链上创建低成本，高吞吐量的永久存储。 这些创新是：</p><ul><li>区块编织（Blockweave）</li><li>访问证明（Proof of Access）</li><li>野火（Wildfire）</li><li>区块阴影（Blockshadows）</li></ul><p>虽然这些技术相互交织，但是每种技术在创建适用于快速事务处理和低成本永久性存储的新型网络方面都发挥着关键作用。</p><h3 id="4-1-区块编织（Blockweave）"><a href="#4-1-区块编织（Blockweave）" class="headerlink" title="4.1 区块编织（Blockweave）"></a>4.1 区块编织（Blockweave）</h3><p>大多数区块链的一个众所周知的特性是，必须存储每个区块以作为“完整节点”参与验证交易。 Arweave并非如此。</p><p>取而代之的是，Arweave引入了两个新概念，这些概念允许节点在不拥有整个链条的情况下完成关键的网络功能。这些概念中的第一个是块哈希列表，它是所有先前块的哈希的列表。这样可以验证旧块，并有效评估潜在的新块。这些概念的第二个是钱包列表，这是系统中所有活动钱包的列表。这样就可以在不占用最后一次交易使用的区块的情况下验证交易。使用这些由网络同步并可以由矿工下载的区块链列表和钱包列表，节点几乎可以立即加入网络并参与对组织的挖掘。</p><p>此外，Arweave使用“持续验证”系统，而不是让每个矿工在进入网络时都验证从基因块到当前块的整个块结构。当矿工加入Arweave网络时，他们将下载当前区块并从当前区块中检索区块哈希和钱包列表。由于这些区块链和钱包列表已通过每个区块的持续进行进行了连续验证，因此新矿工可以立即开始参与，而无需验证整个组织。当然，完全编织验证可用于希望执行该验证的任何节点。通过这种方式，矿工无需查找与钱包相关联的先前交易即可验证新交易。取而代之的是，矿工将只需要验证交易是否已由钱包拥有者的私钥正确签名。为了防止召回块伪造攻击，块哈希表的哈希将与每个新块一起分发。</p><p>Arweave - 一种类区块链的区块编织结构（Lightpaper）</p><p><img src="/images/arweave/image-20220412232151857.png" alt="image-20220412232151857">图1：blockweave数据结构的示意图，展示了到前一个区块和回调区块的链接。</p><h3 id="4-2-访问证明（Proof-of-Access）"><a href="#4-2-访问证明（Proof-of-Access）" class="headerlink" title="4.2 访问证明（Proof of Access）"></a>4.2 访问证明（Proof of Access）</h3><p>Arweaves共识机制基于访问证明（PoA）和工作证明（PoW）。虽然典型的PoW系统仅依赖于前一个块才能生成每个连续的块，但PoA算法会合并来自随机选择的前一个块的数据。结合区块编织数据结构，矿工不需要存储所有区块（形成一个区块链），而是可以存储任何先前的区块（由PoA和野火推动），从而形成区块编织，即区块编织。通过获取当前块的哈希值并计算其相对于当前块高度的模数，可以选择要合并到下一个块中的“调用块”。</p><p>调用块中的事务与在当前块中找到的事务一起进行哈希处理，以生成下一个块。当矿工找到合适的哈希后，他们会将新块与回调区块一起分发给网络的其他成员。这使网络的其他成员，即使没有自己的回调区块副本的那些成员，也可以独立地验证新块是否有效。</p><h3 id="4-3-野火（Wildfire）"><a href="#4-3-野火（Wildfire）" class="headerlink" title="4.3 野火（Wildfire）"></a>4.3 野火（Wildfire）</h3><p>作为数据存储系统，Arweave不仅需要存储大量信息的能力，而且还需要以最方便的方式提供对该数据的访问。此外，Arweave系统的重要组成部分是在请求时对数据进行无成本的访问。随后，Arweave增加了一层激励措施，以鼓励矿工自由共享数据。</p><p>Wildfire是一种系统，它通过使网络上数据请求的快速满足成为参与的必要部分，从而解决了分散式网络中数据共享的问题。 Wildfire通过在每个节点本地创建一个排名系统来进行工作，该排名系统确定新块和事务向对等对象分发的速度如何，基于它们对请求进行响应并接受来自其他对象的数据的速度。对等体按其等级顺序服务，而性能不佳的对等体则被从网络中黑名单中删除。从经济上激励同伴，使他们在彼此的排名中保持良好的位置，以便他们可以花费最大的时间进行有效的挖掘。</p><p>Arweave - 一种类区块链的区块编织结构（Lightpaper）</p><p><img src="/images/arweave/image-20220412232319579.png" alt="image-20220412232319579"></p><p>图2：野火系统示意图。 每个节点根据这些对等点之前对它们的表现进行评估，对其对等点进行排名。<br>这极大地鼓励系统中的节点以对其他对等方尽可能最友好的方式运行，而不会给正在接收数据的人，甚至可能是一次性请求的那些人带来代价。 更进一步，它创建了一种网络拓扑，该拓扑适合于最有效的全局路由，因为首选了允许在系统中快速传输新数据的连接。 实际上，野火机制构建了一个网络拓扑，该拓扑映射了Internet的底层物理连接基础，以适应其架构随时间的变化。 总体而言，野火系统可确保新块的高速分发，并以较短的延迟保持数据可用。</p><h3 id="4-4-区块阴影（Blockshadows）"><a href="#4-4-区块阴影（Blockshadows）" class="headerlink" title="4.4 区块阴影（Blockshadows）"></a>4.4 区块阴影（Blockshadows）</h3><p>在传统的区块链系统中，当挖掘一个新块时，无论一个节点已经拥有多少块数据，每个完整的块都会分配到网络中的每个节点。这不仅浪费大量数据，而且极大地降低了网络就块达成共识的速度。因此，Arweave引入了一种新技术，即块影子，它不仅可以最大程度地减少数据浪费，而且可以实现快速的块共识和巨大的事务吞吐量。</p><p>Blockshadowing的工作原理是部分取消来自块的事务，并且仅在节点之间发送最小的块“影子”，该影子允许对等方重建完整的块，而不是传输完整的块本身。这些区块影子专门包含钱包列表和哈希列表的哈希，并且代替区块内的交易，仅包含交易哈希的列表。根据这一信息（可能只有几千字节），一个已经在该区块中拥有所有交易的节点以及一个最新的哈希和钱包列表可以重建几乎任意大小的整个区块。为了促进这一点，节点还将立即彼此共享事务，但是只有在它们高度确定网络中的其他节点也具有事务处理后，才尝试将事务放置在一个块中。</p><p>这个区块集散系统的结果是一个快速，灵活的区块分配系统，该系统可以使交易以尽可能快的速度在网络上分布，并且可以以接近网络的速度达成共识。此外，该系统可确保当网络使用率很高时，交易费用不会显着增加，并且乐观的100mbps网络上的交易吞吐量的理论限制为每秒约5000笔交易。</p><h3 id="4-5-民主内容政策（Democratic-Content-Policy）"><a href="#4-5-民主内容政策（Democratic-Content-Policy）" class="headerlink" title="4.5 民主内容政策（Democratic Content Policy）"></a>4.5 民主内容政策（Democratic Content Policy）</h3><p>为了支持网络中各个参与者的自由以控制他们存储的内容，并允许整个网络以民主方式拒绝受到广泛谴责的内容，Arweave软件提供了一个黑名单系统。每个节点主节点都有一个（可选）黑名单，其中包含例如它不希望存储的某些数据的哈希值或子字符串，并且永远不会写入与此匹配的磁盘内容。这些黑名单可以由个人建立，也可以通过协作建立，也可以从其他来源导入。</p><p>在本地级别，这些黑名单允许节点控制自己的内容，但是这些本地拒绝的总和也会创建网络范围的内容拒绝。超过一半以上的网络拒绝的内容不仅会被这些单个节点中的每一个拒绝，而且还将被整个网络整体拒绝。这创建了一个民主的全网络内容拒绝系统，该系统可以将各种文化和观点中的黑名单合并为一个普遍删除的微小的特定内容黑名单。这个接近普遍，民主的黑名单使网络不受少数行为者的干扰，同时仍允许其以民主方式保护自己的自由。</p><h2 id="4-6-讨论（Discussion）"><a href="#4-6-讨论（Discussion）" class="headerlink" title="4.6 讨论（Discussion）"></a>4.6 讨论（Discussion）</h2><h3 id="4-6-1-存储池（Storage-Pools）"><a href="#4-6-1-存储池（Storage-Pools）" class="headerlink" title="4.6.1 存储池（Storage Pools）"></a>4.6.1 存储池（Storage Pools）</h3><p>对Arweave的一种潜在的理论攻击已经变得非常大，那就是矿工可能会合作维护一个组织的单个副本，他们都可以使用这些副本来检索召回块。 虽然这种行为乍看起来似乎是问题，但事实并非如此。 如果此类“存储池”被大部分矿工雇用，那么其他矿工存储稀有矿块的动机就会增加。 这是因为，如果集中存储区不可用，则当将来该稀有块成为撤回块时，具有稀有块副本的矿工将很可能获得奖励。 这种自私的行为为网络提供了风险抵销功能，该功能会随着数据丢失（由集中存储池引起）的可能性增长而扩展。</p><h2 id="5-构建App（Building-Apps）"><a href="#5-构建App（Building-Apps）" class="headerlink" title="5. 构建App（Building Apps）"></a>5. 构建App（Building Apps）</h2><p>可以使用简单的REST API构建使用组织的应用程序。 REST端点是HTTP，可以直接访问网络，因此任何Arweave钱包都可以读取和写入数据。 客户只需要通过Chrome扩展程序或具有Arweave钱包集成功能的本机应用程序将其Arweave钱包带入网站，即可从网络读取数据或向网络写入数据。 可以在组织之上构建几种体系结构。</p><h3 id="5-1-客户端-服务器架构（Client-Server-Architecture）"><a href="#5-1-客户端-服务器架构（Client-Server-Architecture）" class="headerlink" title="5.1 客户端-服务器架构（Client-Server Architecture）"></a>5.1 客户端-服务器架构（Client-Server Architecture）</h3><p>传统的Web或本机应用程序具有客户端-服务器体系结构。在云上运行的服务器将被“启用Arweave”，与一个或多个Arweave节点进行交互，代表客户端读取和写入数据。这些服务可以是将客户端作为访问者的网站，也可以是将客户端请求传递给开发人员操作的服务器的本机应用程序。这些服务器将需要维护AR令牌的浮动，以确保可以处理写入数据的请求。使用该架构从编织读取数据仍然是免费的。</p><p>该架构的获利潜力很简单。开发人员将需要通过广告，每月订阅或直接付款来获得更大的价值，而不是使用其为存储提供动力的AR令牌数量。永久性不可变存储有许多应用。例如，存储抗量子，加密的法律案例文件，身份或医疗记录。尽管某些法规需要适应敏感信息的存储，地理范围和被遗忘的权利，但也可以通过加密和密钥管理来缓解这种情况。几个创收模型可以在组织的顶部分层，其主要价值主张是链上永久不可变的存储。</p><h3 id="5-2-无服务器架构（Serverless-Architecture）"><a href="#5-2-无服务器架构（Serverless-Architecture）" class="headerlink" title="5.2 无服务器架构（Serverless Architecture）"></a>5.2 无服务器架构（Serverless Architecture）</h3><p>客户端可以通过启用Arweave的浏览器访问应用程序，而应用程序可以自身运行。由于浏览器的普及和Web技术的普及，使用HTML / CSS / JS将这些应用程序存储为标准前端Web应用程序是最有意义的。但是，如果客户端的本机应用程序包含针对不同语言（例如LLVM字节码）或脚本语言（如Python）的解释器/解析器，则它们可以在客户端上运行，并且可能会受益于Web应用程序中的相同可升级性。</p><p>开发人员不仅可以将无服务器的应用程序部署到Arweave，而且这些应用程序还可以将持久性和可证明状态写入网络。由于Arweave没有施加特定的数据结构，因此开发人员可以自由地以对他们来说最有意义的格式存储数据。如果该应用程序最好通过高度优化的Merkle结构（例如以太坊虚拟机（EVM）中找到的结构）来满足，则可以轻松地将其实现。如果开发人员正在寻找更多的文本Blob样式存储，那么这也是微不足道的。</p><p>无服务器应用程序非常有趣，因为它们可以写入自己的数据。例如，基于分布式计算将允许训练神经网络存储其结果，并可能与其他网络共享其结果模型。</p><h3 id="5-3-基于事件的（Event-Based）"><a href="#5-3-基于事件的（Event-Based）" class="headerlink" title="5.3 基于事件的（Event Based）"></a>5.3 基于事件的（Event Based）</h3><p>在Twitter成立之初，便有了蓬勃发展的家庭手工业应用程序生态系统，而开发人员则在“ firehost” API的基础上开发，这些API将推文流化为任何愿意付费访问的人。 情况已不再如此，在Facebook Cambridge Analytica惨败之后，这些向客户提供数据分析的服务的许多“可信赖的合作伙伴”都被任意关闭。</p><p>Arweave是一个分散的公共数据网络，因此，除了被民主拒绝的内容外，它永远不会审查数据访问或数据本身。 这意味着开发人员可以自由地在Arweave之上进行构建，并且可以使用REST API侦听传入的数据。 触发事件后，侦听器将触发订阅了这些事件的客户端的相应函数调用。 开发人员不必担心会受到限制或关闭，因为网络受到激励以向他们提供对数据馈送的可靠访问。</p><h3 id="5-4-无信任和可证明（Trustless-and-Provable）"><a href="#5-4-无信任和可证明（Trustless-and-Provable）" class="headerlink" title="5.4 无信任和可证明（Trustless and Provable）"></a>5.4 无信任和可证明（Trustless and Provable）</h3><p>可以对应用程序体系结构进行设计，以便轻松实现需要存储并保证防篡改的信息。 此外，可证明公平的运行时代码可以存储在组织上，并由客户端直接解释。 客户端使用内容的事务ID，可以在计算之前验证编织中的有效负载，并确保它们运行的代码既不受信任又可以证明是公平的，即与其他客户端运行的代码相同。 这为服务于其他区块链网络的无信任随机数生成器和其他基于oracle的服务开辟了有趣的可能性。</p><h2 id="6-用例（Use-Cases）"><a href="#6-用例（Use-Cases）" class="headerlink" title="6. 用例（Use Cases）"></a>6. 用例（Use Cases）</h2><p>永久存储有几个用例。 具体而言，法规要求将文件存档长达一定年限。 可证明的媒体报道，学术研究和不变的记录在我们回声室和假新闻泛滥的现代世界中变得越来越重要。</p><h3 id="6-1-真实性（Authenticity）"><a href="#6-1-真实性（Authenticity）" class="headerlink" title="6.1 真实性（Authenticity）"></a>6.1 真实性（Authenticity）</h3><p>法律体系常常与文件真实性的诉讼纠缠在一起。 Arweave通过提供来自作者的任何数字内容的不确定且可验证的存储来解决此问题。 2017年，特拉华州裁定在法院诉讼程序中可以接受区块链证据。 这些记录可能会大大加快有关艺术归属和知识财产之争的争议。 对于创意经济而言，效果是双重的，使艺术家可以将自己的作品立即转让给他人，并避免琐碎的诉讼。</p><h2 id="7-结论（Conclusion）"><a href="#7-结论（Conclusion）" class="headerlink" title="7. 结论（Conclusion）"></a>7. 结论（Conclusion）</h2><p>我们提出了一个新的区块链网络，该网络支持低成本的不可变数据存储和高吞吐量的加密货币。通过使用一种称为blockweave的类似于区块链的新数据结构，可以实现Arweave协议。通过区块隐藏灵活的大小交易区块分配；一种新的共识机制，即减少对工作证明的依赖度，称为访问证明；以及称为Wildfire的自我优化网络拓扑。就像比特币网络一样，我们在隔离方面的技术进步并不是十分复杂。但是，当结合起来形成整个网络时，紧急行为非常强大。从测试网的结果可以看出，在公共的，无许可的和分散的网络协议上，安全，可靠和不变的数据存储是可能的。除了数据存储期限外，任意大小的块都使安全的高吞吐量加密货币成为可能，而无需诉诸复杂的共识机制，例如dBFT或dPoS。</p><p>Arweave通过其REST API紧密地连接到Internet的结构中，并且正在使用Arweave主网建立一些创收业务。 Arweave与其他流行的加密货币之间的桥梁，安全的计算和智能合约协议将使低成本和永久性的数据存储轻松集成到分散式应用程序的技术堆栈中。一个全面全球化的信息和金融交流世界需要永久记录。通过结合加密技术和分布式系统，我们为这些永久记录提供了基础。我们希望Arweave将成为现有互联网协议（例如，万维网）的必要伴侣。与他人合作，建立更加开放和透明的未来。</p><h2 id="8-引用（Reference）"><a href="#8-引用（Reference）" class="headerlink" title="8. 引用（Reference）"></a>8. 引用（Reference）</h2><ol><li>Aweave白皮书地址：<a href="https://www.arweave.org/files/arweave-lightpaper.pdf">https://www.arweave.org/files/arweave-lightpaper.pdf</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Arweave </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用密码学库</title>
      <link href="/2022/03/28/cryptography/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%93%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/28/cryptography/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%93%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="PRIVATE FILE">    <label for="pass">PRIVATE FILE</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19hMGg6ZrNiMTsEm3xBjqefMyaIYrRalyeYWQs7b/6/fE9t5o+rB59v30xybC2Jl25s+QoBoT7zD59aRZeY+fCpmw5EgigjNCEbNfp3jAtdGXhLgZigB+3djkwjhHBHh0ppBZztDbKfcUDSiD/UE+67y97VFUH3CQFgLst6UbptEeWKSnDdAj+4iabK1kvBuu5kjqPr+JR6xaWUDo80cCOqiuQPGNKzjYb4seJS+7I8Lml1UqYYHAlFvzdzA65usE7DGfR9zGIo9Pbh2iBVLcX3CRHOnSVYidUpUek0FqDpLSr3bwcHRQpKdr202u5lDVh2N/FvKpxD8NzvSLoMjClLeXi/fOgq0OVPMHeKyN1zeOu3v1zCTjdC2zBGZu4H0ZvkE1MnoFMcj/iggokSgvQFPq2t+ViP8cVpg9semcQBDJmHJ/RImp8C7rPdCCEkfIoNF1jkJvlP5taYafiefzBoH5UtmPUmURz6pxlrJzPYgZksw6wKukAgPj5xiu5+/gFHyQJPkWN6qNj/wcfGAwbg9FzOJbKvHig0ieDnxxflP1ITbNv/NUOvwObYgF5dDwK/uAcCBdRTFKyRsYdz5EF35r2i/KPB5ljpg18V9WYvKHsETg59SA6jxR5Mwukr7rapnJ+skrgKbPHcwSdQhUQ4cX9PMC6mS/J+vMGjGSNTyTqQ9TiNmGoKTTDiz6KVZ9LlqzdAEsSgknR4W0CV0WwbQXMH0fJT52UvEhmDOGXPLFeR0YZJQA9FdEYY9AdtPUxMnyP3gYJ3IMAywXfLjQgWr0AL5dMuLtb5YUpZhSuFxGdL0uGrYHNBOs7GikswFUwBE3OiEDi9xkDCxFEdo92pXu1JRCMAnNqUBZ5li0zgWvpPaxgnOfHabsrOLFR3dSb/GPlYnApXqyyN21rG2idTX6r9dmbLlChSqEGYvQqbMql31V5hZaQz5Qi9NbgbL50v51dB+8sFsrJY54M55Jr1PudHZQex9+ilSJhNC0Kia5fi3dRcIwjtlzQAd7/G9Z6EB7jnObkqEwO1Y4rcpXtc9k+dJRNzNdnVCtgHqLsmHygooWllXp8N2Yxw+WeUGuiFd/vgZD6YaiMuL0bbeJXKF4WzT4aH0+Qi2pu7y7gwirblQpe7Ljgp7HQ2PdhB3WbWTQVWWPVd2YnqVSkryHM0TyspEOAEBEsDeUHyZ/NXaPZgHycyDxY+IWdD6KkoA2wo11Y/iAcDSUibco52jIQvQ0X1z8VvfbZ+CnzKxDOACm5yJelxhbeo7l9jkBOqUY6dbAg2BMwED/G4GtJnXEh7vGlRlJ97jn4sZspj53Np5tHrvURxMwLeEon7vxNjX3CgN0MJTSWowu2tThVRqtqSiltgarh7p0qsdenB7z7Vfo/g0xjlVdP0CtQtF19SDD1H4tz4PwL0G9vOuatIzgrE6nRFAOCjeQwNyauw5cpbirvuLl2RYpIX9B5XU3kzuxOqEUQMYRkJymgADcl/dipLQqUElpS7GauIlyhfvMYPa598fgOXOyBFLZeNzIF4bEQjto9H3WGO2ISPvgNa1WxsarPn8Qz98k6Ab5+R55BB9kzWB8AF0SUi6c2qQofGflIU5FLBQzCbaNyn6nhvM5m3Im/Srk+SjAUzqI8cg6CV/EIXBqm9FvOz12GwX8DXv7X9yROCZR6au/fD8viMnsnGUGzVzyMP6+L1e4cnrs2/vddQpXW5vegn4fzd2t5NGDKiFwLz2jhTSOu2TWgLBGEqIOdf29Bukq5cZpzjP9vgm1Efp5YHPAVjW+Oqwc5EzJkopll/aVJ0oyaWXY98yetz2Z44XHKiARIQle7UpCmn4AGomJDOiBJbIGG0X5mvoj8Uua/+W+Xypg==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript创建一条区块链(二)</title>
      <link href="/2022/03/05/blockchain/other/JavaScript%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%BA%8C)/"/>
      <url>/2022/03/05/blockchain/other/JavaScript%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="将区块链API化"><a href="#将区块链API化" class="headerlink" title="将区块链API化"></a>将区块链API化</h2><p>在这个区块链中，我们想要实现三个API，分别是</p><ul><li>/api/mine：节点使用这个方法来挖掘新的区块</li><li>/api/transactions/new: 账户使用这个方法来建立新的交易</li><li>/api/chain: 返回当前的区块链</li></ul><p>为了复用我们在上篇写好的代码，我们首先安装express.js，并创建一个新文件 app.js。express是一个基于node的http框架，它可以允许我们接受通过http协议传输的节点信息。我们还需要body-parser帮助我们解码节点发送过来的信息。</p><h2 id="实现分布式共识"><a href="#实现分布式共识" class="headerlink" title="实现分布式共识"></a>实现分布式共识</h2><p>以上我们已经实现了一个单机版的区块链了，但区块链之所以有用，是因为它能被部署到多个节点上去，并且所有节点都能够相互更新，实现分布式的共识。这样的机制保证了我们能够抵御double spending attack以及确保只有一条区块链在运行。</p><p>为了实现我们的分布式共识，我们首先需要知道网络上其他的节点在哪里。仿照Ethereum的 Node Discovery Protocol，我们可以做一个类似的搜索节点的功能和节点注册功能</p><pre><code class="javascript">_app.post('/api/nodes/register', (req, res) =&gt; {    // 注册节点    let newNode = _.pick(req.body, ['ip', 'port']);    neighbors.push(newNode);    console.log('new node detected. Node info: ' + JSON.stringify(newNode));    res.send({        message: 'Node ' + newNode.ip + ':' + newNode.port + ' is added to my network'    });});</code></pre><h3 id="共识实现-解决冲突链"><a href="#共识实现-解决冲突链" class="headerlink" title="共识实现: 解决冲突链"></a>共识实现: 解决冲突链</h3><p>知道了附近的节点在哪，我们就可以开始实现我们的共识算法。共识算法的第一部分需要我们能够辨别出最长且有效的链，我们可以通过在之前写的区块链模型里加入新的函数实现。</p><p>在 <code>app.js</code>中，我们可以在每次挖矿之后都向附近的节点广播，以解决冲突链。首先我们需要建立一个新的端点 <code>/api/nodes/resolve</code>。建立好端点之后我们需要在挖矿之后对所有的邻居进行广播。</p><p>这样setup之后，我们的节点在每一次挖矿的时候都会对附近的邻居进行广播并寻求consensus。当然，我们还可以设定定时任务来更高频的进行广播。另外，我们也没有对收到的chain进行电子验证，没有动态化的寻找相邻节点，没有将每一个transaction广播，以及一系列可以完善的地方，不过在这篇教程当中我们就不继续下去了。</p><pre><code class="javascript">_app.get('/api/mine', (req, res) =&gt; {    // 挖矿    myChain.createBlock();    let p = new Promise((resolve) =&gt; resolve());    for (let i of neighbors) {        let resolveUri = 'http://' + i.ip + ':' + i.port + '/api/nodes/resolve';        console.log("send resolve to: " + resolveUri);        p.then(() =&gt; rp({            uri: resolveUri,            method: 'POST',            json: true,            body: {'chain': myChain}        })).then((res) =&gt; {            // 同步最长链            myChain.resolveChain(JSON.parse(res.body)["chain"]);        });    }    p.then(() =&gt; {        res.send({            message: 'A new block is mined, and conflict is resolved',            content: myChain.lastBlock()        });    });});</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上我们实现了一个简单的区块链，虽然这个区块链简陋且不安全，但是我们能够成功将它部署到多个节点上，实现了最基本的区块链的功能。</p><p>完整代码：<a href="https://github.com/zhangzhishun/sugar-blockchain-js">代码</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mp.weixin.qq.com/s/6jwIj_m86dpGk62biEJyIA">30分钟自己写一条区块链(一)</a></li><li><a href="https://mp.weixin.qq.com/s/UbLx2mHEb9OyPeJBwP2bvg">30分钟自己写一条区块链(二)</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 部署文档 </tag>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript创建一条区块链(一)</title>
      <link href="/2022/02/28/blockchain/other/JavaScript%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%B8%80)/"/>
      <url>/2022/02/28/blockchain/other/JavaScript%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>如何从技术上实现一条区块链？<br>首先，这里假定读者有基本的编程能力，虽然本文用了Javascript来写，但掌握任意一门编程语言的读者阅读起来应该不会有任何难度。</p><h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>我们首先需要安装最新版的Node.js</p><h2 id="第一步，搭建区块链模型"><a href="#第一步，搭建区块链模型" class="headerlink" title="第一步，搭建区块链模型"></a>第一步，搭建区块链模型</h2><p>我们首先来搭一个能够新建区块，创建交易的区块链的模型。</p><pre><code class="javascript">'use strict';//定义一个class，叫BlockChain，每一个区块链都是这个class的实例class BlockChain {    constructor() {        this.chain = []; // 储存所有区块        this.difficulty = 4; // 挖矿的难度    }    isProofValid(tentativeBlock) {        // 这里我们判断newProof是不是一个合法的proof的方法是    }    createBlock(transaction, previousHash = undefined) {        // 创造一个新区块    }    createTransaction(sender, receiver, value) {        // 创建一个交易    }    static hash(block) {        // 对一个区块进行哈希:    }    lastBlock() {        // 取得链上的最后一个区块    }    miner() {        // 挖矿程序    }}</code></pre><p>这里要解释一下区块(block)和交易(transaction)各自长什么样，虽然不同区块链的区块模型有很大差异，但最基本的一些元素都是相通的。一个最基本的区块大概长下面这样：</p><pre><code class="javascript">var block = {       timestamp: 1516245715528,     id: 0,    proof: 786453290000,    previousBlockHash: "12f79cda4fb3f084531de2034e6b4acf",    transactions: [{        sender: "0xca35b7d915458ef540ade6068dfe2f44e8fa733c",        receiver: "0x14723a09acff6d2a60dcdf7aa4aff308fddc160c",        value: 100    }]}</code></pre><p>可以看到，一个区块包含了它被挖出来的时间戳(timestamp)，它在区块链里的位置(id)，它的证明(proof, 更多的会在之后讲到)，前一个区块的整体哈希值(previousBlockHash)，包含的交易(transactions)。 作为一个最基本的交易模型，每一个交易只包含了发送者的地址(sender)，接受者的地址(receiver)，以及这次交易的价值(value)。</p><h2 id="第二步，实现基本功能"><a href="#第二步，实现基本功能" class="headerlink" title="第二步，实现基本功能"></a>第二步，实现基本功能</h2><p>工具函数<br>这里我们首先实现一个工具函数Hash(block), 它会帮助我们将一个区块进行哈希。这个函数会在我们进行挖矿(发掘新区块)的时候用到。</p><pre><code class="javascript">static hash(block) {    // 对一个区块进行哈希:    // 现将block 转换成base64    // 将得到的结果进行SHA哈希    const blockStr = JSON.stringify(block);    const blockB64 = new Buffer(blockStr).toString("base64");    const newHash = crypto.createHash("sha256");    newHash.update(blockB64);    return newHash.digest("hex");}</code></pre><p>这个函数将一个区块，也就是一个Javascript object，哈希成一段字符串。我们使用了crypto这个工具，在最新版的Node.js里面已经是内置了，所以我们并不需要安装它。</p><p>创建一个新交易<br>下一步，我们实现创建新交易的方法。</p><pre><code class="javascript">createTransaction(sender, receiver, value) {    // 创建一个交易    // 根据提供的sender, receiver地址，以及转账的价值，建立一个交易    // 并把它加入到我们的区块链里    const transaction = {        sender: sender,        receiver: receiver,        value: value    };    this._packTransactions.push(transaction);    return this.miner();}</code></pre><p>非常直观，我们只是创建了一个object，加入到区块链里并返回而已。</p><p>创建一个新区块<br>我们现在来实现创建一个区块的代码。当我们的区块链连一个区块也没有的时候，我们需要建立第一个区块(genesis block)，这一点我们在constructor里面实现。</p><pre><code class="javascript">constructor() {    this.chain = []; // 储存所有区块    this.difficulty = 4; // 挖矿的难度    this.createBlock(["Genesis Block"], 1); // 创建第一个区块    this._packTransactions = []; // 当前需要打包的数据}createBlock(transaction, previousHash = undefined) {    // 创造一个新区块    // 一开始的proof是0，不一定是有效的，所以我们需要mineProof来找到有效的proof    let block = {        timestamp: Date.now(),        id: this.chain.length,        proof: 0,        previousBlockHash: previousHash || this.constructor.hash(this.lastBlock()),        transactions: transaction    };    const hash = this.mineProof(block);    this.chain.push(block);    return hash;}</code></pre><p>在创建一个新区块的时候，我们用了当前时间的时间戳，以现在区块链的长度作为id，初始的proof设置为0(proof会在下一步详细讲到)，并将上一个区块整体进行哈希并赋值给previousBlockHash。在创建genesis 区块的时候，我们将previousBlockHash设置为1。 为了便于理解，我们建立新区块的时候没有附上任何交易，实际的情况是矿工可以自主选择包含哪些交易，并需要对这些交易进行处理得到一个默克尔树。</p><h2 id="理解挖矿：找到有效的Proof"><a href="#理解挖矿：找到有效的Proof" class="headerlink" title="理解挖矿：找到有效的Proof"></a>理解挖矿：找到有效的Proof</h2><p>读者朋友们应该都听说过工作量证明(Proof of Work)，POW是区块链中用来创造区块的核心算法或者机制。POW本身的目的是为了找到一个数字来解决一个数学问题，而找到这个数字的难度是越来越高的，但一旦找到之后，要证明它解决了这个数学问题又是非常容易的，任何人都能很快做到。 当然除了Proof of Work之外，我们还有Proof of Space, Proof of Stake，在代码里我们就用proof来代表找到的这个数字。 那么这个数学问题到底是什么呢？我们用一个例子来回答。</p><p>给定一个数字A，我们想找到数字B，使得Hash(A<em>B)的结果C的最后1位等于0。也就是说，C可以是Hash(A</em>B)=2ba83…6d0，因为它的最后一位是0。</p><h2 id="实现挖矿"><a href="#实现挖矿" class="headerlink" title="实现挖矿"></a>实现挖矿</h2><p>知道了如何挖矿之后，我们将上面的代码融合到我们的区块链模型里。</p><pre><code class="javascript">    isProofValid(tentativeBlock) {        // 这里我们判断newProof是不是一个合法的proof的方法是        // 将整个区块进行哈希        // 如果得到的散列值指的最后n位都是0，那么这是一个valid proof        // 其中，n = difficulty        const result = this.constructor.hash(tentativeBlock);        return result.substr(result.length - this.difficulty) === '0'.repeat(this.difficulty);    }    mineProof(tentativeBlock) {        console.log("miner block start: " + JSON.stringify(tentativeBlock));        while (!this.isProofValid(tentativeBlock)) {            tentativeBlock.proof += 1; // 如果不是可用的proof，我们就接着枚举        }        const hash = this.constructor.hash(tentativeBlock);        console.log("miner block success. Hash: " + hash);        return hash;    }    createBlock(transaction, previousHash = undefined) {        // 创造一个新区块        // 一开始的proof是0，不一定是有效的，所以我们需要mineProof来找到有效的proof        let block = {            timestamp: Date.now(),            id: this.chain.length,            proof: 0,            previousBlockHash: previousHash || this.constructor.hash(this.lastBlock()),            transactions: transaction        };        const hash = this.mineProof(block);        this.chain.push(block);        return hash;    }    miner() {        // 挖矿程序        if (this._packTransactions.length &gt; 0) {            const hash = this.createBlock([this._packTransactions[this._packTransactions.length - 1]]);            if (hash) {                this._packTransactions.pop();                return hash            }        }    }</code></pre><p>完整代码：<a href="https://github.com/zhangzhishun/sugar-blockchain-js/blob/master/blockchain.js">blockchain</a></p><p>参考：</p><ol><li><a href="https://mp.weixin.qq.com/s/6jwIj_m86dpGk62biEJyIA">30分钟自己写一条区块链(一)</a></li><li><a href="https://mp.weixin.qq.com/s/UbLx2mHEb9OyPeJBwP2bvg">30分钟自己写一条区块链(二)</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 部署文档 </tag>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于以太坊的战艇游戏(Layer2)源码解析</title>
      <link href="/2022/02/24/blockchain/layer2/%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%88%98%E8%89%87%E6%B8%B8%E6%88%8F(Layer2)/"/>
      <url>/2022/02/24/blockchain/layer2/%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%88%98%E8%89%87%E6%B8%B8%E6%88%8F(Layer2)/</url>
      
        <content type="html"><![CDATA[<h1 id="基于以太坊的战艇游戏-Layer2-源码解析"><a href="#基于以太坊的战艇游戏-Layer2-源码解析" class="headerlink" title="基于以太坊的战艇游戏(Layer2)源码解析"></a>基于以太坊的战艇游戏(Layer2)源码解析</h1><h2 id="一、游戏介绍"><a href="#一、游戏介绍" class="headerlink" title="一、游戏介绍"></a>一、游戏介绍</h2><p>每一个玩家都可以看到上图所示的页面。该页面分为两部分，下面部分表示当前玩家的棋盘信息，开始的时候，该玩家随机选择两个格子，用于放置两个战舰；上面部分显示对方玩家的棋盘信息，除了对方玩家的战舰位置。开始的时候，上面部分的棋盘是空的。游戏开始之后，两个玩家轮流猜测对方的战舰的位置，每一次只能猜一个方格。如果对方的战舰不在所猜测的方格中，那么就会在对应位置显示一个水花的图像；反之，则出现一团火的图像。因为双方看不到对方的棋盘，因此，每一次都需要对方玩家回复“所猜测的方格是否有战舰”（我们可以采用密码学的技术检测出对方是否撒谎）。当某一个玩家率先猜中了对方两个战舰的位置，该玩家就赢了，并可以收取自己和对方的赌注。</p><h2 id="二、涉及技术"><a href="#二、涉及技术" class="headerlink" title="二、涉及技术"></a>二、涉及技术</h2><p>使用的编程技术有：</p><ul><li>HTML； Javascript; CCS; (网页前端)</li><li>Web3 （提供了调用智能合约的js接口）</li><li>ganache-cli （在本地模拟以太坊节点）</li><li>remix （以太坊智能合约的IDE）</li><li>Solidity （智能合约编程语言）</li></ul><h2 id="三、技术概括"><a href="#三、技术概括" class="headerlink" title="三、技术概括"></a>三、技术概括</h2><p>下图显示，如果使用layer1的区块链技术，每走一步棋都需要向区块链发布一个交易。</p><p><img src="/images/battle-ship-layer2/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5neWlodWFp,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>下图所示的正是我们使用的方式。</p><p><img src="/images/battle-ship-layer2/watermark,type_W5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5neWlodWFp,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>一个问题：如何检测对方玩家撒谎？<br>具体为，每一个玩家在游戏开始前都需要随机指定两个格子，表示两个战舰的位置，如果某玩家中途变卦，不承认自己所指定的那两个格子呢？再者，当前玩家猜测对方玩家战舰所在的方格位置，对方玩家需要回复该方格下是否有战舰，如果对方玩家不诚信呢？我们使用了Merkle<br>tree进行commit（承诺）。介绍merkle tree（形如下图）不属于本文的范围。</p><p>根据密码学中的hash函数的特点，任意一个节点的变化都会导致根节点变化。并且，我们能够很容易证明某一个节点是否属于该merkle tree。</p><p><img src="/images/battle-ship-layer2/watermark,type_oZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5neWlodWFp,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>这里，我们对两位玩家的所有的游戏方格分别生成两棵merkle tree，叶子节点表示方格的编号。这里为了保密性，在编号后面合并一个随机数（合并后的数据作为hash函数的输入）。</p><p>因此，解决方法是，在玩家指定两个战舰的位置之后，需要生成一棵merkle<br>tree，并向对方发送根节点。该根节点便是对方的承诺，且它不会泄露战舰的位置信息。在游戏过程中，如果要揭露某一个方格下是否存在战舰，需要将对应编号的叶子节点和从该节点到根节点的路径信息发送给对方。若对方能够构造出相同的根节点，证明该玩家是诚信的。（这里涉及到了密码学hash函数的知识）。</p><p>另一个问题：如果一个玩家a中途离开，怎么办？ 当前实现的功能：需要玩家b向智能合约中提交一个控告。为了回应该控告，玩家a要在一分钟之内调用智能合约，取消掉该控告。如果一分钟之后玩家a不回复，那么玩家b就可以取走所有的赌注。</p><h2 id="四、区块链和智能合约的作用"><a href="#四、区块链和智能合约的作用" class="headerlink" title="四、区块链和智能合约的作用"></a>四、区块链和智能合约的作用</h2><p>在这个游戏中，智能合约充当了裁判的角色：若某个玩家撒谎或者中途离开，那么智能合约就会把赌注给另一个玩家。因此，本质上区块链中的智能合约解决了信用问题，并且，重要的是，不需要依赖任何可信的第三方。游戏玩家不需要相信任何人：不用担心对方不诚信，不用担心游戏平台和对方玩家勾结；不用担心自己的赌注莫名奇妙就被取走；不用担心游戏平台宕机。</p><p>下图表示的是智能合约的fields，也即是智能合约需要保存的数据。我们保存了两个玩家的地址，赌注的数量，游戏状态，最终赢家的地址，两个merkle tree的跟节点，超时不回复的数据等等。</p><p>该项目还实现了下述功能：</p><ul><li>Forfeit Game，表示当前玩家放弃该游戏，包括赌注。（已实现）</li><li>Claim Win，在当前玩家猜中对方两个战舰之后，点击该按钮就可以取走所有的赌注。（已实现）</li><li>Accuse<br>Cheating，原本的功能是当发现对方玩家撒谎时，将撒谎的数据发布到智能合约中，让智能合约裁决。如果读者想要实现该功能，需要注意，某一个玩家在向对方发送数据前，需要对该数据签名，以避免耍赖。因此，当某一个玩家要求智能合约裁决时，智能合约需要验证相关签名。（未实现）</li><li>Accuse Timeout，控告对方玩家中途离开；（已实现）</li><li>Respond to Accusation， 当当前玩家被控告时，该玩家需要在一分钟内点击该按钮，表示自己在线，来回复控告。（已实现）</li><li>claim timeout winnings，如果被告人没有在一分钟之内回复，就可以点击该按钮来取走所有的赌注。（已实现）</li></ul><h2 id="五、源码分析"><a href="#五、源码分析" class="headerlink" title="五、源码分析"></a>五、源码分析</h2><h3 id="1-构造Merkle树"><a href="#1-构造Merkle树" class="headerlink" title="1. 构造Merkle树"></a>1. 构造Merkle树</h3><p>使用JavaScript代码实现构造树，首先计算每个位置否存在舰艇+随机数组合后取sha3，作为每个位置的hash，然后每两个页节点取一次hash，循环最终形成一个根节点。</p><p><img src="/images/battle-ship-layer2/merkle.png" alt="img"></p><p>最终构造后的merkle树为5层，每层节点数为1、2、4、8、16</p><p>内容如下：</p><p><img src="/images/battle-ship-layer2/image-20220223205315073.png" alt="image-20220223205315073"></p><p>JS代码：</p><pre><code class="javascript">/* build_merkle  builds a Merkle Tree from the given initial_board and nonces  \args:    initial_board - [[]] - 初始化甲板作为矩阵传递，二维数组，对应横纵坐标，值为是否含有舰艇（bool）    nonces - [[Uint32]] - 随机值矩阵*/function build_merkle(initial_board, nonces) {    check_correct_sizes(initial_board, nonces);    let merkle = [[]];    // add all leaf nodes    for (let i = 0; i &lt; BOARD_LEN; i++) {        for (let j = 0; j &lt; BOARD_LEN; j++) {            merkle[0].push(                web3.utils.keccak256(                    web3.utils.fromAscii(JSON.stringify(initial_board[i][j]) + JSON.stringify(nonces[i][j]))                )            );        }    }    // build tree from leaves    // while, current level of merkle has length &gt; 1, add more levels    let curr_level = 0;    while (merkle[curr_level].length &gt; 1) {        merkle.push([]);        curr_level += 1;        // build new layer of tree        for (let i = 0; i + 1 &lt; merkle[curr_level - 1].length; i += 2) {            // have new_node represent another node in the Merkle tree            let new_node = web3.utils.keccak256(merkle[curr_level - 1][i] + merkle[curr_level - 1][i + 1].substring(2), {encoding: 'hex'});            // finalize finally computes the hash for every argument passed in update            merkle[curr_level].push(new_node);        }        // if this most recent merkle level has an odd length, we need        // to just hoist the last element into the next level        if (merkle[curr_level - 1].length % 2 !== 0) {            merkle[curr_level].push(merkle[curr_level - 1][merkle[curr_level - 1].length - 1]);        }    }    return merkle;}</code></pre><h3 id="2-猜测舰艇位置"><a href="#2-猜测舰艇位置" class="headerlink" title="2. 猜测舰艇位置"></a>2. 猜测舰艇位置</h3><p>首先发送猜测给对手，对手回应是否猜中，如果猜中了猜测者发起合约验证。</p><p>JS代码：</p><pre><code class="javascript">// function called when a user guesses a squareasync function guess_square(i, j, player, opponent, callback) {    // 签名    let signed_guess = await player.build_guess(i, j);    // 发送签名和猜测给对手获取对手回应是否猜中、随机数、merkle验证使用的节点数组    let [opening, nonce, proof] = await opponent.respond_to_guess(i, j, signed_guess);    // 更新页面    $('#' + opponent.my_name + ' &gt; .my-board #' + i + '-' + j)        .css('background-image', 'url(' + (opening ? EXPLOSION_IMG : SPLASH_IMG) + ')');    // interpret response    await player.receive_response_to_guess(i, j, [opening, nonce, proof]);    // return if the guess hit a ship    callback(opening);}</code></pre><p>respond_to_guess方法获取nonce, proof方法，JS代码：</p><pre><code class="javascript">/* 获取零知识证明需要的节点hash  /args:    initial_board - matrix representing my-board state    nonces - nonces for your board    guess - [i, j] - guess building proof for*/function get_proof_for_board_guess(initial_board, nonces, guess) {    let merkle_tree = build_merkle(initial_board, nonces);    let index_in_merkle = guess[0] * BOARD_LEN + guess[1];    let proof = [];    for (let i = 0; i &lt; merkle_tree.length - 1; i++) {        let merkle_group = Math.floor(index_in_merkle / Math.pow(2, i)); // goodod        let index_in_group = merkle_group % 2;        let sibling = Math.min(merkle_group - index_in_group + (index_in_group + 1) % 2, merkle_tree[i].length - 1);        if (sibling == merkle_group) continue;        proof.push(merkle_tree[i][sibling]);    }    return proof;}</code></pre><p>验证是否击中，Solidity代码：</p><pre><code class="solidity">// 验证单个单板上的单个点的证明// args:// - opening_nonce - 对应于web3.utils.fromAscii(JSON.stringify(open) + JSON.stringify(nonce)));// - proof - sha256哈希表，对应于 get_proof_for_board_guess()的输出// - guess - [i, j] - guess开口对应（guess that opening corresponds to）// - commit - board的默克尔根function verify_opening(bytes memory opening_nonce, bytes32[] memory proof, uint guess_leaf_index, bytes32 commit) public pure returns (bool result) {    bytes32 curr_commit = keccak256(opening_nonce); // see if this changes hash    uint index_in_leaves = guess_leaf_index;    uint curr_proof_index = 0;    uint i = 0;    while (curr_proof_index &lt; proof.length) {        // 对于默克尔树的当前层级，猜测的节点在哪个组的索引(相当于默克尔树下一层级parent的索引)        // index of which group the guess is in for the current level of Merkle tree        // (equivalent to index of parent in next level of Merkle tree)        uint group_in_level_of_merkle = index_in_leaves / (2**i);        // Merkle分组（两个为一组分组）索引数，只有(0, 1)        uint index_in_group = group_in_level_of_merkle % 2;        // 当前默克尔层级的最大节点索引        uint max_node_index = ((BOARD_LEN * BOARD_LEN + (2**i) - 1) / (2**i)) - 1;        // curr_commit的同级索引        uint sibling = group_in_level_of_merkle - index_in_group + (index_in_group + 1) % 2;        i++;        if (sibling &gt; max_node_index) continue;        if (index_in_group % 2 == 0) {            curr_commit = keccak256(merge_bytes32(curr_commit, proof[curr_proof_index]));            curr_proof_index++;        } else {            curr_commit = keccak256(merge_bytes32(proof[curr_proof_index], curr_commit));            curr_proof_index++;        }    }    return (curr_commit == commit);}</code></pre><h3 id="3-判定赢"><a href="#3-判定赢" class="headerlink" title="3. 判定赢"></a>3. 判定赢</h3><p>leaf_index_check_p2中记录着已经击中了多少舰艇</p><p>Solidity代码：</p><pre><code class="solidity">// 宣布你赢了比赛// 如果你击中了2个舰艇，然后这个函数会转移赢钱给你和结束游戏。function claim_win() public{    assert(msg.sender == p1 || msg.sender == p2);    bool    isP1Win = true;    if (msg.sender == p2) {        isP1Win = false;    }    if (isP1Win) {        require(leaf_index_check_p2.length &gt;= 2);        winner = p1;    } else {        require(leaf_index_check_p1.length &gt;= 2);        winner = p2;    }    // transfer all the tokens from this contract to the winner (i.e., msg sender)    msg.sender.transfer(address(this).balance);    state = 2;}</code></pre><h3 id="4-控告对手作弊"><a href="#4-控告对手作弊" class="headerlink" title="4. 控告对手作弊"></a>4. 控告对手作弊</h3><p>调用上面的verify_opening方法验证是否满足Merkle树，不满足说明对方作弊。</p><p>Solidity代码：</p><pre><code class="solidity">// 控告对手作弊 — 如果是真的，你就赢了。// opening_nonce - 对应于JS中的web3.utils.fromAscii(JSON.stringify(opening) + JSON.stringify(nonce))// proof - 一个sha256哈希列表，你可以从get_proof_for_board_guess(这是发送者认为是一个谎言)// guess_leaf_index - 猜测船只位置的索引// owner - 这艘船所在的board的所有者的地址function accuse_cheating (    bytes memory opening_nonce,    bytes32[] memory proof,    uint256 guess_leaf_index,    address owner) public returns (bool result) {    assert((msg.sender == p1 &amp;&amp; owner == p2) || (msg.sender == p2 &amp;&amp; owner == p1));    bytes32 com = merkle_root_p1;    if(owner == p2){        com = merkle_root_p2;    }    if(!verify_opening(opening_nonce, proof, guess_leaf_index, com)){        msg.sender.transfer(address(this).balance);        state = 2;        winner = msg.sender;        return true;    }    return false;}</code></pre><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ol><li>源代码提供：<a href="https://blog.csdn.net/liangyihuai/article/details/116459829">https://blog.csdn.net/liangyihuai/article/details/116459829</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
            <tag> Layer2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪崩共识</title>
      <link href="/2022/02/08/blockchain/avalanche/%E9%9B%AA%E5%B4%A9%E5%85%B1%E8%AF%86/"/>
      <url>/2022/02/08/blockchain/avalanche/%E9%9B%AA%E5%B4%A9%E5%85%B1%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><strong>1.引言</strong></p><p>Avalanche主网正式上线，OKEx也已经上架Avalanche原生代币AVAX，曾获得“共识协议3.0”之称的Avalanche重回大众视野，为何Avalanche一举一动受到如此大的市场关注？</p><p>这一切要从2015年5月说起，康奈尔大学出现了一篇《从“雪花”到“雪崩”：一种新型的亚稳态共识协议族》的论文，在市场上引发了雪崩式的迅速反响，成为可以和中本聪的PoW机制、以太坊智能合约相媲美的颠覆性技术创新。</p><p><strong>2.结合早期协议优点并改进缺点</strong></p><p>正如康奈尔大学教授埃米·冈·瑟勒（Emin Gun Sirer）所言：“Avalanche描述了一种新的共识协议，它将中本聪共识协议与经典共识协议相结合，这是一次重大的突破”。在此之前，经典共识协议和中本聪共识协议是早期两类解决分布式系统拜占庭问题的主要共识协议。</p><p>分布式系统中的共识问题一直是计算机科学领域的重要话题，而拜占庭将军问题则是重中之重。战争时期，在军队可能有叛徒和间谍的情况下忠诚的将军如何达成一致的意见，这便是拜占庭将军问题。经典共识协议由图灵奖得主兰伯特提出，具有强一致性、高效的特点，但也有通信成本高、节点无法自由进出的缺点。</p><p><strong>图1：经典共识协议（PBFT）工作原理</strong></p><p><img src="https://hx24.huoxing24.com/image/crawler/2020/09/28/1601261161638216.jpg" alt="拜占庭">资料来源：《区块链技术指南》，OKEx Research</p><p>而著名的中本聪共识协议则创造性地用概率保证实际运行的共识，解决了节点无法自由进出的问题，但是成本高昂问题仍未被解决。</p><p><strong>图2：中本聪共识协议工作原理</strong></p><p><img src="https://hx24.huoxing24.com/image/crawler/2020/09/28/1601261161662703.jpg" alt="拜占庭">资料来源：OKEx Research</p><p>Avalanche共识协议则结合了两类协议的优点：借鉴了中本聪协议概率性安全保障的设计，同时加入了BFT属性，增加系统的效率和安全性。</p><p><strong>3.Avalanche原理：“雪花”到“雪崩”的层层完善</strong></p><p>正如Avalanche白皮书提到的“雪花”到“雪崩”过程，Avalanche的4个子协议组成正是从最简单的Slush协议，到Snowflake、Snowball 和 Avalanch，逐步完善，形成了“雪花”到“雪崩”的质变。</p><p><strong>3.1. “雪泥”Slush 协议：万物之初</strong></p><p>Slush协议是最基础的“雪泥”，通过多次随机抽样来达成共识。为便于理解，这里我们以投票确认颜色为例。节点达成共识的步骤如下：</p><p>（1）初始状态时所有的节点均未着色；</p><p>（2）当节点A收到信息时，未着色的节点将信息颜色设为自己的颜色，并询问其他节点的颜色；</p><p>（3）未着色的节点B收到询问，将自己染成相同颜色并回复；已着色的节点C收到询问会回复自己的颜色；</p><p>（4）节点A收到多个响应后，如果大多数颜色和自己的一直，则不改变颜色，否则改变颜色，即以大多数其他节点的颜色反馈来校正自己的颜色。</p><p>Slush协议就已经解决了经典共识协议通讯成本高的问题，还用部分抽样等方式避免了中本聪共识协议高能耗的问题。后续协议的改进主要为了提升共识协议安全性。</p><p><strong>3.2. “雪花”Snowflake协议：初步改善</strong></p><p>在拜占庭节点存在的情况下，Slush不能提供强大的安全保证。为此，Snowflake作为升级版协议引入了计数器（Counter）来增加系统的安全性。</p><p>具体而言，网络中的攻击节点故意散播错误的颜色，可能导致Slush某一轮统计得到错误的颜色，而Snowflake的计数器统计了某种颜色连续出现的次数，只有某种颜色连续出现多次，节点才会改变自己的颜色。如此避免了拜占庭节点带来的干扰，确保了系统的安全性和活跃度。</p><p><strong>3.3. “雪球”Snowball协议：深入升级</strong></p><p>Snowball在Snowflake的基础上更进一步地。引入了类似信誉积分的制度——信任度，以提高安全性。</p><p>具体而言，Snowflake协议的改进如下：</p><p>（1）每成功查询一次，节点就为该颜色的信任度加1分；</p><p>（2）节点会切换为信任度较高的颜色。</p><p>Snowball协议不仅比Snowflake更难遭受攻击，而且更容易推广到多命令协议。</p><p><strong>3.4. “雪崩”Avalanche协议：量变到质变</strong></p><p>终极Boss“雪崩”——Avalanche又在Snowball的基础上增加了有向无循环图（DAG）来记录所有的交易状态。在DAG中，如果想给从创世点到某节点路径上的所有节点都投票只需要给该节点投票，大大提高了效率。其次，DAG有着类似于区块链的链式结构记录交易信息，使得过去的交易信息很难被篡改，进一步提升了安全性。</p><p>图3：DAG示意图</p><p><img src="https://hx24.huoxing24.com/image/crawler/2020/09/28/1601261161723758.jpg" alt="拜占庭">资料来源：《区块链新共识算法 Snowflake to Avalanche》，OKEx Research</p><p><strong>3.5. Avalanche协议：集前期协议之大成</strong></p><p>吸取了早期两个共识协议的优点，并经过4个协议层次递进、逐步改善，Avalanche协议具有许多优良特性。</p><p>（1）高效的可扩展性：轻量级，可扩展，低延迟；</p><p>（2）高拜占庭容错：即使网络中有超过50%的节点是拜占庭节点，网络依然是安全的;</p><p>（3）静态绿色：与PoW机制不同，Avalanche协议不会浪费任何资源;</p><p>（4）低通信成本：Avalanche协议比传统共识协议的通讯复杂度更低。</p><p><strong>4. 零确认交易与Avalanche协议</strong></p><p>Avalanche刚面世时，人们还没有发现Avalanche协议与零确认交易之间有什么关系。然而在2018年12月左右，BCH社区的技术人员Chris Pacia发表一篇文章，认为可以使用Avalanche协议来保证零确认交易的安全性，一时起千层浪，引发了市场的广泛兴趣。</p><p>Avalanche协议的确认需要多次抽样，为缩短确认时间，则抽样次数必须受到限制，这意味着，恶意节点超过一定比例后，在有限抽样里诚实节点无法达成共识。为此，Chris Pacia认为可以引入PoW机制来保护网络的安全，防止黑客的攻击节点数量太多。</p><p><strong>5. Avalanche现状：众望所归</strong></p><p>自2018年Avalanche白皮书发布以来，受到了广泛的首肯心折，许多VC相竞为之折腰。2019 年，雪崩协议Ava获得了 a16z、Polychain Capital 等机构 600 万美元融资。2020年6月，AVA Lab又完成了一笔1200万美元的代币私募融资，同年7月，又获得IOSG Ventures的战略投资，并就中国市场未来发展达成独家战略合作协议。根据最新消息，AVA的公募于7月8日开启。</p><p><strong>6. 结语</strong></p><p>Avalanche结合了早期两种共识协议的优点并改进其缺点，具有高拓展性、静态绿色以及低通信成本的优点。同时，从Slush到Avalanche层层递进、逐步完善，引入计数器、可信度、DAG等，日臻完善。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.avalabs.org/whitepapers">Avalanche writepaper</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Avalanche </tag>
            
            <tag> 共识算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker方式搭建以太坊网络-私有链</title>
      <link href="/2022/01/29/blockchain/ethereum/Docker%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A---%E7%A7%81%E6%9C%89%E9%93%BE/"/>
      <url>/2022/01/29/blockchain/ethereum/Docker%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A---%E7%A7%81%E6%9C%89%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>本文涉及的知识和技术有：</p><ul><li>Docker：一种时下流行的容器</li><li>geth：以太坊客户端的go实现</li><li>truffle：以太坊合约部署工具</li></ul><h2 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h2><p>此处需要补充一点的是，如果您使用的是虚拟机、云主机或者老破小机器，需要确保分配给主机的内存至少2GB。因为以太坊为了抵御比特大陆这样的ASIC矿机对算力的垄断，采用了和比特币完全不同的PoW算法——ethash。该算法的特点是算力不敏感，内存敏感。该算法目前需要在内存创建大约1GB的DAG用来做PoW运算，且DAG会随着区块的增加呈阶梯状增长，因此建议至少给挖矿节点的宿主机器分配至少2GB的内存，且保留扩大内存容量的灵活性。</p><h2 id="获取geth镜像"><a href="#获取geth镜像" class="headerlink" title="获取geth镜像"></a>获取geth镜像</h2><p>docker hub上有现成的geth镜像。直接获取：</p><pre><code class="bash">docker pull ethereum/client-go:v1.8.12</code></pre><h2 id="创建Docker网络"><a href="#创建Docker网络" class="headerlink" title="创建Docker网络"></a>创建Docker网络</h2><p>旧版本的docker容器相互之间是依靠link建立关系。<br>新版本docker推荐创建自有网路，再将需要互联的容器配置到相同的网络中。<br>于是，我们创建一个名为“ethnet“的网络。该网络配置如下：</p><ul><li>子网172.19.0.0/16<ul><li>IP段172.19.0.0</li><li>掩码255.255.0.0</li><li>IP范围172.19.0.1~172.19.255.254</li><li>IP广播172.19.255.255</li></ul></li></ul><pre><code class="bash">docker network create -d bridge --subnet=172.19.0.0/16 ethnetdocker network ls</code></pre><h1 id="配置以太坊网络"><a href="#配置以太坊网络" class="headerlink" title="配置以太坊网络"></a>配置以太坊网络</h1><p>运行如下命令进入一个容器：</p><pre><code class="bash">docker run -it --rm --network ethnet --ip 172.19.0.50 -v /opt/docker-project/eth/workspace:/workspace --entrypoint /bin/sh ethereum/client-go:v1.8.12</code></pre><blockquote><p>–network ethnet参数指定了该容器加入刚才创建的ethnet网络<br> –ip 172.19.0.50指定了一个固定IP给该容器。</p></blockquote><h2 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h2><p>首先，在容器内的/workspace目录创建目录和文件</p><p>执行以下命令：</p><pre><code class="bash">mkdir -p /workspacedappmkdir -p /workspace/dapp/minermkdir -p /workspace/dapp/datatouch /workspace/dapp/genesis.json</code></pre><p>然后运行如下命令创建账户：</p><pre><code class="bash">geth -datadir /workspace/dapp/miner/data account new</code></pre><p>输入两次password，获得地址。将地址记录下来，后面要用到。</p><blockquote><p>重复如上步骤可以创建多个账户。</p></blockquote><h2 id="创建创世区块"><a href="#创建创世区块" class="headerlink" title="创建创世区块"></a>创建创世区块</h2><p>编辑刚才创建的文件</p><pre><code class="bash">vi /workspace/dapp/data/genesis.json</code></pre><p>文件内容：</p><pre><code class="json">{  "config": {    "chainId": 88,    "homesteadBlock": 0,    "eip155Block": 0,    "eip158Block": 0  },  "alloc"      : {    "b126d89780d2221ceffe5c94efd9ca6a005a9f0c": {"balance": "100000000000000000000"},    "93415bb68da6816c581537a4fa74727ddf6f4f4d": {"balance": "1000000000000000000"},    "fa5773a704ee9e91e60ffb8fe4207e934f70619f": {"balance": "1000000000000000000"}  },  "coinbase"   : "0x0000000000000000000000000000000000000000",  "difficulty" : "0x400",  "extraData"  : "",  "gasLimit"   : "0x2fefd8",  "nonce"      : "0x0000000000000000",  "mixhash"    :  "0x0000000000000000000000000000000000000000000000000000000000000000",  "parentHash" :  "0x0000000000000000000000000000000000000000000000000000000000000000",  "timestamp"  : "0x00"}</code></pre><ul><li>genesis.json是用来创建创世区块的配置文件</li><li>加入同一私链的节点必须使用同一配置文件</li><li>chainid是私链网络的标识，可以是任意数字。</li><li>即使chainid相同，如果genesis.json配置不一样，也将是两个不兼容的网络</li><li>alloc下面列举了4个账户地址，分别是上一步创建并记录下来的地址。</li><li>balance是创世区块为每个账户分配的初始以太币。这里看似分配了很多，其实单位是wei。1eth=10^18wei。也就是除了第一个账户给了100eth外，其它几个账户分别只拥有1eth。这里给第一个账户多分点，是因为我们之后需要用它来部署合约。</li></ul><h2 id="完成以太坊网络配置"><a href="#完成以太坊网络配置" class="headerlink" title="完成以太坊网络配置"></a>完成以太坊网络配置</h2><p>此时可以退出刚才的容器。由于我们运行容器是加了–rm参数，刚才的容器会被删除，但宿主机的/workspace下的文件会被保存下来。</p><h1 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h1><p>上述步骤只是配置好了一个以太坊私有网络，并没有真正创建网络。我们知道，以太坊网络是一个分布式的网络，有了矿工，才有的网络。于是，我们首先得有一个矿工。</p><h2 id="创建“主”矿工节点"><a href="#创建“主”矿工节点" class="headerlink" title="创建“主”矿工节点"></a>创建“主”矿工节点</h2><p>我们接下来打算创建的矿工节点，成为“主”矿工，因为它需要拥有如下特性：</p><ul><li>它是一个容器，并且是持久的容器</li><li>它会自动读取genesis.json文件，并初始化以太坊网络</li><li>它能够连接其它节点（容器）</li><li>它能够接受各种rpc调用，并能够部署合约</li><li>它已经配置好挖矿账户，可以一键挖矿</li></ul><p>于是，我们按照这个要求，开始一步步创建矿工节点。</p><h3 id="创建entrypoint脚本"><a href="#创建entrypoint脚本" class="headerlink" title="创建entrypoint脚本"></a>创建entrypoint脚本</h3><p>创建一个文件：</p><pre><code class="bash">vi /opt/docker-project/eth/workspace/dapp/init.sh</code></pre><p> 文件内容如下：</p><pre><code class="bash">#!/bin/shgeth -datadir ~/data/ init /workspace/dapp/data/genesis.jsonif [  $# -lt 1 ]; then   exec "/bin/sh"else  exec /bin/sh -c "$@"fi</code></pre><blockquote><p>该脚本的功能是让以太坊节点（容器）自动初始化以太坊网络，并且接受一个自动运行脚本作为输入。</p></blockquote><h3 id="创建自动运行脚本"><a href="#创建自动运行脚本" class="headerlink" title="创建自动运行脚本"></a>创建自动运行脚本</h3><p>创建一个文件：</p><pre><code class="bash">vi /opt/docker-project/eth/workspace/dapp/mine.sh</code></pre><p>内容如下：</p><pre><code class="bash">#!/bin/shaccount='b126d89780d2221ceffe5c94efd9ca6a005a9f0c'cp -r /workspace/dapp/miner/data/keystore/* ~/data/keystore/geth -datadir ~/data/ --networkid 88 --rpc --rpcaddr "172.19.0.50" --rpcapi admin,eth,miner,web3,personal,net,txpool --unlock ${account} --etherbase ${account} console</code></pre><ul><li>第一行命令是将刚才生成的账户私钥文件拷贝到容器的home目录下。因为/workspace是宿主目录挂载的，并不是linux文件系统，直接将datadir指定到该目录会导致geth报错。</li><li>第二行命令是启动以太坊节点的命令。<ul><li>–networkid 88指定了networkid，这个必须与genesis.json内设置保持一致</li><li>–rpc –rpcaddr “172.19.0.50” –rpcapi …. 这些参数表示该节点接受rpc，并且指定了rpc的协议</li><li>–unlock “0x…” 加入该参数会需要用户输入账户密码。密码校验后会解锁该账户。账户解锁后，该节点就能使用此账户的私钥进行签名加密等动作，用以进行交易、发布合约等。</li><li>–etherbase 参数指定了挖矿收益账户</li></ul></li></ul><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><pre><code class="bash">chmod +x /opt/docker-project/eth/workspace/dapp/init.shchmod +x /opt/docker-project/eth/workspace/dapp/mine.shdocker run -it --name=miner --network ethnet --ip 172.19.0.50 --hostname node -v /opt/docker-project/eth/workspace:/workspace --entrypoint /workspace/dapp/init.sh ethereum/client-go:v1.8.12 /workspace/dapp/mine.sh</code></pre><blockquote><p>该命令会创建一个持久化的容器。容器的entrypoint和自动运行脚本指定为我们刚创建的那两个脚本。</p></blockquote><p>如果报错：</p><pre><code class="bash">Fatal: Failed to unlock account (no key for given address or file)</code></pre><p>可能原因是没有修改上面的mine.sh脚本的account参数为第一个账户地址</p><h2 id="创建“从”矿工节点"><a href="#创建“从”矿工节点" class="headerlink" title="创建“从”矿工节点"></a>创建“从”矿工节点</h2><p>只有一个节点的网络，怎么看都不像“分布式”网络。所以我们需要创建更多的节点来形成一个“分布式网络”。我们称这些节点叫做“从”矿工。<br> 这类矿工不需要交易，不需要发布合约，因此不需要unlock账户，也不需要接受rpc。它们只知道埋头挖矿。</p><h3 id="创建自动运行脚本-1"><a href="#创建自动运行脚本-1" class="headerlink" title="创建自动运行脚本"></a>创建自动运行脚本</h3><p>“从”矿工节点和“主”矿工节点共享entrypoint，以保证它们创建出完全相同的网络。<br> 只有自动运行脚本不太一样，</p><pre><code class="bash">vi /opt/docker-project/eth/workspace/dapp/node.sh</code></pre><p>文件内容：</p><pre><code class="bash">#!/bin/shcp -r /workspace/dapp/miner/data/keystore/* ~/data/keystore/geth -datadir ~/data/ --networkid 88 console </code></pre><p>创建容器:</p><pre><code class="bash">chmod +x /opt/docker-project/eth/workspace/dapp/node.shdocker run -it --name=node1 --network ethnet --ip 172.19.0.51 --hostname node1 -v /opt/docker-project/eth/workspace:/workspace --entrypoint /workspace/dapp/init.sh ethereum/client-go:v1.8.12 /workspace/dapp/node.sh</code></pre><h1 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h1><p>以上创建出了多个以太坊节点，运行在同一网络下。每个节点都可以执行如下操作。供参考。</p><h2 id="节点发现"><a href="#节点发现" class="headerlink" title="节点发现"></a>节点发现</h2><h3 id="查看节点信息"><a href="#查看节点信息" class="headerlink" title="查看节点信息"></a>查看节点信息</h3><pre><code class="bash">geth -datadir ~/data/ --networkid 88 console&gt;admin.nodeInfo.enode# 输出"enode://708b66364c83af2d3725c309f2bdc0e7d4e395c6ac7310e1a1147b9dfe084649e6c6a3ce6c483c51ab6e924f6abade647246c2b57ecc49d9a573cea896cdf0e6@[::]:30303"</code></pre><h3 id="配置静态节点文件"><a href="#配置静态节点文件" class="headerlink" title="配置静态节点文件"></a>配置静态节点文件</h3><p>~/data/geth/static-nodes.json</p><pre><code class="json">[    "enode://&lt;node public key&gt;@&lt;node IP address&gt;:&lt;node port&gt;"]</code></pre><h3 id="查看连接上的节点"><a href="#查看连接上的节点" class="headerlink" title="查看连接上的节点"></a>查看连接上的节点</h3><pre><code class="bash">geth -datadir ~/data/ --networkid 88 console&gt;admin.peers</code></pre><h3 id="动态添加节点"><a href="#动态添加节点" class="headerlink" title="动态添加节点"></a>动态添加节点</h3><pre><code class="bash">&gt;admin.addPeer("enode://&lt;node public key&gt;@&lt;node IP address&gt;:&lt;node port&gt;")</code></pre><h2 id="挖矿-1"><a href="#挖矿-1" class="headerlink" title="挖矿"></a>挖矿</h2><p>启动miner容器</p><pre><code class="bash">&gt;miner.start(1)</code></pre><ul><li>参数1指定了挖矿的线程数。</li><li>首次启动节点会消耗大约20~30分钟产生DAG</li><li>某开始挖矿后，其它节点将会收到新区块并打印</li></ul><h1 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h1><h2 id="创建truffle镜像"><a href="#创建truffle镜像" class="headerlink" title="创建truffle镜像"></a>创建truffle镜像</h2><p>由于没有找到好用的truffle镜像，我自己创建了一个。Dockerfile内容如下：</p><pre><code class="ruby">FROM alpine:3.8MAINTAINER Cary Tan hbuzzs@163.comENV PS1='[truffle@docker $PWD]\$ 'RUN echo "http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.8/main" &gt; /etc/apk/repositories \      &amp;&amp; echo "http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.8/community" &gt;&gt; /etc/apk/repositories \      &amp;&amp; apk update \          &amp;&amp; apk add curl \      &amp;&amp; apk add npm \      &amp;&amp; apk add git \      &amp;&amp; mkdir -p /workspace \      &amp;&amp; npm config set registry https://registry.npm.taobao.org \      &amp;&amp; npm install -g truffleWORKDIR /workspaceCMD /bin/sh</code></pre><p>也可使用他人上传的镜像：</p><pre><code class="bash">docker pull txcary/truffle:180806# 这个镜像没有curl 需要安装apk add curl</code></pre><h2 id="新建truffle工程"><a href="#新建truffle工程" class="headerlink" title="新建truffle工程"></a>新建truffle工程</h2><pre><code class="bash">mkdir -p /opt/docker-project/truffle/workspace/VanTokencd /opt/docker-project/truffle/workspace/VanTokengit clone https://github.com/trufflesuite/truffle-init-bare.git</code></pre><h2 id="启动truffle容器"><a href="#启动truffle容器" class="headerlink" title="启动truffle容器"></a>启动truffle容器</h2><pre><code class="bash">docker run -it --rm -v /opt/docker-project/truffle/workspace:/workspace --network ethnet txcary/truffle:180806</code></pre><h3 id="测试节点RPC"><a href="#测试节点RPC" class="headerlink" title="测试节点RPC"></a>测试节点RPC</h3><pre><code class="bash">curl 172.19.0.50:8545 -X POST --data '{"id":1,"jsonrpc":"2.0","method":"eth_accounts", "params":[]}' -H "Content-Type: application/json"curl 172.19.0.50:8545 -X POST --data '{"id":1,"jsonrpc":"2.0","method":"eth_getBalance", "params":["0x4c283287839fd441b8c8d18771321bc06a81edae","latest"]}' -H "Content-Type: application/json"</code></pre><ul><li>第一条命令获取节点上的账户</li><li>第二条命令获取账户余额</li><li>如果这两条命令成功了，说明以太坊私有网络搭建成功，并且节点rpc调用成功</li></ul><h3 id="修改truffle-js"><a href="#修改truffle-js" class="headerlink" title="修改truffle.js"></a>修改truffle.js</h3><pre><code class="javascript">module.exports = {        networks: {            development: {                host: "172.19.0.50",                port: 8545,                network_id: 88,                gas: 2900000,                gasPrice: 10000000000            }        }};</code></pre><ul><li>gas使用默认值会导致超限错误，研究半天不知道为什么。要是搞明白的可以给我留言，谢谢！</li><li>gasPrice为默认值</li></ul><h2 id="编写合约Migrations-sol（truffle内置）"><a href="#编写合约Migrations-sol（truffle内置）" class="headerlink" title="编写合约Migrations.sol（truffle内置）"></a>编写合约Migrations.sol（truffle内置）</h2><pre><code class="solidity">pragma solidity &gt;=0.4.22 &lt;0.6.0;contract Migrations {    address public owner;    uint public lastCompletedMigration;    modifier restricted() {        if (msg.sender == owner) _;    }    constructor() public {        owner = msg.sender;    }    function setCompleted(uint completed) public restricted {        lastCompletedMigration = completed;    }    function upgrade(address newAddress) public restricted {        Migrations upgraded = Migrations(newAddress);        upgraded.setCompleted(lastCompletedMigration);    }}</code></pre><h2 id="新建部署脚本"><a href="#新建部署脚本" class="headerlink" title="新建部署脚本"></a>新建部署脚本</h2><p>deploy_contracts.js</p><pre><code class="javascript">var contractsName = artifacts.require("./Storage.sol");module.exports = function(deployer) {  deployer.deploy(contractsName);};</code></pre><h2 id="编译合约"><a href="#编译合约" class="headerlink" title="编译合约"></a>编译合约</h2><pre><code class="bash">truffle compile</code></pre><h2 id="部署合约-1"><a href="#部署合约-1" class="headerlink" title="部署合约"></a>部署合约</h2><pre><code class="bash">truffle migrate --network development --verbose-rpc</code></pre><p>部署成功</p><p><img src="/images/eth_network_set_up/image-20220204103544178.png" alt="image-20220204103544178"></p><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><ul><li><a href="https://www.jianshu.com/p/7994db7a2b89?from=singlemessage">https://www.jianshu.com/p/7994db7a2b89?from=singlemessage</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 部署文档 </tag>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法分析》笔记</title>
      <link href="/2022/01/18/data_struct_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/18/data_struct_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>了解算法分析方法（第二章-13）</li><li>精通表、栈和队列（第三章-27）、树（第四章-40）、散列（第五章-36）、优先队列、堆（第六章-28）、排序（第七章-50）、不相交集类（第八章-17）</li><li>精通图论（第九章-38）、算法设计技巧（第十章-50）、红黑树（第十二章第二节-5）</li></ul><h1 id="第-2-章-算法分析方法"><a href="#第-2-章-算法分析方法" class="headerlink" title="第 2 章 算法分析方法"></a>第 2 章 算法分析方法</h1><h2 id="2-4-运行时间计算"><a href="#2-4-运行时间计算" class="headerlink" title="2.4 运行时间计算"></a>2.4 运行时间计算</h2><h3 id="2-4-1-一般法则"><a href="#2-4-1-一般法则" class="headerlink" title="2.4.1 一般法则"></a>2.4.1 一般法则</h3><ol><li>法则1 —— for循环</li></ol><p>一个for循环的运行时间至多是该for循环内部那些语句（包括测试）的运行时间乘以迭代的次数</p><ol><li>法则2 —— 嵌套的for循环</li></ol><p>在一组嵌套循环内部的一条语句的运行时间为该语句的运行时间乘以该组所有的for循环的大小的乘积</p><ol><li>法则3 —— 顺序语句</li></ol><p>将各个语句的运行时间求和即可。这意味着其中的最大值就是所得的运行时间。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled.png" alt="Untitled"></p><ol><li>法则4 —— if/else语句</li></ol><p>一个if/else语句的运行时间从不超过判断的运行时间再加上S1和S2中运行时间长者的总的运行时间。</p><h1 id="第-3-章-表、栈和队列"><a href="#第-3-章-表、栈和队列" class="headerlink" title="第 3 章 表、栈和队列"></a>第 3 章 表、栈和队列</h1><h2 id="3-1-抽象数据类型"><a href="#3-1-抽象数据类型" class="headerlink" title="3.1 抽象数据类型"></a>3.1 抽象数据类型</h2><p>抽象数据类型（ADT）是带有一组操作的一些对象的集合。</p><h2 id="3-2-表ADT"><a href="#3-2-表ADT" class="headerlink" title="3.2 表ADT"></a>3.2 表ADT</h2><p>我们称形如$A_0$$,A_1,A_2,…,A_{N-1}$的为表，该表大小为N</p><h3 id="3-2-1-表的简单数组实现"><a href="#3-2-1-表的简单数组实现" class="headerlink" title="3.2.1 表的简单数组实现"></a>3.2.1 表的简单数组实现</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%201.png" alt="Untitled"></p><h3 id="3-2-2-简单链表"><a href="#3-2-2-简单链表" class="headerlink" title="3.2.2 简单链表"></a>3.2.2 简单链表</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%202.png" alt="Untitled"></p><h2 id="3-6-栈ADT"><a href="#3-6-栈ADT" class="headerlink" title="3.6 栈ADT"></a>3.6 栈ADT</h2><h3 id="3-6-1-栈模型"><a href="#3-6-1-栈模型" class="headerlink" title="3.6.1 栈模型"></a>3.6.1 栈模型</h3><p>栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做站的顶（top）。</p><p>栈的基本操作有push（进栈）、pop（出栈）</p><p>栈有时又叫LIFO（后进先出）表</p><h3 id="3-6-3-应用"><a href="#3-6-3-应用" class="headerlink" title="3.6.3 应用"></a>3.6.3 应用</h3><ul><li>平衡符号</li><li>后缀表达式</li><li>方法调用</li></ul><h2 id="3-7-队列ADT"><a href="#3-7-队列ADT" class="headerlink" title="3.7 队列ADT"></a>3.7 队列ADT</h2><h3 id="3-7-1-队列模型"><a href="#3-7-1-队列模型" class="headerlink" title="3.7.1 队列模型"></a>3.7.1 队列模型</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%203.png" alt="Untitled"></p><h1 id="第-4-章-树"><a href="#第-4-章-树" class="headerlink" title="第 4 章 树"></a>第 4 章 树</h1><h2 id="4-1-预备知识"><a href="#4-1-预备知识" class="headerlink" title="4.1 预备知识"></a>4.1 预备知识</h2><h2 id="4-2-二叉树"><a href="#4-2-二叉树" class="headerlink" title="4.2 二叉树"></a>4.2 二叉树</h2><h2 id="4-3-查找树ADT-——-二叉查找树"><a href="#4-3-查找树ADT-——-二叉查找树" class="headerlink" title="4.3 查找树ADT ——  二叉查找树"></a>4.3 查找树ADT ——  二叉查找树</h2><h2 id="4-4-AVL树"><a href="#4-4-AVL树" class="headerlink" title="4.4 AVL树"></a>4.4 AVL树</h2><p>AVL树是带有平衡条件的二叉查找树</p><p>特点：</p><ul><li>本身首先是一棵二叉搜索树。</li><li>每个节点的左右子树的高度之差的绝对值（平衡因子）最多为1</li></ul><h3 id="4-4-1-单旋转"><a href="#4-4-1-单旋转" class="headerlink" title="4.4.1 单旋转"></a>4.4.1 单旋转</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%204.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%205.png" alt="Untitled"></p><h3 id="4-4-2-双旋转"><a href="#4-4-2-双旋转" class="headerlink" title="4.4.2 双旋转"></a>4.4.2 双旋转</h3><h2 id="4-5-伸展树"><a href="#4-5-伸展树" class="headerlink" title="4.5 伸展树"></a>4.5 伸展树</h2><p>伸展树保证从空树开始连续M次对树的操作最多花费*O(M log N)*时间</p><p>伸展树基于这样的事实：对于二叉查找树来说，每次操作最坏情形时间*O(N)*并不坏，只要它相对不常发生就行。</p><h2 id="4-6-树的遍历"><a href="#4-6-树的遍历" class="headerlink" title="4.6 树的遍历"></a>4.6 树的遍历</h2><ul><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层序遍历</li></ul><h2 id="4-7-B-树"><a href="#4-7-B-树" class="headerlink" title="4.7 B+树**"></a>4.7 B+树**</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%206.png" alt="Untitled"></p><p>阶为M的B+树的特性：</p><ul><li>数据项存储在树叶上</li><li>非叶子节点存储直到M-1个关键字以指示搜索的方向；关键字i代表子树i+1中的最小的关键字</li><li>树的根或者是一片树叶，或者其儿子数在2和M之间</li><li>除根外，所有非树叶节点的儿子数在<code>⌈M/2⌉</code>和<code>M</code>之间</li><li>所有的树叶都在相同的深度上并有<code>⌈L/2⌉</code>和<code>L</code> 之间个数据项</li></ul><p>B树与B+树不同点：</p><ul><li>单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。</li><li>所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。</li><li>所有的叶子节点形成了一个有序链表，更加便于查找。</li></ul><h1 id="第-5-章-散列"><a href="#第-5-章-散列" class="headerlink" title="第 5 章 散列"></a>第 5 章 散列</h1><h2 id="5-1-一般想法"><a href="#5-1-一般想法" class="headerlink" title="5.1 一般想法"></a>5.1 一般想法</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%207.png" alt="Untitled"></p><h2 id="5-2-散列函数"><a href="#5-2-散列函数" class="headerlink" title="5.2 散列函数"></a>5.2 散列函数</h2><p>如果关键字是整数一般合理的方法就是直接返回<em>key mod Tablesize</em></p><p>如果关键字是字符串，</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%208.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%209.png" alt="Untitled"></p><h2 id="5-3-分离链接法"><a href="#5-3-分离链接法" class="headerlink" title="5.3 分离链接法"></a>5.3 分离链接法</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2010.png" alt="Untitled"></p><p>分离链接法：其做法是将散列到同一个值的所有元素保留到一个表中</p><h2 id="5-4-不同链表的散列表"><a href="#5-4-不同链表的散列表" class="headerlink" title="5.4 不同链表的散列表"></a>5.4 不同链表的散列表</h2><h3 id="5-4-1-线性探测法"><a href="#5-4-1-线性探测法" class="headerlink" title="5.4.1 线性探测法"></a>5.4.1 线性探测法</h3><p>在线性探测法中，函数f是i的线性函数，典型情形是$f(i) = i$</p><h3 id="5-4-2-平方探测法"><a href="#5-4-2-平方探测法" class="headerlink" title="5.4.2 平方探测法"></a>5.4.2 平方探测法</h3><p>平方探测是消除线性探测中一次聚集问题的冲突解决方法。</p><p>平方探测就是冲突函数为二次的探测方法，流行的选择是$f(i)=i^2$</p><p>定理：如果使用平方探测，且表的大小是素数，那么当表至少有一半是空的时候总能够插入一个新元素</p><h3 id="5-4-3-双散列"><a href="#5-4-3-双散列" class="headerlink" title="5.4.3 双散列"></a>5.4.3 双散列</h3><p>对于双散列，一种流行的选择是$f(i)=i*hash_2(x)$</p><h2 id="5-5-再散列"><a href="#5-5-再散列" class="headerlink" title="5.5 再散列"></a>5.5 再散列</h2><p>建立另外一个大约两倍大的表（而且使用一个相关的新散列函数），扫描整个原始散列表，计算每个（未删除的）元素的新散列值并将其插入到新表中</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2011.png" alt="Untitled"></p><h2 id="5-6-标准库中的散列表"><a href="#5-6-标准库中的散列表" class="headerlink" title="5.6 标准库中的散列表"></a>5.6 标准库中的散列表</h2><h2 id="5-7-最坏情形下O-1-访问的散列表"><a href="#5-7-最坏情形下O-1-访问的散列表" class="headerlink" title="5.7 最坏情形下O(1)访问的散列表"></a>5.7 最坏情形下O(1)访问的散列表</h2><h3 id="5-7-1-完美散列"><a href="#5-7-1-完美散列" class="headerlink" title="5.7.1 完美散列"></a>5.7.1 完美散列</h3><h3 id="5-7-2-布谷鸟散列"><a href="#5-7-2-布谷鸟散列" class="headerlink" title="5.7.2 布谷鸟散列"></a>5.7.2 布谷鸟散列</h3><p>在布谷鸟散列中，假设有N个项。我们维护两个分别超过半空的表，且有两个独立的散列函数，可以把每个项分配到每个表中的一个位置。布谷鸟散列保持不变的是一个项总会被存储在这两个位置之一。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2012.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2013.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2014.png" alt="Untitled"></p><h3 id="5-7-3-跳房子散列"><a href="#5-7-3-跳房子散列" class="headerlink" title="5.7.3 跳房子散列"></a>5.7.3 跳房子散列</h3><p>跳房子散列的思路是用事先确定的、对计算机的底层体系结构而言是最优的一个常数，给探测序列的最大长度加个上界。这样做可以给出常数集的最坏查询时间，并且与布谷鸟散列一样，查询可以并行化，以同时检查可用位置的有限集。</p><h2 id="5-8-通用散列法"><a href="#5-8-通用散列法" class="headerlink" title="5.8 通用散列法"></a>5.8 通用散列法</h2><h1 id="第-6-章-优先队列（堆）"><a href="#第-6-章-优先队列（堆）" class="headerlink" title="第 6 章 优先队列（堆）"></a>第 6 章 优先队列（堆）</h1><h2 id="6-1-模型"><a href="#6-1-模型" class="headerlink" title="6.1 模型"></a>6.1 模型</h2><p>优先队列是允许至少下列两种操作的数据结构：插入和删除最小者。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2015.png" alt="Untitled"></p><h2 id="6-2-一些简单的实现"><a href="#6-2-一些简单的实现" class="headerlink" title="6.2 一些简单的实现"></a>6.2 一些简单的实现</h2><ol><li>使用简单链表</li><li>使用二叉查找树</li></ol><h2 id="6-3-二叉堆"><a href="#6-3-二叉堆" class="headerlink" title="6.3 二叉堆"></a>6.3 二叉堆</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2016.png" alt="Untitled"></p><h3 id="6-3-1-结构性质"><a href="#6-3-1-结构性质" class="headerlink" title="6.3.1 结构性质"></a>6.3.1 结构性质</h3><p>堆是一个完全二叉树</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2017.png" alt="Untitled"></p><ol><li>插入</li></ol><p>为将一个元素X插入到堆中，我们在一个可用位置创建一个空穴，否则该堆将不是完全熟，如果可以放在该空穴中而不破坏堆的序，那么插入完成。否则我们把空穴的父节点上的元素移入该空穴中，这样空穴就朝着根的方向上冒一步。继续该过程直到X能被放入空穴中为止。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2018.png" alt="Untitled"></p><ol><li>删除最小元</li></ol><p>删除最小元以类似于插入的方式处理。当删除一个最小元时，要在跟节点建立一个空穴。由于现在堆少了一个元素，因此堆中最后一个元素X必须移动到该堆的某个地方。如果X可以被放倒空穴中，那么deleteMin完成，否则我们将空穴的两个儿子中较小者移入空穴，这样就把空穴向下推了一层，重复该步骤直到X可以被放入空穴中。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2019.png" alt="Untitled"></p><h2 id="6-4-优先队列的应用"><a href="#6-4-优先队列的应用" class="headerlink" title="6.4 优先队列的应用"></a>6.4 优先队列的应用</h2><h2 id="6-5-d-堆"><a href="#6-5-d-堆" class="headerlink" title="6.5 d-堆"></a>6.5 d-堆</h2><p>d-堆是二叉堆的简单推广，就像一个二叉堆，只是所有的节点都有d个儿子（因此，二叉堆是2-堆）</p><h2 id="6-6-左式堆"><a href="#6-6-左式堆" class="headerlink" title="6.6 左式堆"></a>6.6 左式堆</h2><p>左式堆像二叉堆那样也具有结构性和有序性。左式堆具有相同的堆序性质，左式堆也是二叉树，左式堆和叉二树唯一的区别是：左式堆不是理想平衡的，而实际上趋向于非常不平衡。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2020.png" alt="Untitled"></p><h2 id="6-7-斜堆"><a href="#6-7-斜堆" class="headerlink" title="6.7 斜堆"></a>6.7 斜堆</h2><p>斜堆是左式堆的自调节形式，实现起来极其简单。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2021.png" alt="Untitled"></p><h2 id="6-8-二项队列"><a href="#6-8-二项队列" class="headerlink" title="6.8 二项队列"></a>6.8 二项队列</h2><h3 id="6-8-1-二项队列结构"><a href="#6-8-1-二项队列结构" class="headerlink" title="6.8.1 二项队列结构"></a>6.8.1 二项队列结构</h3><p>一个二项队列不是一颗堆序的树，而是堆序的树的集合，称为森林。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2022.png" alt="Untitled"></p><h1 id="第-7-章-排序"><a href="#第-7-章-排序" class="headerlink" title="第 7 章 排序"></a>第 7 章 排序</h1><h2 id="7-2-插入排序"><a href="#7-2-插入排序" class="headerlink" title="7.2 插入排序"></a>7.2 插入排序</h2><p>插入排序由N-1趟排序组成。对于p=1到N-1趟，插入排序保证从位置0到位置p上的元素为已排序状态。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2023.png" alt="Untitled"></p><p>时间复杂度：$O(N^2)$</p><p>定理：通过交换相邻元素进行排序的任何算法平均都需要$Ω(N^2)$时间</p><h2 id="7-4-希尔排序"><a href="#7-4-希尔排序" class="headerlink" title="7.4 希尔排序"></a>7.4 希尔排序</h2><p>定理：使用希尔排序最坏情形运行时间为$O(N^2)$</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2024.png" alt="Untitled"></p><h2 id="7-5-堆排序"><a href="#7-5-堆排序" class="headerlink" title="7.5 堆排序"></a>7.5 堆排序</h2><p>优先队列可以用以$O(NlogN)$时间的排序。基于该思想的算法叫做堆排序。</p><h2 id="7-6-归并排序"><a href="#7-6-归并排序" class="headerlink" title="7.6 归并排序"></a>7.6 归并排序</h2><p>归并排序以O(NlogN)最坏情形时间运行。它是递归算法一个好的实例。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2025.png" alt="Untitled"></p><h2 id="7-7-快速排序"><a href="#7-7-快速排序" class="headerlink" title="7.7 快速排序"></a>7.7 快速排序</h2><p>快速排序是事件中一种快速的排序算法，在C++或对Java基本类型的排序汇总特别有用。平均运行时间是$O(NlogN)$。</p><h1 id="第-9-章-图论"><a href="#第-9-章-图论" class="headerlink" title="第 9 章 图论"></a>第 9 章 图论</h1><h2 id="9-1-定义"><a href="#9-1-定义" class="headerlink" title="9.1 定义"></a>9.1 定义</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2026.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2027.png" alt="Untitled"></p><h2 id="9-2-拓扑排序"><a href="#9-2-拓扑排序" class="headerlink" title="9.2 拓扑排序"></a>9.2 拓扑排序</h2><h2 id="9-3-最短路径算法"><a href="#9-3-最短路径算法" class="headerlink" title="9.3 最短路径算法"></a>9.3 最短路径算法</h2><h3 id="9-3-1-无权最短路径"><a href="#9-3-1-无权最短路径" class="headerlink" title="9.3.1 无权最短路径"></a>9.3.1 无权最短路径</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2028.png" alt="Untitled"></p><h2 id="未完"><a href="#未完" class="headerlink" title="未完"></a>未完</h2><h1 id="第-9-章-算法设计技巧"><a href="#第-9-章-算法设计技巧" class="headerlink" title="第 9 章 算法设计技巧"></a>第 9 章 算法设计技巧</h1><h2 id="10-1-贪婪算法"><a href="#10-1-贪婪算法" class="headerlink" title="10.1 贪婪算法"></a>10.1 贪婪算法</h2><p>贪婪算法分阶段地工作，在每一个阶段可以认为所做决定是好的。而不考虑将来的后果。</p><h2 id="10-2-分治算法"><a href="#10-2-分治算法" class="headerlink" title="10.2 分治算法"></a>10.2 分治算法</h2><p>分治算法由两部分组成：</p><ul><li>分：递归解决较小的问题</li><li>治：然后从子问题的解构建原问题的解</li></ul><h2 id="10-3-动态规划"><a href="#10-3-动态规划" class="headerlink" title="10.3 动态规划"></a>10.3 动态规划</h2><p>将递归算法重新写成非递归算法，让后者把那些子问题的答案系统第记录在一个表内，利用这种方法的一种技巧叫做动态规划</p><h2 id="10-4-随机数算法"><a href="#10-4-随机数算法" class="headerlink" title="10.4 随机数算法"></a>10.4 随机数算法</h2><h2 id="10-5-回溯算法"><a href="#10-5-回溯算法" class="headerlink" title="10.5 回溯算法"></a>10.5 回溯算法</h2><h1 id="第-12-章-高级数据结构及其实现"><a href="#第-12-章-高级数据结构及其实现" class="headerlink" title="第 12 章 高级数据结构及其实现"></a>第 12 章 高级数据结构及其实现</h1><h2 id="12-2-红黑树"><a href="#12-2-红黑树" class="headerlink" title="12.2 红黑树"></a>12.2 红黑树</h2><p>对红黑树的操作在最坏情形下花费O(logN)时间</p><p>红黑树是具有下列着色性质的二叉查找树：</p><ul><li>每一个节点或者着成红色，或者着成黑色</li><li>根是黑色的</li><li>如果一个节点是红色，那么它的子节点必须是黑色的</li><li>从一个节点到一个null引用的每一条路径必须包含相同数目的黑色节点</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPFS原理深入分析</title>
      <link href="/2022/01/18/distributed_storage/IPFS%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/18/distributed_storage/IPFS%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="〇、目标"><a href="#〇、目标" class="headerlink" title="〇、目标"></a>〇、目标</h1><ol><li>熟悉IPFS概念</li><li>熟悉IPFS上传文件、下载文件过程</li></ol><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="2-BACKGROUND"><a href="#2-BACKGROUND" class="headerlink" title="2. BACKGROUND"></a>2. BACKGROUND</h2><h3 id="Distributed-Hash-Tables-DHTs"><a href="#Distributed-Hash-Tables-DHTs" class="headerlink" title="Distributed Hash Tables(DHTs)"></a>Distributed Hash Tables(DHTs)</h3><ol><li><p>Kademlia DHT</p><p> 优点</p><ul><li>【通信性能】通过大规模网络高效查找:查询平均需要通信$log_2(n)$向上取整节点。(例如，一个由10,000,000个节点组成的网络需要20个跳数)</li><li>【通信性能】低协调开销:优化了发送给其他节点的控制消息的数量</li><li>【安全】通过选择长期存在的节点来抵抗各种攻击</li><li>【应用】在对等应用程序中广泛使用，包括Gnutella和BitTorrent，形成了超过2000万个节点的网络。</li></ul></li><li><p>Coral DSHT</p><p> 优点</p><ul><li>【通信性能】Kademlia将值存储在id与键最接近(使用XOR-distance)的节点中。这并不考虑应用程序数据的局域性，忽略可能已经拥有数据的远节点，并不管最近节点是否需要这份数据而去强制它们存储数据。这浪费了大量的存储和带宽。相反，Coral在能够提供数据块的对等节点存储地址信息</li><li>【通信性能】Coral将DHT API从get_value(key)放宽为get_any_values(key) (DSHT中的“sloppy”)。这仍然工作直到Coral用户只需要一个(工作)peer，而不是完整的列表。作为交换，Coral只能将值的子集分发到最近的节点，从而避免了热点(当一个键变得流行时，会重载所有最近的节点)</li><li>【通信性能】Coral根据区域和大小组织了一个称为簇的独立DSHT层次结构。这使得节点可以首先查询其区域内的对等节点，在不查询远处节点的情况下查找附近的数据，大大减少了查找的延迟</li></ul></li><li><p>S/Kademlia DHT</p><p>S/Kademlia扩展了Kademlia以两种特别重要的方式来抵御恶意攻击:</p><ul><li>【安全】S/Kademlia提供了安全的NodeId生成方案，并防止女巫攻击。它要求节点创建一个PKI密钥对，从密钥对中获得自己的身份，并对彼此的消息进行签名。一种方案包括一个工作证明加密谜题，以使生成女巫攻击的成本很高</li><li>【安全】S/Kademlia节点在不相交的路径上查找值，以确保在网络中存在大量对手的情况下，诚实的节点可以相互连接。即使对抗分数高达一半的节点S/Kademlia实现了0.85的成功率，</li></ul></li></ol><h3 id="Block-Exchanges-BitTorrentc"><a href="#Block-Exchanges-BitTorrentc" class="headerlink" title="Block Exchanges - BitTorrentc"></a>Block Exchanges - BitTorrentc</h3><p>BitTorrent（简称BT）是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。</p><p>BitTorrent是一个广泛成功的点对点文件处理系统，它成功地协调了互不信任的点(群)网络，在相互分发文件的过程中进行合作。BitTorrent及其生态系统中IPFS设计的关键特性包括:</p><ol><li>BitTorrent的数据交换协议使用了一种类似于tit-for-tat的策略，奖励那些相互贡献的节点，惩罚那些只窃取别人资源的节点</li><li>BitTorrent同行跟踪文件片段的可用性，优先发送最罕见的片段。这减轻了种子的负担，使非种子同伴能够相互交易</li><li>BitTorrent标准的tit-for-tat易受某些利用带宽共享策略的攻击。PropShare是一种不同的对等带宽分配策略，它能更好地抵抗利用策略，并提高群的性能</li></ol><h3 id="Version-Control-Systems-Git"><a href="#Version-Control-Systems-Git" class="headerlink" title="Version Control Systems - Git"></a>Version Control Systems - Git</h3><p>版本控制系统提供了对随时间变化的文件建模的工具，并有效地分发不同的版本。流行的版本控制系统Git提供了一个功能强大的Merkle dag对象模型，它以分布式友好的方式捕获对文件系统树的更改。</p><ol><li>不可变对象代表Files (blob)、Directories (tree)和Changes (commit)</li><li>对象是内容寻址的，通过其内容的加密散列</li><li>与其他物体的链接被嵌入，形成一个默克尔DAG。这提供了许多有用的完整性和工作流属性</li><li>大多数版本化元数据(分支、标签等)都是简单的指针引用，因此创建和更新的成本很低</li><li>版本更改仅更新引用或添加对象</li><li>将版本更改分发给其他用户只是简单地传输对象和更新远程引用</li></ol><h3 id="Self-Certified-Filesystems-SFS"><a href="#Self-Certified-Filesystems-SFS" class="headerlink" title="Self-Certified Filesystems - SFS"></a>Self-Certified Filesystems - SFS</h3><p>SFS[12,11]提出了两种引人注目的实现：</p><ul><li>分布式信任链</li><li>平等共享的全局命名空间</li></ul><p>SFS引入了一种用于构建自认证文件系统的技术:</p><p>使用以下scheme：</p><p><code>/sfs/&lt;Location&gt;:&lt;HostID&gt;</code></p><p>其中Location是服务器的网络地址，并且:HostID = hash(public_key || Location)</p><p>因此SFS文件系统的名称证明了它的服务器。用户可以验证服务器提供的公钥，协商共享密钥，并确保所有流量的安全。所有SFS实例共享一个全局命名空间，其中的名称分配是加密的，不受任何集中主体的限制。</p><h2 id="3-IPFS-DESIGN"><a href="#3-IPFS-DESIGN" class="headerlink" title="3. IPFS DESIGN"></a>3. IPFS DESIGN</h2><p>IPFS协议被划分为负责不同功能的子协议堆栈</p><h3 id="3-1-身份——管理节点身份的生成和更新"><a href="#3-1-身份——管理节点身份的生成和更新" class="headerlink" title="3.1 身份——管理节点身份的生成和更新"></a>3.1 身份——管理节点身份的生成和更新</h3><p>节点由一个NodeId标识，这是一个公钥的加密哈希，是用S/Kademlia的静态加密谜题创建的。节点存储它们的公钥和私钥(使用密码短语加密)。用户可以在每次启动时自由实例化一个新的节点标识，尽管这样会损失已积累的网络利益。节点被激励保持不变</p><h3 id="3-2-网络——管理与其他对等体的连接，使用各种底层网络协议。可配置的"><a href="#3-2-网络——管理与其他对等体的连接，使用各种底层网络协议。可配置的" class="headerlink" title="3.2 网络——管理与其他对等体的连接，使用各种底层网络协议。可配置的"></a>3.2 网络——管理与其他对等体的连接，使用各种底层网络协议。可配置的</h3><p>IPFS网络栈特性:</p><ul><li>传输:IPFS可以使用任何传输协议，最适合于WebRTC数据通道(用于浏览器连接)或uTP(LEDBAT)</li><li>可靠性:如果底层网络不提供，IPFS可以使用uTP (LEDBAT[14])或SCTP[15]提供可靠性</li><li>连通性:IPFS也使用ICE NAT穿越技术</li><li>完整性:可选地使用哈希校验和检查消息的完整性</li><li>真实性:可选地检查mes- sage的真实性，通过使用发送方的特权密钥进行数字签名。</li></ul><h3 id="3-3-路由——维护定位特定对等体和对象的信息。响应本地和远程查询。默认为DHT，但可切换"><a href="#3-3-路由——维护定位特定对等体和对象的信息。响应本地和远程查询。默认为DHT，但可切换" class="headerlink" title="3.3 路由——维护定位特定对等体和对象的信息。响应本地和远程查询。默认为DHT，但可切换"></a>3.3 路由——维护定位特定对等体和对象的信息。响应本地和远程查询。默认为DHT，但可切换</h3><p>IPFS节点需要一个路由系统，它可以找到其他节点的网络地址，以及可以为特定对象服务的节点。IPFS使用S/Kademlia和Coral DSHT实现这一点。IPFS的对象大小和使用模式类似于Coral和Mainline，因此IPFS DHT根据其大小对存储的值进行区分。小值(等于或小于1KB)直接存储在DHT上。对于较大的值，DHT存储引用，这些引用是可以为块提供服务的节点的nodeid</p><h3 id="3-4-块交换——一个新的块交换协议-BitSwap-，它管理有效的块分配。以市场为模型，对数据复制的激励很弱。可切换的贸易策略"><a href="#3-4-块交换——一个新的块交换协议-BitSwap-，它管理有效的块分配。以市场为模型，对数据复制的激励很弱。可切换的贸易策略" class="headerlink" title="3.4 块交换——一个新的块交换协议(BitSwap)，它管理有效的块分配。以市场为模型，对数据复制的激励很弱。可切换的贸易策略"></a>3.4 块交换——一个新的块交换协议(BitSwap)，它管理有效的块分配。以市场为模型，对数据复制的激励很弱。可切换的贸易策略</h3><p>在IPFS中，数据分发是通过使用BitTorrent启发的协议BitSwap与对等点交换块来实现的。像BitTorrent一样，BitSwap对等体正在寻找一组块(want_list)，并有另一组块交换(have_list)。与BitTorrent不同，BitSwap并不局限于一个torrent中的区块。BitSwap操作是一个持久的市场，节点可以获取他们需要的块，而不管这些块是什么文件的一部分。这些块可以来自文件系统中完全不相关的文件。节点聚集在一起进行交易。</p><h3 id="3-5-对象——一个Merkle-DAG，由具有链接的内容定位的不可变对象组成。用于表示任意的数据结构，例如文件层次结构和通信系统"><a href="#3-5-对象——一个Merkle-DAG，由具有链接的内容定位的不可变对象组成。用于表示任意的数据结构，例如文件层次结构和通信系统" class="headerlink" title="3.5 对象——一个Merkle DAG，由具有链接的内容定位的不可变对象组成。用于表示任意的数据结构，例如文件层次结构和通信系统"></a>3.5 对象——一个Merkle DAG，由具有链接的内容定位的不可变对象组成。用于表示任意的数据结构，例如文件层次结构和通信系统</h3><p>DHT和BitSwap允许IPFS形成一个大规模的点对点系统，用于快速、可靠地存储和分发块。在这些之上，IPFS构建了一个Merkle DAG，一个有向无环图，其中对象之间的链接是嵌入源中的目标的加密散列。这是Git数据结构的一般化。</p><p>默克尔DAG为IPFS提供了许多有用的属性：</p><ol><li>内容寻址:所有内容由其多哈希校验和唯一标识，包括链接</li><li>抗篡改:所有内容都通过校验和进行验证。如果数据被篡改或损坏，IPFS会检测到它</li><li>重复数据删除:所有包含相同内容的对象都是相同的，且只存储一次。对于索引对象，如git树和提交，或数据的公共部分，这尤其有用。</li></ol><h3 id="3-6-文件——受Git启发的文件版本的文件系统层次结构"><a href="#3-6-文件——受Git启发的文件版本的文件系统层次结构" class="headerlink" title="3.6 文件——受Git启发的文件版本的文件系统层次结构"></a>3.6 文件——受Git启发的文件版本的文件系统层次结构</h3><p>IPFS还定义了一组对象，用于在Merkle DAG之上对版本化的文件系统建模。该对象模型类似于Git s:</p><ol><li>块:一个可变大小的数据块</li><li>列表:块或其他列表的集合</li><li>树:块、列表或其他树的集合</li><li>提交:树版本历史中的快照。</li></ol><h3 id="3-7-命名——一个自认证的可变名称系统"><a href="#3-7-命名——一个自认证的可变名称系统" class="headerlink" title="3.7 命名——一个自认证的可变名称系统"></a>3.7 命名——一个自认证的可变名称系统</h3><p>到目前为止，IPFS堆栈形成了一个点对点块交换，构造了一个对象的内容寻址DAG。它用于发布和检索不可变对象。它甚至可以跟踪这些对象的版本历史。但是，缺少一个关键组件:可变命名。没有它，所有新内容的通信都必须在带外进行，发送IPFS链接。需要的是在同一路径上检索可变状态的某种方法。值得说明的是，如果可变数据是必要的，我们最终努力建立一个不可变的默克尔DAG。考虑一下来自Merkle DAG的IPFS属性:对象可以(a)通过其散列检索，(b)完整性检查，(c)链接到其他对象，以及(d)无限期缓存。在某种意义上:对象是永久的。这些是高性能分布式系统的关键属性，在分布式系统中，数据跨网络链路移动的代价很高。对象内容寻址构建了一个具有(a)显著带宽优化、(b)不可信内容服务、(c)永久链接和(d)对任何对象及其引用进行完全永久备份的能力的web。Merkle DAG(不可变的内容寻址对象)和命名(指向Merkle DAG的可变指针)瞬时出现在许多成功的分布式系统中。这包括Git版本控制系统，它有不可变对象和可变引用;和Plan， UNIX的分布式继承者，及其可变的Fossil和不可变的Venti文件系统。LBFS也使用可变索引和不可变块。</p><h2 id="4-IPFS共识"><a href="#4-IPFS共识" class="headerlink" title="4. IPFS共识"></a>4. IPFS共识</h2><p>IPFS创新的采用了一种混合共识机制——复制证明（PoRep）+时空证明（PoSt）+ 预期共识(EC)</p><ol><li>复制证明：共识机制中的核心因素，尽管IPFS的网络协议、共识、其他算法都基本定型，但是复制证明仍然处于不断完善的方案中。</li><li>时空证明:（PoSt)提出了证明链（proof-chain）的数据结构，证明链把一些的挑战（challenge）和证明（proof）链接起来形成。在证明链的基础上添加上时间段，这样就得到了一段时间内的矿工存储数据的证明，这就是时空证明（Proof of Spacetime，PoSt）。PoSt可以证明在该段时间内矿工存储了特定的数据，并且利用时间戳锚定这些证明链，这样即使验证者（verifier）不在线，也可以在未来的某个时间内利用时空证明去验证该矿工生成了证明链，PoSt会被提交到链上用来产生新的Block。</li><li>预期共识:（Expected Consensus，EC）是在每一轮里面选举出来一名或者多名矿工来创建新的区块，矿工赢得选举的可能性跟矿工当前的有效存储（算力）成正比。IPFS把矿工在网络中的当前存储数据相对于整个网络的存储比例转化为矿工投票权（voting power of the miner）。无论在该周期里，选举出来的是一名还是多名矿工，被选举出来的矿工都需要创建新的区块，并把新的区块对网络进行广播。 尽管链中的区块是线性的，但是IPFS的区块数据结构采用的DAG（有向无环图），可以在同一时间产生多个区块（所以Filecoin的交易要比BTC的有效的多，这也是为什么把Filecoin叫做“可能的blockchain 3.0”的原因） </li></ol><p>Filecoin首创的混合共识机制，从根本上定义了Filecoin是一个合理高效、去中心化的系统，并体现出Filecoin的公平性、保密性和公开可验证性</p><h1 id="二、上传文件"><a href="#二、上传文件" class="headerlink" title="二、上传文件"></a>二、上传文件</h1><p><img src="/images/ipfs/upload_file.png" alt="img.png"></p><h2 id="1-生成默克尔DAG的结构"><a href="#1-生成默克尔DAG的结构" class="headerlink" title="1. 生成默克尔DAG的结构"></a>1. 生成默克尔DAG的结构</h2><p>生成的结构有两种Layout：balanced和trickle的。这里介绍默认的balanced结构，首先生成root作为根节点，然后将文件分割，默认按照256KB大小读取一个chunk，生成叶子节点，依次生成node1，node2，root节点会有Link指向挂在root节点的叶子节点node1和node2。root节点下面能够Link的叶子节点数量是有限的，IPFS中默认设置的是174个（定义的Link的总的大小是8KB，每个Link的大小是34 + 8 + 5【sha256 multihash + size + no name + protobuf framing】，默认的Link的个数为8192/47约等于174）。</p><p><img src="/images/ipfs/image-1.png" alt="/images/ipfs/image-1.png"></p><p>如下图所示，超过174个后则会新创建一个new root节点，并Link到old root，新的chunk作为node3（这里用node3简约了，实际上是第175个节点）被new root直接Link。</p><p><img src="/images/ipfs/image-4.png" alt="/images/ipfs/image-4.png"></p><p>当继续有新的chunk添加时，则会生成node34作为node3和node4的父节点，node34含有两个Link分别链接到node3和node4。</p><p><img src="/images/ipfs/image-5.png" alt="/images/ipfs/image-5.png"></p><p>IPFS在init的时候会生成.ipfs目录，如下图所示，其中blocks则为文件块存储的目录，datastore为leveldb数据库，其中存储了文件系统的根哈希等，存储相关的配置关联在.ipfs目录下面的config文件。</p><p><img src="/images/ipfs/image-6.png" alt="/images/ipfs/image-6.png"></p><h2 id="2-对块进行存储"><a href="#2-对块进行存储" class="headerlink" title="2. 对块进行存储"></a>2. 对块进行存储</h2><ul><li>如下图所示，一个Block存储时，首先由dagService（实现了DAGService接口）调用Add进行添加；</li><li>之后由blockService（实现了BlockService接口）调用AddBlock添加该Block；</li><li>再调用arccache的Put，arccache是对存储的Block做arc策略的缓存；</li><li>再之后由VerifBS调用Put进行存储，VerifyBS主要对CID的合法性进行校验，合法则进行Put；</li><li>接着blockstore（实现了Blockstore接口）调用Put进行存储，Put函数中会对CID进行转化，调用dshelp的CidToDsKey方法将CID转化成存储的Key；</li><li>再接着调用keytransform.Datastore的Put，Put函数中会将前缀拼上，这时Key加上了前缀/blocks；</li><li>然后调用measure的Put函数，measure是对mount的封装；</li><li>之后调用mount的Put函数，mount和IPFS的config配置文件中结构对应，根据key去查找对应的datastore，由于前缀是/blocks则可以找到对应的measure；</li><li>调用该measure的Put函数；</li><li>最后调用flatfs的Put函数，由Put函数调用doPut最终调用encode函数将完整的block写入的目录指定为/home/test/.ipfs/blocks/WD，其中WD来自于blocks/CIQFSQATUBIEIFDECKTNGHOKPOEE7WUPM5NNNSJCCDROMM6YHEKTWDY中的倒数第三第二个字符。这样该Block则写入了该目录下面的文件中。</li></ul><p><img src="/images/ipfs/image-7.png" alt="/images/ipfs/image-7.png"></p><p><img src="/images/ipfs/image-9.png" alt="/images/ipfs/image-9.png"></p><h1 id="三、下载文件"><a href="#三、下载文件" class="headerlink" title="三、下载文件"></a>三、下载文件</h1><p><img src="/images/ipfs/download_file.png" alt="img.png"></p><ol><li>检查本地的blockstore中是否存在请求的数据，如果存在则直接从本地返回；否则会向对等节点发送block hash列表；</li><li>对等节点通过DHT和路由层算法，找到每个block hash所在的节点，将文件返回来；</li><li>本地节点在接收block文件的同时缓存一份到本地的blockstore中</li><li>更新DHT</li><li>组装block文件，返回至用户端</li></ol><h1 id="附：资料"><a href="#附：资料" class="headerlink" title="附：资料"></a>附：资料</h1><ol><li>IPFS白皮书：<a href="https://github.com/ipfs/papers/raw/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf">https://github.com/ipfs/papers/raw/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf</a></li><li>上传/下载文件过程：<ul><li><a href="https://www.jianshu.com/p/9eb1e5f83e13">https://www.jianshu.com/p/9eb1e5f83e13</a></li><li><a href="https://www.chaindesk.cn/witbook/24/449">https://www.chaindesk.cn/witbook/24/449</a></li></ul></li><li><a href="https://www.jiabaotz.com/finance/79470.html">IPFS/Filecoin的共识机制有哪些特点？</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言核心编程》笔记</title>
      <link href="/2022/01/17/go/Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/17/go/Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第-1-章-基础知识"><a href="#第-1-章-基础知识" class="headerlink" title="第 1 章 基础知识"></a>第 1 章 基础知识</h1><h2 id="1-1-语言简介"><a href="#1-1-语言简介" class="headerlink" title="1.1 语言简介"></a>1.1 语言简介</h2><h3 id="1-1-1-Go语言的诞生背景"><a href="#1-1-1-Go语言的诞生背景" class="headerlink" title="1.1.1 Go语言的诞生背景"></a>1.1.1 Go语言的诞生背景</h3><ul><li><strong>当前编程语言对并发的支持不是很好</strong>，不能很好地发挥多核CPU的威力</li><li>程序规模越来越大，<strong>编译速度越来越慢</strong></li><li>现有的<strong>编程语言设计越来越复杂</strong>，某些特性的实现不怎么优雅</li></ul><h3 id="1-1-3-Go语言的特性"><a href="#1-1-3-Go语言的特性" class="headerlink" title="1.1.3 Go语言的特性"></a>1.1.3 Go语言的特性</h3><p><img src="/images/go_core_programming/Untitled.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%201.png" alt="Untitled"></p><h2 id="1-3-Go词法单元"><a href="#1-3-Go词法单元" class="headerlink" title="1.3 Go词法单元"></a>1.3 Go词法单元</h2><h3 id="1-3-1-token"><a href="#1-3-1-token" class="headerlink" title="1.3.1 token"></a>1.3.1 token</h3><p>token是构成源程序的基本不可再分割的单元。</p><p>编译器编译源程序的第一步就是将源程序分割成一个个独立的token，这个过程就是词法分析。</p><p>Go语言的token可以分为关键字、标识符、操作符、分隔符和字面常量</p><p><img src="/images/go_core_programming/Untitled%202.png" alt="Untitled"></p><h3 id="1-3-2-标识符"><a href="#1-3-2-标识符" class="headerlink" title="1.3.2 标识符"></a>1.3.2 标识符</h3><ol><li>标识符用来标识变量、类型、常量等语法对象的符号名称，其在语法分析时作为一个token存在。</li><li>标识符分为两类：<ul><li>语言设计者预留的标识符：语言设计者确定，包括语言的预声明标识符及保留字</li><li>编程者可以自定义的标识符：用户定义的变量名、常量名、函数名等</li></ul></li><li>标识符规则：开头一个字符必须是字母或下划线，区分大小写</li><li><strong>关键字（keywords，25个）</strong></li></ol><p><img src="/images/go_core_programming/Untitled%203.png" alt="Untitled"></p><ol><li><strong>内置数据类型标识符（20个）</strong></li></ol><p><img src="/images/go_core_programming/Untitled%204.png" alt="Untitled"></p><ol><li><strong>内置函数（15个）</strong></li></ol><p><img src="/images/go_core_programming/Untitled%205.png" alt="Untitled"></p><ol><li><strong>常量值标识符（4个）</strong></li></ol><p><img src="/images/go_core_programming/Untitled%206.png" alt="Untitled"></p><p>空白标识符： <code>_</code></p><h3 id="1-3-3-操作符（operators）和分隔符（delimiters）"><a href="#1-3-3-操作符（operators）和分隔符（delimiters）" class="headerlink" title="1.3.3 操作符（operators）和分隔符（delimiters）"></a>1.3.3 操作符（operators）和分隔符（delimiters）</h3><p>操作符包括运算符、现式的分隔符、其他语法辅助符号</p><h3 id="1-3-4-字面常量"><a href="#1-3-4-字面常量" class="headerlink" title="1.3.4 字面常量"></a>1.3.4 字面常量</h3><ol><li>Go的字面量出现在两个地方：<ul><li>用于常量和变量的初始化</li><li>用在表达式里或函数调用实参</li></ul></li><li>字面量分类：<ul><li>整型字面量</li><li>浮点型字面量</li><li>复数类型字面量</li><li>字符型字面量</li><li>字符串字面量</li></ul></li></ol><h2 id="1-4-变量和常量"><a href="#1-4-变量和常量" class="headerlink" title="1.4 变量和常量"></a>1.4 变量和常量</h2><h3 id="1-4-1-变量"><a href="#1-4-1-变量" class="headerlink" title="1.4.1 变量"></a>1.4.1 变量</h3><h3 id="1-4-2-常量"><a href="#1-4-2-常量" class="headerlink" title="1.4.2 常量"></a>1.4.2 常量</h3><h2 id="1-5-基本数据类型"><a href="#1-5-基本数据类型" class="headerlink" title="1.5 基本数据类型"></a>1.5 基本数据类型</h2><p>Go内置七类基本数据类型：</p><p><img src="/images/go_core_programming/Untitled%207.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%208.png" alt="Untitled"></p><h2 id="1-5-4-复数类型"><a href="#1-5-4-复数类型" class="headerlink" title="1.5.4 复数类型"></a>1.5.4 复数类型</h2><p>Go语言内置的复数类型有两种，分别是complex64和complex128。复数的字面量表示和数学表示法一样。</p><p><img src="/images/go_core_programming/Untitled%209.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2010.png" alt="Untitled"></p><h3 id="1-5-6-rune类型"><a href="#1-5-6-rune类型" class="headerlink" title="1.5.6 rune类型"></a>1.5.6 rune类型</h3><p>Go内置两种字符类型：</p><ul><li>bute的字节类类型（byte是uint的别名）</li><li>表示Uniocode编码的字符rune（rune是int32类型的别名）</li></ul><h2 id="1-6-复合数据类型"><a href="#1-6-复合数据类型" class="headerlink" title="1.6 复合数据类型"></a>1.6 复合数据类型</h2><ol><li>复合数据类型就是由其他类型组合而成的类型。</li><li>Go基本的复合数据类型有：<ul><li><p>指针</p></li><li><p>数据</p></li><li><p>切片</p></li><li><p>字典（map）</p></li><li><p>通道</p></li><li><p>结构</p></li><li><p>接口</p><p><img src="/images/go_core_programming/Untitled%2011.png" alt="Untitled"></p></li></ul></li></ol><h3 id="1-6-1-指针"><a href="#1-6-1-指针" class="headerlink" title="1.6.1 指针"></a>1.6.1 指针</h3><ol><li>Go支持指针，声明类型为 <code>*T</code> ，Go支持多级指针 <code>**T</code> 。通过在变量名前加 <code>&amp;</code> 获取变量的地址。</li><li>指针的特点：<ul><li>在赋值语句中，<code>*T</code> 出现在 <code>=</code> 左边表示指针声明，<code>*T</code> 出现在 <code>=</code> 右边表示取指针指向的值（varName为变量名）。示例：<pre><code class="go">var a = 11p := &amp;a // *p和a的值都是11</code></pre></li><li>结构体指针访问结构体字段仍然使用 <code>.</code> 点操作符，Go语言没有 <code>-&gt;</code> 操作符，例如：<pre><code class="go">type User struct {    name string    age int}andes := User {    name: "andes",    age: 10,}p := &amp;andesfmt.Println(p.name) // p.name通过"."操作符访问成员变量</code></pre></li><li>Go不支持指针的运算  Go由于支持垃圾回收，如果支持指针运算则会给垃圾回收的实现带来很多不便。例如：  <img src="/images/go_core_programming/Untitled%2012.png" alt="Untitled"></li><li>函数中允许返回局部变量的地址  Go编译器使用”栈逃逸“机制将这种局部变量的空间分配在堆上，例如：  <img src="/images/go_core_programming/Untitled%2013.png" alt="Untitled"></li></ul></li></ol><h3 id="1-6-2-数组"><a href="#1-6-2-数组" class="headerlink" title="1.6.2 数组"></a>1.6.2 数组</h3><ol><li>数组的类型名是<code>[n]elementType</code>，n是数组长度，elementType是数组元素类型。</li></ol><p><img src="/images/go_core_programming/Untitled%2014.png" alt="Untitled"></p><ol><li>数组的特点：<ul><li>数组创建完长度就固定了，不可以再追加元素了</li><li>数组是值类型的，数组赋值或作为函数参数都是值拷贝</li><li>数组长度是数组类型的组成部分，<code>[10]int</code>和<code>[20]int</code>是不同的类型</li><li>可以根据数组创建切片</li></ul></li><li>数组相关操作：<ul><li><p>数组元素访问</p><p><img src="/images/go_core_programming/Untitled%2015.png" alt="Untitled"></p></li><li><p>数组长度</p><p><img src="/images/go_core_programming/Untitled%2016.png" alt="Untitled"></p></li></ul></li></ol><h3 id="1-6-3-切片"><a href="#1-6-3-切片" class="headerlink" title="1.6.3 切片"></a>1.6.3 切片</h3><p>Go语言的数组的定长性和值拷贝限制了其使用场景，Gp提供了另一种数据类型slice（切片），这是一种变长数组，其数据结构中有指向数组的指针，所以是一种引用类型。</p><p>例如：</p><pre><code class="go">type slice struct {    array unsafe.Pointer    len int    cap int}</code></pre><p>Go为切片维护三个元素：</p><ul><li>指向底层数组的指针</li><li>切片的元素数量</li><li>底层数组的容量</li></ul><p><img src="/images/go_core_programming/Untitled%2017.png" alt="Untitled"></p><ol><li>切片的创建<ul><li>由数组创建：创建语法<code>array[b:e]</code> ，表示创建一个包含e-b各元素额的切片，第一个元素是<code>array[b]</code>，最后一个元素是<code>array[e-1]</code> 。例如：  <img src="/images/go_core_programming/Untitled%2018.png" alt="Untitled"></li><li>通过内置函数<code>make</code>创建切片。<code>make</code>创建的切片各元素被默认为输出华为切片元素类型的零值。  <img src="/images/go_core_programming/Untitled%2019.png" alt="Untitled">  <img src="/images/go_core_programming/Untitled%2020.png" alt="Untitled"></li></ul><ol><li>切片支持的操作<ul><li>内置函数<code>len()</code>返回切片长度</li><li>内置函数<code>cap()</code>返回切片底层数组容量</li><li>内置函数<code>append()</code>对切片追加元素</li><li>内置函数<code>copy()</code>用于复制一个切片</li></ul></li></ol></li></ol><h3 id="1-6-4-map"><a href="#1-6-4-map" class="headerlink" title="1.6.4 map"></a>1.6.4 map</h3><p>Go语言内置的字典类型叫map。</p><p><code>map</code>类型的格式是：<code>map[K]T</code> ，其中K可以是任意可以进行比较的类型，T是值类型。</p><p><code>map</code>也是一种引用类型。</p><ol><li><code>map</code>的创建<ul><li>使用字面量创建，例如：  <img src="/images/go_core_programming/Untitled%2021.png" alt="Untitled"></li><li>使用内置的make函数创建，例如  <img src="/images/go_core_programming/Untitled%2022.png" alt="Untitled">  <img src="/images/go_core_programming/Untitled%2023.png" alt="Untitled"></li></ul></li><li><code>map</code>支持的操作<ul><li><p><code>map</code>的单个键值访问格式为<code>mapName[key]</code></p></li><li><p>可以使用<code>range</code>遍历一个<code>map</code>类型的变量，但不能保证每次迭代元素的顺序</p></li><li><p>删除<code>map</code>中的某个键值，<code>delete(mapName,key)</code> 。<code>delete</code>是内置函数，用来删除<code>map</code>中的某个键值对</p></li><li><p>可以使用内置的<code>len()</code> 函数返回<code>map</code>中的键值对数量</p><p>注意：</p></li><li><p>Go内置的<code>map</code>不是并发安全的，并发安全的<code>map</code>可以使用标准包<code>sync</code>中的map</p></li><li><p>不要直接修改<code>map value</code>内某个元素的值，如果想修改<code>map</code>的某个键值，则必须整理赋值</p></li></ul></li></ol><h3 id="1-6-5-struct"><a href="#1-6-5-struct" class="headerlink" title="1.6.5 struct"></a>1.6.5 struct</h3><p>Go中的struct类型和C类似，中文翻译为结构，由多个不同类型元素组合而成。</p><ul><li>struct结构中的类型可以是任意类型</li><li>struct的存储空间是连续的，其字段按照声明时的顺序存放（注意字段值之间有对齐要求）</li></ul><p>struct有两种形式：</p><ul><li>struct类型字面量</li><li>使用type声明的自定义struct类型</li></ul><ol><li>strct类型字面量 struct类型字面量的声明格式如下： <img src="/images/go_core_programming/Untitled%2024.png" alt="Untitled"></li><li>自定义struct类型 自定义struct类型声明格式如下： <img src="/images/go_core_programming/Untitled%2025.png" alt="Untitled"></li><li>struct类型变量的初始化，示例： <img src="/images/go_core_programming/Untitled%2026.png" alt="Untitled"></li><li>其他复合类型<ul><li>接口（Interface）</li><li>通道（chan）</li></ul></li></ol><h2 id="1-7-控制结构"><a href="#1-7-控制结构" class="headerlink" title="1.7 控制结构"></a>1.7 控制结构</h2><p>程序执行从本质上来说就是两种模式：顺序和跳转</p><h3 id="1-7-1-if-语句"><a href="#1-7-1-if-语句" class="headerlink" title="1.7.1 if 语句"></a>1.7.1 if 语句</h3><h3 id="1-7-2-switch-语句"><a href="#1-7-2-switch-语句" class="headerlink" title="1.7.2 switch 语句"></a>1.7.2 switch 语句</h3><h3 id="1-7-3-for-语句"><a href="#1-7-3-for-语句" class="headerlink" title="1.7.3 for 语句"></a>1.7.3 for 语句</h3><h3 id="1-7-4-标签和跳转"><a href="#1-7-4-标签和跳转" class="headerlink" title="1.7.4 标签和跳转"></a>1.7.4 标签和跳转</h3><ol><li>标签 Go语言使用标签（Lable）来标识一个语句的位置，用于goto、break、continue语句的跳转。标签的语法是： <img src="/images/go_core_programming/Untitled%2027.png" alt="Untitled"></li><li>goto goto语句用于函数的内部跳转，需要配合标签一起使用： <img src="/images/go_core_programming/Untitled%2028.png" alt="Untitled"> goto特点：<ul><li>goto语句只能在函数内跳转</li><li>goto语句不能跳过内部变量声明语句，这些变量在goto语句的标签语句处有事可见的</li><li>goto语句只能调到同级作用域或者上层作用域，不能跳到内部作用域</li></ul></li><li>break break用于函数内跳出for、switch、select语句的执行，有两种使用格式：<ul><li>单独使用：用于跳出break当前所在的for、switch、select语句的执行</li><li>和标签一起使用：用于跳出标签所标识的for、switch、select语句的执行，可用于跳出多重循环，但标签和break必须在同一个函数内，例如：  <img src="/images/go_core_programming/Untitled%2029.png" alt="Untitled"></li></ul></li><li>continue continue用于跳出for循环的本次迭代，跳到for循环的下一次迭代的post语句处执行，有两种使用格式：<ul><li><p>单独使用：跳出continue当前所在的for循环的本次迭代</p></li><li><p>和标签一起使用：跳出标签所标示的for语句的本次迭代，但标签和continue必须在同一个函数内，例如：</p><p><img src="/images/go_core_programming/Untitled%2030.png" alt="Untitled"></p></li></ul></li><li>return和函数调用 return语句也能引发控制流程的跳转，用于函数和方法的退出。</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p><code>slice</code> 和 <code>array</code> 区别</p><ul><li>创建方式不同：数组<code>var identifier [len]type</code> ；切片<code>var slice3 = []int{}</code></li><li><code>slice</code>的<code>array</code>实际上是数组的指针，所以作为函数参数传递时不同：数组传递的是数组的副本；<code>slice</code>传递的是数组的指针</li><li>长度是否固定：数组长度固定；切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大</li></ul></li><li><p>struct能不能比较？<a href="https://juejin.cn/post/6881912621616857102">https://juejin.cn/post/6881912621616857102</a> </p></li><li><p>slice，len，cap，共享，扩容</p></li><li><p>for 循环遍历 slice 有什么问题</p><ul><li>for rang A，是对A的值拷贝，问题代码：<pre><code class="go">func TestName(t *testing.T) {    s :=[]int{1,2,3,4}    m :=make(map[int]*int)    for k,v:=range s{        m[k]= &amp;v    }    for key, value := range m {        fmt.Printf("map[%v]=%v\n", key, *value)    }    fmt.Println(m)}</code></pre>  改正：<pre><code class="go">func TestName(t *testing.T) {    s := []int{1, 2, 3, 4}    m := make(map[int]*int)    for k, v := range s {        // 这里变动        n := v        m[k] = &amp;n    }    for key, value := range m {        fmt.Printf("map[%v]=%v\n", key, *value)    }    fmt.Println(m)}</code></pre></li></ul></li><li><p>请你说说golang的CSP思想</p></li><li><p>进程，协程，线程各自的优缺点</p></li></ol><h1 id="第-2-章-函数"><a href="#第-2-章-函数" class="headerlink" title="第 2 章 函数"></a>第 2 章 函数</h1><p>Go中的函数：</p><ul><li>函数是一种类型，函数类型变量可以向其他类型变量一样使用，可以作为其它函数的参数或返回值，也可以直接调用执行</li><li>函数支持多值返回</li><li>支持闭包</li><li>函数支持可变参数</li></ul><h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><h3 id="2-1-1-函数定义"><a href="#2-1-1-函数定义" class="headerlink" title="2.1.1 函数定义"></a>2.1.1 函数定义</h3><p>包括如下几个部分：</p><ul><li>函数声明关键字func</li><li>函数名</li><li>参数列表</li><li>返回列表和函数体</li></ul><p>函数的特点：</p><ul><li>函数可以没有输入参数，也可以没有返回值（默认返回0）</li><li>多个相邻的相同类型的参数可以使用简写模式</li><li>支持有名的返回值，参数名就相当于函数体内最外层的局部变量，命名返回值变量会被初始化成类型零值</li><li>不支持默认值参数</li><li>不支持函数重载</li><li>不支持函数嵌套，严格的说是不支持命名函数的嵌套定义，但支持嵌套匿名函数</li></ul><h3 id="2-1-2-多值返回"><a href="#2-1-2-多值返回" class="headerlink" title="2.1.2 多值返回"></a>2.1.2 多值返回</h3><p>习惯用法：如果多值返回之有错误类型，则一般将错误类型作为最后一个返回值</p><h3 id="2-1-3-实参到形参的传递"><a href="#2-1-3-实参到形参的传递" class="headerlink" title="2.1.3 实参到形参的传递"></a>2.1.3 实参到形参的传递</h3><p>Go函数实参到形参的传递永远是值拷贝。有时函数调用后实参指向的值发生了变化，那是因为参数传递的是指针值的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本，二者指向同一地址。</p><h3 id="2-1-4-不定参数"><a href="#2-1-4-不定参数" class="headerlink" title="2.1.4 不定参数"></a>2.1.4 不定参数</h3><p>Go支持不定数据的形式参数，声明使用<code>param ...type</code> .</p><p>不定参数特点：</p><ul><li>所有的不定参数类型必须是相同的</li><li>不定参数必须是函数的最后一个参数</li><li>不定参数在函数体内相当于切片，对切片的操作同样适合对不定参数的操作</li><li>切片可以作为参数传递给不定参数，切片名后要加上”…”</li><li>形参为不定参数的函数和形参为切片的函数类型不相同</li></ul><h2 id="2-2-函数签名和匿名函数"><a href="#2-2-函数签名和匿名函数" class="headerlink" title="2.2 函数签名和匿名函数"></a>2.2 函数签名和匿名函数</h2><h3 id="2-2-1-函数签名"><a href="#2-2-1-函数签名" class="headerlink" title="2.2.1 函数签名"></a>2.2.1 函数签名</h3><p>函数类型又叫函数签名，可以使用fmt.Printf的%T格式化参数打印函数的类型</p><h3 id="2-2-2-匿名函数"><a href="#2-2-2-匿名函数" class="headerlink" title="2.2.2 匿名函数"></a>2.2.2 匿名函数</h3><p>Go提供两种函数：有名函数和匿名函数</p><p>匿名函数可以直接复制给函数变量，可以当做实参，也可以作为返回值，还可以直接被调用。</p><h2 id="2-3-defer"><a href="#2-3-defer" class="headerlink" title="2.3 defer"></a>2.3 defer</h2><p>Go提供了defer关键字，可以注册多个延迟调用，这些调用以先进后出的顺序在函数返回前被执行。这有点类似于Java语言中异常处理的finaly语句。</p><p>defer常用语保证一些资源最终一定能够得到回收和释放。</p><p>特点：</p><ul><li>defer后面必须是函数或方法的调用，不能是语句</li><li>defer函数的实参在注册时通过值拷贝传递进去</li><li>defer语句必须先注册后才能执行</li></ul><p>优势：可以在一定程度上避免资源泄露</p><p>缺点：</p><ul><li>defer会推迟资源的释放</li><li>defer不要写在循环语句里面</li><li>defer最好不要对有名返回值参数进行操作</li></ul><h2 id="2-4-闭包"><a href="#2-4-闭包" class="headerlink" title="2.4 闭包"></a>2.4 闭包</h2><p>闭包是由函数及其相关引用环境组合而成的实体。</p><p><code>闭包 = 函数 + 引用环境</code></p><ol><li>闭包对闭包外的环境引入是直接引用，编译器检测到闭包会将闭包引用的外部变量分配到堆上</li><li>如果函数返回的闭包引用了该函数的局部变量（参数或函数内部变量）<ol><li>多次调用该函数返回的多个闭包所引用的外部变量是多个副本，原因是每次调用函数都会为局部变量分配内存</li><li>用一个闭包函数多次，如果该闭包修改了其引用的外部变量，则每一次调用该闭包对该外包变量都有影响，因为闭包函数共享外部引用</li></ol></li></ol><h3 id="2-4-2-闭包的价值"><a href="#2-4-2-闭包的价值" class="headerlink" title="2.4.2 闭包的价值"></a>2.4.2 闭包的价值</h3><p>对象是附有行为的数据，闭包是附有数据的行为。</p><h2 id="2-5-panic和recover"><a href="#2-5-panic和recover" class="headerlink" title="2.5 panic和recover"></a>2.5 panic和recover</h2><p>panic用来主动抛出错误</p><p>recover用来捕获panic抛出的错误</p><h3 id="2-5-1-基本概念"><a href="#2-5-1-基本概念" class="headerlink" title="2.5.1 基本概念"></a>2.5.1 基本概念</h3><p><img src="/images/go_core_programming/Untitled%2031.png" alt="Untitled"></p><p>引发panic的情况：</p><ul><li>程序主动调用panic函数</li><li>程序产生运行时错误，由运行时检测并抛出</li></ul><p>recover用来捕获panic，阻止panic继续向上传递</p><h3 id="2-5-2-使用场景"><a href="#2-5-2-使用场景" class="headerlink" title="2.5.2 使用场景"></a>2.5.2 使用场景</h3><ul><li>程序遇到了无法正常执行下去的错误，主动调用panic函数结束程序运行</li><li>在调试程序时，通过主动调用panic实现快速退出，panic打印出的堆栈能够更快的定位错误</li></ul><h2 id="2-6-错误处理"><a href="#2-6-错误处理" class="headerlink" title="2.6 错误处理"></a>2.6 错误处理</h2><h3 id="2-6-1-error"><a href="#2-6-1-error" class="headerlink" title="2.6.1 error"></a>2.6.1 error</h3><p>Go语言内置错误接口类型error</p><p>错误处理的最佳实践：</p><ul><li>在多个返回值的函数中，error通常作为函数最后一个返回值</li><li>如果一个函数返回error类型变量，则先用if语句处理<code>error != nil</code> 的异常场景，正常逻辑放到if语句块后面保持代码平坦</li><li>defer语句应该放到err判断的后面，不然有可能产生panic</li><li>在错误逐级向上传递的过程中，错误信息应该不断地丰富和完善，而不是简单抛出下层调用的错误</li></ul><pre><code class="go">func deferDemo() error {    err := createResource1()    if err != nil {        return ERR_CREATE_RESOURCE1_FAILED    }    defer func() {        if err != nil {            destroyResource1()        }    }()}</code></pre><h3 id="2-6-2-错误和异常"><a href="#2-6-2-错误和异常" class="headerlink" title="2.6.2 错误和异常"></a>2.6.2 错误和异常</h3><p>Go程序需要处理的错误类型：</p><ul><li>运行时错误：无法避免，可以recover这些panic</li><li>程序逻辑错误</li></ul><p>error和panic应该遵循如下原则：</p><ul><li>程序发生的错误导致程序不能容错继续执行，此时程序应该主动调用panic或由运行时抛出panic</li><li>程序虽然发生错误，但是程序能够容错继续执行，此时应该使用错误返回值的方式处理错误，或者在可能发生运行时错误的非关键分支上使用recover捕获panic</li></ul><pre><code class="go">func TestName(t *testing.T) {    height := []int{2,3,4,5,18,17,6}    defer func() {        if err := recover(); err != nil {            fmt.Println(err)        }    }()    print(height[10])}</code></pre><h2 id="2-7-底层实现"><a href="#2-7-底层实现" class="headerlink" title="2.7 底层实现"></a>2.7 底层实现</h2><h1 id="第-3-章-类型系统"><a href="#第-3-章-类型系统" class="headerlink" title="第 3 章 类型系统"></a>第 3 章 类型系统</h1><h2 id="3-1-类型简介"><a href="#3-1-类型简介" class="headerlink" title="3.1 类型简介"></a>3.1 类型简介</h2><h3 id="3-1-1-命名类型和未命名类型"><a href="#3-1-1-命名类型和未命名类型" class="headerlink" title="3.1.1 命名类型和未命名类型"></a>3.1.1 命名类型和未命名类型</h3><p>命名类型：可以通过标识符来表示（3.2节详细介绍）</p><p>未命名类型：一个类型由预声明类型、关键字和操作符组合而成，又称为类型字面量。例如：数组（array）、切片（slice）、字典（map）、通道（channel）、指针（pointer）、函数字面量（function）、结构（struct）和接口（interface）都属于类型字面量</p><h3 id="3-1-2-底层类型"><a href="#3-1-2-底层类型" class="headerlink" title="3.1.2 底层类型"></a>3.1.2 底层类型</h3><p>所有“类型”都有一个underlying type（底层类型）。底层类型的规则如下：</p><ul><li>预声明类型（Pre-declared types）和类型字面量（type literals）的底层类型是他们自身</li><li>自定义类型type newtype oldtype中的newtype的底层是逐层递归向下查找的，知道查到的oldtype是预声明类型（Pre-declared types）或类型字面量（type literals）为止。</li></ul><h3 id="3-1-3-类型相同和类型赋值"><a href="#3-1-3-类型相同和类型赋值" class="headerlink" title="3.1.3 类型相同和类型赋值"></a>3.1.3 类型相同和类型赋值</h3><p><strong>类型相同</strong></p><p>Go是强类型的语言，编译器在编译时会进行严格的类型校验。两个命名类型是否相同的判断：</p><ul><li>两个命名类型相同的条件是两个类型声明的语句完全相同</li><li>命名类型和未命令类型永远不相同</li><li>两个未命名类型相同的条件是他们的类型声明字面量的结构相同，并且内部元素的类型相同</li><li>通过类型别名语句声明的两个类型相同</li></ul><p><strong>类型可直接赋值</strong></p><p>类型为T1的变量a可以赋值给类型为T2的变量b，称为类型T1可以赋值给类型T2，伪代码：</p><pre><code class="go">var b T2 = a</code></pre><p>a可以赋值给变量b必须要满足如下条件中的一个：</p><ul><li>T1和T2的类型相同</li><li>T1和T2具有相同的底层类型，并且T1和T2里面至少有一个是未命名类型</li><li>T2是接口类型，T1是具体类型，T1的方法集是T2方法集的超级</li><li>T1和T2都是通道类型，他们拥有相同的元素类型，并且T1和T2至少有一个是未命名类型</li><li>a是预声明标识符nil，T2是pointer、function、slice、map、channel、interface类型中的一个</li><li>a是一个字面常量值，可以用来表示类型T的值</li></ul><h3 id="3-1-4-类型强制转换"><a href="#3-1-4-类型强制转换" class="headerlink" title="3.1.4 类型强制转换"></a>3.1.4 类型强制转换</h3><p>由于Go是强类型的语言，如果不满足自动转换的条件，则必须进行强制类型转换。</p><p>非常量类型的变量x可以强制转化并传递给类型T，需要满足如下任一条件：</p><ul><li>x可以直接赋值给T类型变量</li><li>x类型和T具有相同的底层类型</li><li>x的类型和T都是未命名的指针类型，并且指针指向的类型具有相同的底层类型</li><li>x的类型和T都是整型或者都是浮点型</li><li>x的类型和T都是复数类型</li><li>x是整数值或[]byte类型的值，T是string类型</li><li>x是一个字符串，T是[]byte或[]rune</li></ul><h2 id="3-2-类型方法"><a href="#3-2-类型方法" class="headerlink" title="3.2 类型方法"></a>3.2 类型方法</h2><h3 id="3-2-1-自定义类型"><a href="#3-2-1-自定义类型" class="headerlink" title="3.2.1 自定义类型"></a>3.2.1 自定义类型</h3><p>自定义类型都是命名类型</p><p><img src="/images/go_core_programming/Untitled%2032.png" alt="Untitled"></p><p>自定义struct类型</p><h3 id="3-2-2-方法"><a href="#3-2-2-方法" class="headerlink" title="3.2.2 方法"></a>3.2.2 方法</h3><p><img src="/images/go_core_programming/Untitled%2033.png" alt="Untitled"></p><p>类型方法有如下特点：</p><ul><li>可以为命名类型增加方法（除了接口），非命名类型不能自定义方法</li><li>为类型增加方法有一个限制，就是方法的定义必须和类型的定义在同一个包中</li><li>方法的命名空间可见性和变量一样，大写开头的方法可也在包外被访问，否则只能在包内可见</li><li>使用type定义的自定义类型是一个新类型，新类型不能调用原有类型的方法，但是底层类型支持的运算可以被新类型继承</li></ul><p><img src="/images/go_core_programming/Untitled%2034.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2035.png" alt="Untitled"></p><h2 id="3-3-方法调用"><a href="#3-3-方法调用" class="headerlink" title="3.3 方法调用"></a>3.3 方法调用</h2><h3 id="3-3-1-一般调用"><a href="#3-3-1-一般调用" class="headerlink" title="3.3.1 一般调用"></a>3.3.1 一般调用</h3><p><img src="/images/go_core_programming/Untitled%2036.png" alt="Untitled"></p><h3 id="3-3-2-方法值"><a href="#3-3-2-方法值" class="headerlink" title="3.3.2 方法值"></a>3.3.2 方法值</h3><p><img src="/images/go_core_programming/Untitled%2037.png" alt="Untitled"></p><h3 id="3-3-3-方法表达式"><a href="#3-3-3-方法表达式" class="headerlink" title="3.3.3 方法表达式"></a>3.3.3 方法表达式</h3><p>方法表达式相当于提供一种语法将类型方法调用显示第转换为函数调用，接受者必须显示地传递进去。</p><h3 id="3-3-4-方法集"><a href="#3-3-4-方法集" class="headerlink" title="3.3.4 方法集"></a>3.3.4 方法集</h3><p>命名类型方法接受者有两种类型，一个是值类型，另一个是指针类型，这个和函数是一样的，前者的形参是值类型，后者的形参是指针类型。</p><p>无论接受者是什么类型，方法和函数的实参传递都是值拷贝，如果接受者是值类型，则传递的是值的副本；如果接受者是指针类型，则传递的是指针的副本</p><h3 id="3-3-5-值调用和表达式调用的方法集"><a href="#3-3-5-值调用和表达式调用的方法集" class="headerlink" title="3.3.5 值调用和表达式调用的方法集"></a>3.3.5 值调用和表达式调用的方法集</h3><h2 id="3-4-组合和方法集"><a href="#3-4-组合和方法集" class="headerlink" title="3.4 组合和方法集"></a>3.4 组合和方法集</h2><p>结构类型为Go提供了强大的类型扩展，主要体现在两个方面：</p><ul><li>struct可以嵌入任意其他类型的字段</li><li>struct可以嵌套自身的指针类型的字段</li></ul><h3 id="3-4-1-组合"><a href="#3-4-1-组合" class="headerlink" title="3.4.1 组合"></a>3.4.1 组合</h3><p>因为Go没有继承的语义，结构和字段之间是“has a”的关系而不是“is a”的关系，没有父子概念，仅仅是整体和局部的概念，所以后续统称这种嵌套的结构和字段的关系为组合</p><h3 id="3-4-2-组合的方法集"><a href="#3-4-2-组合的方法集" class="headerlink" title="3.4.2 组合的方法集"></a>3.4.2 组合的方法集</h3><h2 id="3-5-函数类型"><a href="#3-5-函数类型" class="headerlink" title="3.5 函数类型"></a>3.5 函数类型</h2><h1 id="第-4-章-接口（未看）"><a href="#第-4-章-接口（未看）" class="headerlink" title="第 4 章 接口（未看）"></a>第 4 章 接口（未看）</h1><h1 id="第-5-章-并发"><a href="#第-5-章-并发" class="headerlink" title="第 5 章 并发"></a>第 5 章 并发</h1><h2 id="5-1-并发基础"><a href="#5-1-并发基础" class="headerlink" title="5.1 并发基础"></a>5.1 并发基础</h2><h3 id="5-1-1-并发和并行"><a href="#5-1-1-并发和并行" class="headerlink" title="5.1.1 并发和并行"></a>5.1.1 并发和并行</h3><ol><li>并行就是在任一粒度的时间内都具备同时执行的能力：例如多机</li><li>并发是在规定的时间内多个请求都得到执行和处理，强调的是给外界的感受，实际上内部可能是分时操作的</li></ol><h3 id="5-1-2-goroutine"><a href="#5-1-2-goroutine" class="headerlink" title="5.1.2 goroutine"></a>5.1.2 goroutine</h3><p>Go语言的并发执行体称为goroutine，通过go关键字来启动一个goroutine。</p><p>goroutine特性：</p><ul><li>go的执行是非阻塞的，不会等待</li><li>go后面的函数的返回值会被忽略</li><li>调度器不能保证多个goroutine的执行次序</li><li>没有父子goroutine的概念，所有goroutne是平等地被调用和执行的</li><li>Go程序在执行时会单独为main函数创建一个goroutine，遇到其他go关键字时再去创建其他的goroutinue</li><li>Go没有暴露goroutine id给用户，所以不能在一个goroutine里面显式地操作另一个goroutine，不过runtime包提供了一些函数访问和设置goroutine的相关信息</li></ul><ol><li>func GOMAXPROCS</li></ol><p>设置或查询可以并发执行的goroutine数目</p><pre><code class="go">package goroutine_testimport (    "runtime"    "testing")func TestName(t *testing.T) {    // 获取GOMAXPROCS    println("GOMAXPROCS=",runtime.GOMAXPROCS(0))    // 设置GOMAXPROCS    runtime.GOMAXPROCS(2)    // 获取GOMAXPROCS    println("GOMAXPROCS=",runtime.GOMAXPROCS(0))}</code></pre><ol><li>func Goexit</li></ol><p>结束当前goroutinue的运行。Goexit不会产生panic。</p><ol><li>fun Gosched</li></ol><p>放弃当前调度执行机会，将当前goroutinue放到队列中等待下次被调度</p><h3 id="5-1-3-chan"><a href="#5-1-3-chan" class="headerlink" title="5.1.3 chan"></a>5.1.3 chan</h3><ol><li>chan是Go语言里面的一个关键字，是channel的简写，通道。通道是Go通过通信来共享内容的载体。</li><li>通道类型：<ul><li><p>有缓冲的通道：主要用于通信</p></li><li><p>无缓冲的通道：既可以用于通信，也可以用于两个goroutinue的同步</p><p><img src="/images/go_core_programming/Untitled%2038.png" alt="Untitled"></p><pre><code class="go">func TestName(t *testing.T) {  println("NumGoroutinue=", runtime.NumGoroutine())  c := make(chan struct{})  ci := make(chan int, 100)  go func(i chan struct{}, j chan int) {      for i := 0; i &lt; 10; i++ {          ci &lt;- i      }      close(ci)      // 写通道      c &lt;- struct{}{}  }(c, ci)  // NumGoroutinue可以返回当前程序的goroutinue数目  println("NumGoroutinue=", runtime.NumGoroutine())  // 读通道c，通过通道进行同步等待  &lt;-c  // 此时ci通道已经关闭，匿名函数启动的goroutinue已经退出  println("NumGoroutinue=", runtime.NumGoroutine())  for v := range ci {      println(v)  }}</code></pre></li></ul></li><li>操作不同状态的chan会引发三种行为<ul><li>panic<ul><li>向已经关闭的通道写数据会导致panic。由写入者关闭通道能最大程度地避免向已经关闭的通道写数据而导致panic</li><li>重复关闭的通道会导致panic</li></ul></li><li>阻塞<ul><li>向未初始化的通道写数据或读数据都会导致当前goroutine的永久阻塞</li><li>向缓冲区已满的通道写入数据会导致goroutinue阻塞</li><li>通道中没有数据，读取该通道会导致goroutinue阻塞</li></ul></li><li>非阻塞<ul><li>读者已经关闭的通道不会引发阻塞而是立即返回通道元素类型的零值，可以使用comma，ok语法判断通道是否已经关闭</li><li>向有缓冲且没有满的通道读/写不会引发阻塞</li></ul></li></ul></li></ol><h3 id="5-1-4-WaitGroup"><a href="#5-1-4-WaitGroup" class="headerlink" title="5.1.4 WaitGroup"></a>5.1.4 WaitGroup</h3><p>sync包提供了多个goroutine同步的机制，主要是通过WaitGroup实现的。</p><h3 id="5-1-5-select"><a href="#5-1-5-select" class="headerlink" title="5.1.5 select"></a>5.1.5 select</h3><p>select用于多路监听多个通道</p><ul><li>当监听的通道没有状态是可读或可写的，select是阻塞的</li><li>监听的通道中有一个状态是可读或可写的，则select就不会阻塞，而是进入处理就绪通道的分支流程</li><li>如果监听的通道有多个可读或可写的状态，则select随机选取一个处理</li></ul><pre><code class="go">import "testing"func TestName(t *testing.T) {    ch := make(chan int, 2)    go func(chan int) {        for {            select {            case ch &lt;- 0:            case ch &lt;- 1:            }        }    }(ch)    for i := 0; i &lt; 10; i++ {        println(&lt;-ch)    }}</code></pre><h3 id="5-1-6-扇入（Fan-in）和扇出（Fan-out）"><a href="#5-1-6-扇入（Fan-in）和扇出（Fan-out）" class="headerlink" title="5.1.6 扇入（Fan in）和扇出（Fan out）"></a>5.1.6 扇入（Fan in）和扇出（Fan out）</h3><p>扇入：将多路通道聚合到一条通道中处理，Go最简单的扇入就是使用select聚合多条通道服务</p><p>扇出：将一条通道发散到多条通道中处理，Go语言里面具体实现就是使用go关键字启动多个goroutine并发处理 </p><pre><code class="go">import (    "fmt"    "sync"    "testing")var wg sync.WaitGroupfunc TestWaitGroup(t *testing.T) {    for i := 0; i &lt; 10; i++ {        wg.Add(1)        go func(i int) {            defer wg.Done()            fmt.Printf("go func: %d\n", i)        }(i)    }    wg.Wait()    println("success!")}</code></pre><h3 id="5-1-7-通知退出机制"><a href="#5-1-7-通知退出机制" class="headerlink" title="5.1.7 通知退出机制"></a>5.1.7 通知退出机制</h3><p>读取已经关闭的通道不会引起阻塞，也不会导致panic，而是立即返回该通道存储类型的零值。</p><p>关闭select监听的某个通道能使select立即感知这种通知，然后进行相应的处理，这就是所谓的退出通知机制。</p><p>下面通过一个随机数生成器的示例掩饰退出通知机制，下游的消费者不需要随机数时显式地通知生产者停止生产：</p><pre><code class="go">import (    "fmt"    "math/rand"    "runtime"    "testing")func GenerateIntA(done chan struct{}) chan int {    ch := make(chan int)    go func() {    Lable:        for {            select {            case ch &lt;- rand.Int():            case &lt;-done:                break Lable            }        }        close(ch)    }()    return ch}func TestNotiExit(t *testing.T) {    println("NumGoroutine=", runtime.NumGoroutine())    done := make(chan struct{})    ch := GenerateIntA(done)    println("NumGoroutine=", runtime.NumGoroutine())    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    close(done)    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    println("NumGoroutine=", runtime.NumGoroutine())}</code></pre><h2 id="5-2-并发范式"><a href="#5-2-并发范式" class="headerlink" title="5.2 并发范式"></a>5.2 并发范式</h2><h3 id="5-2-1-生成器"><a href="#5-2-1-生成器" class="headerlink" title="5.2.1 生成器"></a>5.2.1 生成器</h3><ol><li>最简单的带缓冲的生成器</li></ol><pre><code class="go">import (    "fmt"    "math/rand"    "testing")func GenerateInt() chan int {    ch := make(chan int, 3)    go func() {        for {            ch &lt;- rand.Int()        }    }()    return ch}func TestGenerateInt(t *testing.T) {    ch := GenerateInt()    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)}</code></pre><ol><li>多个goroutinue增强型生成器</li></ol><p><img src="/images/go_core_programming/Untitled%2039.png" alt="Untitled"></p><ol><li>有时希望生成器能够自动退出，可以借助Go通道的退出通知机制实现，例如：</li></ol><p><img src="/images/go_core_programming/Untitled%2040.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2041.png" alt="Untitled"></p><ol><li>融合并发、缓冲、退出通知等多重特性的生成器</li></ol><pre><code class="go">package genericimport (    "fmt"    "math/rand"    "testing")func GenerateIntA(done chan struct{}) chan int {    fmt.Println("GenerateIntA")    ch := make(chan int, 5)    go func() {    Lable:        for {            select {            case ch &lt;- rand.Int():            case &lt;-done:                break Lable            }        }        close(ch)    }()    return ch}func GenerateIntB(done chan struct{}) chan int {    fmt.Println("GenerateIntB")    ch := make(chan int, 5)    go func() {    Lable:        for {            select {            case ch &lt;- rand.Int():            case &lt;-done:                break Lable            }        }        close(ch)    }()    return ch}func GenerateInt(done chan struct{}) chan int {    ch := make(chan int)    send := make(chan struct{})    go func() {    Lable:        for {            select {            case ch &lt;- &lt;-GenerateIntA(send):            case ch &lt;- &lt;-GenerateIntB(send):            case &lt;-done:                send &lt;- struct{}{}                send &lt;- struct{}{}                break Lable            }        }        close(ch)    }()    return ch}func Test(t *testing.T)  {    done := make(chan struct{})    ch := GenerateInt(done)    for i := 0; i &lt; 10; i++ {        fmt.Println(&lt;-ch)    }    done &lt;- struct{}{}    fmt.Println("stop generate")}</code></pre><h3 id="5-2-2-管道"><a href="#5-2-2-管道" class="headerlink" title="5.2.2 管道"></a>5.2.2 管道</h3><p>通道可以分为两个方向，一个是读另一个是写，加入一个函数的输入参数和输出参数都是相同的chan类型，则该函数可以调用自己，最终形成一个调用链。这很像UNIX系统的管道，是一个有类型的管道</p><h3 id="5-2-3-每个请求一个goroutine"><a href="#5-2-3-每个请求一个goroutine" class="headerlink" title="5.2.3 每个请求一个goroutine"></a>5.2.3 每个请求一个goroutine</h3><p>来一个请求或任务就启动一个goroutine去处理，典型的就是Go中的HTTP server服务。</p><h3 id="5-2-4-固定worker工作池"><a href="#5-2-4-固定worker工作池" class="headerlink" title="5.2.4 固定worker工作池"></a>5.2.4 固定worker工作池</h3><p>程序中除了主要的main goroutine，还开启了如下几类goroutine：</p><ul><li>初始化任务的goroutine</li><li>分发任务的goroutine</li><li>等待所有worker结束通知，然后关闭结果通道的goroutine</li></ul><p>程序采用三个通道，分别是：</p><ul><li>传递task任务的通道</li><li>传递task结果的通道</li><li>接收worker处理完任务后所发送通知的通道</li></ul><p>计算多个整数的和样例代码：</p><pre><code class="go">package mainimport (    "fmt"    "math/rand"    "time")// 工作池的goroutine数目const NUMBER = 10// 工作任务type task struct {    // 存放数据    data int    // 任务结果    result chan&lt;- int}// 任务处理：计算begin和end的和// 执行结果写入结果chan resultfunc (t *task) do() {    // 模拟计算耗时    r := rand.Intn(1000)    fmt.Println("Sleep:", r, "ms")    time.Sleep(time.Duration(r) * time.Millisecond)    // 模拟任务结果就是任务数据    t.result &lt;- t.data}func main() {    workers := NUMBER    taskChan := make(chan task, 10)    resultChan := make(chan int, 10)    done := make(chan struct{}, 10)    // 初始化task的goroutine    go InitTask(taskChan, resultChan, 100)    // 分发任务到NUMBER个goroutine池    DistributeTask(taskChan, workers, done)    // 获取各个goroutine处理完任务的通知并关闭结果通道    go CloseResult(done, resultChan, workers)    // 通过结果通道获取结果并汇总    sum := ProcessResult(resultChan)    fmt.Println("sum=", sum)}// 初始化待处理task chanfunc InitTask(taskChan chan&lt;- task, r chan int, p int) {    for i := 0; i &lt;= p; i++ {        taskChan &lt;- task{            data:   i,            result: r,        }    }    close(taskChan)}// 读取task chan并分发到worker goroutine处理，总的数量是workersfunc DistributeTask(taskChan &lt;-chan task, works int, done chan struct{}) {    for i := 0; i &lt; works; i++ {        go ProcessTask(taskChan, done)    }}// 工作goroutine处理具体工作，并将处理结果发送到结果chanfunc ProcessTask(taskChan &lt;-chan task, done chan struct{}) {    for t := range taskChan {        t.do()    }    done &lt;- struct{}{}}// 通过done channel同步等待所有工作goroutine的结束，然后关闭结果chanfunc CloseResult(done chan struct{}, resultChan chan int, workers int) {    for i := 0; i &lt; workers; i++ {        &lt;-done    }    close(done)    close(resultChan)}// 读取结果通道，汇总结果func ProcessResult(resultChan chan int) int {    sum := 0    for r := range resultChan {        sum += r    }    return sum}</code></pre><p><img src="/images/go_core_programming/Untitled%2042.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2043.png" alt="Untitled"></p><h3 id="5-2-5-future模式"><a href="#5-2-5-future模式" class="headerlink" title="5.2.5 future模式"></a>5.2.5 future模式</h3><p>用处：子调用相互之间没有依赖，如果串行调用则耗时会很长，此时可以使用Go并发编程中的future模式</p><p>工作原理：</p><ol><li>使用chan作为函数参数</li><li>启动goroutine调用安徽省农户</li><li>通过chan传递如参数</li><li>做其他可以并行处理的事情</li><li>通过chan异步获取结果</li></ol><pre><code class="go">package mainimport (    "fmt"    "time")// 一个查询结构体// 这里的sql和result是一个简单的抽象，具体的应用可能是更复杂的数据类型type query struct {    // 参数Channel    sql chan string    // 结果Channel    result chan string}// 执行Queryfunc execQuery(q query) {    // 启动协程    go func() {        // 获取输入        sql := &lt;-q.sql        // 访问数据库        // 输出结果通道        q.result &lt;- "result from " + sql    }()}func main() {    // 初始化Query    q := query{make(chan string, 1), make(chan string, 1)}    // 执行Query，注意执行的时候无需准备参数    go execQuery(q)    // 发送参数    q.sql &lt;- "select * from table"    // 做其他事情    time.Sleep(1 * time.Second)    // 获取结果    fmt.Println(&lt;-q.result)}</code></pre><p><img src="/images/go_core_programming/Untitled%2044.png" alt="Untitled"></p><h2 id="5-3-context标准库"><a href="#5-3-context标准库" class="headerlink" title="5.3 context标准库"></a>5.3 context标准库</h2><p>Go中的goroutine之间没有父与子的关系，没有所谓的子进程退出后的通知机制，goroutine之间平行地被调度，多个goroutine如何协作工作设计通信、同步、通知和退出四个方面</p><ul><li>通信：chan通道是goroutine之间通信的基础（通信指程序的数据通道）</li><li>同步：不带缓冲的chan提供了一个天然的同步等待机制；sync.WaitGroup也为多个goroutine协同工作提供一种同步等待机制</li><li>通知：这个通知和上面通信的数据不一样，通知不是业务数据，而是管理、控制流数据。在输入端绑定两个chan，一个用于业务流数据，另一个用于异常通知数据，然后使用select收敛进行处理</li><li>退出：借助通道和select的广播机制实现退出</li></ul><h3 id="5-3-1-context的设计目的"><a href="#5-3-1-context的设计目的" class="headerlink" title="5.3.1 context的设计目的"></a>5.3.1 context的设计目的</h3><ul><li>退出通知机制：通知可以传递给整个goroutine调用树上的每一个goroutine</li><li>数据传递：数据可以传递给整个goroutine调用树上的每一个goroutine</li></ul><h3 id="5-3-2-基本数据结构"><a href="#5-3-2-基本数据结构" class="headerlink" title="5.3.2 基本数据结构"></a>5.3.2 基本数据结构</h3><p>context工作机制：第一个创建 Context goroutine被称为 root 节点。 root 节点负责创建一个实现context接口的具体对象，并将该对象作为参数传递到其新拉起的goroutine，下游的 goroutine 继续封装该对象，再传递到更下游的goroutine，Context 对象在传递的过程中最终形成一个树状的数据结构，这样通过位于 root 节点（树的根节点） Context 对象就能遍历整个 Context 对象树，通知和消息就可以通过 root 节点传递出去，实现了上游 goroutine 下游 goroutine 的消息传递。</p><p><strong>Context接口</strong></p><p>Context作为参数传递</p><p><img src="/images/go_core_programming/Untitled%2045.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2046.png" alt="Untitled"></p><p><strong>canceler接口</strong></p><p>conceler规定了取消通知的Context具体类型需要实现的接口</p><p><img src="/images/go_core_programming/Untitled%2047.png" alt="Untitled"></p><p><strong>empty Context结构</strong></p><p>实现了Context接口但不具备任何功能，其存在的目的是作为Context对象树的根（root节点）</p><p><strong>cancelCtx</strong></p><p>cancelCtx是一个实现了Context耳机口的具体类型，同时实现了conceler接口</p><p><strong>timerCtx</strong></p><p>timerCtx是一个实现了Context接口的具体类型，内部封装cancelCtx类型实例，同时有一个deadlinebianl,yonglaishixian定时退出通知</p><p><strong>valueCtx</strong></p><p>valueCtx是一个实现了Context接口的具体类型，内部封装了Context接口类型，同时封装了一个k/v的存储遍历，valueCtx可以用来传递通知信息</p><p><img src="/images/go_core_programming/Untitled%2048.png" alt="Untitled"></p><h3 id="5-3-3-API函数"><a href="#5-3-3-API函数" class="headerlink" title="5.3.3 API函数"></a>5.3.3 API函数</h3><p>以下两个函数是构造Context取消树的根节点对象，根节点对象用作后续With包装函数的实参：</p><ul><li>func Background() Context</li><li>func TODO() Context</li></ul><h3 id="5-3-6-使用Context传递数据的争议"><a href="#5-3-6-使用Context传递数据的争议" class="headerlink" title="5.3.6 使用Context传递数据的争议"></a>5.3.6 使用Context传递数据的争议</h3><p>使用context传递数据的坏处：</p><ul><li>传递的都是interface{}类型的值，编译器不能进行严格的类型校验</li><li>从interface{}到具体类型需要使用类型断言和接口查询，有一定的运行期开销和性能损失</li><li>值在传递过程中有可能被后续的服务覆盖且不易被发现</li><li>传递信息不简明。较晦涩；不能通过代码或文档一眼看到传递的是什么，不利于后续维护</li></ul><p>context应该传递什么数据：</p><ul><li>日志信息</li><li>调低是信息</li><li>不影响业务主逻辑的可选数据</li></ul><h2 id="5-4-并发模型"><a href="#5-4-并发模型" class="headerlink" title="5.4 并发模型"></a>5.4 并发模型</h2><h3 id="5-4-1-CSP简介"><a href="#5-4-1-CSP简介" class="headerlink" title="5.4.1 CSP简介"></a>5.4.1 CSP简介</h3><p>CSP基本思想：将并发系统抽象为Channel和Process两部分，Channel用来传递消息，Process用于执行，Channel和Process之间相互独立，没有从属关系，消息的发送和接收有严格的时序限制。</p><p>Go中Channel就是通道，Process就是goroutine</p><h3 id="5-4-2-调度模型"><a href="#5-4-2-调度模型" class="headerlink" title="5.4.2 调度模型"></a>5.4.2 调度模型</h3><p>协程是一种用户态的轻量级线程，写成的调度完全由用户态程序控制，协程拥有自己的寄存器上下文和栈。</p><p>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候恢复先前保存的寄存器上下文和栈，每个内核线程可以对应多个用户协程，当一个协程执行体阻塞了，调度器会调度另一个携程执行，最大效率地利用操作系统分给系统线程的时间片。</p><p>好处：</p><ul><li>控制了系统线程数，保证每个线程的运行时间片充足</li><li>调度层能进行用户态的切换，不会导致单个协程阻塞整个程序的情况，尽量减少上下文切换，提升运行效率</li></ul><p>由此可见，协程是一种非常高效、理想的执行模型。Go的并发执行模型就是一种变种的协程模型。</p><h3 id="5-4-3-并发和调度"><a href="#5-4-3-并发和调度" class="headerlink" title="5.4.3 并发和调度"></a>5.4.3 并发和调度</h3><p>goroutine好处：</p><ul><li>goroutine可以在用户空间调度，避免了内核态和用户态的切换导致的成本</li><li>goroutine是语言原生支持的，提供了非常简洁的语法，屏蔽了大部分复杂底层实现</li><li>goroutine更小的占空间允许用户创建成千上万的实例</li></ul><p>goroutinue调度模型：</p><ol><li>实体G（Goroutine）</li></ol><p>G是Go运行时对goroutine的抽象描述，G中存放并发执行的代码入口地址、上下文、运行环境（关联的P和M）、运行栈等执行相关的元信息</p><ol><li>实体M（Machine）</li></ol><p>M代表OS内核线程，是操作系统层面调度和执行的实体。M仅负责执行，M不停地被唤醒或创建，然后执行。M启动时进入的是运行时的管理代码，有这段代码获取G和P资源，然后执行调度。另外Go</p><p>语言运行时会单独创建一个监控线程，负责对程序的内存、调度等信息进行监控和控制</p><ol><li>实体P（Processor）</li></ol><p>P代表M运行G所需的资源，是对资源的一种抽象和管理，P不是一段代码实体，而是一个管理的数据结构，P主要是降低M管理调度G的复杂性，增加一个简洁的控制层数据结构。</p><p><img src="/images/go_core_programming/Untitled%2049.png" alt="Untitled"></p><p><strong>m0和g0</strong></p><p>m0和g0是启动程序后的主线程，这个m对应的信息会存放在全局变量m0种，m0负责执行初始化操作和启动第一个g，之后m0就和其他m一样了。</p><p><img src="/images/go_core_programming/Untitled%2050.png" alt="Untitled"></p><h1 id="第-7-章-语言陷阱"><a href="#第-7-章-语言陷阱" class="headerlink" title="第 7 章 语言陷阱"></a>第 7 章 语言陷阱</h1><h2 id="7-1-多值赋值和短变量声明"><a href="#7-1-多值赋值和短变量声明" class="headerlink" title="7.1 多值赋值和短变量声明"></a>7.1 多值赋值和短变量声明</h2><h3 id="7-1-1-多值赋值"><a href="#7-1-1-多值赋值" class="headerlink" title="7.1.1 多值赋值"></a>7.1.1 多值赋值</h3><p>非法：</p><p><img src="/images/go_core_programming/Untitled%2051.png" alt="Untitled"></p><p>多值赋值语义：</p><ul><li>对左侧操作数中的表达式、索引值进行计算和确定，首先确定左侧的操作数的地址，然后对右侧的赋值表达式进行计算，如果发现右侧的表达式计算引用了左侧的变量，则创建临时变量进行值拷贝，最后完成计算</li><li>从左到右的顺序依次赋值</li></ul><p>示例：</p><pre><code class="go">import (    "fmt"    "testing")func Test(t *testing.T) {    x := []int{1, 2, 3}    i := 0    i, x[i] = 1, 2    fmt.Println(i, x) // 1 [2 2 3]    x = []int{1, 2, 3}    i = 0    x[i], i = 2, 1    fmt.Println(i, x) // 1 [2 2 3]    x = []int{1, 2, 3}    i = 0    x[i], i = 2, x[i] // set tmp=x[0],x[0]=2,i=tmp ==&gt; i=1    fmt.Println(i, x) // 1 [2 2 3]    x[0], x[0] = 1, 2    fmt.Println(x[0]) // 2}</code></pre><h3 id="7-1-2-短变量的声明和赋值"><a href="#7-1-2-短变量的声明和赋值" class="headerlink" title="7.1.2 短变量的声明和赋值"></a>7.1.2 短变量的声明和赋值</h3><p>约定：</p><ul><li>使用“:=”操作符，变量的定义和初始化同时完成</li><li>变量名后不要跟任何类型名，Go编译器完全靠右边的值进行推导</li><li>支持多值短变量声明赋值</li><li>只能用在函数和类型方法的内部</li></ul><p><img src="/images/go_core_programming/Untitled%2052.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2053.png" alt="Untitled"></p><h2 id="7-2-range复用临时变量"><a href="#7-2-range复用临时变量" class="headerlink" title="7.2 range复用临时变量"></a>7.2 range复用临时变量</h2><p><img src="/images/go_core_programming/Untitled%2054.png" alt="Untitled"></p><p>结果打印的都是9，原因：</p><ul><li>for range下的迭代变量i的值是共用的</li><li>main函数所在的goiroutinue和后续启动的goroutines存在竞争关系</li></ul><p>正确写法：</p><p><img src="/images/go_core_programming/Untitled%2055.png" alt="Untitled"></p><h2 id="7-3-defer陷阱"><a href="#7-3-defer陷阱" class="headerlink" title="7.3 defer陷阱"></a>7.3 defer陷阱</h2><p>对带defer的函数返回整体上有三个步骤</p><ul><li>执行return的值拷贝，将return语句返回的值复制到函数返回值栈区（如果只有一个return，不带任何变量或值，则此步骤不做任何动作）</li><li>执行defer语句，多个defer按照FILO顺序执行</li><li>执行调整RET指令</li></ul><h2 id="7-4-切片困惑"><a href="#7-4-切片困惑" class="headerlink" title="7.4 切片困惑"></a>7.4 切片困惑</h2><h3 id="7-4-1-数组"><a href="#7-4-1-数组" class="headerlink" title="7.4.1 数组"></a>7.4.1 数组</h3><p>Go的数组是有固定个相同类型元素的数据结构，底层采用连续的内存空间存放，数组一旦声明后大小就不可改变了。</p><p>Go中的数组是一种基本类型。数组的类型不仅包括其元素类型，也包括其大小，[2]int和[5]int是两个完全不同的数组类型</p><p><img src="/images/go_core_programming/Untitled%2056.png" alt="Untitled"></p><p>数组名无论作为函数实参还是作为struct嵌入字段，或者数组之间的直接赋值都是值拷贝</p><h3 id="7-4-2-切片"><a href="#7-4-2-切片" class="headerlink" title="7.4.2 切片"></a>7.4.2 切片</h3><p><strong>切片创建</strong></p><ol><li>通过数组创建</li></ol><p>array[b:e]创建一个包括e-b个元素的切片，包含b，不包含e</p><ol><li>make</li></ol><p>make([]T, len, cap)中的T是切片元素类型，len是长度，cap是底层数组的容量。cap是可选参数</p><ol><li>直接声明</li></ol><p><img src="/images/go_core_programming/Untitled%2057.png" alt="Untitled"></p><p>切片数据结构</p><p><img src="/images/go_core_programming/Untitled%2058.png" alt="Untitled"></p><p>多个切片共享一个底层数组，其中一个切片的append操作可能引发如下两种情况：</p><ul><li>append追加的元素没有超过底层数组的容量，此种append操作会直接操作共享的底层数组，如果其他切片有引用数组被覆盖的原色，则会导致其他切片的值也会隐式地发生变化</li><li>append追加的元素加上原来的元素如果超出底层数组的容量，则此种append操作会重新申请新数组，并将原来数组的值复制到新数组</li></ul><p>由于有这种二义性，所以在使用切片过程中应该尽量避免多个切面共享底层数组，可以使用copy进行显式的复制</p><h2 id="7-5-值、指针和引用"><a href="#7-5-值、指针和引用" class="headerlink" title="7.5 值、指针和引用"></a>7.5 值、指针和引用</h2><h3 id="7-5-1-传值还是传引用"><a href="#7-5-1-传值还是传引用" class="headerlink" title="7.5.1 传值还是传引用"></a>7.5.1 传值还是传引用</h3><p>Go只有一种参数传递规则：值拷贝，含义：</p><ul><li>函数参数传递时使用的是值拷贝</li><li>实例赋值给接口变量，接口对实例的引用是值拷贝</li></ul><p>有时在明明是值拷贝的地方结果却修改了变量的内容，有以下两种情况：</p><ul><li>直接传递的是指针，指针传递同样是值拷贝，但指针和指针副本的值指向的地址是同一地方，所以能修改实参值</li><li>参数是负荷数据类型，这些复合数据类型内部有指针类型的元素，此时参数的值bi拷贝并不影响指针的指向</li></ul><h3 id="7-5-2-函数名的意义"><a href="#7-5-2-函数名的意义" class="headerlink" title="7.5.2 函数名的意义"></a>7.5.2 函数名的意义</h3><ul><li>类型信息</li><li>函数的执行代码的起始位置</li><li>可以通过函数名进行函数调用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文工具</title>
      <link href="/2022/01/12/other/%E8%AE%BA%E6%96%87%E5%B7%A5%E5%85%B7/"/>
      <url>/2022/01/12/other/%E8%AE%BA%E6%96%87%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="论文下载"><a href="#论文下载" class="headerlink" title="论文下载"></a>论文下载</h2><ol><li><a href="https://www.scidown.cn/">scidown</a></li><li><a href="https://doi.qqsci.com/">企鹅论文</a></li><li><a href="https://tool.yovisun.com/scihub/">sci-hub</a></li><li><a href="http://www.5638.org/">科研宝库</a></li></ol><h1 id="论文翻译"><a href="#论文翻译" class="headerlink" title="论文翻译"></a>论文翻译</h1><ol><li><a href="https://www.onlinedoctranslator.com/">DocTranslator</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共识算法</title>
      <link href="/2022/01/08/blockchain/consensus/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/08/blockchain/consensus/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ol><li>拜占庭将军问题概述</li><li>共识算法定义(作用)</li><li>共识算法种类</li><li>共识算法优缺点对比以及应用</li></ol><h1 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h1><p>莱斯利·兰波特在其论文中描述了如下问题：</p><blockquote><p>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</p></blockquote><p>系统的问题在于，可能将军中出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。</p><p>上述的故事映射到计算机系统里便是：</p><p>在分布式系统中存在恶意的计算机节点，这些节点会选择性响应某些请求或篡改系统中的数据。 那么<font color="red">在上述不可靠的信道上，系统中所有非恶意节点如何通过消息传递达成共识？</font></p><h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><h2 id="定义-作用"><a href="#定义-作用" class="headerlink" title="定义(作用)"></a>定义(作用)</h2><p>共识算法<font color="red">使高度分散且彼此不信任的网络环境中的节点就某个事务达成一致且不分叉</font></p><p>按拜占庭容错性分类：</p><ol><li><p>容忍非拜占庭错误（CTF）：容忍网络环境中存在故障节点但不存在恶意节点</p></li><li><p>容忍拜占庭错误（BFT）：容忍网络环境中同时存在故障节点和恶意节点</p></li></ol><h2 id="算法需满足的条件"><a href="#算法需满足的条件" class="headerlink" title="算法需满足的条件"></a>算法需满足的条件</h2><p>FLP不可能问题：在异步网络中，哪怕只有一个节点故障也不可能存在能够容忍节点故障的一致性算法。</p><p>需满足的约束条件：</p><ol><li><strong>消息安全</strong>：节点件必须采用非对称加密对消息进行签名保证消息可传递（不可用对称加密，因为信道不安全）</li><li><strong>处理FLP不可能问题</strong>：设置消息最大时延</li><li><strong>共识结论合法</strong>：结论必须是一个节点的提案</li></ol><h2 id="算法详情"><a href="#算法详情" class="headerlink" title="算法详情"></a>算法详情</h2><h3 id="Paxos（CTF）"><a href="#Paxos（CTF）" class="headerlink" title="Paxos（CTF）"></a>Paxos（CTF）</h3><ol><li><p>概念</p><p>Paxos原理基于<font color="red">“两阶段提交”</font>算法并进行泛化和扩展，通过消息传递来逐步消除系统中的不确定状态，是Raft、ZAB设计的基础</p><p>Paxos角色：</p><ul><li><strong>提案者（Proposer）</strong>：提出一个提案等待大家批准为结案（value）</li><li><strong>接受者（Acceptor）</strong>：对提案进行投票，接受提案</li><li><strong>学习者（Learner）</strong>：获取批准结果，不参与投票</li></ul></li><li><p>共识过程</p><p><img src="/images/consensus/paxos_flow_chart.png" alt="img.png"><br>pok：收到提议请求； aok：收到提交请求；最大提案编号：MaxN；AcceptN：接收到的提案编号； AcceptV：接收到的提案值；</p></li><li><p>举例说明 假设集群中有2个Proposer、3个Acceptor、1个Learner</p><ul><li>有两个Proposer，两个都提出 prepare request。来自 Proposer A的 request 先于Proposer B 的 request 到达 Acceptor X和 Acceptor Y， 但来自Proposer B的 request 首先到达 Proposer Z.<br><img src="/images/consensus/paxos_prepare1.png" alt="img.png"></li><li>如果接收（accept）prepare request 的 Acceptor 之前没有看到其他的提议，则 Acceptor 以 prepare response 作出响应， 该 prepare response承诺永远不接受具有较低提议编号的另一提议。<br><img src="/images/consensus/paxos_prepare2.png" alt="img.png"></li><li>Acceptor Z收到了 Proposer A 的 request ，Acceptor X和 Acceptor Y收到了 Proposer B的 request 。 如果 Proposer 之前已经看到具有更高提议号的request ，则忽略晚到的 request，如Acceptor Z将忽略 Proposer A的 request（因为2&lt;4）。 如果 Proposer 之前没有看到更高编号的 request，它再次承诺忽略具有较低提议编号的任何请求，并发回其已接受的编号最高的提议以及该提议的值。 如 Acceptor X和Y 对Proposer B的 request 的做法。<br><img src="/images/consensus/paxos_prepare3.png" alt="img.png"></li><li>一旦 Proposer 收到大多数 Acceptor 的准备响应，它就可以发出接受请求<ul><li>对于Proposer A：由于 Proposer A仅收到表明没有先前提案的答复， 因此它向每个具有与其初始提案相同的提议编号和值的 Acceptor 发送 accept request（n = 2，v = 8）。然而，这些 request 都将被忽略，因为目标 Acceptor 都承诺不接受的提议编号低于4 的 request（这是对 Proposer B 的承诺）</li><li>对于Proposer B：Proposer B 向每个 Acceptor 发送 accept request ， 该 request 包含先前使用的提议号（n = 4）以及与其接收的准备响应消息中的最高提议号相关联的值（v = 8）。 请注意，这不是 Proposer B 最初提出的值，而是它看到的 prepare response 消息中的最高值。<br><img src="/images/consensus/paxos_accept1.png" alt="img.png"></li></ul></li><li>如果 Acceptor accept 的 accept request 的 编号 比其已经看到的更高或相等，则它会 accept 并向每个 Learner 节点发送通知。 当 Learner 发现大多数 Acceptor已接受某个值时，Paxos算法会选择该值<br><img src="/images/consensus/paxos_sync1.png" alt="img.png"></li><li>一旦Paxos选择了一个值，与其他 Proposer 的进一步沟通就无法改变这个值。 如果另一个 Proposer（如 Proposer C）发送的 request 的 提案号比之前看到的提案号更高，并且具有不同的值（例如，n= 6，v = 7）， 则每个接受者都会使用之前的最高提案进行响应（n = 4，v = 8）。这要求提议者C发送包含[n = 6，v = 8] 的接受请求，该请求仅确认已经选择的值。此外，如果一些少数接受者还没有选择一个价值，这个过程可以确保他们最终就同一价值达成共识。 （批注，这个过程总是成立的，具体论证过程见上）</li></ul></li></ol><h3 id="Raft（CTF）"><a href="#Raft（CTF）" class="headerlink" title="Raft（CTF）"></a>Raft（CTF）</h3><ol><li><p>概念</p><p>Raft相比Paxos是一种旨在<font color="red">易于理解</font>的共识算法。</p><p>Raft角色：</p><ul><li><strong>领导者（Leader）</strong></li><li><strong>候选领导者（Candidate）</strong></li><li><strong>跟随者（Follower）</strong></li></ul></li><li><p>共识过程</p><p><a href="http://www.kailing.pub/raft/index.html">Raft演示地址</a></p><p>主要阶段：</p><ul><li><strong>Leader选举</strong></li><li><strong>同步日志</strong></li></ul></li></ol><h3 id="PoW（BFT）"><a href="#PoW（BFT）" class="headerlink" title="PoW（BFT）"></a>PoW（BFT）</h3><ol><li><p>概念</p><p>POW <font color="red">工作量证明共识机制</font>，系统通过让所有节点公平地去计算一个随机数，最先寻找到随机数的节点即拥有记账权</p></li><li><p>比特币共识过程</p><ul><li>客户端发起交易广播到网络中等待确认</li><li>网络中的用户将所有等待确认的交易打包到一个区块链中</li><li><strong>不断修改区块头中的Nonce值以使该区块头的hash值小于一个特定的目标值</strong></li><li>计算出Nonce后向全网广播</li><li>网络中收到提案区块的节点对Nonce进行验证，验证合法交易被确认，该块加入链</li></ul></li></ol><h3 id="PoS（BFT）"><a href="#PoS（BFT）" class="headerlink" title="PoS（BFT）"></a>PoS（BFT）</h3><p>权益证明机制，是为解决PoW算法大量浪费资源问题而提出的一种替代算法，该算法中区块的记账权<font color="red">由权益最高的节点获得</font></p><h3 id="DPoS（BFT）"><a href="#DPoS（BFT）" class="headerlink" title="DPoS（BFT）"></a>DPoS（BFT）</h3><ol><li><p>概念</p><p>股份授权证明机制，是PoS的一种衍生算法，算法的思想是<font color="red">系统中持有权益的节点投票选举出一部分代表，再由这些代表轮流获取区块链记账权</font>，类似于股份制公司的“董事会”</p></li><li><p>共识过程</p><ul><li>每个节点将自己持有的权益转换为选票投给自己信任的节点</li><li>选票最多的N个节点当选为见证人（Witness），即代表</li><li>见证人在一个规定时间内随机排列并轮流对交易打包，生成新区块连接到最长链，见证人收获m％的交易手续费</li></ul></li></ol><h3 id="PBFT（BFT）"><a href="#PBFT（BFT）" class="headerlink" title="PBFT（BFT）"></a>PBFT（BFT）</h3><ol><li><p>概念</p><p><font color="red">PBFT在保证可用性和安全性的前提下，提供了(n-1)/3的容错性</font>，意思就是如果系统内有n个节点，那么系统最多能容忍的作恶/故障节点为(n-1)/3个。（作恶节点可以不响应或者回应错误的信息）</p></li><li><p>共识过程</p><p>​    <img src="/images/consensus/pbft_flow_chart.png" alt="共识算法系列：PBFT算法关键点综述、优缺点总结"></p><p>定义：</p><ul><li><p>f：恶意节点</p></li><li><p>Digest(m)：消息摘要</p></li></ul><p>过程：</p><ul><li><strong>预准备阶段</strong>：发送原本的消息m，让每个节点都获取原始消息</li><li><strong>准备阶段</strong>：用Digest(m)去发送，如果一个节点收到<strong>2f+1</strong>个prepare消息，就认为准备阶段结束，说明已经有大部分节点认同了这个m</li><li><strong>提交阶段</strong>：用Digest(m)去发送，如果一个节点收到<strong>2f+1</strong>个commit，那么就可以认为，就说明已经有大多数节点“执行”了这些m，这个阶段主要是为了View Change服务</li><li><strong>回执阶段</strong>：提交结束后将结果返回给客户端，客户端收到至少<strong>f+1</strong>个消息即可确认</li></ul></li></ol><h3 id="DBFT（BFT）"><a href="#DBFT（BFT）" class="headerlink" title="DBFT（BFT）"></a>DBFT（BFT）</h3><ol><li><p>概念</p><p>授权拜占庭容错，系统中的代币持有者<font color="red">通过投票选举出自己所支持的共识节点，这些选出来的共识节点再通过BFT来达成共识并生成区块</font></p></li><li><p>共识过程</p><p><img src="/images/consensus/dbft_flow_chart.png" alt="image-20220108234438067"></p><p>过程：</p><ul><li>节点<strong>投票</strong>选出一定数量的共识节点</li><li>议长设置视图并广播提案<code>&lt;PrepareRequest&gt;</code>消息</li><li>议员收到提案对其验证，验证通过后议员向全网发送<code>&lt;PrepareResponse&gt;</code>消息</li><li>当收到n-f条<code>&lt;PrepareResponse&gt;</code>消息时，议员们发布一个新的区块，对区块签名，发送给其他节点进行同步<code>&lt;Synchronization&gt;</code></li><li>其他节点收到完整区块后达到相同的区块高度，清除本地内存中所存储的当前视图交易数据，准备下一次共识</li></ul></li></ol><h2 id="算法优缺点与应用"><a href="#算法优缺点与应用" class="headerlink" title="算法优缺点与应用"></a>算法优缺点与应用</h2><table><thead><tr><th>算法</th><th>优点</th><th>缺点</th><th>应用</th></tr></thead><tbody><tr><td>Paxos</td><td>- 容忍非拜占庭错误节点能力高<br>- 性能高</td><td>- 算法难以理解<br>- 不能容忍拜占庭错误节点</td><td>ZooKeeper、GoogleChubby</td></tr><tr><td>Raft</td><td>- 算法容忍非拜占庭错误节点能力高<br>- 性能高<br>- 易于理解和实现</td><td>- 不能容忍拜占庭错误节点</td><td>IPFS Private Cluster、R3 CodaQuorum</td></tr><tr><td>Pow</td><td>- 算法逻辑简单<br>- 安全性高<br>- 容错性高</td><td>- 资源消耗过高<br>- 系统吞吐量低</td><td>Bitcoin、Ethereum、Dogcoin、Litecoin、Zcash</td></tr><tr><td>PoS</td><td>- 缓解PoW资源浪费问题<br>- 相对PoW提高了出块速度</td><td>- 易出现持币人屯币现象，造成寡头优势</td><td>Blackcoin、ADA、Peercoin、Casper、Nxt</td></tr><tr><td>DPoS</td><td>- 解决了PoW资源浪费问题<br>- 性能较高<br>- 出块速度较快</td><td>- 相比其他算法该算法趋于中心化<br>- 投票无门槛，权益余额大票数越大，易造成联合选举行为</td><td>EOS、Bitshares、Steemit、Lisk、Ark、GXChain、ASCH</td></tr><tr><td>PBFT</td><td>- 无代币<br>- 性能效率高<br>- 安全性高</td><td>- 确认流程过多，通信开销大<br>- 无法避免恶意节点担任主节点<br>- 节点不可进行动态增删<br>- 无法承受大规模节点</td><td>Fabric</td></tr><tr><td>DBFT</td><td>- 借鉴DPoS，参与共识节点数量较少，因此提高了性能</td><td>- 相比其他算法该算法趋于中心化</td><td>NEO</td></tr></tbody></table><h1 id="引发思考"><a href="#引发思考" class="headerlink" title="引发思考"></a>引发思考</h1><ol><li><p>PBFT在节点数超过100后性能继续下降，如何缓解？</p><ul><li><p>方法一：带宽优化：</p><ul><li>客户端将请求发给任意节点，而不是只发给主节点，然后节点直接将请求广播给所有节点</li><li>设计共享交易池，预先进行交易的广播，仅共识交易哈希值主节点打包交易hash，广播包含hash的提案消息，而不是广播交易数据</li><li>从节点在提交之前主动向主节点获取可能缺失的交易，最终提交之前确认交易合法性</li></ul><p><img src="/images/consensus/pbft_bandwidth_optimization.png" alt="image-20220109102820146"></p></li><li><p>方法二：BFT问题转换成CFT问题，即规避拜占庭行为</p><p><img src="/images/consensus/fast_bft_flow_chart.png" alt="image-20220109104150146"></p></li><li><p>方法三：点对点网络转换为星型网络</p><p><img src="/images/consensus/hot_stuff_flow_chart.png" alt="image-20220109104400275"></p></li></ul></li><li><p>PBFT无法动态增删节点，如何解决？</p><p>先请求分布式CA，再通过配置交易的方式，准入与删除共识节点</p><p><img src="/images/consensus/pbft_add_delete_node.png" alt="image-20220109103818671"></p></li><li><p>PBFT中prepare和commit阶段为何都要2f+1个节点反馈确认?（这2f+1节点反馈的结果并不一定是相同的）</p><p>对于prepare和commit来说，节点需要在2f+1个状态复制机的沟通内就要做出决定，这是刚好可以保证一致性的，考虑最坏的情况：我们假设收到的有f个是正常节点发过来的，也有f个是恶意节点发过来的，那么，第2f+1个只可能是正常节点发过来的。（因为我们限制了最多只有f个恶意节点）由此可知，“大多数”正常的节点还是可以让系统工作下去的。所以2f+1这个参数和n&gt;3f+1的要求是逻辑自洽的。</p></li><li><p>PBFT中client为何只需要f+1个相同的回复就可确认？</p><p>之前我们说，prepare和commit阶段为何都要2f+1个节点反馈，才能确认。client只需要f+1个相同的reply就可以了呢？我们还是来考虑最坏的情况，我们假设这f+1个相同的reply中，有f个都是恶意节点。</p><p>所以至少有一个rely是正常节点发出来的，因为在prepare阶段，这个正常的节点已经可以保证prepared(m,v,n,i)为真，所以已经能代表大多数的意见，所以，client只需要f+1个相同的reply就能保证他拿到的是整个系统内“大多数正常节点“的意见，从而达到一致性。</p></li><li><p>PBFT中如果primary是恶意节点呢？</p><p>对于一致性，我们可以这么看：如果prepared(m，v，n，i)为真，那么prepared(m’，v，n，j)一定是错误的，因为对于同一个提案我们不可能有两种结果，从而保证整个系统的一致性。</p><p>假设primary节点是恶意的，那么意味着在replicas节点中⾄多有f-1个恶意的节点，prepared(m，v，n，i)为真，则证明有f+1个善意节点达成了了⼀致，prepared(m’，v，n，j)为真，意味着另外f+1个善意节点达成了一致，因为系统中只有2f+1个善意节点，因此最少有⼀个善意节点发送了两个冲突的prepare消息，这是不可能的。所以prepared(m，v，n，i)为真，那么prepared(m’，v，n，j)是错误的。</p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://b23.tv/c2IGPiA">李永乐老师讲解拜占庭将军问题</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">维基百科对拜占庭将军问题的解释</a></li><li><a href="https://blog.csdn.net/alinyua/article/details/86153013">Paxos学习笔记及图解</a></li><li><a href="https://pmg.csail.mit.edu/papers/osdi99.pdf">PBFT提出者论文《Practical Byzantine Fault Tolerance》</a></li><li><a href="https://zhuanlan.zhihu.com/p/53897982">共识算法系列：PBFT算法关键点综述、优缺点总结</a></li><li><a href="http://www.jsjkx.com/CN/article/openArticlePDF.jsp?id=19169">区块链共识算法对比研究</a></li><li><a href="https://www.modb.pro/doc/42136">联盟区块链共识算法的实践与挑战 - 端豪 杭州趣链科技架构师</a></li><li><a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf">Paxos论文</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 共识算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric区块链应用开发</title>
      <link href="/2021/10/26/blockchain/fabric/%E7%AC%AC13%E7%AB%A0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2021/10/26/blockchain/fabric/%E7%AC%AC13%E7%AB%A0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Fabric区块链应用开发"><a href="#Fabric区块链应用开发" class="headerlink" title="Fabric区块链应用开发"></a>Fabric区块链应用开发</h1><h2 id="13-1-简介"><a href="#13-1-简介" class="headerlink" title="13.1 简介"></a>13.1 简介</h2><p>智能合约是无状态的、事件驱动的代码</p><h3 id="1-智能合约开发"><a href="#1-智能合约开发" class="headerlink" title="1. 智能合约开发"></a>1. 智能合约开发</h3><p>智能合约代码本质上是为了对上层业务逻辑进行支持</p><p>需要开发者具备的能力：</p><ul><li>了解所选用区块链平台的智能合约结构、语言特性、状态存储方式等知识</li><li>对智能合约的生命周期管理进行考虑，包括代码编写、版本管理、提交验证以及升级版本</li></ul><h3 id="2-应用程序开发"><a href="#2-应用程序开发" class="headerlink" title="2. 应用程序开发"></a>2. 应用程序开发</h3><p>应用程序通过调用智能合约提供的方法接口来实现业务逻辑。可以运行在区块链的网络节点上，也可以运行在中心化的服务器上。</p><p>需要开发者具备的能力：</p><ul><li>掌握至少一种应用程序开发语言</li><li>熟练使用智能合约SDK</li></ul><h2 id="13-2-链码的原理、接口与结构"><a href="#13-2-链码的原理、接口与结构" class="headerlink" title="13.2 链码的原理、接口与结构"></a>13.2 链码的原理、接口与结构</h2><p>链码职责：</p><ul><li>对Fabric应用程序发送的交易做出响应，执行代码逻辑，与账本进行交互</li><li>创建一些状态（state）并写入账本</li></ul><p>链码与节点的交互使用gRPC协议</p><h3 id="13-2-1-Chaincode接口"><a href="#13-2-1-Chaincode接口" class="headerlink" title="13.2.1 Chaincode接口"></a>13.2.1 Chaincode接口</h3><pre><code class="go">// Chaincode interface must be implemented by all chaincodes. The fabric runs// the transactions by calling these functions as specified.type Chaincode interface {    // Init is called during Instantiate transaction after the chaincode container    // has been established for the first time, allowing the chaincode to    // initialize its internal data    // 当链码收到实例化的交易时，Init方法会被调用（Fabric1.4版本）    Init(stub ChaincodeStubInterface) pb.Response    // Invoke is called to update or query the ledger in a proposal transaction.    // Updated state variables are not committed to the ledger until the    // transaction is committed.    // 当链码收到升级或查询类型的交易时，Invoke方法会被调用（Fabric1.4版本）    Invoke(stub ChaincodeStubInterface) pb.Response}</code></pre><h3 id="13-2-2-链码结构"><a href="#13-2-2-链码结构" class="headerlink" title="13.2.2 链码结构"></a>13.2.2 链码结构</h3><pre><code class="go">package main// 引入必要的包import (    "fmt"    // shim包提供了链码与账本交互的中间层。链码通过shim.ChaincodeStubInterface提供的方法来读取和修改账本状态    "github.com/hyperledger/fabric/core/chaincode/shim"    // Init和Invoke方法需要返回pb.Response类型    pb "github.com/hyperledger/fabric/protos/peer")// 声明一个结构体type SimpleChaincode struct {}// 为结构体添加Init方法func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {    // 该方法用来完成一些初始化的工作    return shim.Success(nil)}// 为结构体添加Invoke方法func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {    // 响应调用或查询的业务逻辑在该方法中实现    return shim.Success(nil)}// 主函数，需要调用shim.Start()方法func main() {    err := shim.Start(new(SimpleChaincode))    if err != nil {        fmt.Printf("Error starting Simple chaincode: %s", err)    }}</code></pre><h3 id="13-2-3-链码基本工作原理"><a href="#13-2-3-链码基本工作原理" class="headerlink" title="13.2.3 链码基本工作原理"></a>13.2.3 链码基本工作原理</h3><p><img src="https://img-blog.csdnimg.cn/2e6b5bf1c26e4f8396154f82fcbe29fe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>步骤：</p><ul><li>用户通过客户端（SDK或CLI）向Fabric的背书节点（endorser）发出调用链码的交易提案（proposal）。节点对提案进行包括ACL权限检查在内的各种检验，通过后则创建模拟执行这一交易的环境</li><li>节点和链码容器之间通过gRPC消息来交互，模拟执行交易并给出背书结论</li></ul><h2 id="13-3-链码开发API"><a href="#13-3-链码开发API" class="headerlink" title="13.3 链码开发API"></a>13.3 链码开发API</h2><h3 id="13-3-1-账本状态交互API"><a href="#13-3-1-账本状态交互API" class="headerlink" title="13.3.1 账本状态交互API"></a>13.3.1 账本状态交互API</h3><p><img src="https://img-blog.csdnimg.cn/edd578638df647ce87034b4e1ae34133.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="13-3-2-交易信息相关API"><a href="#13-3-2-交易信息相关API" class="headerlink" title="13.3.2 交易信息相关API"></a>13.3.2 交易信息相关API</h3><p><img src="https://img-blog.csdnimg.cn/53fea4951f7f457d8f9175cc3935a3cc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="13-3-3-参数读取API"><a href="#13-3-3-参数读取API" class="headerlink" title="13.3.3 参数读取API"></a>13.3.3 参数读取API</h3><p><img src="https://img-blog.csdnimg.cn/e8c5d6e04792454dbeec1f4c3039cac7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="13-3-4-其他API"><a href="#13-3-4-其他API" class="headerlink" title="13.3.4 其他API"></a>13.3.4 其他API</h3><p><img src="https://img-blog.csdnimg.cn/dde665b33019483ba78615f5f0ec9b37.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="13-4-应用开发案例一：转账"><a href="#13-4-应用开发案例一：转账" class="headerlink" title="13.4 应用开发案例一：转账"></a>13.4 应用开发案例一：转账</h2><p>目标：</p><ul><li>掌握智能合约的基本结构</li><li>掌握查询账本、修改账本、删除账本的方法</li></ul><p><a href="https://gitee.com/hbuzzs/fabric-chaincode-example/blob/master/chaincode/src/github.com/1.chaincode_example02/chaincode_example02.go">查看代码</a></p><h2 id="13-5-应用开发案例二：资产权属管理"><a href="#13-5-应用开发案例二：资产权属管理" class="headerlink" title="13.5 应用开发案例二：资产权属管理"></a>13.5 应用开发案例二：资产权属管理</h2><p>目标：</p><ul><li>掌握资产的创建、查询、转移所有权等操作</li></ul><p><a href="https://gitee.com/hbuzzs/fabric-chaincode-example/blob/master/chaincode/src/github.com/2.marbles02/marbles_chaincode.go">查看代码</a></p><h2 id="13-6-应用开发案例三：调用其他链码"><a href="#13-6-应用开发案例三：调用其他链码" class="headerlink" title="13.6 应用开发案例三：调用其他链码"></a>13.6 应用开发案例三：调用其他链码</h2><p>目标：</p><ul><li>掌握如何调用其他链码<br><a href="https://gitee.com/hbuzzs/fabric-chaincode-example/blob/master/chaincode/src/github.com/3.passthru/passthru.go">查看代码</a></li></ul><h2 id="13-7-应用开发案例四：发送事件"><a href="#13-7-应用开发案例四：发送事件" class="headerlink" title="13.7 应用开发案例四：发送事件"></a>13.7 应用开发案例四：发送事件</h2><p>目标：</p><ul><li>掌握如何发送事件</li></ul><p><a href="https://gitee.com/hbuzzs/fabric-chaincode-example/blob/master/chaincode/src/github.com/4.eventsender/eventsender.go">查看代码</a></p><h2 id="13-8-开发最佳实践小结"><a href="#13-8-开发最佳实践小结" class="headerlink" title="13.8 开发最佳实践小结"></a>13.8 开发最佳实践小结</h2><ol><li>重视资源限制</li><li>无状态设计</li><li>避免非确定性逻辑</li><li>链码结构设计</li><li>链码生命周期的管理</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《区块链原理、设计与应用-杨保华、陈昌》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric CA应用与配置</title>
      <link href="/2021/10/18/blockchain/fabric/%E7%AC%AC11%E7%AB%A0-Fabric-CA%E5%BA%94%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/10/18/blockchain/fabric/%E7%AC%AC11%E7%AB%A0-Fabric-CA%E5%BA%94%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Fabric-CA应用与配置"><a href="#Fabric-CA应用与配置" class="headerlink" title="Fabric CA应用与配置"></a>Fabric CA应用与配置</h1><h2 id="11-1-简介"><a href="#11-1-简介" class="headerlink" title="11.1 简介"></a>11.1 简介</h2><ol><li>Fabric CA项目主要功能：</li></ol><ul><li>负责Fabric网络内所有实体的身份管理，包括身份的注册、注销等</li><li>负责证书管理，包括ECerts（身份证书）、TCerts（交易证书）等的发放和注销</li><li>服务端支持基于客户端命令行和RESTful API的交互方式</li></ul><ol start="2"><li>基本组件<br>采用典型的CS架构，目前包含两个基本组件：</li></ol><ul><li>服务端：fabric-ca-server实现核心的PKI服务功能，支持多种数据库后台（包括MySQL、PostgreSQL等），并支持集成LDAP作为用户注册管理功能</li><li>客户端（Client）：fabric-ca-client封装了服务端的RESTful API，提供访问服务端的命令，供用户与服务端进行交互</li></ul><h2 id="11-2-安装服务端和客户端"><a href="#11-2-安装服务端和客户端" class="headerlink" title="11.2 安装服务端和客户端"></a>11.2 安装服务端和客户端</h2><h3 id="11-2-1-本地编译"><a href="#11-2-1-本地编译" class="headerlink" title="11.2.1 本地编译"></a>11.2.1 本地编译</h3><ol><li>配置编译环境<br>基本依赖：</li></ol><ul><li>Golang 1.7+，并配置GOPATH环境变量</li><li>libtool和libltdl-dev依赖库</li></ul><ol start="2"><li>编译二进制文件</li></ol><h3 id="11-2-2-获取和使用Docker镜像（推荐）"><a href="#11-2-2-获取和使用Docker镜像（推荐）" class="headerlink" title="11.2.2 获取和使用Docker镜像（推荐）"></a>11.2.2 获取和使用Docker镜像（推荐）</h3><pre><code class="shell">docker pull hyperledger/fabric-ca：1.4.0</code></pre><p>快速进入容器，采用默认配置快速初始化并启动服务：</p><pre><code class="shell">docker run -it hyperledger/fabric-cafabric-ca-server init -b admin:adminpw</code></pre><ol><li>挂载本地配置文件<pre><code class="shell">docker run -it -v LOCAL_PATH:/etc/hyperledger/fabric-ca-server hyperledger/fabric-ca bash</code></pre></li><li>暴露RESTful服务<br>为了让其他物理机能访问到容器内的服务，可以将该端口映射到本地宿主机<br>例如下面命令将本地的7054端口与容器端口映射关联，之后其他物理机可以通过访问本地宿主机的7054端口来访问容器内服务：<pre><code class="shell">docker run -it -v LOCAL_PATH:/etc/hyperledger/fabric-ca-server -p 7054:7054 hyperledger/fabric-ca bash</code></pre></li></ol><h2 id="11-3-启动CA服务"><a href="#11-3-启动CA服务" class="headerlink" title="11.3 启动CA服务"></a>11.3 启动CA服务</h2><ol><li>配置读取<br>fabric-ca-server服务所需要的相关配置项会依次尝试从命令行参数、环境变量（命名需要带有<code>FABIRIC_CA_SERVER</code>前缀）或主配置目录（未指定配置文件路径时）下本地配置文件来读取。<br>例如指定启用TLS可以通过如下三种方式来进行配置，优先级由高到低：</li></ol><ul><li>命令行参数：<code>--tls-enabled=true</code></li><li>环境变量：<code>FABRIC_CA_SERVER_TLS_ENABLED=true</code></li><li>配置文件：<code>tls.enabled=true</code><br>如果都未发现，则采用内置的默认值（false）</li></ul><ol start="2"><li>主配置目录<br>本地配置文件默认都是从所谓主配置目录（Home Dir）下进行查找，还可以预置证书和密钥文件<br>主配置目录的具体路径获取规则：依此从环境变量<code>FABRIC_CA_SERVER_HOME</code>、<code>FABRIC_CA_HOME</code>、<code>CA_CFG_PATH</code>等中读取。一般推荐使用默认的<code>/etc/hyperledger/fabric-ca-server</code>路径作为主配置目录环境变量的指向路径，用户也可以根据需求自行设定。</li><li>初始化fabric-ca-server<br>首次使用fabric-ca-server服务的情况下，使用init命令来完成初始化<pre><code class="shell">fabric-ca-server init -b admin:adminpw</code></pre></li><li>启动fabric-ca-server<pre><code class="shell">fabric-ca-server start -b admin:adminpw</code></pre></li><li>RESTful API<br>默认的RESTful服务监听在7054地址，服务前缀为/api/v1<br>参考<a href="https://github.com/hyperledger/fabric-ca/blob/release-1.4/swagger/swagger-fabric-ca.json">swagger</a>，主要接口：</li></ol><ul><li>POST /cainfo：获取某个CA服务的基本信息，body中可带有cname信息</li><li>POST /enroll：使用用户登记功能，body中可带有host、request、profile、label、caname等信息</li><li>POST /reenroll：使用用户重新登记功能，body中可带有host、request、profile、label、caname信息</li><li>POST /register：使用用户注册功能，body中可带有id、type、secret、max_enrollments、affiliation_path、attires、caname等信息</li><li>POST /revoke：撤销某个证书，body中可带有id、aki、serial、reson、caname等信息</li><li>POST /tcert：申请获取一批交易证书，body可以带有count、arr_names、encrypy_attrs、validity_period、caname等信息</li></ul><h2 id="11-4-服务端命令剖析"><a href="#11-4-服务端命令剖析" class="headerlink" title="11.4 服务端命令剖析"></a>11.4 服务端命令剖析</h2><h3 id="11-4-1-全局命令参数"><a href="#11-4-1-全局命令参数" class="headerlink" title="11.4.1 全局命令参数"></a>11.4.1 全局命令参数</h3><ol><li><p>通用参数<br><img src="https://img-blog.csdnimg.cn/d38a58e238c74b05bffda95b4f82ca17.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a80a90a362f248bb85d771717a33edda.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>证书签名请求参数<br><img src="https://img-blog.csdnimg.cn/3028936c69b346e2a6a019110b707b06.png" alt="在这里插入图片描述"></p></li><li><p>数据库相关参数<br><img src="https://img-blog.csdnimg.cn/e92be96027a641b494192a6422585b4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>TLS相关参数<br><img src="https://img-blog.csdnimg.cn/762ade5b32084acdbf63dca432a04017.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>LDAP参数</p></li></ol><p><img src="https://img-blog.csdnimg.cn/85444b1b43624510a4cb2d2cb309f1de.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="11-4-2-init命令"><a href="#11-4-2-init命令" class="headerlink" title="11.4.2 init命令"></a>11.4.2 init命令</h3><p>fabric-ca-server init [flags]<br>初始化一个fabric-ca-server服务，主要用于生成密钥相关的证书文件以及配置文件等</p><h3 id="11-4-3-start命令"><a href="#11-4-3-start命令" class="headerlink" title="11.4.3 start命令"></a>11.4.3 start命令</h3><p>fabric-ca-server start [flags]<br>启动一个fabric-ca-server服务</p><h2 id="11-5-服务端配置文件解析"><a href="#11-5-服务端配置文件解析" class="headerlink" title="11.5 服务端配置文件解析"></a>11.5 服务端配置文件解析</h2><p>服务端配置文件最常见的路径在<code>/etc/hyperledger/fabric-ca-server/fabric-ca-server-config.yaml</code>，包括通用配置、TLS配置、CA配置、注册管理配置、数据库配置、LDAP配置、组织结构配置、签名、证书申请等几个部分</p><ol><li>通用配置<br>包括服务监听的端口号，是否输出更多的DEBUG日志等：</li></ol><ul><li>port：7054:指定服务的监听端口；</li><li>debug：false：是否启用DEBUG模式，输出更多的调试信息</li></ul><ol start="2"><li>TLS配置<br>是否在服务端启用TLS，身份验证的证书和签名的私钥。<br>客户端进行TLS认证的模式：</li></ol><ul><li>NoClientCert：不启用，默认值</li><li>RequestClientCert：请求客户端提供证书</li><li>RequireAnyClientCert：要求客户端提供合法格式的证书</li><li>VerifyClientCertIfGiven：如果客户端提供证书则进行验证</li><li>RequireAndVerfyClientCert：要求并且要验证客户端的证书<br><img src="https://img-blog.csdnimg.cn/1f825f49e6ce4934950b5f592f2d2a4c.png" alt="在这里插入图片描述"></li></ul><ol start="3"><li>CA配置<br>包括实例的名称、签名私钥文件、身份验证证书和证书链文件等。这些私钥和证书文件会用来作为生成ECert、TCert的跟证书</li></ol><p><img src="https://img-blog.csdnimg.cn/e589721894da46f98846a55600162d17.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>4. 注册管理配置<br>   当fabric-ca-server自身提供用户的注册管理时使用，这种情况下需要禁用LDAP功能，否则fabric-ca-server将会把注册管理数据转发到LDAP进行查询<br>   配置内容：</p><ul><li>对enrollment过程的用户名和密码进行验证</li><li>获取某个认证实体的用户属性信息<br><img src="https://img-blog.csdnimg.cn/1fae1c7aac014e7883509aa6f1ca1fe6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><ol start="5"><li>数据库配置</li></ol><p>数据库支持SQlite3、Postgres、MySQL，可以在本段中进行配置，默认为SQlite3类型的本地数据库。<br><img src="https://img-blog.csdnimg.cn/02546b184e374c5ebccdf1f4745f9e92.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/77cad42365984779910a8bacc78a8e10.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol start="6"><li>LDAP配置<br>配置使用远端的LDAP来进行注册管理，认证enrollment的用户名和密码，并获取用户属性信息。</li></ol><p><img src="https://img-blog.csdnimg.cn/6bd9a1e5382c47ec90ad5dd4a4de068e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>7. 组织结构配置<br>   每个组织若干部门<br>   <img src="https://img-blog.csdnimg.cn/1a00ad4dabeb487b99c4c8708f385f7f.png" alt="在这里插入图片描述"></p><ol start="8"><li><p>签发证书相关配置<br>签发证书相关的配置包括签名方法、证书超时时间等<br>fabric-ca-server可以作为用户证书的签发CA，还可以作为根CA来进一步支持其他中间CA<br><img src="https://img-blog.csdnimg.cn/d160955a705a46c5bbe7b8f04afc8b7f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>证书申请请求配置<br>CA自身证书的申请请求配置。<br>当CA作为根证书服务时，将给予请求生成一个自签名的证书；当CA作为中间证书服务时，将请求发给上层的根证书进行签署。<br><img src="https://img-blog.csdnimg.cn/1daf145fbb9c45aaac6fc7839950e659.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>BCCSP配置<br>配置所选择的加密库<br><img src="https://img-blog.csdnimg.cn/7a71d04006b04ee2abfccc343c1f1146.png" alt="在这里插入图片描述"></p></li><li><p>多CA支持配置<br>通过cacount：自动创建除了默认CA外的多个CA实例，如ca1、ca2等<br>通过cafiles：可以指定多个CA配置文件路径，每个配置文件会启动一个CA服务，注意不同配置文件之间需要避免冲突</p></li><li><p>中间层CA配置<br>当CA作为中间层CA服务时的相关配置，包括父CA的地址和名称、登记信息、TLS配置等。注意当intermediate.parentserver.url非空时，意味着本CA是中间层CA服务，否则为根CA服务。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/66edf93596874e29bf47f8d179bf25d8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_8,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="11-6-与服务端进行交互"><a href="#11-6-与服务端进行交互" class="headerlink" title="11.6 与服务端进行交互"></a>11.6 与服务端进行交互</h2><h3 id="1-配置读取"><a href="#1-配置读取" class="headerlink" title="1. 配置读取"></a>1. 配置读取</h3><p>主配置目录回一次尝试从环境变量FABRIC_CA_CLIENT_HOME、FABRIC_CA_HOME、CA_CFG_PATH中读取。一般推荐使用$HOME/.fabric-ca-client作为主目录环境变量的指向路径。用户也可以根据需求自行设定</p><h3 id="2-登记用户"><a href="#2-登记用户" class="headerlink" title="2. 登记用户"></a>2. 登记用户</h3><p>通过enroll命令可以对注册到fabric-ca-server中的尸体进行登记，获取其证书信息</p><h3 id="3-注册用户"><a href="#3-注册用户" class="headerlink" title="3. 注册用户"></a>3. 注册用户</h3><p>登记后的用户身份可以采用如下命令来注册新用户：<br><img src="https://img-blog.csdnimg.cn/7671d461d79d489dbfc385099893eda4.png" alt="在这里插入图片描述"></p><h3 id="4-登记节点"><a href="#4-登记节点" class="headerlink" title="4. 登记节点"></a>4. 登记节点</h3><p>登记Peer或Orderer节点的操作与登记用户身份类似。通过-M可以制定本地MSP的跟路径来在其下存放证书文件：<br><img src="https://img-blog.csdnimg.cn/50e9a165e55a486ca563c02f331353cd.png" alt="在这里插入图片描述"></p><h2 id="11-7-客户端命令剖析"><a href="#11-7-客户端命令剖析" class="headerlink" title="11.7 客户端命令剖析"></a>11.7 客户端命令剖析</h2><p>fabric-ca-client命令可以跟服务端进行交互，主要功能如下：</p><ul><li>enroll：登陆获取ECert</li><li>getcacert：获取CA服务的证书链</li><li>reenroll：再次登陆</li><li>register：注册用户实体</li><li>revoke：吊销签发的实体证书</li></ul><h3 id="11-7-1-全局命令参数"><a href="#11-7-1-全局命令参数" class="headerlink" title="11.7.1 全局命令参数"></a>11.7.1 全局命令参数</h3><ol><li><p>通用参数<br><img src="https://img-blog.csdnimg.cn/4eee18cbd50240e1a6470fc39b32116c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>证书签名请求参数</p></li></ol><p><img src="https://img-blog.csdnimg.cn/ab42cc36468241dba8d999a52c41c210.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol start="3"><li>登记相关参数<br><img src="https://img-blog.csdnimg.cn/b99ecbab7c174619a1f3d74bb51515be.png" alt="在这里插入图片描述"></li><li>身份实体相关参数<br><img src="https://img-blog.csdnimg.cn/8aace32f85084e83a30989546a0d80c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>吊销证书相关参数<br><img src="https://img-blog.csdnimg.cn/c200513ee89d42948556a5c8fc5e7a0c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>TLS相关参数<br><img src="https://img-blog.csdnimg.cn/0ccc5b4916714fb99d4f084a20eda7bf.png" alt="在这里插入图片描述"><h3 id="11-7-2-enroll命令"><a href="#11-7-2-enroll命令" class="headerlink" title="11.7.2 enroll命令"></a>11.7.2 enroll命令</h3></li></ol><p>命令格式为：<code>fabric-ca-client enrool -u http://user:userpw@serverAddr.serverPort</code>。该命令会向服务器申请签发ECert证书。</p><h3 id="11-7-3-getcacert命令"><a href="#11-7-3-getcacert命令" class="headerlink" title="11.7.3 getcacert命令"></a>11.7.3 getcacert命令</h3><p>想服务端申请根证书信息</p><h3 id="11-7-4-reenroll命令"><a href="#11-7-4-reenroll命令" class="headerlink" title="11.7.4 reenroll命令"></a>11.7.4 reenroll命令</h3><p>生成新的签名证书材料</p><h3 id="11-7-5-register命令"><a href="#11-7-5-register命令" class="headerlink" title="11.7.5 register命令"></a>11.7.5 register命令</h3><p>注册新的用户实体身份</p><h3 id="11-7-6-revoke命令"><a href="#11-7-6-revoke命令" class="headerlink" title="11.7.6 revoke命令"></a>11.7.6 revoke命令</h3><p>吊销指定的证书或者指定实体相关的所有的证书</p><h2 id="11-8-客户端配置文件解析"><a href="#11-8-客户端配置文件解析" class="headerlink" title="11.8 客户端配置文件解析"></a>11.8 客户端配置文件解析</h2><ol><li><p>通用配置<br><img src="https://img-blog.csdnimg.cn/6f2976a99c6d4e4797fe4d8dbee5491a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>TLS配置<br><img src="https://img-blog.csdnimg.cn/21baf3eab22447cca6581cbba1be4d8b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>证书签名申请配置<br>客户端想要申请一个ECert时，需要提供证书签名申请文件（CSR）相关的信息<br><img src="https://img-blog.csdnimg.cn/633022e95b7140f1aeacb90a901ee7af.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>注册管理配置<br><img src="https://img-blog.csdnimg.cn/3c19735238e74a97855c28e462437994.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>登记配置<br><img src="https://img-blog.csdnimg.cn/d8e0eda7b98d41bdac2fc78ac2423c13.png" alt="在这里插入图片描述"></p></li><li><p>BCCSP配置<br><img src="https://img-blog.csdnimg.cn/f1aed0c548c444899afef3cc821a28c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="11-9-生产环境部署"><a href="#11-9-生产环境部署" class="headerlink" title="11.9 生产环境部署"></a>11.9 生产环境部署</h2></li><li><p>根证书的生成<br><img src="https://img-blog.csdnimg.cn/a450542e7d5140ebb99e551c3bcacf58.png" alt="在这里插入图片描述"></p></li><li><p>分层部署结构<br>PKI推荐采用分层的结构，即不由根CA来直接签发证书，而是通过由根CA签发的中间CA甚至更下层CA来实现对服务器实体和用户证书的管理。<br><img src="https://img-blog.csdnimg.cn/e8990f51f1e34fc49822fd36bf77c765.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>TLS机制<br><img src="https://img-blog.csdnimg.cn/1953c78b88f640e2a2980dae3612bfaa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>负载均衡和高可用<br><img src="https://img-blog.csdnimg.cn/ed38164183bf471090acd45d1a50199b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/94883dcb5f964e2e90bfd221c812791e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ol><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/identity/identity.html">Fabric CA官方介绍</a></li><li>《区块链原理、设计与应用-杨保华、陈昌》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric1.0架构与设计</title>
      <link href="/2021/09/24/blockchain/fabric/%E7%AC%AC12%E7%AB%A0-Fabric1-0%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/24/blockchain/fabric/%E7%AC%AC12%E7%AB%A0-Fabric1-0%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Fabric1-0架构与设计"><a href="#Fabric1-0架构与设计" class="headerlink" title="Fabric1.0架构与设计"></a>Fabric1.0架构与设计</h1><h2 id="12-1-整理架构概览"><a href="#12-1-整理架构概览" class="headerlink" title="12.1 整理架构概览"></a>12.1 整理架构概览</h2><h3 id="12-1-1-核心特性"><a href="#12-1-1-核心特性" class="headerlink" title="12.1.1 核心特性"></a>12.1.1 核心特性</h3><ul><li>消除网络处理瓶颈，提高可扩展性：解耦了原子排序环节与其他复杂处理环节</li><li>根据负载进行灵活部署：解藕交易处理节点的逻辑角色为背书节点（Endorser）、确认节点（Commotter）</li><li>提供更多功能：加强了身份证书管理服务，作为单独的Fabric CA项目</li><li>提交隔离安全性：支持多通道特性，不同通道之间的数据彼此隔离</li><li>支持可插拔的架构，包括共识、权限管理、加解密、账本机制等模块，支持多种类型</li><li>支持可编程和第三方实现：引入系统链码来实现区块链系统的处理</li></ul><h3 id="12-1-2-整体架构"><a href="#12-1-2-整体架构" class="headerlink" title="12.1.2 整体架构"></a>12.1.2 整体架构</h3><p><img src="https://img-blog.csdnimg.cn/b05b1fe7b97344f8b0d5ee3edab23675.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_10,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="12-1-3-典型工作流程"><a href="#12-1-3-典型工作流程" class="headerlink" title="12.1.3 典型工作流程"></a>12.1.3 典型工作流程</h3><p>交易处理过程：</p><p><img src="/images/fabric/image-20220307194816235.png" alt="image-20220307194816235"></p><p>各个组件功能：</p><ol><li>客户端（APP）</li></ol><p>客户端使用SDK与Fabric网络交互。</p><p>步骤：</p><ul><li>客户端从CA获取合法的身份证书来加入网络内的应用通道</li><li>构造交易提案（Proposal）提交给Endorser进行背书</li><li>客户端收到足够（背书策略决定）的背书支持后可以利用背书构造一个合法的交易请求</li><li>发给Orderer进行排序处理</li></ul><ol start="2"><li>Endorser节点</li></ol><p>主要提供ProcessProposal方法供客户端调用，完成对焦一天的背书（目前主要是签名）处理，只有部分节点担任Endorser角色</p><p>步骤：</p><ul><li>收到客户端的交易提案</li><li>进行合法性和ACL权限检查</li><li>模拟运行交易，对交易导致的状态变化进行背书并返回结果给客户端</li></ul><ol start="3"><li>Committer节点</li></ol><p>负责维护区块链和账本结构（包括DB、历史DB、索引DB等），同一物理节点可以仅作为Committer角色运行也可以同时担任Endorser和Committer这两种角色</p><p>步骤：</p><ul><li>定期从Orderer获取排序后的批量交易区块结构，对这些交易进行落盘前的最终检查（包括交易消息结构、签名完整性、是否重复、读写集合版本是否匹配等）</li><li>将结果写入账本，同时构造新的区块、更新区块中BlockMetadata[2]记录交易是否合法等信息</li></ul><ol start="4"><li>Orderer</li></ol><p>仅负责排序。为网络中所有合法交易进行全局排序，并将一批排序后的交易组合成区块结构</p><ol start="5"><li>CA</li></ol><p>负责网络中所有证书的管理（分发、撤销等），实现标准的PKI架构</p><h2 id="12-2-核心概念与组件"><a href="#12-2-核心概念与组件" class="headerlink" title="12.2 核心概念与组件"></a>12.2 核心概念与组件</h2><p><img src="https://img-blog.csdnimg.cn/069a68e6f29a42f48f64ce967a44c933.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li>网络层</li></ol><ul><li>面向：系统管理人员</li><li>功能：实现P2P网络，提供底层构建区块链网络的基本能力，包括代表不同角色的节点和服务</li></ul><ol start="2"><li>共识机制和权限管理</li></ol><ul><li>面向：联盟和组织的管理人员</li><li>功能：基于网络层的连通，实现共识机制和权限管理，提供分布式账本的基础</li></ul><ol start="3"><li>业务层</li></ol><ul><li>面向：业务应用开发人员</li><li>功能：基于分布式账本，支持链码、交易等跟业务相关的功能模块，提供更高一层的应用开发支持</li></ul><h3 id="12-2-1-网络层相关组件"><a href="#12-2-1-网络层相关组件" class="headerlink" title="12.2.1 网络层相关组件"></a>12.2.1 网络层相关组件</h3><ol><li>节点</li></ol><ul><li>Endorser（背书节点）：负责对来自客户端的交易进行检查和背书</li><li>Committer（确认节点）：负责检查交易请求，执行交易并维护区块链和账本结构</li><li>Submitter（提交节点）：负责接收交易，转发给排序者</li></ul><ol start="2"><li>排序者</li></ol><p>排序者（Orderer）也称为排序节点，负责对所收到的交易在网络中进行全局排序</p><ol start="3"><li>客户端</li></ol><p>客户端是用户和应用跟区块链网络打交道的桥梁</p><p>功能：</p><ul><li>操作Fabric网络</li><li>操作运行在网络中的链码</li></ul><ol start="4"><li>成员身份管理</li></ol><p>CA节点（Fabric-CA）负责对Fabric网络中的成员身份进行管理</p><p>Fabric网络目前采用数字证书机制来实现对身份的鉴别和权限控制，CA节点则实现了PKI服务，主要负责对身份证书进行管理，包括生成、撤销等</p><ol start="5"><li>Gossip协议</li></ol><p>Fabric网络中的节点之间通过Gossip协议来进行状态同步和数据分发</p><p>基本思想：数据发送方从网络中随机选取若干节点，将数据发送过去；接受方重复这一过程（往往只选择发送方之外的节点进行传播）。数据传输方向可以是发送方发送或获取方拉取</p><h3 id="12-2-2-共识相关组件"><a href="#12-2-2-共识相关组件" class="headerlink" title="12.2.2 共识相关组件"></a>12.2.2 共识相关组件</h3><ol><li>背书过程</li></ol><p>背书：背书节点对收到的来自客户端的请求（交易提案）按照自身分逻辑进行金叉，一决策是否给予支持的过程</p><ol start="2"><li>排序服务</li></ol><p>排序服务通常是由排序节点组成的集群来提供</p><p>排序功能：对一段时间内的一批交易达成一个网络内全局一致的顺序</p><ol start="3"><li>验证过程</li></ol><p>验证是对排序后的一批交易进行提交到账本之前最终检查的过程</p><p>验证内容：</p><ul><li>检查交易结构自身完整性</li><li>检查交易所带背书签名是否满足预设的背书策略</li><li>交易的读写集是否满足多版本并发控制的相关要求</li><li>等</li></ul><h3 id="12-2-3-权限管理相关组件"><a href="#12-2-3-权限管理相关组件" class="headerlink" title="12.2.3 权限管理相关组件"></a>12.2.3 权限管理相关组件</h3><ol><li>成员服务提供者（Membership Service Provider，MSP）</li></ol><p>MSP：抽象代表了一个身份验证的实体，代表用于对某个资源（成员/节点/组织等）进行身份验证的一组机制，是实现权限管理的基础</p><p>基于MSP可以实现对不同资源进行基于身份证书的权限验证。通常情况下，一个组织或联盟可以对应到一个层级化的MSP</p><ol start="2"><li>组织</li></ol><p>组织代表一组拥有共同信任的根证书（可以为根CA证书或中间CA证书）的成员</p><p>组织之间可以相互交换比较敏感的内容</p><p>同一个组织的成员节点在网络中可以被认为是同一个身份，代表组织进行签名</p><p>组织中的成员可以为普通成员角色或者管理员角色，后者拥有更好的权限，可以对组织配置进行修改</p><p>组织中</p><ol start="3"><li>联盟</li></ol><p>联盟由若干组织构成的集合，是联盟联场景所独有的结构形式</p><p>联盟一般用于多个组织相互合作的场景，例如某联盟中指定需要所有参与方同时对交易背书，才允许在网络中执行执行</p><ol start="4"><li>身份证书</li></ol><p>身份证书是Fabric中权限管理的基础，采用基于ECDSA算法的非对称加密算法生成公钥和私钥，证书格式则采用了X.509标准规范</p><h3 id="12-2-4-业务层相关组件"><a href="#12-2-4-业务层相关组件" class="headerlink" title="12.2.4 业务层相关组件"></a>12.2.4 业务层相关组件</h3><ol><li>交易</li></ol><p>交易意味着通过调用链码实现对账本状态进行一次改变</p><ol start="2"><li>区块</li></ol><p>区块意味着一组进行排序后的交易的集合</p><p>区块结构包括：</p><ul><li>区块头：构建区块结构，包含Number（区块序号）、PreviousHash（前一区块头部Hash）、DataHash（本区块Data域内容的Hash值）</li><li>数据：以Envelope结构记录区块内的多个交易信息，使用Merkle树结构</li><li>元数据：记录辅助信息，包括：签名信息、通道的最新配置区块的索引、交易是否合法标记、通道的排序服务信息</li></ul><ol start="3"><li>链码<br>链码源自智能合约的思想</li></ol><p>种类：</p><ul><li>用户链码</li><li>系统链码</li></ul><ol start="4"><li>通道</li></ol><p>通道，狭义地讲，是排序服务上划分的彼此隔离的原子广播渠道，由排序服务进行管理</p><ol start="5"><li>链结构</li></ol><p>链结构内容：</p><ul><li>所绑定的通道内的所有的交易信息，这些交易以区块形式进行存放</li><li>通道内所安装和实例化的链码的相关信息</li><li>对链进行操作的权限管理，以及参与到链上的组织成员</li></ul><ol start="6"><li>账本</li></ol><p>账本主要负责记录发生在网络中的交易信息，账本包括区块链结构和多个数据库结构</p><p><img src="https://img-blog.csdnimg.cn/7046bcd0555f4b1c8b906124c1583c11.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>State Database：状态数据库，由区块链结构中交易执行推演而成，记录最新的世界状态</li><li>History Database：历史数据库，存放各个状态的历史变化记录</li><li>Index Database：索引数据库，存放索引信息</li></ul><h2 id="12-3-gRPC消息协议【待补充】"><a href="#12-3-gRPC消息协议【待补充】" class="headerlink" title="12.3 gRPC消息协议【待补充】"></a>12.3 gRPC消息协议【待补充】</h2><h2 id="12-4-权限管理和策略"><a href="#12-4-权限管理和策略" class="headerlink" title="12.4 权限管理和策略"></a>12.4 权限管理和策略</h2><h3 id="12-4-1-策略应用场景"><a href="#12-4-1-策略应用场景" class="headerlink" title="12.4.1 策略应用场景"></a>12.4.1 策略应用场景</h3><p><img src="https://img-blog.csdnimg.cn/d7491f1b67b64f7ca0061c1db13bc2fb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="12-4-2-身份证书"><a href="#12-4-2-身份证书" class="headerlink" title="12.4.2 身份证书"></a>12.4.2 身份证书</h3><ul><li>登记证书（ECert）：颁发给提供了注册凭证的用户或节点等实体，一般长期有效</li><li>交易证书（TCert）：办法给用户，控制每个交易的权限，一般针对某个交易，短期有效；</li><li>通信证书（TLSCert）：控制对网络层的接入访问，可以对远端实体身份进行校验，防止窃听</li></ul><h3 id="12-4-3-权限策略的实现"><a href="#12-4-3-权限策略的实现" class="headerlink" title="12.4.3 权限策略的实现"></a>12.4.3 权限策略的实现</h3><p>功能：对通道内数据的各种操作权进行管理。包括对读身份（例如获取通道的交易、区块等数据）、写身份（例如向通道发起交易）、管理员身份（例如加入通道、修改通道的配置信息）等权限进行限制</p><ol><li>数据结构</li></ol><p>实现上，每种策略结构都要实现Evaluate方法，该方法中会对于给定的一组签名数据按照一定规则对它们进行校验，看是否符合约定的条件，符合则说明满足了该策略</p><ol start="2"><li>SIGNATURE策略</li></ol><p>通过签名来对数据进行认证，例如数据必须满足一定的签名身份组合</p><p>SignaturePolicy结构体代表了一个策略的具体内容。支持指定某个特性签名或者满足给定策略集合中的若干个（NOutOf）即可。</p><p>SignaturePolicyEnvelope结构体代表了一个完整的策略，包括版本号、策略规则和策略关联的实体集合。</p><ol start="3"><li>IMPLICIT_META策略</li></ol><p>该策略不直接进行签名检查，而是通过引用其子元素的策略（最终还是通过SIGNATURE策略）来进行检查。检查结果通过Rule来进行限制。</p><h3 id="12-4-4-通道策略"><a href="#12-4-4-通道策略" class="headerlink" title="12.4.4 通道策略"></a>12.4.4 通道策略</h3><p>通道策略是层级化结构，最上层为/Channel。在每一级别都可以指定策略，作为本层级的默认策略。</p><p><img src="https://img-blog.csdnimg.cn/fb8f53d53d93442bb99be2c966e8c128.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>未经修改的情况下，会为通道内元素预先定义一些默认的策略，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/ab4a0a6391d5405ea7eeecc9cc4f73c1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="12-4-5-背书策略"><a href="#12-4-5-背书策略" class="headerlink" title="12.4.5 背书策略"></a>12.4.5 背书策略</h3><p>用户在实例化链码使，可以指定背书策略</p><p>背书策略采用SignaturePolicy结构进行指定，同样可以基于MSPPrincipal结构构建任意复杂的签名校验组合</p><p>下面的命令指定要么Org1的管理员进行背书，或者Org2和Org3的成员同时进行背书才满足背书策略：<br><img src="https://img-blog.csdnimg.cn/54576b21b6bd4f499ae6ca0f358ea0c4.png" alt="在这里插入图片描述"></p><h3 id="12-4-6-实例化策略"><a href="#12-4-6-实例化策略" class="headerlink" title="12.4.6 实例化策略"></a>12.4.6 实例化策略</h3><p>实例化策略一般用于最终确认阶段，Committer利用VSCC对网络中进行链码部署的cao zuo操作进行权限检查</p><p>实例化策略采用SignaturePolicy结构进行指定，可以给予MSTPPrincipal结构构建任意复杂的签名校验组合</p><p>默认情况下，会以当前MSP的管理员身份作为默认的策略，这可以避免脸吗被通道中其他组织成员私自在其他通道内进行实例化</p><h2 id="12-5-用户链码"><a href="#12-5-用户链码" class="headerlink" title="12.5 用户链码"></a>12.5 用户链码</h2><h3 id="12-5-1-基本结构"><a href="#12-5-1-基本结构" class="headerlink" title="12.5.1 基本结构"></a>12.5.1 基本结构</h3><p>链码的典型结构：</p><p><img src="https://img-blog.csdnimg.cn/1312f1b5804645f2a4534ffa4eafdca7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>用户只需要关注到Init()和Invoke()函数的视线，其中利用shim.ChaincodeStubInterface结构实现跟账本的交互逻辑</p><p>用户链码支持install、instantiate、invoke、query、upgrade、package、signpackage等操作，其生命周期被生命周期管理系统链码（LSCC）进行管理</p><h3 id="12-5-2-链码与Peer的交互过程"><a href="#12-5-2-链码与Peer的交互过程" class="headerlink" title="12.5.2 链码与Peer的交互过程"></a>12.5.2 链码与Peer的交互过程</h3><p><img src="https://img-blog.csdnimg.cn/5859c9af4dac47d29d0fb51746ee4742.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>Type：消息的类型</li><li>TxId：关联的交易ID</li><li>Payload：存储消息内容</li></ul><p>交互过程：<br><img src="https://img-blog.csdnimg.cn/a9909a44a56e4a9cba4fa7890df883fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>用户链码调用shim.Start()方法后，首先向Peer发送<code>ChaincodeMessage_REGISTER</code>消息尝试进行注册。之后开始等待接收来自Peer的消息。此时状态为出事的created</li><li>Peer收到来自链码容器的<code>ChaincodeMessage_REGISTER</code>消息，注册到本地的一个handler结构，返回<code>ChaincodeMessage_REGISTERED</code>消息给链码容器，更新状态为established，之后自动发出<code>ChaincodeMessage_READY</code>消息给链码容器，更新状态为ready</li><li>链码侧收到<code>ChaincodeMessage_REGISTERED</code>消息后，不进行任何操作，注册成功。更新状态为establied。收到<code>ChaincodeMessage_READY</code>消息后更新状态为ready</li><li>Peer侧发出<code>ChaincodeMessage_INIT</code>消息给链码容器，对链码进行初始化</li><li>链码容器收到<code>ChaincodeMessage_INIT</code>消息，调用用户链码代码Init()方法进行初始化，成功后返回<code>ChaincodeMessage_COMPLETED</code>消息，此时链码容器可以被调用了</li><li>链码被调用时，Peer发出<code>ChaincodeMessage_TRANSACTION</code>消息给链码</li><li>链码收到<code>ChaincodeMessage_TRANSACTION</code>消息，会调用Invoke()方法。根据Invoke()方法中用户实现的逻辑发送消息。Peer侧收到这些消息，进行相应处理，并回复<code>ChaincodeMessage_RESPONSE</code>消息，最后链码侧会回复调用完成的消息<code>ChaincodeMessage_COMPLETE</code>给Peer侧</li></ul><p>上述过程中，Peer和链码侧会定期的发送<code>ChaincodeMessage_KEEPALIVE</code>消息给对方，以确保彼此在线</p><h3 id="12-5-3-链码处理状态机"><a href="#12-5-3-链码处理状态机" class="headerlink" title="12.5.3 链码处理状态机"></a>12.5.3 链码处理状态机</h3><p><img src="https://img-blog.csdnimg.cn/93a115e4e5c84464b0dbca6c18a5ecbe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="12-6-系统链码"><a href="#12-6-系统链码" class="headerlink" title="12.6 系统链码"></a>12.6 系统链码</h3><p>系统链码负责Fabric节点自身的处理逻辑，包括系统配置、背书、校验等工作</p><p>类型：</p><p><img src="https://img-blog.csdnimg.cn/ed6c8e03be1142d5bd37d2a2da50f85c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/67644becc0894c9e9322b56981a2b27b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5p2v57OW5LiN5Yqg5ZKW5ZWh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="1-配置系统链码"><a href="#1-配置系统链码" class="headerlink" title="1. 配置系统链码"></a>1. 配置系统链码</h4><p>Configuration System Chaincode即配置系统链码，是负责配置管理的系统链码，支持被从链外进行调用。</p><p>CSCC支持如下类型Invoke方法：</p><ul><li>JoinChain：当某个节点申请加入某条通道时被调用。负责跟根据传入的初始区块参数生成所加入通道的创世区块，并完成账本、通道相关数据结构的初始化工作。调用后节点本地将维护所加入通道的数据结构，并创建初始区块。</li><li>GetConfigBlock：当需要获取节点在某个通道上配置时候被调用。该方法获取指定通道的配置区块（未更新时等价于初始区块）的内容</li><li>UpdateConfigBlock：当需要更新节点在某个通道上的配置时被调用。根据传入的区块数据生成区块结构，替换掉现有的配置区块结构。替换后配置区块数据将跟该通道内的初始区块不再一致</li><li>GetChannels：需要获取到节点所加入所有通道列表时被调用。该方法获取该节点已经加入的所有通道的信息</li></ul><h4 id="2-背书管理系统链码"><a href="#2-背书管理系统链码" class="headerlink" title="2. 背书管理系统链码"></a>2. 背书管理系统链码</h4><p>Endorsement Sysment Chaincode即背书管理系统链码。负责背书（签名）过程，并可以支持对被书策略进行管理，仅支持链内系统调用。</p><h4 id="3-生命周期系统链码"><a href="#3-生命周期系统链码" class="headerlink" title="3. 生命周期系统链码"></a>3. 生命周期系统链码</h4><p>Liftcycle System Chaincode即生命周期系统链码，负责对用户链码的生命周期进行管理，支持被从链外进行调用</p><p>链码生命周期包括安装、部署、升级、权限管理、获取信息等环节。这些操作都可以通过对LSCC进行Invoke来实现：</p><ul><li>INSTALL：安装意味着将用户链码相关文件打包，放置到节点的文件系统，默认在/var/hyperledger/production/chaincodes/路径下</li><li>DEPLOY：意味着链码被部署和实例化，生成链码容器。此过程中会检查通道的ACL，从本地拿到链码数据，检查Instantiation Policy</li><li>UPGRADE：升级链码时被调用。检查Instantiation Policy，通过则对本地文件进行替换，并生成新的链码容器</li><li>GETCCINFO：获取链码信息时被调用。检查节点对钙通道是否有读权限，通过则返回指定链码的信息</li><li>GETCCDATA：获取链码数据时被调用。检查节点对该通道是否有读权限，通过则返回指定链码的完整数据</li><li>GETCHAINCODES：获取节点在通道上的连码信息，检查节点是否具有管理员权限，通过则返回在通道上的所有链码信息，包括已安装和已实例化的</li></ul><h4 id="4-查询系统链码"><a href="#4-查询系统链码" class="headerlink" title="4. 查询系统链码"></a>4. 查询系统链码</h4><p>Query System Chaincode，查询系统链码，负责提供一些账本和链信息的查询方法：</p><ul><li>GetChainInfo：获取区块链的信息，包括高度值、当前区块Hash值、上一个区块Hash值等</li><li>GetBlockByNumber：根据给定高度，返回对应区块的数据</li><li>GetBlockByHash：根据给定的区块头Hash值，返回对应区块的数据</li><li>GetTransactionByID：根据给定的TxID，返回对应交易的数据</li><li>GetBlockByTxID：根据给定的TxID，返回包含该交易的区块的数据</li></ul><h4 id="5-验证系统链码"><a href="#5-验证系统链码" class="headerlink" title="5. 验证系统链码"></a>5. 验证系统链码</h4><p>Verification System Chaincode验证系统链码，负责担任Committer角色的节点对从Orderer收到的一批交易进行写入前的再次验证，仅支持链内系统调用。</p><p>VSCC主要过程：</p><ul><li>首先解析出交易结构，并对交易结构格式进行校验</li><li>检查交易的读集合中元素版本跟本地账本中版本一致</li><li>检查带有合法的背书信息（目前主要是检查签名信息）</li><li>通过则返回正确，否则返回错误信息</li></ul><h3 id="12-7-排序服务"><a href="#12-7-排序服务" class="headerlink" title="12.7 排序服务"></a>12.7 排序服务</h3><p>排序服务在超级账本Fabric网络中起到十分核心的作用。所有交易在发送到网络中交由Committer进行验证接受之前，需要先经过排序服务进行全局排序。排序服务提供了原子广播排序功能。</p><p>排序服务三部分：</p><ul><li>gRPC协议对外提供服务接口</li><li>账本组件网络中每个应用通道维护区块链结构</li><li>排序插件跟不同类型的排序后端打交道</li></ul><p><img src="/images/fabric/image-20220306155841781.png" alt="image-20220306155841781"></p><h4 id="12-7-1-gRPC服务接口"><a href="#12-7-1-gRPC服务接口" class="headerlink" title="12.7.1 gRPC服务接口"></a>12.7.1 gRPC服务接口</h4><p>Orderer通过gRPC接口提供了对外的调用服务，主要包括：</p><ul><li>Broadcast：意味着客户端发送交易请求到排序服务进行排序处理</li><li>Deliver：意味着客户端或Peer从排序服务获取排序后的区块（批量交易）</li></ul><h4 id="12-7-2-链和账本管理"><a href="#12-7-2-链和账本管理" class="headerlink" title="12.7.2 链和账本管理"></a>12.7.2 链和账本管理</h4><p>Orderer节点本地需要维护网络中的账本结构。其中账本结构支持三种实现类型：</p><ul><li>ram：存放近期若干区块到内存中</li><li>file：存放区块记录到本地文件系统</li><li>json：存放区块记录到本地文件系统（存储格式为json）</li></ul><h4 id="12-7-3-通道配置更新"><a href="#12-7-3-通道配置更新" class="headerlink" title="12.7.3 通道配置更新"></a>12.7.3 通道配置更新</h4><p>对通道配置的更新主要通过Processor结构来完成，该结构主要提供了Process方法。该方法接收一个CONFIG_UPDATE类型的Envelope结构消息，根据请求类型（新建通道或更新配置），将其转换为新建应用通道的请求，或者转换为对通道进行配置更改的请求。</p><p>主要步骤：</p><ul><li>从请求中提取channelID，检查本地是否存在对应的链结构</li><li>如果channelID对应的链在本地存在，则意味着这是一个对已有通道进行配置更新的请求</li><li>如果channelID对应的链在本地不存在，则意味着这是一个新通道的请求</li></ul><h4 id="12-7-4-共识插件"><a href="#12-7-4-共识插件" class="headerlink" title="12.7.4 共识插件"></a>12.7.4 共识插件</h4><p>Orderer模块中包含三种共识插件：</p><ul><li>Solo：单节点的排序功能，试验性质，不具备可扩展性和容错，不能在生产环境中使用</li><li>Kafka：基于Kafka集群的排序实现。支持CFT容错，支持可持久化和扩展性，可在生产环境中使用</li><li>SBFT：支持BFT容错的排序实现，1.0尚未实现</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《区块链原理、设计与应用-杨保华、陈昌》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊源码分析</title>
      <link href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>希望能够分析以太坊的代码来学习区块链技术和GO语言的使用</strong></p><p>分析<a href="https://github.com/ethereum/go-ethereum">go-ethereum</a>的过程，我希望从依赖比较少的底层技术组件开始，慢慢深入到核心逻辑。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-go-ethereum%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="go-ethereum代码阅读环境搭建">go-ethereum代码阅读环境搭建</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%BB%84%E7%9A%AE%E4%B9%A6%E9%87%8C%E9%9D%A2%E5%87%BA%E7%8E%B0%E7%9A%84%E6%89%80%E6%9C%89%E7%9A%84%E7%AC%A6%E5%8F%B7%E7%B4%A2%E5%BC%95/" title="以太坊黄皮书 符号索引">以太坊黄皮书 符号索引</a></li><li><a href="/2021/04/14/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-RLP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="rlp源码解析">rlp源码解析</a></li><li><a href="/2021/05/27/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%86%E6%9E%90%E5%8C%85Trie/" title="trie源码分析">trie源码分析</a></li><li><a href="/2021/06/05/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ethdb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="ethdb源码分析">ethdb源码分析</a></li><li><a href="/2021/04/14/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-RLP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="rpc源码分析">rpc源码分析</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-p2p%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="p2p源码分析">p2p源码分析</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-eth%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="eth协议源码分析">eth协议源码分析</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-event%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="event源码分析">event源码分析</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-node%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="node源码分析">node源码分析</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-accounts%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="accounts源码分析">accounts源码分析</a></li><li>core源码分析<ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-chain_indexer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="区块链索引 chain_indexer源码分析">区块链索引 chain_indexer源码分析</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-bloombits%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="布隆过滤器索引">布隆过滤器索引</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-state%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="state源码分析">state源码分析</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-state-process%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="交易执行和处理部分源码分析">交易执行和处理部分源码分析</a></li><li>vm 虚拟机源码分析<ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-vm-stack-memory%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="虚拟机堆栈和内存数据结构分析">虚拟机堆栈和内存数据结构分析</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-vm-jumptable-instruction/" title="虚拟机指令,跳转表,解释器源码分析">虚拟机指令,跳转表,解释器源码分析</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-vm%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="虚拟机源码分析">虚拟机源码分析</a></li></ul></li><li>待确认交易池的管理txPool<ul><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-txlist%E4%BA%A4%E6%98%93%E6%B1%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="交易池数据结构源码分析">交易池数据结构源码分析</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-txpool%E4%BA%A4%E6%98%93%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="交易池源码分析">交易池源码分析</a></li></ul></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-genesis%E5%88%9B%E4%B8%96%E5%8C%BA%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="创世区块的源码分析">创世区块的源码分析</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-core-blockchain%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="core-blockchain源码分析">core-blockchain源码分析</a></li></ul></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-miner%E6%8C%96%E7%9F%BF%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90CPU%E6%8C%96%E7%9F%BF/" title="miner挖矿部分源码分析CPU挖矿">miner挖矿部分源码分析CPU挖矿</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-pow%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/" title="pow一致性算法">pow一致性算法</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9CClique_PoA%E4%BB%8B%E7%BB%8D/" title="以太坊测试网络Clique_PoA介绍">以太坊测试网络Clique_PoA介绍</a></li><li><a href="/2021/05/17/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/" title="以太坊随机数生成方式">以太坊随机数生成方式</a></li><li><a href="/2021/05/27/blockchain/ethereum/source_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%B0%81%E8%A3%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/" title="封装的一些基础工具">封装的一些基础工具</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于区块链的档案分发系统介绍</title>
      <link href="/1900/01/01/blockchain/fabric/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%A1%A3%E6%A1%88%E5%88%86%E5%8F%91%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/"/>
      <url>/1900/01/01/blockchain/fabric/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%A1%A3%E6%A1%88%E5%88%86%E5%8F%91%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>推荐使用云服务器:</strong><br><a href="https://curl.qcloud.com/uAWpwwiE">【腾讯云】轻量新用户上云福利，2核2G4M 低至 50 元/年 起， 抓住上云好时机！</a></p></blockquote><blockquote><p><strong>解决问题步骤:</strong><br>遇到问题请先看文章最后的常见问题以及评论区<br>无法解决可以先百度/谷歌尝试解决<br>依旧无法解决可以将问题集中汇总联系我，并在最后通过评论方式记录到对应文章以便他人查看</p></blockquote><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>有很多同学也需要搭建这个系统希望我能帮他们搭建，但是我确实太忙了（打工人的无奈），所以只能抛砖引玉尽我所能提供思路吧。</p><p>这篇博客是我对”基于区块链的档案分发管理系统”项目的总结：</p><p>“基于区块链的档案分发管理系统“演示视频：<a href="https://www.bilibili.com/video/bv13y4y137kF">https://www.bilibili.com/video/bv13y4y137kF</a></p><p>Fabric区块链环境问题、代码启动报错问题我可以提供帮助，其他的SpringBoot相关问题、代码改造问题、智能合约编写问题等请百度或查看我赠送的视频课程。</p><h2 id="二、原理和涉及技术点"><a href="#二、原理和涉及技术点" class="headerlink" title="二、原理和涉及技术点"></a>二、原理和涉及技术点</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>三层架构：</p><ul><li>区块链网络：存放数据，使用Fabric搭建。所以在运行过程中需要保证虚拟机中的Fabric网络一直启动</li><li>缓存层：Redis，将常用的数据存于Redis，以此加快查询速度</li><li>DAPP：使用Java开发，前后端使用技术为SpringBoot、Thymeleaf、<a href="https://startbootstrap.com/theme/sb-admin-2">SB-Admin2</a> ,在Java代码中通过FabricSDK与Fabric网络进行交互（触发链码等）</li></ul><h3 id="2-技术点"><a href="#2-技术点" class="headerlink" title="2. 技术点"></a>2. 技术点</h3><ul><li>【必须】Linux：搭建Fabric网络需要使用Linux命令</li><li>【非必须】JavaWeb、SpringBoot、Thymeleaf、HTML、CSS、JS：如果不需要修改代码那么只需要了解SpringBoot启动方式即可，需要修改代码最好熟悉这些</li><li>【非必须】Go：Fabric的智能合约运行在容器中，可以使用Go、Java、Node.js语言开发。如果需要重新开发合约需要会用Go，简单看看教程就可以</li><li>【非必须】区块链基础、Fabric</li><li>【非必须】Docker：Fabric网络在Docker中运行</li><li>【非必须】Redis：搭建起来即可</li></ul><p>说明：以上技术并不是要求都掌握，只是说掌握的越好做起来可能越容易。</p><h2 id="三、环境介绍"><a href="#三、环境介绍" class="headerlink" title="三、环境介绍"></a>三、环境介绍</h2><h3 id="1-硬件环境"><a href="#1-硬件环境" class="headerlink" title="1. 硬件环境"></a>1. 硬件环境</h3><ul><li>Ubuntu16.04服务器（版本要求不必须，18.04、20.04亦可）</li></ul><h3 id="2-软件环境"><a href="#2-软件环境" class="headerlink" title="2. 软件环境"></a>2. 软件环境</h3><ul><li>Fabric：Fabric<font color="red"><strong>1.4.0</strong></font>作为区块链框架</li><li>Java：运行SpringBoot项目</li><li>Maven：项目使用Maven仓库</li><li>Redis、Redis Desktop Manager</li><li>XShell：与Ubuntu连接使用</li><li>XFTP：与Ubuntu传输文件使用</li><li>IntelliJ IDEA：代码编辑器</li></ul><h2 id="四、环境搭建步骤和程序使用方式"><a href="#四、环境搭建步骤和程序使用方式" class="headerlink" title="四、环境搭建步骤和程序使用方式"></a>四、环境搭建步骤和程序使用方式</h2><p><font color="red"><strong>在进行此步骤之前最好先看视频课程</strong></font></p><h3 id="1-Ubuntu上准备基础环境"><a href="#1-Ubuntu上准备基础环境" class="headerlink" title="1. Ubuntu上准备基础环境"></a>1. Ubuntu上准备基础环境</h3><ul><li>Ubuntu系统：安装VMware虚拟机和Ubuntu16.04 64位系统（或18.04、20.04）</li><li>Fabric网络：搭建Fabric单机并运行启动（重难点，多机部署更合适，因为区块链不该是一个节点，作为学习一个节点够了）。参考博客：<a href="/1900/01/01/blockchain/fabric/%E9%83%A8%E7%BD%B2Fabric-v1-4-0%E2%80%94%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2/" title="搭建Fabric环境并启动">搭建Fabric环境并启动</a></li><li>Redis环境：搭建过程参考博客：<a href="/1900/01/01/other/Ubuntu%E5%AE%89%E8%A3%85Redis/" title="Ubuntu安装Redis">Ubuntu安装Redis</a></li></ul><h3 id="2-代码运行机器上准备开发环境"><a href="#2-代码运行机器上准备开发环境" class="headerlink" title="2. 代码运行机器上准备开发环境"></a>2. 代码运行机器上准备开发环境</h3><ul><li>IntelliJ IDEA：运行代码的编辑器</li><li>XShell：远程连接Ubuntu</li><li>XFTP：与Ubuntu进行文件传输</li><li>Java环境：在运行代码的机器上安装JDK<font color="red"><strong>1.8</strong></font></li><li>Maven环境：在运行代码的机器上安装Maven，同时<font color="red">配置使用国内源</font></li></ul><h3 id="3-启动程序"><a href="#3-启动程序" class="headerlink" title="3. 启动程序"></a>3. 启动程序</h3><p>i) 准备证书文件</p><p><font color="red">使用root用户</font>将区块链服务器上的证书文件copy到本地项目中以便使用：<br>从<code>/home/ubuntu/gopath/src/github.com/hyperledger/fabric-samples/first-network/crypto-config</code><br>复制到：<code>src/main/resources/file/fabric/crypto-config</code>目录</p><p>ii) 配置host</p><p>修改代码所在机器（不是Fabric所在机器）的host映射区块链网络的域名example.com</p><pre><code class="bash"># 192.168.31.131 为搭建区块链的服务器的地址，需要根据实际情况修改192.168.31.131      orderer.example.com peer0.org1.example.com peer1.org1.example.com peer0.org2.example.com peer1.org2.example.com</code></pre><p>iii) 检查Redis状态</p><p>执行service redis status 可以查看redis服务的状态为running，说明安装完成系统自动启动了服务。否则执行命令<code>/etc/init.d/redis-server start</code></p><p>iv) 修改Java配置文件</p><ul><li>按着注释修改文件：</li></ul><p><code>src/main/java/com/springboot/config/PathConf.java</code>的<code>org1KeyFileName</code>和<code>org2KeyFileName</code></p><ul><li>修改<code>src/main/resources/application.yml</code>文件中的TODO注释部分（redis账号和密码）</li></ul><p>v) 启动代码</p><p>这里提前看一下SpringBoot+Maven项目如何启动，求求项目启动问题就别再问我了～</p><ul><li>打开ys-file-manage文件夹，项目结构：</li></ul><p><img src="/../images/fabric/image-20220320144055288.png" alt="image-20220320144055288"></p><ul><li><p>将pom.xml添加到maven项目然后点击刷新按钮导入依赖包（如果已操作忽略该步骤）</p><p><img src="/../images/fabric/image-20220320144304432.png" alt="image-20220320144304432"></p><p><img src="/../images/fabric/image-20220320144719203.png" alt="image-20220320144719203"></p></li><li><p>运行<code>src/main/java/com/springboot/SpringBootFileManageApplication.java</code>代码启动服务</p></li></ul><p><img src="/../images/fabric/springboot-startup.png" alt="image-20220317172522948"></p><p>vi) 安装、实例化链码</p><p>如果修改了智能合约不可使用此方式部署，请使用命令行方式：<a href="/1900/01/01/blockchain/fabric/Docker%E6%93%8D%E4%BD%9CFabric%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Docker操作Fabric常用命令">Docker操作Fabric常用命令</a></p><p>链接：<a href="http://localhost:8089/FileManage/admin/chaincodeView">http://localhost:8089/FileManage/admin/chaincodeView</a></p><p><img src="/../images/fabric/image-20220328192236825.png" alt="image-20220328192236825"></p><p>依次输入链码名和链码版本，然后依次点击安装合约、实例化合约等待弹窗返回提示结果</p><p>vii) 注册系统管理员</p><p>链接：<a href="http://localhost:8089/FileManage/admin/insertAdminInfoView">http://localhost:8089/FileManage/admin/insertAdminInfoView</a></p><p>注册成功后会返回登陆ID，使用此ID作为用户名，设置的密码作为登陆密码进行登录</p><p>提示：代码健壮性不强，所以最好所有输入框都要输入内容，否则可能会有想不到的bug</p><p>档案管理员登录地址：<a href="http://localhost:8089/FileManage/admin/adminLoginView">http://localhost:8089/FileManage/admin/adminLoginView</a></p><h2 id="五、部分代码介绍"><a href="#五、部分代码介绍" class="headerlink" title="五、部分代码介绍"></a>五、部分代码介绍</h2><h3 id="1-使用Fabric-Java-SDK连接区块链"><a href="#1-使用Fabric-Java-SDK连接区块链" class="headerlink" title="1. 使用Fabric-Java SDK连接区块链"></a>1. 使用Fabric-Java SDK连接区块链</h3><p>参考博客：<a href="/1900/01/01/blockchain/fabric/%E5%8C%BA%E5%9D%97%E9%93%BEFabric-sdk-java%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4/" title="如何使用SDK连接区块链网络">如何使用SDK连接区块链网络</a> </p><p>参考代码：<a href="https://gitee.com/hbuzzs/FabricSDK/tree/master">Fabric-Java SDK代码</a></p><h3 id="2-编写并部署智能合约"><a href="#2-编写并部署智能合约" class="headerlink" title="2. 编写并部署智能合约"></a>2. 编写并部署智能合约</h3><p>Go开发智能合约：<a href="https://gitee.com/hbuzzs/FileManageChainCode">智能合约代码</a></p><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><h3 id="1-注意要创建超级管理员账号，否则无法登陆"><a href="#1-注意要创建超级管理员账号，否则无法登陆" class="headerlink" title="1. 注意要创建超级管理员账号，否则无法登陆"></a>1. 注意要创建超级管理员账号，否则无法登陆</h3><p>注册系统管理员（超级管理员）链接：<a href="http://localhost:8089/FileManage/admin/insertAdminInfoView">http://localhost:8089/FileManage/admin/insertAdminInfoView</a></p><h3 id="2-使用XShell或XFTP连接Ubuntu失败"><a href="#2-使用XShell或XFTP连接Ubuntu失败" class="headerlink" title="2. 使用XShell或XFTP连接Ubuntu失败"></a>2. 使用XShell或XFTP连接Ubuntu失败</h3><p>可能原因：</p><ul><li>远程连接IP错误</li><li>远程连接密码错误</li><li>远程连接端口错误，应使用22</li><li>Ubuntu上没有安装SSH服务<pre><code class="shell"># 首先在服务器上安装ssh的服务器端sudo apt-get install openssh-server# 启动ssh-server/etc/init.d/ssh restart# 确认ssh-server已经正常工作netstat -tlp# 看到 tcp6 0 0 *:ssh *:* LISTEN - 输出说明ssh-server已经在运行了</code></pre></li><li>Ubuntu没有允许登录用户远程登录（例如未允许root远程登录）<pre><code class="shell"># 编辑/etc/ssh/sshd_config文件；sudo vim /etc/ssh/sshd_config# 找到配置参数：PermitRootLogin 将该参数后面的值修改为yes即可；# 按“esc键” :wq  回车，  保存退出；# 给root用户设置密码；sudo passwd root# 输入两遍密码；（给root用户设置了密码后，就已经可以使用root用户登陆到系统中了）# 重启ssh服务sudo  systemctl  restart  ssh</code></pre></li></ul><h3 id="3-提示证书认证失败"><a href="#3-提示证书认证失败" class="headerlink" title="3. 提示证书认证失败"></a>3. 提示证书认证失败</h3><p>检查Fabric中的证书文件和代码中的证书文件是否一致</p><h3 id="4-Redis连接异常"><a href="#4-Redis连接异常" class="headerlink" title="4. Redis连接异常"></a>4. Redis连接异常</h3><p><img src="/../images/fabric/image-20220328191741714.png" alt="image-20220328191741714"></p><p>可能原因：</p><ul><li>代码所在机器是否不可以连接到Redis（可以ping命令测试）</li><li>代码配置文件中的Redis的IP和密码不正确</li><li>Redis没有开启远程连接（搭建Redis博客中有相关介绍）</li><li>Redis没有设置密码</li></ul><h3 id="5-使用XFTP拷贝文件不完整，缺少密钥文件"><a href="#5-使用XFTP拷贝文件不完整，缺少密钥文件" class="headerlink" title="5. 使用XFTP拷贝文件不完整，缺少密钥文件"></a>5. 使用XFTP拷贝文件不完整，缺少密钥文件</h3><p>可能原因：未使用root用户传输文件，密钥文件是root用户才可以传输的。</p><h3 id="6-项目启动后安装链码报错"><a href="#6-项目启动后安装链码报错" class="headerlink" title="6. 项目启动后安装链码报错"></a>6. 项目启动后安装链码报错</h3><p><img src="/../images/fabric/image-20220429193102060.png" alt="image-20220429193102060"></p><p>可能原因：</p><ul><li>文件证书路径不正确，是否修改了<code>src/main/java/com/springboot/config/PathConf.java</code>的<code>org1KeyFileName</code>和<code>org2KeyFileName</code></li><li>检查项目结构是否如下：<img src="/../images/fabric/image-20220320144055288.png" alt="image-20220320144055288"></li></ul><p>如果两种可能都不是，那么检查一下那个路径有没有那个文件：</p><p><img src="/../images/fabric/image-20220429193457444.png" alt="image-20220429193457444"></p><h3 id="7-与Fabric网络连接超时"><a href="#7-与Fabric网络连接超时" class="headerlink" title="7. 与Fabric网络连接超时"></a>7. 与Fabric网络连接超时</h3><p><img src="/../images/fabric/image-20220429220100251.png" alt="image-20220429220100251"></p><p>可能原因：Fabric网络所在机器性能较差，连接失败，重试或提高Fabric机器配置</p>]]></content>
      
      
      
        <tags>
            
            <tag> 部署文档 </tag>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
