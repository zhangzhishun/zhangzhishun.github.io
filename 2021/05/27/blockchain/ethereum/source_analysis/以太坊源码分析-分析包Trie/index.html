<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>以太坊源码分析-分析包Trie</title><meta name="robots" content="noindex"><meta name="description" content="Blockchain knowledge record blog"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + 'e574a92bc4bac2e317309d7ea1dfcb71';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="/images/system/head_portrait.jpg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="版本说明源码分析使用的版本为：v1.10.3
知识补充以太坊源码中的trie包实现了Merkle Patricia Tries（MPT），这种数据结构实际上是一种Trie树变种。
MPT是以太坊中一种非常重要的数据结构，用来存储用户账户的状态及其变更、交易信息、交易的收据信息。
MPT实际上是三种数据结构的组合，分别是Merkle树、Patricia Trie、和Trie树。
下面分别介绍这三种数据结构。
Merkle树Merkle Tree，通常也被称作Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块(例如，文件或者文件的集合)的hash值。非叶节点是其对应子节点串联字符串的hash

Merkle Tree的主要作用是当我拿到Top Hash的时候，这个hash值代.."><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Sugar's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Sugar's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">以太坊源码分析-分析包Trie</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/works">Works</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/works">Works</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-text">版本说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-text">知识补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Merkle%E6%A0%91"><span class="toc-text">Merkle树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Patricia-Tries"><span class="toc-text">Patricia Tries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie%E6%A0%91"><span class="toc-text">Trie树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84MPT"><span class="toc-text">以太坊的MPT</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%EF%BC%9Aencoding-go"><span class="toc-text">编码转换：encoding.go</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-text">数据结构与方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#node%EF%BC%9Anode-go"><span class="toc-text">node：node.go</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#node%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">node的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">node的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trie%EF%BC%9Atrie-go"><span class="toc-text">Trie：trie.go</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Trie%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">Trie的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Trie%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">Trie的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Trie%E6%A0%91%E7%9A%84%E6%96%B0%E5%BB%BA"><span class="toc-text">1. Trie树的新建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Trie%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-text">2. Trie树的插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Trie%E6%A0%91%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-text">3. Trie树的获取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Trie%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-text">4. Trie树的删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Trie%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">5. Trie树的序列化和反序列化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie%E6%A0%91%E7%9A%84%E9%BB%98%E5%85%8B%E5%B0%94%E8%AF%81%E6%98%8E%EF%BC%9Aproof-go"><span class="toc-text">Trie树的默克尔证明：proof.go</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie%E7%9A%84%E5%8A%A0%E5%AF%86%EF%BC%9Asecurity-trie-go"><span class="toc-text">Trie的加密：security_trie.go</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trie%E5%8C%85%E4%B8%AD%E5%85%B6%E4%BB%96%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">trie包中其他的功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E5%9C%B0%E5%9D%80"><span class="toc-text">参考资料地址</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Ethereum"><i class="tag post-item-tag">Ethereum</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">以太坊源码分析-分析包Trie</h1><time class="has-text-grey" datetime="2021-05-27T11:12:06.000Z">2021-05-27</time><article class="mt-2 post-content"><h1 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h1><p>源码分析使用的版本为：<a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum/tree/v1.10.3">v1.10.3</a></p>
<h1 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h1><p>以太坊源码中的trie包实现了Merkle Patricia Tries（MPT），这种数据结构实际上是一种Trie树变种。</p>
<p>MPT是以太坊中一种非常重要的数据结构，用来存储用户账户的状态及其变更、交易信息、交易的收据信息。</p>
<p>MPT实际上是三种数据结构的组合，分别是Merkle树、Patricia Trie、和Trie树。</p>
<p>下面分别介绍这三种数据结构。</p>
<h2 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h2><p>Merkle Tree，通常也被称作Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块(例如，文件或者文件的集合)的hash值。非叶节点是其对应子节点串联字符串的hash</p>
<p><img src="https://img-blog.csdnimg.cn/20210527141955845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Merkle Tree的主要作用是当我拿到Top Hash的时候，这个hash值代表了整颗树的信息摘要，当树里面任何一个数据发生了变动，都会导致Top Hash的值发生变化。 而Top Hash的值是会存储到区块链的区块头里面去的， 区块头是必须经过工作量证明。 这也就是说我只要拿到一个区块头，就可以对区块信息进行验证。 更加详细的信息请参考那个博客。有详细的介绍。</p>
<h2 id="Patricia-Tries"><a href="#Patricia-Tries" class="headerlink" title="Patricia Tries"></a>Patricia Tries</h2><p>Patricia Tries即为前缀树，<br>前缀树跟Trie树的不同之处在于Trie树给每一个字符串分配一个节点，这样将使那些很长但又没有公共节点的字符串的Trie树退化成数组。在以太坊里面会由黑客构造很多这种节点造成拒绝服务攻击。前缀树的不同之处在于如果节点公共前缀，那么就使用公共前缀，否则就把剩下的所有节点插入同一个节点。Patricia相对Tire的优化正如下图：<br><img src="https://img-blog.csdnimg.cn/20210527141719517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210527141728827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<table>
<thead>
<tr>
<th>Key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>6c0a5c71ec20bq3w</td>
<td>5</td>
</tr>
<tr>
<td>6c0a5c71ec20CX7j</td>
<td>27</td>
</tr>
<tr>
<td>6c0a5c71781a1FXq</td>
<td>18</td>
</tr>
<tr>
<td>6c0a5c71781a9Dog</td>
<td>64</td>
</tr>
<tr>
<td>6c0a8f743b95zUfe</td>
<td>30</td>
</tr>
<tr>
<td>6c0a8f743b95jx5R</td>
<td>2</td>
</tr>
<tr>
<td>6c0a8f740d16y03G</td>
<td>43</td>
</tr>
<tr>
<td>6c0a8f740d16vcc1</td>
<td>48</td>
</tr>
</tbody></table>
<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>Trie树，又称字典树，单词查找树或者前缀树，是一种用于快速检索的多叉树结构，如英文字母的字典树是一个26叉树，数字的字典树是一个10叉树。</p>
<p>Trie树可以利用字符串的公共前缀来节约存储空间。如下图所示，该trie树用10个节点保存了6个字符串：tea，ten，to，in，inn，int：</p>
<p><img src="https://img-blog.csdnimg.cn/20210527141507347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在该trie树中，字符串in，inn和int的公共前缀是“in”，因此可以只存储一份“in”以节省空间。当然，如果系统中存在大量字符串且这些字符串基本没有公共前缀，则相应的trie树将非常消耗内存，这也是trie树的一个缺点。</p>
<p>Trie树的基本性质可以归纳为：</p>
<ul>
<li>根节点不包含字符，除根节点以外每个节点只包含一个字符</li>
<li>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串</li>
<li>每个节点的所有子节点包含的字符串不相同</li>
</ul>
<h2 id="以太坊的MPT"><a href="#以太坊的MPT" class="headerlink" title="以太坊的MPT"></a>以太坊的MPT</h2><p>每一个以太坊的区块头包含三颗MPT树，分别是</p>
<ul>
<li>交易树</li>
<li>收据树(交易执行过程中的一些数据)</li>
<li>状态树(账号信息， 合约账户和用户账户)</li>
</ul>
<p>下图中是两个区块头，其中state root，tx root receipt root分别存储了这三棵树的树根，第二个区块显示了当账号 175的数据变更(27 -&gt; 45)的时候，只需要存储跟这个账号相关的部分数据，而且老的区块中的数据还是可以正常访问。(这个有点类似与函数式编程语言中的不可变的数据结构的实现)</p>
<p><img src="https://img-blog.csdnimg.cn/20210527142811419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="编码转换：encoding-go"><a href="#编码转换：encoding-go" class="headerlink" title="编码转换：encoding.go"></a>编码转换：encoding.go</h2><p>encoding.go主要处理trie树中的三种编码格式的相互转换的工作。 三种编码格式分别为下面的三种编码格式。</p>
<ul>
<li>KEYBYTES encoding这种编码格式就是原生的key字节数组，大部分的Trie的API都是使用这边编码格式</li>
<li>HEX encoding 这种编码格式每一个字节包含了Key的一个半字节，尾部接上一个可选的’终结符’,’终结符’代表这个节点到底是叶子节点还是扩展节点。当节点被加载到内存里面的时候使用的是这种节点，因为它的方便访问。</li>
<li>COMPACT encoding 这种编码格式就是上面黄皮书里面说到的Hex-Prefix Encoding，这种编码格式可以看成是HEX encoding这种编码格式的另外一种版本，可以在存储到数据库的时候节约磁盘空间。</li>
</ul>
<p>简单的理解为：将普通的字节序列keybytes编码为带有t标志与奇数个半字节nibble标志位的keybytes</p>
<ul>
<li>keybytes为按完整字节（8bit）存储的正常信息</li>
<li>hex为按照半字节nibble（4bit）储存信息的格式。供compact使用</li>
</ul>
<p>为了便于作黄皮书中Modified Merkle Patricia Tree的节点的key，编码为偶数字节长度的hex格式。其第一个半字节nibble会在低的2个bit位中，由高到低分别存放t标志与奇数标志。经compact编码的keybytes，在增加了hex的t标志与半字节nibble为偶数个（即完整的字节）的情况下，便于存储</p>
<h2 id="数据结构与方法"><a href="#数据结构与方法" class="headerlink" title="数据结构与方法"></a>数据结构与方法</h2><h3 id="node：node-go"><a href="#node：node-go" class="headerlink" title="node：node.go"></a>node：node.go</h3><h4 id="node的结构"><a href="#node的结构" class="headerlink" title="node的结构"></a>node的结构</h4><p>可以看到node分为4种类型：</p>
<ul>
<li>fullNode：黄皮书里面的分支节点</li>
<li>shortNode：黄皮书里面的扩展节点和叶子节点(通过shortNode.Val的类型来判断当前节点是叶子节点(shortNode.Val为valueNode)还是拓展节点(通过shortNode.Val指向下一个node))</li>
<li>hashNode</li>
<li>valueNode</li>
</ul>
<pre><code class="go">type node interface {
    fstring(string) string
    cache() (hashNode, bool)
}

type (
    fullNode struct {
        Children [17]node // Actual trie node data to encode/decode (needs custom encoder)
        flags    nodeFlag
    }
    shortNode struct {
        Key   []byte
        Val   node
        flags nodeFlag
    }
    hashNode  []byte
    valueNode []byte
)
</code></pre>
<h4 id="node的方法"><a href="#node的方法" class="headerlink" title="node的方法"></a>node的方法</h4><h3 id="Trie：trie-go"><a href="#Trie：trie-go" class="headerlink" title="Trie：trie.go"></a>Trie：trie.go</h3><h4 id="Trie的结构"><a href="#Trie的结构" class="headerlink" title="Trie的结构"></a>Trie的结构</h4><p>root包含了当前的root节点， db是后端的KV存储，trie的结构最终都是需要通过KV的形式存储到数据库里面去，然后启动的时候是需要从数据库里面加载的。 originalRoot 启动加载的时候的hash值，通过这个hash值可以在数据库里面恢复出整颗的trie树。cachegen字段指示了当前Trie树的cache时代，每次调用Commit操作的时候，会增加Trie树的cache时代。 cache时代会被附加在node节点上面，如果当前的cache时代 - cachelimit参数 大于node的cache时代，那么node会从cache里面卸载，以便节约内存。 其实这就是缓存更新的LRU算法， 如果一个缓存在多久没有被使用，那么就从缓存里面移除，以节约内存空间。</p>
<pre><code class="go">// Trie is a Merkle Patricia Trie.
// The zero value is an empty trie with no database.
// Use New to create a trie that sits on top of a database.
//
// Trie is not safe for concurrent use.
type Trie struct {
    db   *Database
    root node
    // Keep track of the number leafs which have been inserted since the last
    // hashing operation. This number will not directly map to the number of
    // actually unhashed nodes
    unhashed int
}
</code></pre>
<h4 id="Trie的方法"><a href="#Trie的方法" class="headerlink" title="Trie的方法"></a>Trie的方法</h4><h5 id="1-Trie树的新建"><a href="#1-Trie树的新建" class="headerlink" title="1. Trie树的新建"></a>1. Trie树的新建</h5><p>Trie树的插入，查找和删除 Trie树的初始化调用New函数，函数接受一个hash值和一个Database参数，如果hash值不是空值的化，就说明是从数据库加载一个已经存在的Trie树， 就调用trei.resolveHash方法来加载整颗Trie树，这个方法后续会介绍。 如果root是空，那么就新建一颗Trie树返回</p>
<pre><code class="go">// New creates a trie with an existing root node from db.
//
// If root is the zero hash or the sha3 hash of an empty string, the
// trie is initially empty and does not require a database. Otherwise,
// New will panic if db is nil and returns a MissingNodeError if root does
// not exist in the database. Accessing the trie loads nodes from db on demand.
func New(root common.Hash, db *Database) (*Trie, error) {
    if db == nil {
        panic("trie.New called without a database")
    }
    trie := &amp;Trie{
        db: db,
    }
    if root != (common.Hash{}) &amp;&amp; root != emptyRoot {
        rootnode, err := trie.resolveHash(root[:], nil)
        if err != nil {
            return nil, err
        }
        trie.root = rootnode
    }
    return trie, nil
}
</code></pre>
<h5 id="2-Trie树的插入"><a href="#2-Trie树的插入" class="headerlink" title="2. Trie树的插入"></a>2. Trie树的插入</h5><p>Trie树的插入，这是一个递归调用的方法，从根节点开始，一直往下找，直到找到可以插入的点，进行插入操作。参数node是当前插入的节点， prefix是当前已经处理完的部分key， key是还没有处理玩的部分key, 完整的key = prefix + key。 value是需要插入的值。 返回值bool是操作是否改变了Trie树(dirty)，node是插入完成后的子树的根节点， error是错误信息。</p>
<ul>
<li><p>如果节点类型是nil(一颗全新的Trie树的节点就是nil的),这个时候整颗树是空的，直接返回shortNode{key, value, t.newFlag()}， 这个时候整颗树的跟就含有了一个shortNode节点。</p>
</li>
<li><p>如果当前的根节点类型是shortNode(也就是叶子节点)，首先计算公共前缀，如果公共前缀就等于key，那么说明这两个key是一样的，如果value也一样的(dirty == false)，那么返回错误。 如果没有错误就更新shortNode的值然后返回。如果公共前缀不完全匹配，那么就需要把公共前缀提取出来形成一个独立的节点(扩展节点),扩展节点后面连接一个branch节点，branch节点后面看情况连接两个short节点。首先构建一个branch节点(branch := &amp;fullNode{flags: t.newFlag()}),然后再branch节点的Children位置调用t.insert插入剩下的两个short节点。这里有个小细节，key的编码是HEX encoding,而且末尾带了一个终结符。考虑我们的根节点的key是abc0x16，我们插入的节点的key是ab0x16。下面的branch.Children[key[matchlen]]才可以正常运行，0x16刚好指向了branch节点的第17个孩子。如果匹配的长度是0，那么直接返回这个branch节点，否则返回shortNode节点作为前缀节点。</p>
</li>
<li><p>如果当前的节点是fullNode(也就是branch节点)，那么直接往对应的孩子节点调用insert方法,然后把对应的孩子节点只想新生成的节点。</p>
</li>
<li><p>如果当前节点是hashNode, hashNode的意思是当前节点还没有加载到内存里面来，还是存放在数据库里面，那么首先调用 t.resolveHash(n, prefix)来加载到内存，然后对加载出来的节点调用insert方法来进行插入。</p>
<pre><code class="go">func (t *Trie) insert(n node, prefix, key []byte, value node) (bool, node, error) {
  if len(key) == 0 {
      if v, ok := n.(valueNode); ok {
          return !bytes.Equal(v, value.(valueNode)), value, nil
      }
      return true, value, nil
  }
  switch n := n.(type) {
  case *shortNode:
      matchlen := prefixLen(key, n.Key)
      // If the whole key matches, keep this short node as is
      // and only update the value.
      if matchlen == len(n.Key) {
          dirty, nn, err := t.insert(n.Val, append(prefix, key[:matchlen]...), key[matchlen:], value)
          if !dirty || err != nil {
              return false, n, err
          }
          return true, &amp;shortNode{n.Key, nn, t.newFlag()}, nil
      }
      // Otherwise branch out at the index where they differ.
      branch := &amp;fullNode{flags: t.newFlag()}
      var err error
      _, branch.Children[n.Key[matchlen]], err = t.insert(nil, append(prefix, n.Key[:matchlen+1]...), n.Key[matchlen+1:], n.Val)
      if err != nil {
          return false, nil, err
      }
      _, branch.Children[key[matchlen]], err = t.insert(nil, append(prefix, key[:matchlen+1]...), key[matchlen+1:], value)
      if err != nil {
          return false, nil, err
      }
      // Replace this shortNode with the branch if it occurs at index 0.
      if matchlen == 0 {
          return true, branch, nil
      }
      // Otherwise, replace it with a short node leading up to the branch.
      return true, &amp;shortNode{key[:matchlen], branch, t.newFlag()}, nil

  case *fullNode:
      dirty, nn, err := t.insert(n.Children[key[0]], append(prefix, key[0]), key[1:], value)
      if !dirty || err != nil {
          return false, n, err
      }
      n = n.copy()
      n.flags = t.newFlag()
      n.Children[key[0]] = nn
      return true, n, nil

  case nil:
      return true, &amp;shortNode{key, value, t.newFlag()}, nil

  case hashNode:
      // We've hit a part of the trie that isn't loaded yet. Load
      // the node and insert into it. This leaves all child nodes on
      // the path to the value in the trie.
      rn, err := t.resolveHash(n, prefix)
      if err != nil {
          return false, nil, err
      }
      dirty, nn, err := t.insert(rn, prefix, key, value)
      if !dirty || err != nil {
          return false, rn, err
      }
      return true, nn, nil

  default:
      panic(fmt.Sprintf("%T: invalid node: %v", n, n))
  }
}
</code></pre>
<h5 id="3-Trie树的获取"><a href="#3-Trie树的获取" class="headerlink" title="3. Trie树的获取"></a>3. Trie树的获取</h5><p>Trie树的Get方法，基本上就是很简单的遍历Trie树，来获取Key的信息。</p>
<pre><code class="go">// Get returns the value for key stored in the trie.
// The value bytes must not be modified by the caller.
func (t *Trie) Get(key []byte) []byte {
  res, err := t.TryGet(key)
  if err != nil {
      log.Error(fmt.Sprintf("Unhandled trie error: %v", err))
  }
  return res
}
// TryGet returns the value for key stored in the trie.
// The value bytes must not be modified by the caller.
// If a node was not found in the database, a MissingNodeError is returned.
func (t *Trie) TryGet(key []byte) ([]byte, error) {
  value, newroot, didResolve, err := t.tryGet(t.root, keybytesToHex(key), 0)
  if err == nil &amp;&amp; didResolve {
      t.root = newroot
  }
  return value, err
}
func (t *Trie) tryGet(origNode node, key []byte, pos int) (value []byte, newnode node, didResolve bool, err error) {
  switch n := (origNode).(type) {
  case nil:
      return nil, nil, false, nil
  case valueNode:
      return n, n, false, nil
  case *shortNode:
      if len(key)-pos &lt; len(n.Key) || !bytes.Equal(n.Key, key[pos:pos+len(n.Key)]) {
          // key not found in trie
          return nil, n, false, nil
      }
      value, newnode, didResolve, err = t.tryGet(n.Val, key, pos+len(n.Key))
      if err == nil &amp;&amp; didResolve {
          n = n.copy()
          n.Val = newnode
      }
      return value, n, didResolve, err
  case *fullNode:
      value, newnode, didResolve, err = t.tryGet(n.Children[key[pos]], key, pos+1)
      if err == nil &amp;&amp; didResolve {
          n = n.copy()
          n.Children[key[pos]] = newnode
      }
      return value, n, didResolve, err
  case hashNode:
      child, err := t.resolveHash(n, key[:pos])
      if err != nil {
          return nil, n, true, err
      }
      value, newnode, _, err := t.tryGet(child, key, pos)
      return value, newnode, true, err
  default:
      panic(fmt.Sprintf("%T: invalid node: %v", origNode, origNode))
  }
}
// TryGetNode attempts to retrieve a trie node by compact-encoded path. It is not
// possible to use keybyte-encoding as the path might contain odd nibbles.
func (t *Trie) TryGetNode(path []byte) ([]byte, int, error) {
  item, newroot, resolved, err := t.tryGetNode(t.root, compactToHex(path), 0)
  if err != nil {
      return nil, resolved, err
  }
  if resolved &gt; 0 {
      t.root = newroot
  }
  if item == nil {
      return nil, resolved, nil
  }
  return item, resolved, err
}
func (t *Trie) tryGetNode(origNode node, path []byte, pos int) (item []byte, newnode node, resolved int, err error) {
  // If we reached the requested path, return the current node
  if pos &gt;= len(path) {
      // Although we most probably have the original node expanded, encoding
      // that into consensus form can be nasty (needs to cascade down) and
      // time consuming. Instead, just pull the hash up from disk directly.
      var hash hashNode
      if node, ok := origNode.(hashNode); ok {
          hash = node
      } else {
          hash, _ = origNode.cache()
      }
      if hash == nil {
          return nil, origNode, 0, errors.New("non-consensus node")
      }
      blob, err := t.db.Node(common.BytesToHash(hash))
      return blob, origNode, 1, err
  }
  // Path still needs to be traversed, descend into children
  switch n := (origNode).(type) {
  case nil:
      // Non-existent path requested, abort
      return nil, nil, 0, nil

  case valueNode:
      // Path prematurely ended, abort
      return nil, nil, 0, nil

  case *shortNode:
      if len(path)-pos &lt; len(n.Key) || !bytes.Equal(n.Key, path[pos:pos+len(n.Key)]) {
          // Path branches off from short node
          return nil, n, 0, nil
      }
      item, newnode, resolved, err = t.tryGetNode(n.Val, path, pos+len(n.Key))
      if err == nil &amp;&amp; resolved &gt; 0 {
          n = n.copy()
          n.Val = newnode
      }
      return item, n, resolved, err

  case *fullNode:
      item, newnode, resolved, err = t.tryGetNode(n.Children[path[pos]], path, pos+1)
      if err == nil &amp;&amp; resolved &gt; 0 {
          n = n.copy()
          n.Children[path[pos]] = newnode
      }
      return item, n, resolved, err

  case hashNode:
      child, err := t.resolveHash(n, path[:pos])
      if err != nil {
          return nil, n, 1, err
      }
      item, newnode, resolved, err := t.tryGetNode(child, path, pos)
      return item, newnode, resolved + 1, err

  default:
      panic(fmt.Sprintf("%T: invalid node: %v", origNode, origNode))
  }
}
</code></pre>
</li>
</ul>
<h5 id="4-Trie树的删除"><a href="#4-Trie树的删除" class="headerlink" title="4. Trie树的删除"></a>4. Trie树的删除</h5><p>代码跟插入比较类似</p>
<pre><code class="go">// Delete removes any existing value for key from the trie.
func (t *Trie) Delete(key []byte) {
    if err := t.TryDelete(key); err != nil {
        log.Error(fmt.Sprintf("Unhandled trie error: %v", err))
    }
}

// TryDelete removes any existing value for key from the trie.
// If a node was not found in the database, a MissingNodeError is returned.
func (t *Trie) TryDelete(key []byte) error {
    t.unhashed++
    k := keybytesToHex(key)
    _, n, err := t.delete(t.root, nil, k)
    if err != nil {
        return err
    }
    t.root = n
    return nil
}

// delete returns the new root of the trie with key deleted.
// It reduces the trie to minimal form by simplifying
// nodes on the way up after deleting recursively.
func (t *Trie) delete(n node, prefix, key []byte) (bool, node, error) {
    switch n := n.(type) {
    case *shortNode:
        matchlen := prefixLen(key, n.Key)
        if matchlen &lt; len(n.Key) {
            return false, n, nil // don't replace n on mismatch
        }
        if matchlen == len(key) {
            return true, nil, nil // remove n entirely for whole matches
        }
        // The key is longer than n.Key. Remove the remaining suffix
        // from the subtrie. Child can never be nil here since the
        // subtrie must contain at least two other values with keys
        // longer than n.Key.
        dirty, child, err := t.delete(n.Val, append(prefix, key[:len(n.Key)]...), key[len(n.Key):])
        if !dirty || err != nil {
            return false, n, err
        }
        switch child := child.(type) {
        case *shortNode:
            // Deleting from the subtrie reduced it to another
            // short node. Merge the nodes to avoid creating a
            // shortNode{..., shortNode{...}}. Use concat (which
            // always creates a new slice) instead of append to
            // avoid modifying n.Key since it might be shared with
            // other nodes.
            return true, &amp;shortNode{concat(n.Key, child.Key...), child.Val, t.newFlag()}, nil
        default:
            return true, &amp;shortNode{n.Key, child, t.newFlag()}, nil
        }

    case *fullNode:
        dirty, nn, err := t.delete(n.Children[key[0]], append(prefix, key[0]), key[1:])
        if !dirty || err != nil {
            return false, n, err
        }
        n = n.copy()
        n.flags = t.newFlag()
        n.Children[key[0]] = nn

        // Check how many non-nil entries are left after deleting and
        // reduce the full node to a short node if only one entry is
        // left. Since n must've contained at least two children
        // before deletion (otherwise it would not be a full node) n
        // can never be reduced to nil.
        //
        // When the loop is done, pos contains the index of the single
        // value that is left in n or -2 if n contains at least two
        // values.
        pos := -1
        for i, cld := range &amp;n.Children {
            if cld != nil {
                if pos == -1 {
                    pos = i
                } else {
                    pos = -2
                    break
                }
            }
        }
        if pos &gt;= 0 {
            if pos != 16 {
                // If the remaining entry is a short node, it replaces
                // n and its key gets the missing nibble tacked to the
                // front. This avoids creating an invalid
                // shortNode{..., shortNode{...}}.  Since the entry
                // might not be loaded yet, resolve it just for this
                // check.
                cnode, err := t.resolve(n.Children[pos], prefix)
                if err != nil {
                    return false, nil, err
                }
                if cnode, ok := cnode.(*shortNode); ok {
                    k := append([]byte{byte(pos)}, cnode.Key...)
                    return true, &amp;shortNode{k, cnode.Val, t.newFlag()}, nil
                }
            }
            // Otherwise, n is replaced by a one-nibble short node
            // containing the child.
            return true, &amp;shortNode{[]byte{byte(pos)}, n.Children[pos], t.newFlag()}, nil
        }
        // n still contains at least two values and cannot be reduced.
        return true, n, nil

    case valueNode:
        return true, nil, nil

    case nil:
        return false, nil, nil

    case hashNode:
        // We've hit a part of the trie that isn't loaded yet. Load
        // the node and delete from it. This leaves all child nodes on
        // the path to the value in the trie.
        rn, err := t.resolveHash(n, prefix)
        if err != nil {
            return false, nil, err
        }
        dirty, nn, err := t.delete(rn, prefix, key)
        if !dirty || err != nil {
            return false, rn, err
        }
        return true, nn, nil

    default:
        panic(fmt.Sprintf("%T: invalid node: %v (%v)", n, n, key))
    }
}
</code></pre>
<h5 id="5-Trie树的序列化和反序列化"><a href="#5-Trie树的序列化和反序列化" class="headerlink" title="5. Trie树的序列化和反序列化"></a>5. Trie树的序列化和反序列化</h5><p>序列化主要是指把内存表示的数据存放到数据库里面， 反序列化是指把数据库里面的Trie数据加载成内存表示的数据。 序列化的目的主要是方便存储，减少存储大小等。 反序列化的目的是把存储的数据加载到内存，方便Trie树的插入，查询，修改等需求。</p>
<p>Trie的序列化主要才作用了前面介绍的Compat Encoding和 RLP编码格式。 序列化的结构在黄皮书里面有详细的介绍。</p>
<p><img src="https://img-blog.csdnimg.cn/20210527171804758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MjU0Njk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Trie树的使用方法在trie_test.go里面有比较详细的参考。 这里我列出一个简单的使用流程。首先创建一个空的Trie树，然后插入一些数据，最后调用trie.Commit()方法进行序列化并得到一个hash值(root), 也就是上图中的KEC(c(J,0))或者是TRIE(J)。</p>
<pre><code class="go">func TestInsert(t *testing.T) {
    trie := newEmpty()

    updateString(trie, "doe", "reindeer")
    updateString(trie, "dog", "puppy")
    updateString(trie, "dogglesworth", "cat")

    exp := common.HexToHash("8aad789dff2f538bca5d8ea56e8abe10f4c7ba3a5dea95fea4cd6e7c3a1168d3")
    root := trie.Hash()
    if root != exp {
        t.Errorf("case 1: exp %x got %x", exp, root)
    }

    trie = newEmpty()
    updateString(trie, "A", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")

    exp = common.HexToHash("d23786fb4a010da3ce639d66d5e904a11dbc02746d1ce25029e53290cabf28ab")
    root, err := trie.Commit(nil)
    if err != nil {
        t.Fatalf("commit error: %v", err)
    }
    if root != exp {
        t.Errorf("case 2: exp %x got %x", exp, root)
    }
}
</code></pre>
<p>下面我们来分析下Commit()的主要流程。 经过一系列的调用，最终调用了hasher.go的hash方法。</p>
<pre><code class="go">// Commit writes all nodes to the trie's memory database, tracking the internal
// and external (for account tries) references.
func (t *Trie) Commit(onleaf LeafCallback) (root common.Hash, err error) {
    if t.db == nil {
        panic("commit called on trie with nil database")
    }
    if t.root == nil {
        return emptyRoot, nil
    }
    // Derive the hash for all dirty nodes first. We hold the assumption
    // in the following procedure that all nodes are hashed.
    rootHash := t.Hash()
    h := newCommitter()
    defer returnCommitterToPool(h)

    // Do a quick check if we really need to commit, before we spin
    // up goroutines. This can happen e.g. if we load a trie for reading storage
    // values, but don't write to it.
    if _, dirty := t.root.cache(); !dirty {
        return rootHash, nil
    }
    var wg sync.WaitGroup
    if onleaf != nil {
        h.onleaf = onleaf
        h.leafCh = make(chan *leaf, leafChanSize)
        wg.Add(1)
        go func() {
            defer wg.Done()
            h.commitLoop(t.db)
        }()
    }
    var newRoot hashNode
    newRoot, err = h.Commit(t.root, t.db)
    if onleaf != nil {
        // The leafch is created in newCommitter if there was an onleaf callback
        // provided. The commitLoop only _reads_ from it, and the commit
        // operation was the sole writer. Therefore, it's safe to close this
        // channel here.
        close(h.leafCh)
        wg.Wait()
    }
    if err != nil {
        return common.Hash{}, err
    }
    t.root = newRoot
    return rootHash, nil
}

// Hash returns the root hash of the trie. It does not write to the
// database and can be used even if the trie doesn't have one.
func (t *Trie) Hash() common.Hash {
    hash, cached, _ := t.hashRoot()
    t.root = cached
    return common.BytesToHash(hash.(hashNode))
}
</code></pre>
<p>下面我们简单介绍下hash方法，hash方法主要做了两个操作。 一个是保留原有的树形结构，并用cache变量中， 另一个是计算原有树形结构的hash并把hash值存放到cache变量中保存下来。</p>
<p>计算原有hash值的主要流程：</p>
<ul>
<li>如果当前节点是shortNode, 调用h.hashShortNodeChildren(n)把所有的子节点的hash值求出来，把原有的子节点替换成子节点的hash值。 这是一个递归调用的过程，会从树叶依次往上计算直到树根。然后调用shortnodeToHash方法计算当前节点的hash值，并把当前节点的hash值放入cache节点，然后返回。</li>
<li>如果当前节点是fullNode, 调用h.hashFullNodeChildren(n)把所有的子节点的hash值求出来，把原有的子节点替换成子节点的hash值。 这是一个递归调用的过程，会从树叶依次往上计算直到树根。然后调用fullnodeToHash方法计算当前节点的hash值，并把当前节点的hash值放入cache节点，然后返回。</li>
<li>否则的话这个节点没有children。直接返回。<br>返回值说明， cache变量包含了原有的node节点，并且包含了node节点的hash值。 hash变量返回了当前节点的hash值(这个值其实是根据node和node的所有子节点计算出来的)。</li>
</ul>
<p>有一个小细节： 根节点调用hash函数的时候， force参数是为true的，其他的子节点调用的时候force参数是为false的。 force参数的用途是当||c(J,i)||&lt;32的时候也对c(J,i)进行hash计算，这样保证无论如何也会对根节点进行Hash计算。</p>
<pre><code class="go">// hash collapses a node down into a hash node, also returning a copy of the
// original node initialized with the computed hash to replace the original one.
func (h *hasher) hash(n node, force bool) (hashed node, cached node) {
    // Return the cached hash if it's available
    if hash, _ := n.cache(); hash != nil {
        return hash, n
    }
    // Trie not processed yet, walk the children
    switch n := n.(type) {
    case *shortNode:
        collapsed, cached := h.hashShortNodeChildren(n)
        hashed := h.shortnodeToHash(collapsed, force)
        // We need to retain the possibly _not_ hashed node, in case it was too
        // small to be hashed
        if hn, ok := hashed.(hashNode); ok {
            cached.flags.hash = hn
        } else {
            cached.flags.hash = nil
        }
        return hashed, cached
    case *fullNode:
        collapsed, cached := h.hashFullNodeChildren(n)
        hashed = h.fullnodeToHash(collapsed, force)
        if hn, ok := hashed.(hashNode); ok {
            cached.flags.hash = hn
        } else {
            cached.flags.hash = nil
        }
        return hashed, cached
    default:
        // Value and hash nodes don't have children so they're left as were
        return n, n
    }
}

// shortnodeToHash creates a hashNode from a shortNode. The supplied shortnode
// should have hex-type Key, which will be converted (without modification)
// into compact form for RLP encoding.
// If the rlp data is smaller than 32 bytes, `nil` is returned.
func (h *hasher) shortnodeToHash(n *shortNode, force bool) node {
    h.tmp.Reset()
    if err := rlp.Encode(&amp;h.tmp, n); err != nil {
        panic("encode error: " + err.Error())
    }

    if len(h.tmp) &lt; 32 &amp;&amp; !force {
        return n // Nodes smaller than 32 bytes are stored inside their parent
    }
    return h.hashData(h.tmp)
}
</code></pre>
<p>hashShortNodeChildren方法,这个方法把所有的子节点替换成他们的hash，可以看到cache变量接管了原来的Trie树的完整结构，collapsed变量把子节点替换成子节点的hash值。<br>首先把collapsed.Key从Hex Encoding 替换成 Compact Encoding, 然后递归调用hash方法计算子节点的hash和cache，这样就把子节点替换成了子节点的hash值。</p>
<pre><code class="go">// hashShortNodeChildren collapses the short node. The returned collapsed node
// holds a live reference to the Key, and must not be modified.
// The cached
func (h *hasher) hashShortNodeChildren(n *shortNode) (collapsed, cached *shortNode) {
    // Hash the short node's child, caching the newly hashed subtree
    collapsed, cached = n.copy(), n.copy()
    // Previously, we did copy this one. We don't seem to need to actually
    // do that, since we don't overwrite/reuse keys
    //cached.Key = common.CopyBytes(n.Key)
    collapsed.Key = hexToCompact(n.Key)
    // Unless the child is a valuenode or hashnode, hash it
    switch n.Val.(type) {
    case *fullNode, *shortNode:
        collapsed.Val, cached.Val = h.hash(n.Val, false)
    }
    return collapsed, cached
}
</code></pre>
<p>hashFullNodeChildren方法,这个方法遍历每个子节点，把子节点替换成子节点的Hash值。</p>
<pre><code class="go">func (h *hasher) hashFullNodeChildren(n *fullNode) (collapsed *fullNode, cached *fullNode) {
    // Hash the full node's children, caching the newly hashed subtrees
    cached = n.copy()
    collapsed = n.copy()
    if h.parallel {
        var wg sync.WaitGroup
        wg.Add(16)
        for i := 0; i &lt; 16; i++ {
            go func(i int) {
                hasher := newHasher(false)
                if child := n.Children[i]; child != nil {
                    collapsed.Children[i], cached.Children[i] = hasher.hash(child, false)
                } else {
                    collapsed.Children[i] = nilValueNode
                }
                returnHasherToPool(hasher)
                wg.Done()
            }(i)
        }
        wg.Wait()
    } else {
        for i := 0; i &lt; 16; i++ {
            if child := n.Children[i]; child != nil {
                collapsed.Children[i], cached.Children[i] = h.hash(child, false)
            } else {
                collapsed.Children[i] = nilValueNode
            }
        }
    }
    return collapsed, cached
}
</code></pre>
<p>fullnodeToHash方法和shortnodeToHash方法：<br>直接调用rlp.Encode方法对这个节点进行编码（此时认为node的所有子节点都替换成了子节点的hash值）</p>
<p>如果编码后的值小于32，并且这个节点不是根节点，那么就把他们直接存储在他们的父节点里面，否则调用h.sha.Write方法进行hash计算， 然后把hash值和编码后的数据存储到数据库里面，然后返回hash值。</p>
<p>可以看到每个值大于32的节点的值和hash都存储到了数据库里面。</p>
<pre><code class="go">// shortnodeToHash creates a hashNode from a shortNode. The supplied shortnode
// should have hex-type Key, which will be converted (without modification)
// into compact form for RLP encoding.
// If the rlp data is smaller than 32 bytes, `nil` is returned.
func (h *hasher) shortnodeToHash(n *shortNode, force bool) node {
    h.tmp.Reset()
    if err := rlp.Encode(&amp;h.tmp, n); err != nil {
        panic("encode error: " + err.Error())
    }

    if len(h.tmp) &lt; 32 &amp;&amp; !force {
        return n // Nodes smaller than 32 bytes are stored inside their parent
    }
    return h.hashData(h.tmp)
}

// shortnodeToHash is used to creates a hashNode from a set of hashNodes, (which
// may contain nil values)
func (h *hasher) fullnodeToHash(n *fullNode, force bool) node {
    h.tmp.Reset()
    // Generate the RLP encoding of the node
    if err := n.EncodeRLP(&amp;h.tmp); err != nil {
        panic("encode error: " + err.Error())
    }

    if len(h.tmp) &lt; 32 &amp;&amp; !force {
        return n // Nodes smaller than 32 bytes are stored inside their parent
    }
    return h.hashData(h.tmp)
}
</code></pre>
<p>Trie的反序列化过程。还记得之前创建Trie树的流程么。 如果参数root的hash值不为空，那么就会调用rootnode, err := trie.resolveHash(root[:], nil) 方法来得到rootnode节点。</p>
<p>首先从数据库里面通过hash值获取节点的RLP编码后的内容。 然后调用decodeNode来解析内容。</p>
<pre><code class="go">func (it *nodeIterator) resolveHash(hash hashNode, path []byte) (node, error) {
    if it.resolver != nil {
        if blob, err := it.resolver.Get(hash); err == nil &amp;&amp; len(blob) &gt; 0 {
            if resolved, err := decodeNode(hash, blob); err == nil {
                return resolved, nil
            }
        }
    }
    resolved, err := it.trie.resolveHash(hash, path)
    return resolved, err
}
</code></pre>
<p>decodeNode方法，这个方法根据rlp的list的长度来判断这个编码到底属于什么节点，如果是2个字段那么就是shortNode节点，如果是17个字段，那么就是fullNode，然后分别调用各自的解析函数。</p>
<pre><code class="go">// decodeNode parses the RLP encoding of a trie node.
func decodeNode(hash, buf []byte, cachegen uint16) (node, error) {
    if len(buf) == 0 {
        return nil, io.ErrUnexpectedEOF
    }
    elems, _, err := rlp.SplitList(buf)
    if err != nil {
        return nil, fmt.Errorf("decode error: %v", err)
    }
    switch c, _ := rlp.CountValues(elems); c {
    case 2:
        n, err := decodeShort(hash, elems)
        return n, wrapError(err, "short")
    case 17:
        n, err := decodeFull(hash, elems)
        return n, wrapError(err, "full")
    default:
        return nil, fmt.Errorf("invalid number of list elements: %v", c)
    }
}
</code></pre>
<p>decodeShort方法，通过key是否有终结符号来判断到底是叶子节点还是中间节点。如果有终结符那么就是叶子结点，通过SplitString方法解析出来val然后生成一个shortNode。 不过没有终结符，那么说明是扩展节点， 通过decodeRef来解析剩下的节点，然后生成一个shortNode。</p>
<pre><code class="go">func decodeShort(hash, buf, elems []byte, cachegen uint16) (node, error) {
    kbuf, rest, err := rlp.SplitString(elems)
    if err != nil {
        return nil, err
    }
    flag := nodeFlag{hash: hash}
    key := compactToHex(kbuf)
    if hasTerm(key) {
        // value node
        val, _, err := rlp.SplitString(rest)
        if err != nil {
            return nil, fmt.Errorf("invalid value node: %v", err)
        }
        return &amp;shortNode{key, append(valueNode{}, val...), flag}, nil
    }
    r, _, err := decodeRef(rest)
    if err != nil {
        return nil, wrapError(err, "val")
    }
    return &amp;shortNode{key, r, flag}, nil
}
</code></pre>
<p>decodeRef方法根据数据类型进行解析，如果类型是list，那么有可能是内容&lt;32的值，那么调用decodeNode进行解析。 如果是空节点，那么返回空，如果是hash值，那么构造一个hashNode进行返回，注意的是这里没有继续进行解析，如果需要继续解析这个hashNode，那么需要继续调用resolveHash方法。 到这里decodeShort方法就调用完成了。</p>
<pre><code class="go">func decodeRef(buf []byte, cachegen uint16) (node, []byte, error) {
    kind, val, rest, err := rlp.Split(buf)
    if err != nil {
        return nil, buf, err
    }
    switch {
    case kind == rlp.List:
        // 'embedded' node reference. The encoding must be smaller
        // than a hash in order to be valid.
        if size := len(buf) - len(rest); size &gt; hashLen {
            err := fmt.Errorf("oversized embedded node (size is %d bytes, want size &lt; %d)", size, hashLen)
            return nil, buf, err
        }
        n, err := decodeNode(nil, buf)
        return n, rest, err
    case kind == rlp.String &amp;&amp; len(val) == 0:
        // empty node
        return nil, rest, nil
    case kind == rlp.String &amp;&amp; len(val) == 32:
        return append(hashNode{}, val...), rest, nil
    default:
        return nil, nil, fmt.Errorf("invalid RLP string size %d (want 0 or 32)", len(val))
    }
}
</code></pre>
<p>decodeFull方法。根decodeShort方法的流程差不多。</p>
<pre><code class="go">func decodeFull(hash, buf, elems []byte, cachegen uint16) (*fullNode, error) {
    n := &amp;fullNode{flags: nodeFlag{hash: hash}}
    for i := 0; i &lt; 16; i++ {
        cld, rest, err := decodeRef(elems)
        if err != nil {
            return n, wrapError(err, fmt.Sprintf("[%d]", i))
        }
        n.Children[i], elems = cld, rest
    }
    val, _, err := rlp.SplitString(elems)
    if err != nil {
        return n, err
    }
    if len(val) &gt; 0 {
        n.Children[16] = append(valueNode{}, val...)
    }
    return n, nil
}
</code></pre>
<h2 id="Trie树的默克尔证明：proof-go"><a href="#Trie树的默克尔证明：proof-go" class="headerlink" title="Trie树的默克尔证明：proof.go"></a>Trie树的默克尔证明：proof.go</h2><p>主要提供两个方法，Prove方法获取指定Key的proof证明， proof证明是从根节点到叶子节点的所有节点的hash值列表。 VerifyProof方法，接受一个roothash值和proof证明和key来验证key是否存在。</p>
<p>Prove方法，从根节点开始。把经过的节点的hash值一个一个存入到list中。然后返回。</p>
<pre><code class="go">// Prove constructs a merkle proof for key. The result contains all encoded nodes
// on the path to the value at key. The value itself is also included in the last
// node and can be retrieved by verifying the proof.
//
// If the trie does not contain a value for key, the returned proof contains all
// nodes of the longest existing prefix of the key (at least the root node), ending
// with the node that proves the absence of the key.
func (t *Trie) Prove(key []byte, fromLevel uint, proofDb ethdb.KeyValueWriter) error {
    // Collect all nodes on the path to key.
    key = keybytesToHex(key)
    var nodes []node
    tn := t.root
    for len(key) &gt; 0 &amp;&amp; tn != nil {
        switch n := tn.(type) {
        case *shortNode:
            if len(key) &lt; len(n.Key) || !bytes.Equal(n.Key, key[:len(n.Key)]) {
                // The trie doesn't contain the key.
                tn = nil
            } else {
                tn = n.Val
                key = key[len(n.Key):]
            }
            nodes = append(nodes, n)
        case *fullNode:
            tn = n.Children[key[0]]
            key = key[1:]
            nodes = append(nodes, n)
        case hashNode:
            var err error
            tn, err = t.resolveHash(n, nil)
            if err != nil {
                log.Error(fmt.Sprintf("Unhandled trie error: %v", err))
                return err
            }
        default:
            panic(fmt.Sprintf("%T: invalid node: %v", tn, tn))
        }
    }
    hasher := newHasher(false)
    defer returnHasherToPool(hasher)

    for i, n := range nodes {
        if fromLevel &gt; 0 {
            fromLevel--
            continue
        }
        var hn node
        n, hn = hasher.proofHash(n)
        if hash, ok := hn.(hashNode); ok || i == 0 {
            // If the node's database encoding is a hash (or is the
            // root node), it becomes a proof element.
            enc, _ := rlp.EncodeToBytes(n)
            if !ok {
                hash = hasher.hashData(enc)
            }
            proofDb.Put(hash, enc)
        }
    }
    return nil
}
</code></pre>
<p>VerifyProof方法，接收一个rootHash参数，key参数，和KeyValueReader， 来一个一个验证是否能够和数据库里面的能够对应上。</p>
<pre><code class="go">// VerifyProof checks merkle proofs. The given proof must contain the value for
// key in a trie with the given root hash. VerifyProof returns an error if the
// proof contains invalid trie nodes or the wrong value.
func VerifyProof(rootHash common.Hash, key []byte, proofDb ethdb.KeyValueReader) (value []byte, err error) {
    key = keybytesToHex(key)
    wantHash := rootHash
    for i := 0; ; i++ {
        buf, _ := proofDb.Get(wantHash[:])
        if buf == nil {
            return nil, fmt.Errorf("proof node %d (hash %064x) missing", i, wantHash)
        }
        n, err := decodeNode(wantHash[:], buf)
        if err != nil {
            return nil, fmt.Errorf("bad proof node %d: %v", i, err)
        }
        keyrest, cld := get(n, key, true)
        switch cld := cld.(type) {
        case nil:
            // The trie doesn't contain the key.
            return nil, nil
        case hashNode:
            key = keyrest
            copy(wantHash[:], cld)
        case valueNode:
            return cld, nil
        }
    }
}

// get returns the child of the given node. Return nil if the
// node with specified key doesn't exist at all.
//
// There is an additional flag `skipResolved`. If it's set then
// all resolved nodes won't be returned.
func get(tn node, key []byte, skipResolved bool) ([]byte, node) {
    for {
        switch n := tn.(type) {
        case *shortNode:
            if len(key) &lt; len(n.Key) || !bytes.Equal(n.Key, key[:len(n.Key)]) {
                return nil, nil
            }
            tn = n.Val
            key = key[len(n.Key):]
            if !skipResolved {
                return key, tn
            }
        case *fullNode:
            tn = n.Children[key[0]]
            key = key[1:]
            if !skipResolved {
                return key, tn
            }
        case hashNode:
            return key, n
        case nil:
            return key, nil
        case valueNode:
            return nil, n
        default:
            panic(fmt.Sprintf("%T: invalid node: %v", tn, tn))
        }
    }
}
</code></pre>
<h2 id="Trie的加密：security-trie-go"><a href="#Trie的加密：security-trie-go" class="headerlink" title="Trie的加密：security_trie.go"></a>Trie的加密：security_trie.go</h2><p>为了避免刻意使用很长的key导致访问时间的增加， security_trie包装了一下trie树， 所有的key都转换成keccak256算法计算的hash值。同时在数据库里面存储hash值对应的原始的key。</p>
<pre><code class="go">// SecureTrie wraps a trie with key hashing. In a secure trie, all
// access operations hash the key using keccak256. This prevents
// calling code from creating long chains of nodes that
// increase the access time.
//
// Contrary to a regular trie, a SecureTrie can only be created with
// New and must have an attached database. The database also stores
// the preimage of each key.
//
// SecureTrie is not safe for concurrent use.
type SecureTrie struct {
    trie             Trie
    hashKeyBuf       [common.HashLength]byte
    secKeyCache      map[string][]byte
    secKeyCacheOwner *SecureTrie // Pointer to self, replace the key cache on mismatch
}

// NewSecure creates a trie with an existing root node from a backing database
// and optional intermediate in-memory node pool.
//
// If root is the zero hash or the sha3 hash of an empty string, the
// trie is initially empty. Otherwise, New will panic if db is nil
// and returns MissingNodeError if the root node cannot be found.
//
// Accessing the trie loads nodes from the database or node pool on demand.
// Loaded nodes are kept around until their 'cache generation' expires.
// A new cache generation is created by each call to Commit.
// cachelimit sets the number of past cache generations to keep.
func NewSecure(root common.Hash, db *Database) (*SecureTrie, error) {
    if db == nil {
        panic("trie.NewSecure called without a database")
    }
    trie, err := New(root, db)
    if err != nil {
        return nil, err
    }
    return &amp;SecureTrie{trie: *trie}, nil
}

// Get returns the value for key stored in the trie.
// The value bytes must not be modified by the caller.
func (t *SecureTrie) Get(key []byte) []byte {
    res, err := t.TryGet(key)
    if err != nil {
        log.Error(fmt.Sprintf("Unhandled trie error: %v", err))
    }
    return res
}
// TryGet returns the value for key stored in the trie.
// The value bytes must not be modified by the caller.
// If a node was not found in the database, a MissingNodeError is returned.
func (t *SecureTrie) TryGet(key []byte) ([]byte, error) {
    return t.trie.TryGet(t.hashKey(key))
}
// Commit writes all nodes and the secure hash pre-images to the trie's database.
// Nodes are stored with their sha3 hash as the key.
//
// Committing flushes nodes from memory. Subsequent Get calls will load nodes
// from the database.
func (t *SecureTrie) Commit(onleaf LeafCallback) (root common.Hash, err error) {
    // Write all the pre-images to the actual disk database
    if len(t.getSecKeyCache()) &gt; 0 {
        if t.trie.db.preimages != nil { // Ugly direct check but avoids the below write lock
            t.trie.db.lock.Lock()
            for hk, key := range t.secKeyCache {
                t.trie.db.insertPreimage(common.BytesToHash([]byte(hk)), key)
            }
            t.trie.db.lock.Unlock()
        }
        t.secKeyCache = make(map[string][]byte)
    }
    // Commit the trie to its intermediate node database
    return t.trie.Commit(onleaf)
}
</code></pre>
<h2 id="trie包中其他的功能"><a href="#trie包中其他的功能" class="headerlink" title="trie包中其他的功能"></a>trie包中其他的功能</h2><ul>
<li>databases.go trie数据结构和磁盘数据库之间的一个写入层，方便trie中节点的插入删除操作</li>
<li>iterator.go 遍历Trie的键值迭代器</li>
</ul>
<h1 id="参考资料地址"><a href="#参考资料地址" class="headerlink" title="参考资料地址"></a>参考资料地址</h1><ul>
<li><a target="_blank" rel="noopener" href="https://ethereum.org/en/whitepaper">以太坊白皮书</a></li>
<li><a target="_blank" rel="noopener" href="https://ethereum.github.io/yellowpaper/paper.pdf">以太坊黄皮书（英文版）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/wanshan1024/ethereum_yellowpaper/blob/master/ethereum_yellow_paper_cn.pdf">以太坊黄皮书（中文版）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ZtesoftCS/go-ethereum-code-analysis">分析参考资料</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016050921">博客参考资料</a></li>
</ul>
<!-- flag of hidden posts --></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em></section><article class="mt-6 comment-container"><script async repo="zhangzhishun/blockchain-blog-comment" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/zhang_zhishun"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/zhangzhishun"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Sugar 2022</span></p><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>