<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sugar&#39;s blog</title>
  
  <subtitle>一杯糖不加咖啡 Sugar 区块链博客 计算机博客</subtitle>
  <link href="https://zhangzhishun.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhangzhishun.github.io/"/>
  <updated>2022-05-18T13:29:32.346Z</updated>
  <id>https://zhangzhishun.github.io/</id>
  
  <author>
    <name>Sugar</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NFT框架 OpenZeppelin合约源码介绍</title>
    <link href="https://zhangzhishun.github.io/2022/05/25/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelin%E5%90%88%E7%BA%A6%E6%BA%90%E7%A0%81%E4%BB%8B%E7%BB%8D/"/>
    <id>https://zhangzhishun.github.io/2022/05/25/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelin%E5%90%88%E7%BA%A6%E6%BA%90%E7%A0%81%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-05-25T02:25:11.000Z</published>
    <updated>2022-05-18T13:29:32.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><h2 id="1-代码版本"><a href="#1-代码版本" class="headerlink" title="1. 代码版本"></a>1. 代码版本</h2><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/release-v4.6">release-v4.6</a></p><p>TBD</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h1&gt;&lt;h2 id=&quot;1-代码版本&quot;&gt;&lt;a href=&quot;#1-代码版本&quot; class=&quot;headerlink&quot; title=&quot;1. 代码</summary>
      
    
    
    
    
    <category term="NFT" scheme="https://zhangzhishun.github.io/tags/NFT/"/>
    
    <category term="OpenZeppelin" scheme="https://zhangzhishun.github.io/tags/OpenZeppelin/"/>
    
  </entry>
  
  <entry>
    <title>NFT框架 OpenZeppelin ERC721源码分析</title>
    <link href="https://zhangzhishun.github.io/2022/05/19/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelinERC721%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://zhangzhishun.github.io/2022/05/19/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelinERC721%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-05-19T02:25:11.000Z</published>
    <updated>2022-05-18T13:17:43.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><h2 id="1-代码版本"><a href="#1-代码版本" class="headerlink" title="1. 代码版本"></a>1. 代码版本</h2><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/release-v4.6">release-v4.6</a></p><h2 id="2-什么是ERC721？"><a href="#2-什么是ERC721？" class="headerlink" title="2. 什么是ERC721？"></a>2. 什么是ERC721？</h2><p>ERC-721 为 NFT 引入了一个标准，换言之， 这种类型的代币是独一无二的</p><h1 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h1><h2 id="ERC20涉及到的合约列表"><a href="#ERC20涉及到的合约列表" class="headerlink" title="ERC20涉及到的合约列表"></a>ERC20涉及到的合约列表</h2><ul><li>Context</li><li>IERC165、ERC165</li><li>IERC721Metadata</li><li>IERC721</li><li>ERC721</li></ul><h2 id="1-Context"><a href="#1-Context" class="headerlink" title="1. Context"></a>1. Context</h2><p>参考： <a href="/2022/05/18/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelinERC20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="NFT框架 OpenZeppelin ERC20源码分析">NFT框架 OpenZeppelin ERC20源码分析</a></p><h2 id="2-IERC165、ERC165"><a href="#2-IERC165、ERC165" class="headerlink" title="2. IERC165、ERC165"></a>2. IERC165、ERC165</h2><pre><code class="solidity">// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)pragma solidity ^0.8.0;/** * @dev ERC165 标准的接口，如https://eips.ethereum.org/EIPS/eip-165[EIP] * * 实现者可以声明对合约接口的支持，然后可以被其他人查询（{ERC165Checker}） * * 有关实现，请参阅 {ERC165} */interface IERC165 {    /**     * @dev 如果此合约通过`interfaceId`实现了定义的接口，则返回 true     * 见对应：https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP部分]了解有关如何创建这些 ID 的更多信息。     *     * 此函数调用必须使用少于 30 000 个气体     */    function supportsInterface(bytes4 interfaceId) external view returns (bool);}// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)pragma solidity ^0.8.0;import "./IERC165.sol";/** * @dev {IERC165}接口的实现。 * * 想要实现 ERC165 的合约应该从这个合约继承并覆盖 {supportsInterface} 来检查用于将支持的附加接口 ID。例如： * * ```solidity * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); * } * ``` * * 或者，{ERC165Storage} 提供了一种更易于使用但更昂贵的实现方式 */abstract contract ERC165 is IERC165 {    /**     * @dev See {IERC165-supportsInterface}.     */    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {        return interfaceId == type(IERC165).interfaceId;    }}</code></pre><h2 id="3-IERC721Metadata"><a href="#3-IERC721Metadata" class="headerlink" title="3. IERC721Metadata"></a>3. IERC721Metadata</h2><pre><code class="solidity">// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)pragma solidity ^0.8.0;import "../IERC721.sol";/** * @title ERC-721 Non-Fungible Token Standard, optional metadata extension * @dev See https://eips.ethereum.org/EIPS/eip-721 */interface IERC721Metadata is IERC721 {    /**     * @dev Returns the token collection name.     */    function name() external view returns (string memory);    /**     * @dev Returns the token collection symbol.     */    function symbol() external view returns (string memory);    /**     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.     */    function tokenURI(uint256 tokenId) external view returns (string memory);}</code></pre><h2 id="4-IERC721"><a href="#4-IERC721" class="headerlink" title="4. IERC721"></a>4. IERC721</h2><pre><code class="solidity">// SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)pragma solidity ^0.8.0;import "../../utils/introspection/IERC165.sol";/** * @dev Required interface of an ERC721 compliant contract. */interface IERC721 is IERC165 {    /**     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.     */    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);    /**     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.     */    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);    /**     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.     */    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);    /**     * @dev Returns the number of tokens in ``owner``'s account.     */    function balanceOf(address owner) external view returns (uint256 balance);    /**     * @dev Returns the owner of the `tokenId` token.     *     * Requirements:     *     * - `tokenId` must exist.     */    function ownerOf(uint256 tokenId) external view returns (address owner);    /**     * @dev Safely transfers `tokenId` token from `from` to `to`.     *     * Requirements:     *     * - `from` cannot be the zero address.     * - `to` cannot be the zero address.     * - `tokenId` token must exist and be owned by `from`.     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.     *     * Emits a {Transfer} event.     */    function safeTransferFrom(        address from,        address to,        uint256 tokenId,        bytes calldata data    ) external;    /**     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients     * are aware of the ERC721 protocol to prevent tokens from being forever locked.     *     * Requirements:     *     * - `from` cannot be the zero address.     * - `to` cannot be the zero address.     * - `tokenId` token must exist and be owned by `from`.     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.     *     * Emits a {Transfer} event.     */    function safeTransferFrom(        address from,        address to,        uint256 tokenId    ) external;    /**     * @dev Transfers `tokenId` token from `from` to `to`.     *     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.     *     * Requirements:     *     * - `from` cannot be the zero address.     * - `to` cannot be the zero address.     * - `tokenId` token must be owned by `from`.     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.     *     * Emits a {Transfer} event.     */    function transferFrom(        address from,        address to,        uint256 tokenId    ) external;    /**     * @dev Gives permission to `to` to transfer `tokenId` token to another account.     * The approval is cleared when the token is transferred.     *     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.     *     * Requirements:     *     * - The caller must own the token or be an approved operator.     * - `tokenId` must exist.     *     * Emits an {Approval} event.     */    function approve(address to, uint256 tokenId) external;    /**     * @dev Approve or remove `operator` as an operator for the caller.     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.     *     * Requirements:     *     * - The `operator` cannot be the caller.     *     * Emits an {ApprovalForAll} event.     */    function setApprovalForAll(address operator, bool _approved) external;    /**     * @dev Returns the account approved for `tokenId` token.     *     * Requirements:     *     * - `tokenId` must exist.     */    function getApproved(uint256 tokenId) external view returns (address operator);    /**     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.     *     * See {setApprovalForAll}     */    function isApprovedForAll(address owner, address operator) external view returns (bool);}</code></pre><h2 id="5-ERC721"><a href="#5-ERC721" class="headerlink" title="5. ERC721"></a>5. ERC721</h2><p>ERC-721不可替代令牌标准的可选枚举扩展。</p><p>主要方法：</p><p>ERC721合约定义了基本的接口方法：</p><ul><li><p>safeTransferFrom：转移代币所有权</p></li><li><p>transferFrom：转移代币所有权</p></li><li><p>setApprovalForAll：授权operator具有所有代币的控制权</p></li><li><p>balanceOf：返回owner的代币数量</p></li><li><p>ownerOf：根据tokenId返回代币持有者address</p></li><li><p>getApproved：查询tokenId的授权人operator address</p></li><li><p>approve 授权tokenId给地址to</p></li><li><p>isApprovedForAll：查询一个地址是否为另一个地址的授权操作者。</p></li><li><p>totalSupply：返回由此契约跟踪的有效nft的计数（代币总量），其中每个nft都有一个分配的、可查询的所有者，且所有者不等于零地址</p></li><li><p>tokenByIndex：返回第index的NFT的tokenId。没有指定排序顺序。</p></li><li><p>tokenOfOwnerByIndex：返回分配给指定人的第index的NFT的tokenId。没有指定排序顺序</p></li></ul><p>源码：</p><pre><code class="solidity">// SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)pragma solidity ^0.8.0;import "./IERC721.sol";import "./IERC721Receiver.sol";import "./extensions/IERC721Metadata.sol";import "../../utils/Address.sol";import "../../utils/Context.sol";import "../../utils/Strings.sol";import "../../utils/introspection/ERC165.sol";/** * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including * the Metadata extension, but not including the Enumerable extension, which is available separately as * {ERC721Enumerable}. */contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {    using Address for address;    using Strings for uint256;    // Token name    string private _name;    // Token symbol    string private _symbol;    // Mapping from token ID to owner address    mapping(uint256 =&gt; address) private _owners;    // Mapping owner address to token count    mapping(address =&gt; uint256) private _balances;    // Mapping from token ID to approved address    mapping(uint256 =&gt; address) private _tokenApprovals;    // Mapping from owner to operator approvals    mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;    /**     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.     */    constructor(string memory name_, string memory symbol_) {        _name = name_;        _symbol = symbol_;    }    /**     * @dev See {IERC165-supportsInterface}.     */    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {        return            interfaceId == type(IERC721).interfaceId ||            interfaceId == type(IERC721Metadata).interfaceId ||            super.supportsInterface(interfaceId);    }    /**     * @dev See {IERC721-balanceOf}.     */    function balanceOf(address owner) public view virtual override returns (uint256) {        require(owner != address(0), "ERC721: balance query for the zero address");        return _balances[owner];    }    /**     * @dev See {IERC721-ownerOf}.     */    function ownerOf(uint256 tokenId) public view virtual override returns (address) {        address owner = _owners[tokenId];        require(owner != address(0), "ERC721: owner query for nonexistent token");        return owner;    }    /**     * @dev See {IERC721Metadata-name}.     */    function name() public view virtual override returns (string memory) {        return _name;    }    /**     * @dev See {IERC721Metadata-symbol}.     */    function symbol() public view virtual override returns (string memory) {        return _symbol;    }    /**     * @dev See {IERC721Metadata-tokenURI}.     */    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");        string memory baseURI = _baseURI();        return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";    }    /**     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty     * by default, can be overridden in child contracts.     */    function _baseURI() internal view virtual returns (string memory) {        return "";    }    /**     * @dev See {IERC721-approve}.     */    function approve(address to, uint256 tokenId) public virtual override {        address owner = ERC721.ownerOf(tokenId);        require(to != owner, "ERC721: approval to current owner");        require(            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),            "ERC721: approve caller is not owner nor approved for all"        );        _approve(to, tokenId);    }    /**     * @dev See {IERC721-getApproved}.     */    function getApproved(uint256 tokenId) public view virtual override returns (address) {        require(_exists(tokenId), "ERC721: approved query for nonexistent token");        return _tokenApprovals[tokenId];    }    /**     * @dev See {IERC721-setApprovalForAll}.     */    function setApprovalForAll(address operator, bool approved) public virtual override {        _setApprovalForAll(_msgSender(), operator, approved);    }    /**     * @dev See {IERC721-isApprovedForAll}.     */    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {        return _operatorApprovals[owner][operator];    }    /**     * @dev See {IERC721-transferFrom}.     */    function transferFrom(        address from,        address to,        uint256 tokenId    ) public virtual override {        //solhint-disable-next-line max-line-length        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");        _transfer(from, to, tokenId);    }    /**     * @dev See {IERC721-safeTransferFrom}.     */    function safeTransferFrom(        address from,        address to,        uint256 tokenId    ) public virtual override {        safeTransferFrom(from, to, tokenId, "");    }    /**     * @dev See {IERC721-safeTransferFrom}.     */    function safeTransferFrom(        address from,        address to,        uint256 tokenId,        bytes memory data    ) public virtual override {        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");        _safeTransfer(from, to, tokenId, data);    }    /**     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients     * are aware of the ERC721 protocol to prevent tokens from being forever locked.     *     * `data` is additional data, it has no specified format and it is sent in call to `to`.     *     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.     * implement alternative mechanisms to perform token transfer, such as signature-based.     *     * Requirements:     *     * - `from` cannot be the zero address.     * - `to` cannot be the zero address.     * - `tokenId` token must exist and be owned by `from`.     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.     *     * Emits a {Transfer} event.     */    function _safeTransfer(        address from,        address to,        uint256 tokenId,        bytes memory data    ) internal virtual {        _transfer(from, to, tokenId);        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");    }    /**     * @dev Returns whether `tokenId` exists.     *     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.     *     * Tokens start existing when they are minted (`_mint`),     * and stop existing when they are burned (`_burn`).     */    function _exists(uint256 tokenId) internal view virtual returns (bool) {        return _owners[tokenId] != address(0);    }    /**     * @dev Returns whether `spender` is allowed to manage `tokenId`.     *     * Requirements:     *     * - `tokenId` must exist.     */    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {        require(_exists(tokenId), "ERC721: operator query for nonexistent token");        address owner = ERC721.ownerOf(tokenId);        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);    }    /**     * @dev Safely mints `tokenId` and transfers it to `to`.     *     * Requirements:     *     * - `tokenId` must not exist.     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.     *     * Emits a {Transfer} event.     */    function _safeMint(address to, uint256 tokenId) internal virtual {        _safeMint(to, tokenId, "");    }    /**     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.     */    function _safeMint(        address to,        uint256 tokenId,        bytes memory data    ) internal virtual {        _mint(to, tokenId);        require(            _checkOnERC721Received(address(0), to, tokenId, data),            "ERC721: transfer to non ERC721Receiver implementer"        );    }    /**     * @dev Mints `tokenId` and transfers it to `to`.     *     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible     *     * Requirements:     *     * - `tokenId` must not exist.     * - `to` cannot be the zero address.     *     * Emits a {Transfer} event.     */    function _mint(address to, uint256 tokenId) internal virtual {        require(to != address(0), "ERC721: mint to the zero address");        require(!_exists(tokenId), "ERC721: token already minted");        _beforeTokenTransfer(address(0), to, tokenId);        _balances[to] += 1;        _owners[tokenId] = to;        emit Transfer(address(0), to, tokenId);        _afterTokenTransfer(address(0), to, tokenId);    }    /**     * @dev Destroys `tokenId`.     * The approval is cleared when the token is burned.     *     * Requirements:     *     * - `tokenId` must exist.     *     * Emits a {Transfer} event.     */    function _burn(uint256 tokenId) internal virtual {        address owner = ERC721.ownerOf(tokenId);        _beforeTokenTransfer(owner, address(0), tokenId);        // Clear approvals        _approve(address(0), tokenId);        _balances[owner] -= 1;        delete _owners[tokenId];        emit Transfer(owner, address(0), tokenId);        _afterTokenTransfer(owner, address(0), tokenId);    }    /**     * @dev Transfers `tokenId` from `from` to `to`.     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.     *     * Requirements:     *     * - `to` cannot be the zero address.     * - `tokenId` token must be owned by `from`.     *     * Emits a {Transfer} event.     */    function _transfer(        address from,        address to,        uint256 tokenId    ) internal virtual {        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");        require(to != address(0), "ERC721: transfer to the zero address");        _beforeTokenTransfer(from, to, tokenId);        // Clear approvals from the previous owner        _approve(address(0), tokenId);        _balances[from] -= 1;        _balances[to] += 1;        _owners[tokenId] = to;        emit Transfer(from, to, tokenId);        _afterTokenTransfer(from, to, tokenId);    }    /**     * @dev Approve `to` to operate on `tokenId`     *     * Emits an {Approval} event.     */    function _approve(address to, uint256 tokenId) internal virtual {        _tokenApprovals[tokenId] = to;        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);    }    /**     * @dev Approve `operator` to operate on all of `owner` tokens     *     * Emits an {ApprovalForAll} event.     */    function _setApprovalForAll(        address owner,        address operator,        bool approved    ) internal virtual {        require(owner != operator, "ERC721: approve to caller");        _operatorApprovals[owner][operator] = approved;        emit ApprovalForAll(owner, operator, approved);    }    /**     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.     * The call is not executed if the target address is not a contract.     *     * @param from address representing the previous owner of the given token ID     * @param to target address that will receive the tokens     * @param tokenId uint256 ID of the token to be transferred     * @param data bytes optional data to send along with the call     * @return bool whether the call correctly returned the expected magic value     */    function _checkOnERC721Received(        address from,        address to,        uint256 tokenId,        bytes memory data    ) private returns (bool) {        if (to.isContract()) {            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {                return retval == IERC721Receiver.onERC721Received.selector;            } catch (bytes memory reason) {                if (reason.length == 0) {                    revert("ERC721: transfer to non ERC721Receiver implementer");                } else {                    assembly {                        revert(add(32, reason), mload(reason))                    }                }            }        } else {            return true;        }    }    /**     * @dev Hook that is called before any token transfer. This includes minting     * and burning.     *     * Calling conditions:     *     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be     * transferred to `to`.     * - When `from` is zero, `tokenId` will be minted for `to`.     * - When `to` is zero, ``from``'s `tokenId` will be burned.     * - `from` and `to` are never both zero.     *     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].     */    function _beforeTokenTransfer(        address from,        address to,        uint256 tokenId    ) internal virtual {}    /**     * @dev Hook that is called after any transfer of tokens. This includes     * minting and burning.     *     * Calling conditions:     *     * - when `from` and `to` are both non-zero.     * - `from` and `to` are never both zero.     *     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].     */    function _afterTokenTransfer(        address from,        address to,        uint256 tokenId    ) internal virtual {}}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h1&gt;&lt;h2 id=&quot;1-代码版本&quot;&gt;&lt;a href=&quot;#1-代码版本&quot; class=&quot;headerlink&quot; title=&quot;1. 代码</summary>
      
    
    
    
    
    <category term="NFT" scheme="https://zhangzhishun.github.io/tags/NFT/"/>
    
    <category term="OpenZeppelin" scheme="https://zhangzhishun.github.io/tags/OpenZeppelin/"/>
    
  </entry>
  
  <entry>
    <title>NFT框架 OpenZeppelin ERC20源码分析</title>
    <link href="https://zhangzhishun.github.io/2022/05/18/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelinERC20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://zhangzhishun.github.io/2022/05/18/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelinERC20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-05-18T02:25:11.000Z</published>
    <updated>2022-05-18T13:17:43.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><h2 id="1-代码版本"><a href="#1-代码版本" class="headerlink" title="1. 代码版本"></a>1. 代码版本</h2><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/release-v4.6">release-v4.6</a></p><h2 id="2-什么是ERC20？"><a href="#2-什么是ERC20？" class="headerlink" title="2. 什么是ERC20？"></a>2. 什么是ERC20？</h2><p>ERC20 代币合约跟踪可替代代币：</p><ul><li>任何一个代币都完全等同于任何其他代币</li><li>没有任何代币具有与之相关的特殊权利或行为</li></ul><p>这使得 ERC20 代币可用于交换货币、投票权、质押等媒介</p><h1 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h1><h2 id="ERC20涉及到的合约列表"><a href="#ERC20涉及到的合约列表" class="headerlink" title="ERC20涉及到的合约列表"></a>ERC20涉及到的合约列表</h2><ul><li>Context</li><li>IERC20</li><li>IERC20Metadata</li><li>ERC20</li></ul><h2 id="1-Context"><a href="#1-Context" class="headerlink" title="1. Context"></a>1. Context</h2><p>提供有关当前执行上下文的信息，包括交易的发送者及其数据，虽然可以通过 msg.sender 和 msg.data使用，但是不应直接访问它们，因为在处理元交易时，帐户发送和为执行付费可能不是实际的发送者（就应用程序而言被关注到）</p><pre><code class="solidity">// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)pragma solidity ^0.8.0;/** * @dev Provides information about the current execution context, including the * sender of the transaction and its data. While these are generally available * via msg.sender and msg.data, they should not be accessed in such a direct * manner, since when dealing with meta-transactions the account sending and * paying for execution may not be the actual sender (as far as an application * is concerned). * * This contract is only required for intermediate, library-like contracts. */abstract contract Context {      /**       * 获取与当前合约交互的地址，该地址可能是用户地址，也可能是合约地址       */    function _msgSender() internal view virtual returns (address) {        return msg.sender;    }      /**       * 获取消息data       */    function _msgData() internal view virtual returns (bytes calldata) {        return msg.data;    }}</code></pre><h2 id="2-IERC20"><a href="#2-IERC20" class="headerlink" title="2. IERC20"></a>2. IERC20</h2><p>EIP 中定义的 ERC20 标准的接口</p><pre><code class="javascript">// SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)pragma solidity ^0.8.0;/** * @dev Interface of the ERC20 standard as defined in the EIP. */interface IERC20 {    /**     * @dev 当 `value` 代币从一个账户 (`from`) 移动到另一个（`to`）触发此事件     *     * 请注意，`value` 可能为零     */    event Transfer(address indexed from, address indexed to, uint256 value);    /**     * @dev 当“owner”的“spender” token通过调用 {approve} 设置时触发此事件     * `value` 是新的津贴。     */    event Approval(address indexed owner, address indexed spender, uint256 value);    /**     * @dev 返回存在的token数量     */    function totalSupply() external view returns (uint256);    /**     * @dev 返回 `account` 拥有的token数量     */    function balanceOf(address account) external view returns (uint256);    /**     * @dev 将 `amount` 令牌从调用者的帐户移至 `to`。     *     * 返回一个布尔值，指示操作是否成功。     *     * 发出 {Transfer} 事件。     */    function transfer(address to, uint256 amount) external returns (bool);    /**     * @dev 返回允许“spender”通过 {transferFrom} 代表“owner”花费的token的剩余数量。默认为零。     *     * 当 {approve} 或 {transferFrom} 被调用时，这个值会改变。     */    function allowance(address owner, address spender) external view returns (uint256);    /**     * @dev Sets 将 `amount` 设置为 `spender` 在调用者代币上的限额。     * 返回一个布尔值，指示操作是否成功。     *      * 重要提示：请注意，使用此方法更改配额会带来风险     * 即有人可能会因不幸的交易排序而同时使用旧配额和新配额     * 缓解这种竞争条件的一种可能解决方案是首先将支出者的津贴减少到 0，然后设置所需的值：     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729      *      * 发出 {Approval} 事件     */    function approve(address spender, uint256 amount) external returns (bool);    /**     * @dev 使用allowance机制将指定amount的token从“from”转移到“to”     * 然后从调用者的allowance中扣除“金额”     *      * 返回一个布尔值，该值指示操作是否成功     *      * 发出 {transferFrom} 事件     */    function transferFrom(        address from,        address to,        uint256 amount    ) external returns (bool);}</code></pre><h2 id="3-IERC20Metadata"><a href="#3-IERC20Metadata" class="headerlink" title="3. IERC20Metadata"></a>3. IERC20Metadata</h2><p>来自 ERC20 标准的可选metadata功能的接口</p><pre><code class="solidity">// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)pragma solidity ^0.8.0;import "../IERC20.sol";/** * @dev Interface for the optional metadata functions from the ERC20 standard. * * _Available since v4.1._ */interface IERC20Metadata is IERC20 {    /**     * @dev 返回token名字     */    function name() external view returns (string memory);    /**     * @dev 返回token的标志     */    function symbol() external view returns (string memory);    /**     * @dev 返回token的小数点位数     */    function decimals() external view returns (uint8);}</code></pre><h2 id="4-ERC20"><a href="#4-ERC20" class="headerlink" title="4. ERC20"></a>4. ERC20</h2><p>ERC-721不可替代令牌标准的可选枚举扩展。</p><p>主要方法：</p><p>ERC721合约定义了基本的接口方法：</p><ul><li><p>safeTransferFrom：转移代币所有权</p></li><li><p>transferFrom：转移代币所有权</p></li><li><p>setApprovalForAll：授权operator具有所有代币的控制权</p></li><li><p>balanceOf：返回owner的代币数量</p></li><li><p>ownerOf：根据tokenId返回代币持有者address</p></li><li><p>getApproved：查询tokenId的授权人operator address</p></li><li><p>approve 授权tokenId给地址to</p></li><li><p>isApprovedForAll：查询一个地址是否为另一个地址的授权操作者。</p></li><li><p>totalSupply：返回由此契约跟踪的有效nft的计数（代币总量），其中每个nft都有一个分配的、可查询的所有者，且所有者不等于零地址</p></li><li><p>tokenByIndex：返回第index的NFT的tokenId。没有指定排序顺序。</p></li><li><p>tokenOfOwnerByIndex：返回分配给指定人的第index的NFT的tokenId。没有指定排序顺序</p></li></ul><p>源码：</p><pre><code class="solidity">// SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)pragma solidity ^0.8.0;import "./IERC20.sol";import "./extensions/IERC20Metadata.sol";import "../../utils/Context.sol";/** * @dev {IERC20} 接口的实现 * * 此实现与创建令牌的方式无关 * 这意味着必须使用 {_mint} 在派生合约中添加供应机制。 * 有关通用机制，请参阅 {ERC20PresetMinterPauser} *  * 提示：有关详细说明，请参阅我们的指南 https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[如何实施供应机制] *  * 我们遵循了一般的 OpenZeppelin Contracts 指南： * 函数在失败时恢复而不是返回 `false`。这种行为仍然是传统的，并且与 ERC20 应用程序的期望不冲突 * 此外，在调用 {transferFrom} 时会发出 {Approval} 事件。这允许应用程序仅通过收听所述事件来重建所有帐户的限额。 EIP 的其他实现可能不会发出这些事件，因为规范没有要求。 * 最后，添加了非标准的 {decreaseAllowance} 和 {increaseAllowance} 函数，以缓解围绕设置限额的众所周知的问题。请参阅 {IERC20-approve} */contract ERC20 is Context, IERC20, IERC20Metadata {    mapping(address =&gt; uint256) private _balances;    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;    uint256 private _totalSupply;    string private _name;    string private _symbol;    /**     * @dev 设置 {name} 和 {symbol}.     *     * {decimals} 的默认值为 18。要为 {decimals} 选择不同的值，应重载它     *      * 这两个值都是不可变的：只能在构造过程中设置一次     */    constructor(string memory name_, string memory symbol_) {        _name = name_;        _symbol = symbol_;    }    /**     * @dev 返回token的名字     */    function name() public view virtual override returns (string memory) {        return _name;    }    /**     * @dev 返回token的标志，通常是比名字短一点的缩写     */    function symbol() public view virtual override returns (string memory) {        return _symbol;    }    /**     * @dev 返回用于获取其用户表示的小数位数     * 例如，如果“decimals”等于“2”，则“505”代币的余额应显示为“5.05”（“505 / 10 ** 2”）     * 代币通常选择 18 的值，模仿 Ether 和 Wei 之间的关系。这是 {ERC20} 使用的值，除非此函数被覆盖；          * 注意：此信息仅用于_显示_目的：它绝不会影响合约的任何算术，包括 {IERC20-balanceOf} 和 {IERC20-transfer}     */    function decimals() public view virtual override returns (uint8) {        return 18;    }    /**     * @dev See {IERC20-totalSupply}.     */    function totalSupply() public view virtual override returns (uint256) {        return _totalSupply;    }    /**     * @dev See {IERC20-balanceOf}.     */    function balanceOf(address account) public view virtual override returns (uint256) {        return _balances[account];    }    /**     * @dev See {IERC20-transfer}.     *     * 规定:     *     * - `to` 不能是零地址.     * - 调用者至少有`amount`数量的token     */    function transfer(address to, uint256 amount) public virtual override returns (bool) {        address owner = _msgSender();        _transfer(owner, to, amount);        return true;    }    /**     * @dev See {IERC20-allowance}.     */    function allowance(address owner, address spender) public view virtual override returns (uint256) {        return _allowances[owner][spender];    }    /**     * @dev See {IERC20-approve}.     *     * 注意：如果 `amount` 是最大值 `uint256`，则不会在 `transferFrom` 上更新配额。这在语义上等同于无限批准     *     * 规定:     *     * - `spender` 不能是零地址.     */    function approve(address spender, uint256 amount) public virtual override returns (bool) {        address owner = _msgSender();        _approve(owner, spender, amount);        return true;    }    /**     * @dev See {IERC20-transferFrom}.     *     * 发出一个 {Approval} 事件，指示更新的配额     * EIP 不需要这样做。请参阅 {ERC20} 开头的注释     *      * 注意：如果当前allowance是最大的 `uint256`，则不会更新限额     *     * 规定:     *     * - `from` 和 `to` 不能是零地址.     * - `from` 至少有`amount`数量的token     * - 调用者从`from`获取到的allowance至少是`amount`.     */    function transferFrom(        address from,        address to,        uint256 amount    ) public virtual override returns (bool) {        address spender = _msgSender();        _spendAllowance(from, spender, amount);        _transfer(from, to, amount);        return true;    }    /**     * @dev 以原子方式增加调用者授予 `spender` 的allowance。     *     * 这是 {approve} 的替代方案，可用作缓解     * {IERC20-approve} 中描述的问题     *     * 发出一个 {Approval} 事件，指示更新的allowance     *      * 规定:     *     * - `spender` 不能是零地址.     */    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {        address owner = _msgSender();        _approve(owner, spender, allowance(owner, spender) + addedValue);        return true;    }    /**     * @dev 以原子方式减少调用者授予 `spender` 的allowance。     *     * 这是 {approve} 的替代方案，可用作缓解     * {IERC20-approve} 中描述的问题。     *     * 发出一个 {Approval} 事件，指示更新的allowance。     *      * 规定:     *     * - `spender` 不能是零地址.     * - `spender` 至少有来自调用者授予的subtractedValue数量的allowance     */    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {        address owner = _msgSender();        uint256 currentAllowance = allowance(owner, spender);        require(currentAllowance &gt;= subtractedValue, "ERC20: decreased allowance below zero");        unchecked {            _approve(owner, spender, currentAllowance - subtractedValue);        }        return true;    }    /**     * @dev 将令牌的“数量”从“from”移动到“to”。     *     * 这个内部函数等价于{transfer}，可用于     * 例如实施自动代币费用，削减机制等。     *     * 发出 {Transfer} 事件     *     * 规定:     *     * - `from` 不能是零地址.     * - `to` 不能是零地址.     * - `from` 的余额至少 `amount`     */    function _transfer(        address from,        address to,        uint256 amount    ) internal virtual {        require(from != address(0), "ERC20: transfer from the zero address");        require(to != address(0), "ERC20: transfer to the zero address");        _beforeTokenTransfer(from, to, amount);        uint256 fromBalance = _balances[from];        require(fromBalance &gt;= amount, "ERC20: transfer amount exceeds balance");        unchecked {            _balances[from] = fromBalance - amount;        }        _balances[to] += amount;        emit Transfer(from, to, amount);        _afterTokenTransfer(from, to, amount);    }    /** @dev 创建 `amount` 代币并将它们分配给 `account`，增加总供应量。     *     * 发出一个 {Transfer} 事件，并将 `from` 设置为零地址。       *      * 规定:     *     * - `account` 不能是零地址.     */    function _mint(address account, uint256 amount) internal virtual {        require(account != address(0), "ERC20: mint to the zero address");        _beforeTokenTransfer(address(0), account, amount);        _totalSupply += amount;        _balances[account] += amount;        emit Transfer(address(0), account, amount);        _afterTokenTransfer(address(0), account, amount);    }    /**     * @dev 销毁 `account` 中的 `amount` 代币，减少总供应量。     *     * 发出一个 {Transfer} 事件，并将 `to` 设置为零地址。     Destroys `amount` tokens from `account`, reducing the     *     * 规定:     *     * - `account` 不能是零地址     * - `account` 至少有`amount`个token     */    function _burn(address account, uint256 amount) internal virtual {        require(account != address(0), "ERC20: burn from the zero address");        _beforeTokenTransfer(account, address(0), amount);        uint256 accountBalance = _balances[account];        require(accountBalance &gt;= amount, "ERC20: burn amount exceeds balance");        unchecked {            _balances[account] = accountBalance - amount;        }        _totalSupply -= amount;        emit Transfer(account, address(0), amount);        _afterTokenTransfer(account, address(0), amount);    }    /**     * @dev 将 `amount` 设置为 `spender` 在 `owner` 的代币上的限额。     *     * 这个内部函数相当于`approve`，可以用来     * 例如为某些子系统设置自动限额等。     *     * 发出 {Approval} 事件     *      * 规定:     *     * - `owner` 不能是零地址.     * - `spender` 不能是零地址.     */    function _approve(        address owner,        address spender,        uint256 amount    ) internal virtual {        require(owner != address(0), "ERC20: approve from the zero address");        require(spender != address(0), "ERC20: approve to the zero address");        _allowances[owner][spender] = amount;        emit Approval(owner, spender, amount);    }    /**     * @dev 根据花费的“amount”更新“owner”对“spender”的津贴     *     * 在无限津贴的情况下不更新津贴金额     * 如果没有足够的配额，请恢复     *     * 可能会发出 {Approval} 事件。     */    function _spendAllowance(        address owner,        address spender,        uint256 amount    ) internal virtual {        uint256 currentAllowance = allowance(owner, spender);        if (currentAllowance != type(uint256).max) {            require(currentAllowance &gt;= amount, "ERC20: insufficient allowance");            unchecked {                _approve(owner, spender, currentAllowance - amount);            }        }    }    /**     * @dev 在任何token转移之前调用的Hook     * 这包括mint和burn     *      * 调用条件:     *     * - 当 `from` 和 `to` 都非零时，`from` 的amount数量的token将被转移到`to`     * - 当 `from` 为零时，将为 `to` 铸造 `amount` 数量的token     * - 当 `to` 为 0 时，`from` 的`amount` 数量的token将被烧毁     * - `from` 和 `to` 永远不会都是零     *     * 要了解有关挂钩的更多信息，请访问：ROOT:extending-contracts.adoc#using-hooks[Using Hooks]     */    function _beforeTokenTransfer(        address from,        address to,        uint256 amount    ) internal virtual {}    /**     * @dev 在任何token转移后调用的Hook     * 这包括mint和burn     *     * 调用条件：     *     * - 当 `from` 和 `to` 都非零时，`from` 的`amount`数量的token已转移到`to`     * - 当 `from` 为零时，为 `to` 铸造 `amount` 数量的token     * - 当 `to` 为 0 时，`from` 的`amount`数量的token已被烧毁     * - `from` 和 `to` 永远不会都是零     *      * 要了解有关挂钩的更多信息，请访问：ROOT:extending-contracts.adoc#using-hooks[Using Hooks]     */    function _afterTokenTransfer(        address from,        address to,        uint256 amount    ) internal virtual {}}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h1&gt;&lt;h2 id=&quot;1-代码版本&quot;&gt;&lt;a href=&quot;#1-代码版本&quot; class=&quot;headerlink&quot; title=&quot;1. 代码</summary>
      
    
    
    
    
    <category term="NFT" scheme="https://zhangzhishun.github.io/tags/NFT/"/>
    
    <category term="OpenZeppelin" scheme="https://zhangzhishun.github.io/tags/OpenZeppelin/"/>
    
  </entry>
  
  <entry>
    <title>Solidity学习笔记(攻击)</title>
    <link href="https://zhangzhishun.github.io/2022/05/17/blockchain/ethereum/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E6%94%BB%E5%87%BB)/"/>
    <id>https://zhangzhishun.github.io/2022/05/17/blockchain/ethereum/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E6%94%BB%E5%87%BB)/</id>
    <published>2022-05-17T11:29:23.000Z</published>
    <updated>2022-05-17T03:02:24.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Solidity学习笔记-攻击"><a href="#Solidity学习笔记-攻击" class="headerlink" title="Solidity学习笔记(攻击)"></a>Solidity学习笔记(攻击)</h1><p>本文参考：<a href="https://solidity-by-example.org/">https://solidity-by-example.org/</a></p><p>推荐视频课程：<a href="https://www.bilibili.com/video/BV1St411a7Pk">https://www.bilibili.com/video/BV1St411a7Pk</a></p><h2 id="Re-Entrancy（重入）"><a href="#Re-Entrancy（重入）" class="headerlink" title="Re-Entrancy（重入）"></a>Re-Entrancy（重入）</h2><p>漏洞假设合约 A 调用合约 B</p><p>Reentracy 漏洞允许 B 在 A 完成执行之前回调 A</p><p><a href="https://solidity-by-example.org/hacks/re-entrancy">https://solidity-by-example.org/hacks/re-entrancy</a></p><p>预防技术：</p><ul><li>确保在调用外部合约之前发生所有状态更改</li><li>使用防止重新进入的函数修饰符这里是重新进入</li></ul><p>保护的示例：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract ReEntrancyGuard {    bool internal locked;    modifier noReentrant() {        require(!locked, "No re-entrancy");        locked = true;        _;        locked = false;    }}</code></pre><h2 id="数值溢出"><a href="#数值溢出" class="headerlink" title="数值溢出"></a>数值溢出</h2><p>Solidity &lt; 0.8</p><p>Integers in Solidity 溢出/下溢没有任何错误</p><p>Solidity &gt;= 0.8 </p><p>Solidity 0.8 溢出/下溢的默认行为是抛出错误</p><p>预防技术：</p><ul><li>使用 SafeMath 来防止算术上溢和下溢</li><li>Solidity 0.8 默认为上溢/下溢引发错误</li></ul><h2 id="自毁"><a href="#自毁" class="headerlink" title="自毁"></a>自毁</h2><p>合约可以通过调用 selfdestruct 从区块链中删除</p><p>selfdestruct 将存储在合约中的所有剩余 Ether 发送到指定地址</p><p>恶意合约可以使用 selfdestruct 强制将 Ether 发送到任何合约</p><p>预防：不要依赖address(this).balance</p><p><a href="https://solidity-by-example.org/hacks/self-destruct">https://solidity-by-example.org/hacks/self-destruct</a></p><h2 id="访问私有数据"><a href="#访问私有数据" class="headerlink" title="访问私有数据"></a>访问私有数据</h2><p>攻击：智能合约上的所有数据都可以读取。让我们看看如何读取私有数据。在此过程中，您将了解 Solidity 如何存储状态变量。</p><p>预防：不要在区块链上存储敏感信息</p><h2 id="Delegatecall"><a href="#Delegatecall" class="headerlink" title="Delegatecall"></a>Delegatecall</h2><p>漏洞delegatecall 使用起来很棘手，错误的使用或不正确的理解会导致毁灭性的后果</p><p>使用delegatecall 时必须牢记两件事</p><ul><li>delegatecall 保留上下文（存储、调用者等）</li><li>合约调用 delegatecall 和合约被调用的存储布局必须相同</li></ul><p><a href="https://solidity-by-example.org/hacks/delegatecall">https://solidity-by-example.org/hacks/delegatecall</a></p><h2 id="Source-of-Randomness"><a href="#Source-of-Randomness" class="headerlink" title="Source of Randomness"></a>Source of Randomness</h2><p>漏洞blockhash和block.timestamp不是随机性的可靠来源</p><p>预防技术：不要使用 blockhash 和 block.timestamp 作为随机源</p><h2 id="Denial-of-Service"><a href="#Denial-of-Service" class="headerlink" title="Denial of Service"></a>Denial of Service</h2><p>漏洞有很多方法可以攻击智能合约使其无法使用</p><p>我们在这里介绍的一个漏洞是通过使发送以太币的功能失败来拒绝服务</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;/*The goal of KingOfEther is to become the king by sending more Ether thanthe previous king. Previous king will be refunded with the amount of Etherhe sent.*//*1. Deploy KingOfEther2. Alice becomes the king by sending 1 Ether to claimThrone().2. Bob becomes the king by sending 2 Ether to claimThrone().   Alice receives a refund of 1 Ether.3. Deploy Attack with address of KingOfEther.4. Call attack with 3 Ether.5. Current king is the Attack contract and no one can become the new king.What happened?Attack became the king. All new challenge to claim the throne will be rejectedsince Attack contract does not have a fallback function, denying to accept theEther sent from KingOfEther before the new king is set.*/contract KingOfEther {    address public king;    uint public balance;    function claimThrone() external payable {        require(msg.value &gt; balance, "Need to pay more to become the king");        (bool sent, ) = king.call{value: balance}("");        require(sent, "Failed to send Ether");        balance = msg.value;        king = msg.sender;    }}contract Attack {    KingOfEther kingOfEther;    constructor(KingOfEther _kingOfEther) {        kingOfEther = KingOfEther(_kingOfEther);    }    // You can also perform a DOS by consuming all gas using assert.    // This attack will work even if the calling contract does not check    // whether the call was successful or not.    //    // function () external payable {    //     assert(false);    // }    function attack() public payable {        kingOfEther.claimThrone{value: msg.value}();    }}</code></pre><p>预防技术：防止这种情况的一种方法是允许用户提取他们的以太币而不是发送它</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract KingOfEther {    address public king;    uint public balance;    mapping(address =&gt; uint) public balances;    function claimThrone() external payable {        require(msg.value &gt; balance, "Need to pay more to become the king");        balances[king] += balance;        balance = msg.value;        king = msg.sender;    }    function withdraw() public {        require(msg.sender != king, "Current king cannot withdraw");        uint amount = balances[msg.sender];        balances[msg.sender] = 0;        (bool sent, ) = msg.sender.call{value: amount}("");        require(sent, "Failed to send Ether");    }}</code></pre><h2 id="Phishing-with-tx-origin"><a href="#Phishing-with-tx-origin" class="headerlink" title="Phishing with tx.origin"></a>Phishing with tx.origin</h2><p>msg.sender 和 tx.origin 有什么区别？</p><p>如果合约 A 调用 B，B 调用 C，在 C 中 msg.sender 是 B，tx.origin 是 A</p><p>漏洞恶意合约可以欺骗合约所有者调用只有所有者才能调用的函数</p><p>预防技术：使用msg.sender 而不是 tx.origin</p><h2 id="用外部合约隐藏恶意代码"><a href="#用外部合约隐藏恶意代码" class="headerlink" title="用外部合约隐藏恶意代码"></a>用外部合约隐藏恶意代码</h2><p>在 Solidity 中，任何地址都可以被转换为特定的合约，即使该地址上的合约不是被转换的那个</p><p>这可以被利用来隐藏恶意代码。让我们看看如何</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;/*Let's say Alice can see the code of Foo and Bar but not Mal.It is obvious to Alice that Foo.callBar() executes the code inside Bar.log().However Eve deploys Foo with the address of Mal, so that calling Foo.callBar()will actually execute the code at Mal.*//*1. Eve deploys Mal2. Eve deploys Foo with the address of Mal3. Alice calls Foo.callBar() after reading the code and judging that it is   safe to call.4. Although Alice expected Bar.log() to be execute, Mal.log() was executed.*/contract Foo {    Bar bar;    constructor(address _bar) {        bar = Bar(_bar);    }    function callBar() public {        bar.log();    }}contract Bar {    event Log(string message);    function log() public {        emit Log("Bar was called");    }}// This code is hidden in a separate filecontract Mal {    event Log(string message);    // function () external {    //     emit Log("Mal was called");    // }    // Actually we can execute the same exploit even if this function does    // not exist by using the fallback    function log() public {        emit Log("Mal was called");    }}</code></pre><p>预防技巧：</p><ul><li><p>在构造函数内部初始化一个新合约</p></li><li><p>公开外部合约的地址，以便可以查看外部合约的代码</p></li></ul><pre><code class="solidity">Bar public bar;constructor() public {    bar = new Bar();}</code></pre><h2 id="Honeypot"><a href="#Honeypot" class="headerlink" title="Honeypot"></a>Honeypot</h2><p>Honeypot是捕捉黑客的陷阱</p><p>结合两个漏洞利用重入和隐藏恶意代码，我们可以构建一个捕捉恶意用户的合约</p><p><a href="https://solidity-by-example.org/hacks/honeypot">https://solidity-by-example.org/hacks/honeypot</a></p><h2 id="Front-Running"><a href="#Front-Running" class="headerlink" title="Front Running"></a>Front Running</h2><p>交易需要一些时间才能被挖掘，攻击者可以观察交易池并发送交易，将其包含在原始交易之前的块中。这种机制可以被滥用来对交易进行重新排序以使攻击者受益。</p><p>预防性技术：</p><ul><li>使用commit-reveal scheme</li><li>使用submarine send</li></ul><h2 id="Block-Timestamp-Manipulation"><a href="#Block-Timestamp-Manipulation" class="headerlink" title="Block Timestamp Manipulation"></a>Block Timestamp Manipulation</h2><p>block.timestamp 可以被矿工操纵，具有以下约束：</p><ul><li>它不能被标记为早于其父级的时间</li><li>它不能距离现在太远</li></ul><p>预防技术：</p><ul><li>不要使用 block.timestamp 作为entropy和随机数的来源</li></ul><h2 id="签名重播"><a href="#签名重播" class="headerlink" title="签名重播"></a>签名重播</h2><p>在链外签署消息并在执行函数之前签署需要签名的合约是一种有用的技术</p><p>例如，该技术用于：</p><ul><li>减少链上的交易数量</li><li>无气体交易，称为元交易</li></ul><p>漏洞：可以使用相同的签名多次执行一个功能，如果签名者的意图是批准一次交易，这可能是有害的</p><h2 id="绕过合约大小检查"><a href="#绕过合约大小检查" class="headerlink" title="绕过合约大小检查"></a>绕过合约大小检查</h2><p>如果一个地址是一个合约，那么该地址存储的代码大小将大于 0 对吗？</p><p>让我们看看如何创建一个由 extcodesize 返回的代码大小等于 0 的合约。</p><p><a href="https://solidity-by-example.org/hacks/contract-size">https://solidity-by-example.org/hacks/contract-size</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Solidity学习笔记-攻击&quot;&gt;&lt;a href=&quot;#Solidity学习笔记-攻击&quot; class=&quot;headerlink&quot; title=&quot;Solidity学习笔记(攻击)&quot;&gt;&lt;/a&gt;Solidity学习笔记(攻击)&lt;/h1&gt;&lt;p&gt;本文参考：&lt;a href=&quot;ht</summary>
      
    
    
    
    
    <category term="Ethereum" scheme="https://zhangzhishun.github.io/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Solidity学习笔记(应用部分)</title>
    <link href="https://zhangzhishun.github.io/2022/05/10/blockchain/ethereum/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%BA%94%E7%94%A8%E9%83%A8%E5%88%86)/"/>
    <id>https://zhangzhishun.github.io/2022/05/10/blockchain/ethereum/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%BA%94%E7%94%A8%E9%83%A8%E5%88%86)/</id>
    <published>2022-05-10T11:29:23.000Z</published>
    <updated>2022-05-16T01:06:29.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Solidity学习笔记-应用部分"><a href="#Solidity学习笔记-应用部分" class="headerlink" title="Solidity学习笔记(应用部分)"></a>Solidity学习笔记(应用部分)</h1><p>本文参考：<a href="https://solidity-by-example.org/">https://solidity-by-example.org/</a></p><p>推荐视频课程：<a href="https://www.bilibili.com/video/BV1St411a7Pk">https://www.bilibili.com/video/BV1St411a7Pk</a></p><h2 id="以太坊钱包"><a href="#以太坊钱包" class="headerlink" title="以太坊钱包"></a>以太坊钱包</h2><p>一个基本钱包的例子</p><ul><li>任何人都可以发送 ETH</li><li>只有所有者可以提款</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract EtherWallet {    address payable public owner;    constructor() {        owner = payable(msg.sender);    }    receive() external payable {}    function withdraw(uint _amount) external {        require(msg.sender == owner, "caller is not owner");        payable(msg.sender).transfer(_amount);    }    function getBalance() external view returns (uint) {        return address(this).balance;    }}</code></pre><h2 id="多签名钱包"><a href="#多签名钱包" class="headerlink" title="多签名钱包"></a><font color="red">多签名钱包</font></h2><p>让我们创建一个多重签名钱包，以下是规范</p><p>钱包所有者可以</p><ul><li>提交交易</li><li>批准和撤销对待处理交易的批准</li><li>在足够多的所有者批准后，任何人都可以执行交易</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract MultiSigWallet {    event Deposit(address indexed sender, uint amount, uint balance);    event SubmitTransaction(        address indexed owner,        uint indexed txIndex,        address indexed to,        uint value,        bytes data    );    event ConfirmTransaction(address indexed owner, uint indexed txIndex);    event RevokeConfirmation(address indexed owner, uint indexed txIndex);    event ExecuteTransaction(address indexed owner, uint indexed txIndex);    address[] public owners;    mapping(address =&gt; bool) public isOwner;    uint public numConfirmationsRequired;    struct Transaction {        address to;        uint value;        bytes data;        bool executed;        uint numConfirmations;    }    // mapping from tx index =&gt; owner =&gt; bool    mapping(uint =&gt; mapping(address =&gt; bool)) public isConfirmed;    Transaction[] public transactions;    modifier onlyOwner() {        require(isOwner[msg.sender], "not owner");        _;    }    modifier txExists(uint _txIndex) {        require(_txIndex &lt; transactions.length, "tx does not exist");        _;    }    modifier notExecuted(uint _txIndex) {        require(!transactions[_txIndex].executed, "tx already executed");        _;    }    modifier notConfirmed(uint _txIndex) {        require(!isConfirmed[_txIndex][msg.sender], "tx already confirmed");        _;    }    constructor(address[] memory _owners, uint _numConfirmationsRequired) {        require(_owners.length &gt; 0, "owners required");        require(            _numConfirmationsRequired &gt; 0 &amp;&amp;                _numConfirmationsRequired &lt;= _owners.length,            "invalid number of required confirmations"        );        for (uint i = 0; i &lt; _owners.length; i++) {            address owner = _owners[i];            require(owner != address(0), "invalid owner");            require(!isOwner[owner], "owner not unique");            isOwner[owner] = true;            owners.push(owner);        }        numConfirmationsRequired = _numConfirmationsRequired;    }    receive() external payable {        emit Deposit(msg.sender, msg.value, address(this).balance);    }    function submitTransaction(        address _to,        uint _value,        bytes memory _data    ) public onlyOwner {        uint txIndex = transactions.length;        transactions.push(            Transaction({                to: _to,                value: _value,                data: _data,                executed: false,                numConfirmations: 0            })        );        emit SubmitTransaction(msg.sender, txIndex, _to, _value, _data);    }    function confirmTransaction(uint _txIndex)        public        onlyOwner        txExists(_txIndex)        notExecuted(_txIndex)        notConfirmed(_txIndex)    {        Transaction storage transaction = transactions[_txIndex];        transaction.numConfirmations += 1;        isConfirmed[_txIndex][msg.sender] = true;        emit ConfirmTransaction(msg.sender, _txIndex);    }    function executeTransaction(uint _txIndex)        public        onlyOwner        txExists(_txIndex)        notExecuted(_txIndex)    {        Transaction storage transaction = transactions[_txIndex];        require(            transaction.numConfirmations &gt;= numConfirmationsRequired,            "cannot execute tx"        );        transaction.executed = true;        (bool success, ) = transaction.to.call{value: transaction.value}(            transaction.data        );        require(success, "tx failed");        emit ExecuteTransaction(msg.sender, _txIndex);    }    function revokeConfirmation(uint _txIndex)        public        onlyOwner        txExists(_txIndex)        notExecuted(_txIndex)    {        Transaction storage transaction = transactions[_txIndex];        require(isConfirmed[_txIndex][msg.sender], "tx not confirmed");        transaction.numConfirmations -= 1;        isConfirmed[_txIndex][msg.sender] = false;        emit RevokeConfirmation(msg.sender, _txIndex);    }    function getOwners() public view returns (address[] memory) {        return owners;    }    function getTransactionCount() public view returns (uint) {        return transactions.length;    }    function getTransaction(uint _txIndex)        public        view        returns (            address to,            uint value,            bytes memory data,            bool executed,            uint numConfirmations        )    {        Transaction storage transaction = transactions[_txIndex];        return (            transaction.to,            transaction.value,            transaction.data,            transaction.executed,            transaction.numConfirmations        );    }}</code></pre><p>这是一个测试从多重签名钱包发送交易的合约</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract TestContract {    uint public i;    function callMe(uint j) public {        i += j;    }    function getData() public pure returns (bytes memory) {        return abi.encodeWithSignature("callMe(uint256)", 123);    }}</code></pre><h2 id="默克尔树"><a href="#默克尔树" class="headerlink" title="默克尔树"></a>默克尔树</h2><p>Merkle 树允许您以密文方式证明一个元素包含在一个集合中，而不会泄露整个集合</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract MerkleProof {    function verify(        bytes32[] memory proof,        bytes32 root,        bytes32 leaf,        uint index    ) public pure returns (bool) {        bytes32 hash = leaf;        for (uint i = 0; i &lt; proof.length; i++) {            bytes32 proofElement = proof[i];            if (index % 2 == 0) {                hash = keccak256(abi.encodePacked(hash, proofElement));            } else {                hash = keccak256(abi.encodePacked(proofElement, hash));            }            index = index / 2;        }        return hash == root;    }}contract TestMerkleProof is MerkleProof {    bytes32[] public hashes;    constructor() {        string[4] memory transactions = [            "alice -&gt; bob",            "bob -&gt; dave",            "carol -&gt; alice",            "dave -&gt; bob"        ];        for (uint i = 0; i &lt; transactions.length; i++) {            hashes.push(keccak256(abi.encodePacked(transactions[i])));        }        uint n = transactions.length;        uint offset = 0;        while (n &gt; 0) {            for (uint i = 0; i &lt; n - 1; i += 2) {                hashes.push(                    keccak256(                        abi.encodePacked(hashes[offset + i], hashes[offset + i + 1])                    )                );            }            offset += n;            n = n / 2;        }    }    function getRoot() public view returns (bytes32) {        return hashes[hashes.length - 1];    }    /* verify    3rd leaf    0x1bbd78ae6188015c4a6772eb1526292b5985fc3272ead4c65002240fb9ae5d13    root    0x074b43252ffb4a469154df5fb7fe4ecce30953ba8b7095fe1e006185f017ad10    index    2    proof    0x948f90037b4ea787c14540d9feb1034d4a5bc251b9b5f8e57d81e4b470027af8    0x63ac1b92046d474f84be3aa0ee04ffe5600862228c81803cce07ac40484aee43    */}</code></pre><h2 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h2><p>您不能遍历映射</p><p>下面是一个如何创建可迭代映射的示例</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;library IterableMapping {    // Iterable mapping from address to uint;    struct Map {        address[] keys;        mapping(address =&gt; uint) values;        mapping(address =&gt; uint) indexOf;        mapping(address =&gt; bool) inserted;    }    function get(Map storage map, address key) public view returns (uint) {        return map.values[key];    }    function getKeyAtIndex(Map storage map, uint index) public view returns (address) {        return map.keys[index];    }    function size(Map storage map) public view returns (uint) {        return map.keys.length;    }    function set(        Map storage map,        address key,        uint val    ) public {        if (map.inserted[key]) {            map.values[key] = val;        } else {            map.inserted[key] = true;            map.values[key] = val;            map.indexOf[key] = map.keys.length;            map.keys.push(key);        }    }    function remove(Map storage map, address key) public {        if (!map.inserted[key]) {            return;        }        delete map.inserted[key];        delete map.values[key];        uint index = map.indexOf[key];        uint lastIndex = map.keys.length - 1;        address lastKey = map.keys[lastIndex];        map.indexOf[lastKey] = index;        delete map.indexOf[key];        map.keys[index] = lastKey;        map.keys.pop();    }}contract TestIterableMap {    using IterableMapping for IterableMapping.Map;    IterableMapping.Map private map;    function testIterableMap() public {        map.set(address(0), 0);        map.set(address(1), 100);        map.set(address(2), 200); // insert        map.set(address(2), 200); // update        map.set(address(3), 300);        for (uint i = 0; i &lt; map.size(); i++) {            address key = map.getKeyAtIndex(i);            assert(map.get(key) == i * 100);        }        map.remove(address(1));        // keys = [address(0), address(3), address(2)]        assert(map.size() == 3);        assert(map.getKeyAtIndex(0) == address(0));        assert(map.getKeyAtIndex(1) == address(3));        assert(map.getKeyAtIndex(2) == address(2));    }}</code></pre><h2 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h2><p>任何遵循 ERC20 标准的合约都是 ERC20 代币</p><p>ERC20 代币提供以下功能：</p><ul><li>转移代币</li><li>允许其他人代表代币持有者转移代币这里是 ERC20 的接口</li></ul><ol><li><p>创建一个ERC20 token</p><p>使用 Open Zeppelin 创建自己的 ERC20 代币很容易</p><p>这里是一个例子：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/ERC20.sol";contract MyToken is ERC20 {    constructor(string memory name, string memory symbol) ERC20(name, symbol) {        // Mint 100 tokens to msg.sender        // Similar to how        // 1 dollar = 100 cents        // 1 token = 1 * (10 ** decimals)        _mint(msg.sender, 100 * 10**uint(decimals()));    }}</code></pre></li></ol><h2 id="ERC721"><a href="#ERC721" class="headerlink" title="ERC721"></a>ERC721</h2><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721">https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721</a></p><h2 id="Precompute-Contract-Address-with-Create2"><a href="#Precompute-Contract-Address-with-Create2" class="headerlink" title="Precompute Contract Address with Create2"></a><font style="color:red">Precompute Contract Address with Create2</font></h2><p>合约地址可以预先计算，在部署合约之前，使用 create2</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Factory {    // Returns the address of the newly deployed contract    function deploy(        address _owner,        uint _foo,        bytes32 _salt    ) public payable returns (address) {        // This syntax is a newer way to invoke create2 without assembly, you just need to pass salt        // https://docs.soliditylang.org/en/latest/control-structures.html#salted-contract-creations-create2        return address(new TestContract{salt: _salt}(_owner, _foo));    }}// This is the older way of doing it using assemblycontract FactoryAssembly {    event Deployed(address addr, uint salt);    // 1. Get bytecode of contract to be deployed    // NOTE: _owner and _foo are arguments of the TestContract's constructor    function getBytecode(address _owner, uint _foo) public pure returns (bytes memory) {        bytes memory bytecode = type(TestContract).creationCode;        return abi.encodePacked(bytecode, abi.encode(_owner, _foo));    }    // 2. Compute the address of the contract to be deployed    // NOTE: _salt is a random number used to create an address    function getAddress(bytes memory bytecode, uint _salt)        public        view        returns (address)    {        bytes32 hash = keccak256(            abi.encodePacked(bytes1(0xff), address(this), _salt, keccak256(bytecode))        );        // NOTE: cast last 20 bytes of hash to address        return address(uint160(uint(hash)));    }    // 3. Deploy the contract    // NOTE:    // Check the event log Deployed which contains the address of the deployed TestContract.    // The address in the log should equal the address computed from above.    function deploy(bytes memory bytecode, uint _salt) public payable {        address addr;        /*        NOTE: How to call create2        create2(v, p, n, s)        create new contract with code at memory p to p + n        and send v wei        and return the new address        where new address = first 20 bytes of keccak256(0xff + address(this) + s + keccak256(mem[p…(p+n)))              s = big-endian 256-bit value        */        assembly {            addr := create2(                callvalue(), // wei sent with current call                // Actual code starts after skipping the first 32 bytes                add(bytecode, 0x20),                mload(bytecode), // Load the size of code contained in the first 32 bytes                _salt // Salt from function arguments            )            if iszero(extcodesize(addr)) {                revert(0, 0)            }        }        emit Deployed(addr, _salt);    }}contract TestContract {    address public owner;    uint public foo;    constructor(address _owner, uint _foo) payable {        owner = _owner;        foo = _foo;    }    function getBalance() public view returns (uint) {        return address(this).balance;    }}</code></pre><h2 id="Minimal-Proxy-Contract"><a href="#Minimal-Proxy-Contract" class="headerlink" title="Minimal Proxy Contract"></a>Minimal Proxy Contract</h2><p>如果您有一个将被多次部署的合约，请使用Minimal Proxy Contract来廉价地部署它们</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;// original code// https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.solcontract MinimalProxy {    function clone(address target) external returns (address result) {        // convert address to 20 bytes        bytes20 targetBytes = bytes20(target);        // actual code //        // 3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3        // creation code //        // copy runtime code into memory and return it        // 3d602d80600a3d3981f3        // runtime code //        // code to delegatecall to address        // 363d3d373d3d3d363d73 address 5af43d82803e903d91602b57fd5bf3        assembly {            /*            reads the 32 bytes of memory starting at pointer stored in 0x40            In solidity, the 0x40 slot in memory is special: it contains the "free memory pointer"            which points to the end of the currently allocated memory.            */            let clone := mload(0x40)            // store 32 bytes to memory starting at "clone"            mstore(                clone,                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000            )            /*              |              20 bytes                |            0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000                                                      ^                                                      pointer            */            // store 32 bytes to memory starting at "clone" + 20 bytes            // 0x14 = 20            mstore(add(clone, 0x14), targetBytes)            /*              |               20 bytes               |                 20 bytes              |            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe                                                                                              ^                                                                                              pointer            */            // store 32 bytes to memory starting at "clone" + 40 bytes            // 0x28 = 40            mstore(                add(clone, 0x28),                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000            )            /*              |               20 bytes               |                 20 bytes              |           15 bytes          |            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3            */            // create new contract            // send 0 Ether            // code starts at pointer stored in "clone"            // code size 0x37 (55 bytes)            result := create(0, clone, 0x37)        }    }}</code></pre><h2 id="Upgradeable-Proxy"><a href="#Upgradeable-Proxy" class="headerlink" title="Upgradeable Proxy"></a>Upgradeable Proxy</h2><p>可升级代理合约的示例。永远不要在生产中使用它</p><p>这个例子展示了如何使用委托调用并在调用 fallback 时返回数据</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Proxy {    address public implementation;    function setImplementation(address _imp) external {        implementation = _imp;    }    function _delegate(address _imp) internal virtual {        assembly {            // calldatacopy(t, f, s)            // copy s bytes from calldata at position f to mem at position t            calldatacopy(0, 0, calldatasize())            // delegatecall(g, a, in, insize, out, outsize)            // - call contract at address a            // - with input mem[in…(in+insize))            // - providing g gas            // - and output area mem[out…(out+outsize))            // - returning 0 on error and 1 on success            let result := delegatecall(gas(), _imp, 0, calldatasize(), 0, 0)            // returndatacopy(t, f, s)            // copy s bytes from returndata at position f to mem at position t            returndatacopy(0, 0, returndatasize())            switch result            case 0 {                // revert(p, s)                // end execution, revert state changes, return data mem[p…(p+s))                revert(0, returndatasize())            }            default {                // return(p, s)                // end execution, return data mem[p…(p+s))                return(0, returndatasize())            }        }    }    fallback() external payable {        _delegate(implementation);    }}contract V1 {    address public implementation;    uint public x;    function inc() external {        x += 1;    }}contract V2 {    address public implementation;    uint public x;    function inc() external {        x += 1;    }    function dec() external {        x -= 1;    }}</code></pre><h2 id="Deploy-Any-Contract"><a href="#Deploy-Any-Contract" class="headerlink" title="Deploy Any Contract"></a>Deploy Any Contract</h2><p><a href="https://solidity-by-example.org/app/deploy-any-contract">https://solidity-by-example.org/app/deploy-any-contract</a></p><h2 id="Write-to-Any-Slot"><a href="#Write-to-Any-Slot" class="headerlink" title="Write to Any Slot"></a>Write to Any Slot</h2><p>Solidity 存储就像一个长度为 2^256 的数组。数组中的每个槽可以存储 32 个字节</p><p>状态变量定义了哪些槽将用于存储数据</p><p>但是使用汇编，您可以写入任何槽<br><a href="https://solidity-by-example.org/app/write-to-any-slot">https://solidity-by-example.org/app/write-to-any-slot</a></p><h2 id="单向支付通道"><a href="#单向支付通道" class="headerlink" title="单向支付通道"></a>单向支付通道</h2><p>支付渠道允许参与者反复将以太币从链下转移。</p><p>以下是该合约的使用方式：</p><ul><li>Alice 部署合约，用一些以太币为其提供资金</li><li>Alice 通过签署消息（链下）授权支付并将签名发送给 Bob</li><li>Bob 通过向智能合约提交签名消息来索取他的付款</li><li>如果 Bob 没有索取他的付款，Alice 在合同到期后取回她的 Ether </li></ul><p>这被称为单向支付通道，因为付款只能在一个从 Alice 到 Bob 的单向</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;import "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/cryptography/ECDSA.sol";import "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/security/ReentrancyGuard.sol";contract UniDirectionalPaymentChannel is ReentrancyGuard {    using ECDSA for bytes32;    address payable public sender;    address payable public receiver;    uint private constant DURATION = 7 * 24 * 60 * 60;    uint public expiresAt;    constructor(address payable _receiver) payable {        require(_receiver != address(0), "receiver = zero address");        sender = payable(msg.sender);        receiver = _receiver;        expiresAt = block.timestamp + DURATION;    }    function _getHash(uint _amount) private view returns (bytes32) {        // NOTE: sign with address of this contract to protect agains        // replay attack on other contracts        return keccak256(abi.encodePacked(address(this), _amount));    }    function getHash(uint _amount) external view returns (bytes32) {        return _getHash(_amount);    }    function _getEthSignedHash(uint _amount) private view returns (bytes32) {        return _getHash(_amount).toEthSignedMessageHash();    }    function getEthSignedHash(uint _amount) external view returns (bytes32) {        return _getEthSignedHash(_amount);    }    function _verify(uint _amount, bytes memory _sig) private view returns (bool) {        return _getEthSignedHash(_amount).recover(_sig) == sender;    }    function verify(uint _amount, bytes memory _sig) external view returns (bool) {        return _verify(_amount, _sig);    }    function close(uint _amount, bytes memory _sig) external nonReentrant {        require(msg.sender == receiver, "!receiver");        require(_verify(_amount, _sig), "invalid sig");        (bool sent, ) = receiver.call{value: _amount}("");        require(sent, "Failed to send Ether");        selfdestruct(sender);    }    function cancel() external {        require(msg.sender == sender, "!sender");        require(block.timestamp &gt;= expiresAt, "!expired");        selfdestruct(sender);    }}</code></pre><h2 id="双向支付通道"><a href="#双向支付通道" class="headerlink" title="双向支付通道"></a>双向支付通道</h2><p>双向支付通道允许参与者 Alice 和 Bob 反复将以太币转移到链下</p><p>支付可以双向进行，Alice 支付 Bob，Bob 支付 Alice</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;pragma experimental ABIEncoderV2;/*Opening a channel1. Alice and Bob fund a multi-sig wallet2. Precompute payment channel address3. Alice and Bob exchanges signatures of initial balances4. Alice and Bob creates a transaction that can deploy a payment channel from   the multi-sig walletUpdate channel balances1. Repeat steps 1 - 3 from opening a channel2. From multi-sig wallet create a transaction that will   - delete the transaction that would have deployed the old payment channel   - and then create a transaction that can deploy a payment channel with the     new balancesClosing a channel when Alice and Bob agree on the final balance1. From multi-sig wallet create a transaction that will   - send payments to Alice and Bob   - and then delete the transaction that would have created the payment channelClosing a channel when Alice and Bob do not agree on the final balances1. Deploy payment channel from multi-sig2. call challengeExit() to start the process of closing a channel3. Alice and Bob can withdraw funds once the channel is expired*/import "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/math/SafeMath.sol";import "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/cryptography/ECDSA.sol";contract BiDirectionalPaymentChannel {    using SafeMath for uint;    using ECDSA for bytes32;    event ChallengeExit(address indexed sender, uint nonce);    event Withdraw(address indexed to, uint amount);    address payable[2] public users;    mapping(address =&gt; bool) public isUser;    mapping(address =&gt; uint) public balances;    uint public challengePeriod;    uint public expiresAt;    uint public nonce;    modifier checkBalances(uint[2] memory _balances) {        require(            address(this).balance &gt;= _balances[0].add(_balances[1]),            "balance of contract must be &gt;= to the total balance of users"        );        _;    }    // NOTE: deposit from multi-sig wallet    constructor(        address payable[2] memory _users,        uint[2] memory _balances,        uint _expiresAt,        uint _challengePeriod    ) payable checkBalances(_balances) {        require(_expiresAt &gt; block.timestamp, "Expiration must be &gt; now");        require(_challengePeriod &gt; 0, "Challenge period must be &gt; 0");        for (uint i = 0; i &lt; _users.length; i++) {            address payable user = _users[i];            require(!isUser[user], "user must be unique");            users[i] = user;            isUser[user] = true;            balances[user] = _balances[i];        }        expiresAt = _expiresAt;        challengePeriod = _challengePeriod;    }    function verify(        bytes[2] memory _signatures,        address _contract,        address[2] memory _signers,        uint[2] memory _balances,        uint _nonce    ) public pure returns (bool) {        for (uint i = 0; i &lt; _signatures.length; i++) {            /*            NOTE: sign with address of this contract to protect                  agains replay attack on other contracts            */            bool valid = _signers[i] ==                keccak256(abi.encodePacked(_contract, _balances, _nonce))                    .toEthSignedMessageHash()                    .recover(_signatures[i]);            if (!valid) {                return false;            }        }        return true;    }    modifier checkSignatures(        bytes[2] memory _signatures,        uint[2] memory _balances,        uint _nonce    ) {        // Note: copy storage array to memory        address[2] memory signers;        for (uint i = 0; i &lt; users.length; i++) {            signers[i] = users[i];        }        require(            verify(_signatures, address(this), signers, _balances, _nonce),            "Invalid signature"        );        _;    }    modifier onlyUser() {        require(isUser[msg.sender], "Not user");        _;    }    function challengeExit(        uint[2] memory _balances,        uint _nonce,        bytes[2] memory _signatures    )        public        onlyUser        checkSignatures(_signatures, _balances, _nonce)        checkBalances(_balances)    {        require(block.timestamp &lt; expiresAt, "Expired challenge period");        require(_nonce &gt; nonce, "Nonce must be greater than the current nonce");        for (uint i = 0; i &lt; _balances.length; i++) {            balances[users[i]] = _balances[i];        }        nonce = _nonce;        expiresAt = block.timestamp.add(challengePeriod);        emit ChallengeExit(msg.sender, nonce);    }    function withdraw() public onlyUser {        require(block.timestamp &gt;= expiresAt, "Challenge period has not expired yet");        uint amount = balances[msg.sender];        balances[msg.sender] = 0;        (bool sent, ) = msg.sender.call{value: amount}("");        require(sent, "Failed to send Ether");        emit Withdraw(msg.sender, amount);    }}</code></pre><h2 id="英式拍卖"><a href="#英式拍卖" class="headerlink" title="英式拍卖"></a>英式拍卖</h2><p>NFT的英式拍卖</p><p>拍卖：</p><ol><li>NFT的卖方部署此合同</li><li>拍卖持续 7 days</li><li>参与者可以通过存入高于当前最高出价者的 ETH 来出价</li><li>如果不是当前的最高出价，所有投标人都可以撤回他们的出价</li></ol><p>拍卖后：</p><ol><li>出价最高者成为 NFT的新所有者</li><li>卖家收到最高出价的 ETH</li></ol><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;interface IERC721 {    function safeTransferFrom(        address from,        address to,        uint tokenId    ) external;    function transferFrom(        address,        address,        uint    ) external;}contract EnglishAuction {    event Start();    event Bid(address indexed sender, uint amount);    event Withdraw(address indexed bidder, uint amount);    event End(address winner, uint amount);    IERC721 public nft;    uint public nftId;    address payable public seller;    uint public endAt;    bool public started;    bool public ended;    address public highestBidder;    uint public highestBid;    mapping(address =&gt; uint) public bids;    constructor(        address _nft,        uint _nftId,        uint _startingBid    ) {        nft = IERC721(_nft);        nftId = _nftId;        seller = payable(msg.sender);        highestBid = _startingBid;    }    function start() external {        require(!started, "started");        require(msg.sender == seller, "not seller");        nft.transferFrom(msg.sender, address(this), nftId);        started = true;        endAt = block.timestamp + 7 days;        emit Start();    }    function bid() external payable {        require(started, "not started");        require(block.timestamp &lt; endAt, "ended");        require(msg.value &gt; highestBid, "value &lt; highest");        if (highestBidder != address(0)) {            bids[highestBidder] += highestBid;        }        highestBidder = msg.sender;        highestBid = msg.value;        emit Bid(msg.sender, msg.value);    }    function withdraw() external {        uint bal = bids[msg.sender];        bids[msg.sender] = 0;        payable(msg.sender).transfer(bal);        emit Withdraw(msg.sender, bal);    }    function end() external {        require(started, "not started");        require(block.timestamp &gt;= endAt, "not ended");        require(!ended, "ended");        ended = true;        if (highestBidder != address(0)) {            nft.safeTransferFrom(address(this), highestBidder, nftId);            seller.transfer(highestBid);        } else {            nft.safeTransferFrom(address(this), seller, nftId);        }        emit End(highestBidder, highestBid);    }}</code></pre><h2 id="荷兰式拍卖"><a href="#荷兰式拍卖" class="headerlink" title="荷兰式拍卖"></a>荷兰式拍卖</h2><p>NFT的荷兰式拍卖</p><p>拍卖：</p><ol><li>NFT 卖方部署此合约，为 NFT设定起始价格</li><li>拍卖持续 7 days</li><li>NFT 的价格随着时间的推移而下降</li><li>参与者可以通过存入高于智能合约计算的当前价格的 ETH 来购买</li><li>当买家购买 NFT 时拍卖结束</li></ol><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;interface IERC721 {    function transferFrom(        address _from,        address _to,        uint _nftId    ) external;}contract DutchAuction {    uint private constant DURATION = 7 days;    IERC721 public immutable nft;    uint public immutable nftId;    address payable public immutable seller;    uint public immutable startingPrice;    uint public immutable startAt;    uint public immutable expiresAt;    uint public immutable discountRate;    constructor(        uint _startingPrice,        uint _discountRate,        address _nft,        uint _nftId    ) {        seller = payable(msg.sender);        startingPrice = _startingPrice;        startAt = block.timestamp;        expiresAt = block.timestamp + DURATION;        discountRate = _discountRate;        require(_startingPrice &gt;= _discountRate * DURATION, "starting price &lt; min");        nft = IERC721(_nft);        nftId = _nftId;    }    function getPrice() public view returns (uint) {        uint timeElapsed = block.timestamp - startAt;        uint discount = discountRate * timeElapsed;        return startingPrice - discount;    }    function buy() external payable {        require(block.timestamp &lt; expiresAt, "auction expired");        uint price = getPrice();        require(msg.value &gt;= price, "ETH &lt; price");        nft.transferFrom(seller, msg.sender, nftId);        uint refund = msg.value - price;        if (refund &gt; 0) {            payable(msg.sender).transfer(refund);        }        selfdestruct(seller);    }}</code></pre><h2 id="众筹"><a href="#众筹" class="headerlink" title="众筹"></a>众筹</h2><p><a href="https://solidity-by-example.org/app/crowd-fund">https://solidity-by-example.org/app/crowd-fund</a></p><h2 id="Multi-Call"><a href="#Multi-Call" class="headerlink" title="Multi Call"></a>Multi Call</h2><p><a href="https://solidity-by-example.org/app/multi-call">https://solidity-by-example.org/app/multi-call</a></p><h2 id="Multi-Delegatecall"><a href="#Multi-Delegatecall" class="headerlink" title="Multi Delegatecall"></a>Multi Delegatecall</h2><p><a href="https://solidity-by-example.org/app/multi-delegatecall">https://solidity-by-example.org/app/multi-delegatecall</a></p><h2 id="时间锁"><a href="#时间锁" class="headerlink" title="时间锁"></a>时间锁</h2><p>TimeLock 是一种合约，用于发布未来要执行的交易。在最短的等待时间之后，可以执行事务</p><p>时间锁通常用于 DAO</p><p><a href="https://solidity-by-example.org/app/time-lock">https://solidity-by-example.org/app/time-lock</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Solidity学习笔记-应用部分&quot;&gt;&lt;a href=&quot;#Solidity学习笔记-应用部分&quot; class=&quot;headerlink&quot; title=&quot;Solidity学习笔记(应用部分)&quot;&gt;&lt;/a&gt;Solidity学习笔记(应用部分)&lt;/h1&gt;&lt;p&gt;本文参考：&lt;a </summary>
      
    
    
    
    
    <category term="Ethereum" scheme="https://zhangzhishun.github.io/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Solidity学习笔记(基础部分)</title>
    <link href="https://zhangzhishun.github.io/2022/05/05/blockchain/ethereum/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86)/"/>
    <id>https://zhangzhishun.github.io/2022/05/05/blockchain/ethereum/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86)/</id>
    <published>2022-05-05T11:29:23.000Z</published>
    <updated>2022-05-16T01:06:29.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Solidity学习笔记-基础部分"><a href="#Solidity学习笔记-基础部分" class="headerlink" title="Solidity学习笔记(基础部分)"></a>Solidity学习笔记(基础部分)</h1><p>本文参考：<a href="https://solidity-by-example.org/">https://solidity-by-example.org/</a></p><p>推荐视频课程：<a href="https://www.bilibili.com/video/BV1St411a7Pk">https://www.bilibili.com/video/BV1St411a7Pk</a></p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><pre><code class="solidity">// SPDX-License-Identifier: MIT// compiler version must be greater than or equal to 0.8.13 and less than 0.9.0pragma solidity ^0.8.13;contract HelloWorld {    string public greet = "Hello World!";}</code></pre><h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><p>这是一个简单的合约，用于获取、增加、减少账户余额</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Counter {    uint public count;    // Function to get the current count    function get() public view returns (uint) {        return count;    }    // Function to increment count by 1    function inc() public {        count += 1;    }    // Function to decrement count by 1    function dec() public {        // This function will fail if count = 0        count -= 1;    }}</code></pre><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>在这里介绍四种数据类型：</p><ul><li>boolean</li><li>uint</li><li>int</li><li>address</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Primitives {    bool public boo = true;    /*    uint stands for unsigned integer, meaning non negative integers    different sizes are available        uint8   ranges from 0 to 2 ** 8 - 1        uint16  ranges from 0 to 2 ** 16 - 1        ...        uint256 ranges from 0 to 2 ** 256 - 1    */    uint8 public u8 = 1;    uint public u256 = 456;    uint public u = 123; // uint is an alias for uint256    /*    Negative numbers are allowed for int types.    Like uint, different ranges are available from int8 to int256        int256 ranges from -2 ** 255 to 2 ** 255 - 1    int128 ranges from -2 ** 127 to 2 ** 127 - 1    */    int8 public i8 = -1;    int public i256 = 456;    int public i = -123; // int is same as int256    // minimum and maximum of int    int public minInt = type(int).min;    int public maxInt = type(int).max;    address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;    /*    In Solidity, the data type byte represent a sequence of bytes.     Solidity presents two type of bytes types :     - fixed-sized byte arrays     - dynamically-sized byte arrays.          The term bytes in Solidity represents a dynamic array of bytes.      It’s a shorthand for byte[] .    */    bytes1 a = 0xb5; //  [10110101]    bytes1 b = 0x56; //  [01010110]    // Default values    // Unassigned variables have a default value    bool public defaultBoo; // false    uint public defaultUint; // 0    int public defaultInt; // 0    address public defaultAddr; // 0x0000000000000000000000000000000000000000}</code></pre><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>Solidity 中有 3 种类型的变量</p><ul><li>local<ul><li>函数内定义</li><li>不存储在区块链</li></ul></li><li>state<ul><li>函数外定义</li><li>存储在区块链</li></ul></li><li>global (保存区块链的信息)</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Variables {    // State variables are stored on the blockchain.    string public text = "Hello";    uint public num = 123;    function doSomething() public {        // Local variables are not saved to the blockchain.        uint i = 456;        // Here are some global variables        uint timestamp = block.timestamp; // Current block timestamp        address sender = msg.sender; // address of the caller    }}</code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是不能被修改的</p><p>它们的值是硬编码的，使用常量可以节省 gas 成本</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Constants {    // coding convention to uppercase constant variables    address public constant MY_ADDRESS = 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc;    uint public constant MY_UINT = 123;}</code></pre><h2 id="不可变变量"><a href="#不可变变量" class="headerlink" title="不可变变量"></a>不可变变量</h2><p>不可变变量就像常量。不可变变量的值可以在构造函数中设置，但之后不能修改。</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Immutable {    // coding convention to uppercase constant variables    address public immutable MY_ADDRESS;    uint public immutable MY_UINT;    constructor(uint _myUint) {        MY_ADDRESS = msg.sender;        MY_UINT = _myUint;    }}</code></pre><h2 id="读取和写入状态变量"><a href="#读取和写入状态变量" class="headerlink" title="读取和写入状态变量"></a>读取和写入状态变量</h2><p>要写入或更新状态变量，您需要发送交易</p><p>但是您可以免费读取状态变量，无需任何交易费用</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract SimpleStorage {    // State variable to store a number    uint public num;    // You need to send a transaction to write to a state variable.    function set(uint _num) public {        num = _num;    }    // You can read from a state variable without sending a transaction.    function get() public view returns (uint) {        return num;    }}</code></pre><h2 id="以太坊单位：Ether-and-Wei"><a href="#以太坊单位：Ether-and-Wei" class="headerlink" title="以太坊单位：Ether and Wei"></a>以太坊单位：Ether and Wei</h2><p>交易使用以太币支付，类似于一美元等于 100 美分，1eth等于 10^18wei</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract EtherUnits {    uint public oneWei = 1 wei;    // 1 wei is equal to 1    bool public isOneWei = 1 wei == 1;    uint public oneEther = 1 ether;    // 1 ether is equal to 10^18 wei    bool public isOneEther = 1 ether == 1e18;}</code></pre><h2 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h2><ol><li><p>一次交易需要支付多少eth？</p><p>您支付的 gas spent * gas price 的eth数量，其中：</p><ul><li>gas是一个计算单位</li><li>gas花费是交易中使用的 gas 总量</li><li>gas price是您愿意为每 gas 支付多少 ether </li></ul><p>具有更高 gas 价格的交易有更高的优先级被包含在一个块中，未使用的Gas将被退还</p></li><li><p>Gas限制</p><p>您可以花费的 gas 量有 2 个上限：</p><ul><li>gas limit（您愿意为交易使用的最大 gas 量，由您设置）</li><li>块 gas 限制（一个块中允许的最大 gas 量，由区块链网络设置）</li></ul></li></ol><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Gas {    uint public i = 0;    // Using up all of the gas that you send causes your transaction to fail.    // State changes are undone.    // Gas spent are not refunded.    function forever() public {        // Here we run a loop until all of the gas are spent        // and the transaction fails        while (true) {            i += 1;        }    }}</code></pre><h2 id="If-Else"><a href="#If-Else" class="headerlink" title="If / Else"></a>If / Else</h2><p>Solidity 支持条件语句 if、else if 和 else</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract IfElse {    function foo(uint x) public pure returns (uint) {        if (x &lt; 10) {            return 0;        } else if (x &lt; 20) {            return 1;        } else {            return 2;        }    }    function ternary(uint _x) public pure returns (uint) {        // if (_x &lt; 10) {        //     return 1;        // }        // return 2;        // shorthand way to write if / else statement        return _x &lt; 10 ? 1 : 2;    }}</code></pre><h2 id="For、While循环"><a href="#For、While循环" class="headerlink" title="For、While循环"></a>For、While循环</h2><p>Solidity 支持 for、while 和 do while 循环，不要编写无界循环，因为这可能会达到 gas 限制，导致您的交易失败</p><p>由于上述原因，很少使用 while 和 do while 循环</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Loop {    function loop() public {        // for loop        for (uint i = 0; i &lt; 10; i++) {            if (i == 3) {                // Skip to next iteration with continue                continue;            }            if (i == 5) {                // Exit loop with break                break;            }        }        // while loop        uint j;        while (j &lt; 10) {            j++;        }    }}</code></pre><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>Mapping是使用语法映射（keyType =&gt; valueType）创建的</p><p>keyType可以是任何内置值类型、字节、字符串或合约地址</p><p>valueType可以是任何类型，包括另一个Mapping或数组</p><p>Mappings不可迭代</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Mapping {    // Mapping from address to uint    mapping(address =&gt; uint) public myMap;    function get(address _addr) public view returns (uint) {        // Mapping always returns a value.        // If the value was never set, it will return the default value.        return myMap[_addr];    }    function set(address _addr, uint _i) public {        // Update the value at this address        myMap[_addr] = _i;    }    function remove(address _addr) public {        // Reset the value to the default value.        delete myMap[_addr];    }}contract NestedMapping {    // Nested mapping (mapping from address to another mapping)    mapping(address =&gt; mapping(uint =&gt; bool)) public nested;    function get(address _addr1, uint _i) public view returns (bool) {        // You can get values from a nested mapping        // even when it is not initialized        return nested[_addr1][_i];    }    function set(        address _addr1,        uint _i,        bool _boo    ) public {        nested[_addr1][_i] = _boo;    }    function remove(address _addr1, uint _i) public {        delete nested[_addr1][_i];    }}</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组可以具有编译时固定大小或动态大小</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Array {    // Several ways to initialize an array    uint[] public arr;    uint[] public arr2 = [1, 2, 3];    // Fixed sized array, all elements initialize to 0    uint[10] public myFixedSizeArr;    function get(uint i) public view returns (uint) {        return arr[i];    }    // Solidity can return the entire array.    // But this function should be avoided for    // arrays that can grow indefinitely in length.    function getArr() public view returns (uint[] memory) {        return arr;    }    function push(uint i) public {        // Append to array        // This will increase the array length by 1.        arr.push(i);    }    function pop() public {        // Remove last element from array        // This will decrease the array length by 1        arr.pop();    }    function getLength() public view returns (uint) {        return arr.length;    }    function remove(uint index) public {        // Delete does not change the array length.        // It resets the value at index to it's default value,        // in this case 0        delete arr[index];    }    function examples() external {        // create array in memory, only fixed size can be created        uint[] memory a = new uint[](5);    }}</code></pre><h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><p>Solidity 支持枚举，它们对于跟踪状态很有用。枚举可以在合约之外声明</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Enum {    // Enum representing shipping status    enum Status {        Pending,        Shipped,        Accepted,        Rejected,        Canceled    }    // Default value is the first element listed in    // definition of the type, in this case "Pending"    Status public status;    // Returns uint    // Pending  - 0    // Shipped  - 1    // Accepted - 2    // Rejected - 3    // Canceled - 4    function get() public view returns (Status) {        return status;    }    // Update status by passing uint into input    function set(Status _status) public {        status = _status;    }    // You can update to a specific enum like this    function cancel() public {        status = Status.Canceled;    }    // delete resets the enum to its first value, 0    function reset() public {        delete status;    }}</code></pre><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>您可以通过创建结构体来定义自己的类型</p><p>它们对于将相关数据组合在一起很有用</p><p>结构体可以在合约之外声明并在另一个合约中导入</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Todos {    struct Todo {        string text;        bool completed;    }    // An array of 'Todo' structs    Todo[] public todos;    function create(string memory _text) public {        // 3 ways to initialize a struct        // - calling it like a function        todos.push(Todo(_text, false));        // key value mapping        todos.push(Todo({text: _text, completed: false}));        // initialize an empty struct and then update it        Todo memory todo;        todo.text = _text;        // todo.completed initialized to false        todos.push(todo);    }    // Solidity automatically created a getter for 'todos' so    // you don't actually need this function.    function get(uint _index) public view returns (string memory text, bool completed) {        Todo storage todo = todos[_index];        return (todo.text, todo.completed);    }    // update text    function update(uint _index, string memory _text) public {        Todo storage todo = todos[_index];        todo.text = _text;    }    // update completed    function toggleCompleted(uint _index) public {        Todo storage todo = todos[_index];        todo.completed = !todo.completed;    }}</code></pre><h2 id="数据存储位置"><a href="#数据存储位置" class="headerlink" title="数据存储位置"></a>数据存储位置</h2><p>变量被声明为 storage、memory 或 calldata 以明确指定数据的位置：</p><ul><li>storage：变量是状态变量（存储在区块链上）</li><li>memory：变量在内存中，在调用函数时存在，在声明要存储在内存中（临时）的变量（函数参数以及函数内部的逻辑）时应使用memory</li><li>calldata：一个不可修改、非持久性的区域，用于存储函数参数。在声明外部函数的动态参数时必须使用 calldata，calldata 是存储函数参数的不可修改、非持久性区域</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract DataLocations {    uint[] public arr;    mapping(uint =&gt; address) map;    struct MyStruct {        uint foo;    }    mapping(uint =&gt; MyStruct) myStructs;    function f() public {        // call _f with state variables        _f(arr, map, myStructs[1]);        // get a struct from a mapping        MyStruct storage myStruct = myStructs[1];        // create a struct in memory        MyStruct memory myMemStruct = MyStruct(0);    }    function _f(        uint[] storage _arr,        mapping(uint =&gt; address) storage _map,        MyStruct storage _myStruct    ) internal {        // do something with storage variables    }    // You can return memory variables    function g(uint[] memory _arr) public returns (uint[] memory) {        // do something with memory array    }    function h(uint[] calldata _arr) external {        // do something with calldata array    }}</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>有几种方法可以从函数中输出</p><p>公共函数不能接受某些数据类型作为输入或输出(例如Mapping)</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Function {    // Functions can return multiple values.    function returnMany()        public        pure        returns (            uint,            bool,            uint        )    {        return (1, true, 2);    }    // Return values can be named.    function named()        public        pure        returns (            uint x,            bool b,            uint y        )    {        return (1, true, 2);    }    // Return values can be assigned to their name.    // In this case the return statement can be omitted.    function assigned()        public        pure        returns (            uint x,            bool b,            uint y        )    {        x = 1;        b = true;        y = 2;    }    // Use destructuring assignment when calling another    // function that returns multiple values.    function destructuringAssignments()        public        pure        returns (            uint,            bool,            uint,            uint,            uint        )    {        (uint i, bool b, uint j) = returnMany();        // Values can be left out.        (uint x, , uint y) = (4, 5, 6);        return (i, b, j, x, y);    }    // Cannot use map for either input or output    // Can use array for input    function arrayInput(uint[] memory _arr) public {}    // Can use array for output    uint[] public arr;    function arrayOutput() public view returns (uint[] memory) {        return arr;    }}</code></pre><h2 id="View、Pure修饰函数"><a href="#View、Pure修饰函数" class="headerlink" title="View、Pure修饰函数"></a>View、Pure修饰函数</h2><p>Getter功能的函数可以声明为 view 或 pure</p><p>View 函数声明不会更改状态</p><p>Pure 函数声明不会更改或读取任何状态变量</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract ViewAndPure {    uint public x = 1;    // Promise not to modify the state.    function addToX(uint y) public view returns (uint) {        return x + y;    }    // Promise not to modify or read from the state.    function add(uint i, uint j) public pure returns (uint) {        return i + j;    }}</code></pre><h2 id="Error异常"><a href="#Error异常" class="headerlink" title="Error异常"></a>Error异常</h2><p>Error异常将撤消事务期间对状态所做的所有更改</p><p>您可以通过调用 require、revert 或 assert 来抛出异常</p><ul><li><p>require用于在执行之前验证输入和条件</p></li><li><p>revert 类似于 require，有关详细信息，请参阅下面的代码</p></li><li><p>assert 用于检查不应为假的代码。断言失败可能意味着存在Bug</p></li></ul><p>使用自定义错误来节省Gas</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Error {    function testRequire(uint _i) public pure {        // Require should be used to validate conditions such as:        // - inputs        // - conditions before execution        // - return values from calls to other functions        require(_i &gt; 10, "Input must be greater than 10");    }    function testRevert(uint _i) public pure {        // Revert is useful when the condition to check is complex.        // This code does the exact same thing as the example above        if (_i &lt;= 10) {            revert("Input must be greater than 10");        }    }    uint public num;    function testAssert() public view {        // Assert should only be used to test for internal errors,        // and to check invariants.        // Here we assert that num is always equal to 0        // since it is impossible to update the value of num        assert(num == 0);    }    // custom error    error InsufficientBalance(uint balance, uint withdrawAmount);    function testCustomError(uint _withdrawAmount) public view {        uint bal = address(this).balance;        if (bal &lt; _withdrawAmount) {            revert InsufficientBalance({balance: bal, withdrawAmount: _withdrawAmount});        }    }}</code></pre><h2 id="Modifier函数"><a href="#Modifier函数" class="headerlink" title="Modifier函数"></a>Modifier函数</h2><p>Modifier是可以在函数调用之前和/或之后运行的代码</p><p>Modifier可用于：</p><ul><li>限制访问</li><li>验证输入</li><li>防止重入黑客攻击</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract FunctionModifier {    // We will use these variables to demonstrate how to use    // modifiers.    address public owner;    uint public x = 10;    bool public locked;    constructor() {        // Set the transaction sender as the owner of the contract.        owner = msg.sender;    }    // Modifier to check that the caller is the owner of    // the contract.    modifier onlyOwner() {        require(msg.sender == owner, "Not owner");        // Underscore is a special character only used inside        // a function modifier and it tells Solidity to        // execute the rest of the code.        _;    }    // Modifiers can take inputs. This modifier checks that the    // address passed in is not the zero address.    modifier validAddress(address _addr) {        require(_addr != address(0), "Not valid address");        _;    }    function changeOwner(address _newOwner) public onlyOwner validAddress(_newOwner) {        owner = _newOwner;    }    // Modifiers can be called before and / or after a function.    // This modifier prevents a function from being called while    // it is still executing.    modifier noReentrancy() {        require(!locked, "No reentrancy");        locked = true;        _;        locked = false;    }    function decrement(uint i) public noReentrancy {        x -= i;        if (i &gt; 1) {            decrement(i - 1);        }    }}</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件允许记录日志到以太坊区块链</p><p>事件的一些用例是：</p><ul><li>监听事件和更新用户界面</li><li>一种廉价的存储形式</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Event {    // Event declaration    // Up to 3 parameters can be indexed.    // Indexed parameters helps you filter the logs by the indexed parameter    event Log(address indexed sender, string message);    event AnotherLog();    function test() public {        emit Log(msg.sender, "Hello World!");        emit Log(msg.sender, "Hello EVM!");        emit AnotherLog();    }}</code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造函数是在创建合约时执行的可选函数</p><p>以下是如何将参数传递给构造函数的示例</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;// Base contract Xcontract X {    string public name;    constructor(string memory _name) {        name = _name;    }}// Base contract Ycontract Y {    string public text;    constructor(string memory _text) {        text = _text;    }}// There are 2 ways to initialize parent contract with parameters.// Pass the parameters here in the inheritance list.contract B is X("Input to X"), Y("Input to Y") {}contract C is X, Y {    // Pass the parameters here in the constructor,    // similar to function modifiers.    constructor(string memory _name, string memory _text) X(_name) Y(_text) {}}// Parent constructors are always called in the order of inheritance// regardless of the order of parent contracts listed in the// constructor of the child contract.// Order of constructors called:// 1. X// 2. Y// 3. Dcontract D is X, Y {    constructor() X("X was called") Y("Y was called") {}}// Order of constructors called:// 1. X// 2. Y// 3. Econtract E is X, Y {    constructor() Y("Y was called") X("X was called") {}}</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Solidity 支持多重继承</p><p>合约可以使用is关键字继承其他合约</p><p>要被子合约覆盖的函数必须声明为virtual</p><p>要覆盖父函数的函数必须使用关键字override</p><p>继承的顺序很重要</p><p>你必须按照从“最基础”到“最衍生”（“most base-like” to “most derived”）的顺序列出父合约</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;/* Graph of inheritance    A   / \  B   C / \ /F  D,E*/contract A {    function foo() public pure virtual returns (string memory) {        return "A";    }}// Contracts inherit other contracts by using the keyword 'is'.contract B is A {    // Override A.foo()    function foo() public pure virtual override returns (string memory) {        return "B";    }}contract C is A {    // Override A.foo()    function foo() public pure virtual override returns (string memory) {        return "C";    }}// Contracts can inherit from multiple parent contracts.// When a function is called that is defined multiple times in// different contracts, parent contracts are searched from// right to left, and in depth-first manner.contract D is B, C {    // D.foo() returns "C"    // since C is the right most parent contract with function foo()    function foo() public pure override(B, C) returns (string memory) {        return super.foo();    }}contract E is C, B {    // E.foo() returns "B"    // since B is the right most parent contract with function foo()    function foo() public pure override(C, B) returns (string memory) {        return super.foo();    }}// Inheritance must be ordered from “most base-like” to “most derived”.// Swapping the order of A and B will throw a compilation error.contract F is A, B {    function foo() public pure override(A, B) returns (string memory) {        return super.foo();    }}</code></pre><h2 id="覆盖继承的合约状态变量"><a href="#覆盖继承的合约状态变量" class="headerlink" title="覆盖继承的合约状态变量"></a>覆盖继承的合约状态变量</h2><p>与函数不同，状态变量不能通过在子合约中重新声明来覆盖</p><p>让我们学习如何正确覆盖继承的状态变量</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract A {    string public name = "Contract A";    function getName() public view returns (string memory) {        return name;    }}// Shadowing is disallowed in Solidity 0.6// This will not compile// contract B is A {//     string public name = "Contract B";// }contract C is A {    // This is the correct way to override inherited state variables.    constructor() {        name = "Contract C";    }    // C.getName returns "Contract C"}</code></pre><h2 id="调用父合约"><a href="#调用父合约" class="headerlink" title="调用父合约"></a>调用父合约</h2><p>可以直接调用父合约，也可以使用关键字 super 调用</p><p>使用关键字 super 会调用所有的直接父合约</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;/* Inheritance tree   A /  \B   C \ /  D*/contract A {    // This is called an event. You can emit events from your function    // and they are logged into the transaction log.    // In our case, this will be useful for tracing function calls.    event Log(string message);    function foo() public virtual {        emit Log("A.foo called");    }    function bar() public virtual {        emit Log("A.bar called");    }}contract B is A {    function foo() public virtual override {        emit Log("B.foo called");        A.foo();    }    function bar() public virtual override {        emit Log("B.bar called");        super.bar();    }}contract C is A {    function foo() public virtual override {        emit Log("C.foo called");        A.foo();    }    function bar() public virtual override {        emit Log("C.bar called");        super.bar();    }}contract D is B, C {    // Try:    // - Call D.foo and check the transaction logs.    //   Although D inherits A, B and C, it only called C and then A.    // - Call D.bar and check the transaction logs    //   D called C, then B, and finally A.    //   Although super was called twice (by B and C) it only called A once.    function foo() public override(B, C) {        super.foo();    }    function bar() public override(B, C) {        super.bar();    }}</code></pre><h2 id="变量可见约束"><a href="#变量可见约束" class="headerlink" title="变量可见约束"></a>变量可见约束</h2><p>函数和状态变量必须声明它们是否可以被其他合约访问</p><p>函数可以声明为：</p><ul><li><p>public：任何合约和账户都可以调用</p></li><li><p>private：只在定义函数的合约内部</p></li><li><p>internal：仅继承内部函数的内部合约</p></li><li><p>external：只有其他合约和账户可以调用</p></li></ul><p>状态变量可以声明为公共的、私有的或内部的，但不能声明为外部的</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Base {    // Private function can only be called    // - inside this contract    // Contracts that inherit this contract cannot call this function.    function privateFunc() private pure returns (string memory) {        return "private function called";    }    function testPrivateFunc() public pure returns (string memory) {        return privateFunc();    }    // Internal function can be called    // - inside this contract    // - inside contracts that inherit this contract    function internalFunc() internal pure returns (string memory) {        return "internal function called";    }    function testInternalFunc() public pure virtual returns (string memory) {        return internalFunc();    }    // Public functions can be called    // - inside this contract    // - inside contracts that inherit this contract    // - by other contracts and accounts    function publicFunc() public pure returns (string memory) {        return "public function called";    }    // External functions can only be called    // - by other contracts and accounts    function externalFunc() external pure returns (string memory) {        return "external function called";    }    // This function will not compile since we're trying to call    // an external function here.    // function testExternalFunc() public pure returns (string memory) {    //     return externalFunc();    // }    // State variables    string private privateVar = "my private variable";    string internal internalVar = "my internal variable";    string public publicVar = "my public variable";    // State variables cannot be external so this code won't compile.    // string external externalVar = "my external variable";}contract Child is Base {    // Inherited contracts do not have access to private functions    // and state variables.    // function testPrivateFunc() public pure returns (string memory) {    //     return privateFunc();    // }    // Internal function call be called inside child contracts.    function testInternalFunc() public pure override returns (string memory) {        return internalFunc();    }}</code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>您可以通过声明接口与其他合约交互</p><p>接口：</p><ul><li>不能实现任何函数</li><li>可以从其他接口继承</li><li>所有声明的函数必须是外部的</li><li>不能声明构造函数</li><li>不能声明状态变量</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Counter {    uint public count;    function increment() external {        count += 1;    }}interface ICounter {    function count() external view returns (uint);    function increment() external;}contract MyContract {    function incrementCounter(address _counter) external {        ICounter(_counter).increment();    }    function getCount(address _counter) external view returns (uint) {        return ICounter(_counter).count();    }}// Uniswap exampleinterface UniswapV2Factory {    function getPair(address tokenA, address tokenB)        external        view        returns (address pair);}interface UniswapV2Pair {    function getReserves()        external        view        returns (            uint112 reserve0,            uint112 reserve1,            uint32 blockTimestampLast        );}contract UniswapExample {    address private factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;    address private dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;    address private weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;    function getTokenReserves() external view returns (uint, uint) {        address pair = UniswapV2Factory(factory).getPair(dai, weth);        (uint reserve0, uint reserve1, ) = UniswapV2Pair(pair).getReserves();        return (reserve0, reserve1);    }}</code></pre><h2 id="Payable关键字"><a href="#Payable关键字" class="headerlink" title="Payable关键字"></a>Payable关键字</h2><p>声明为Payable的函数和地址可以在合约中接收以太币</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Payable {    // Payable address can receive Ether    address payable public owner;    // Payable constructor can receive Ether    constructor() payable {        owner = payable(msg.sender);    }    // Function to deposit Ether into this contract.    // Call this function along with some Ether.    // The balance of this contract will be automatically updated.    function deposit() public payable {}    // Call this function along with some Ether.    // The function will throw an error since this function is not payable.    function notPayable() public {}    // Function to withdraw all Ether from this contract.    function withdraw() public {        // get the amount of Ether stored in this contract        uint amount = address(this).balance;        // send all Ether to owner        // Owner can receive Ether since the address of owner is payable        (bool success, ) = owner.call{value: amount}("");        require(success, "Failed to send Ether");    }    // Function to transfer Ether from this contract to address from input    function transfer(address payable _to, uint _amount) public {        // Note that "to" is declared as payable        (bool success, ) = _to.call{value: _amount}("");        require(success, "Failed to send Ether");    }}</code></pre><h2 id="发送Ether-transfer-send-call"><a href="#发送Ether-transfer-send-call" class="headerlink" title="发送Ether(transfer, send, call)"></a>发送Ether(transfer, send, call)</h2><ol><li><p>如何发送Ether？</p><p>你可以使用以下方法发送Ether给其他合约：</p><ul><li>transfer (2300 gas, 抛出异常)</li><li>send (2300 gas, 返回bool)</li><li>call (转发所有gas或设置的gas, 返回bool)</li></ul></li><li><p>如何接收Ether？</p><p>接收Ether的合约必须至少具有以下函数之一：</p><ul><li>receive() external payable</li><li>fallback() external payable</li></ul></li><li><p>你应该使用哪个函数？</p><p>在 2019 年 12 月之后，建议使用与可重入保护结合的调用方法</p><p>通过以下方式防止重入：</p><ul><li>在调用其他合约之前进行所有状态更改</li><li>使用可重入保护修饰符</li></ul></li></ol><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract ReceiveEther {    /*    Which function is called, fallback() or receive()?           send Ether               |         msg.data is empty?              / \            yes  no            /     \receive() exists?  fallback()         /   \        yes   no        /      \    receive()   fallback()    */    // Function to receive Ether. msg.data must be empty    receive() external payable {}    // Fallback function is called when msg.data is not empty    fallback() external payable {}    function getBalance() public view returns (uint) {        return address(this).balance;    }}contract SendEther {    function sendViaTransfer(address payable _to) public payable {        // This function is no longer recommended for sending Ether.        _to.transfer(msg.value);    }    function sendViaSend(address payable _to) public payable {        // Send returns a boolean value indicating success or failure.        // This function is not recommended for sending Ether.        bool sent = _to.send(msg.value);        require(sent, "Failed to send Ether");    }    function sendViaCall(address payable _to) public payable {        // Call returns a boolean value indicating success or failure.        // This is the current recommended method to use.        (bool sent, bytes memory data) = _to.call{value: msg.value}("");        require(sent, "Failed to send Ether");    }}</code></pre><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>fallback是一个不接受任何参数且不返回任何内容的函数。</p><p>它在以下情况下执行： </p><ul><li>调用不存在的函数</li><li>将 Ether 直接发送到合约但 receive() 不存在或 msg.data 不为空</li></ul><p>fallback 在通过 transfer 或 send 调用时有 2300 gas 限制</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Fallback {    event Log(uint gas);    // Fallback function must be declared as external.    fallback() external payable {        // send / transfer (forwards 2300 gas to this fallback function)        // call (forwards all of the gas)        emit Log(gasleft());    }    // Helper function to check the balance of this contract    function getBalance() public view returns (uint) {        return address(this).balance;    }}contract SendToFallback {    function transferToFallback(address payable _to) public payable {        _to.transfer(msg.value);    }    function callFallback(address payable _to) public payable {        (bool sent, ) = _to.call{value: msg.value}("");        require(sent, "Failed to send Ether");    }}</code></pre><h2 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h2><p>call 是与其他合约交互的低级函数</p><p>这是您通过调用 fallback 函数发送 Ether 时推荐使用的方法</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Receiver {    event Received(address caller, uint amount, string message);    fallback() external payable {        emit Received(msg.sender, msg.value, "Fallback was called");    }    function foo(string memory _message, uint _x) public payable returns (uint) {        emit Received(msg.sender, msg.value, _message);        return _x + 1;    }}contract Caller {    event Response(bool success, bytes data);    // Let's imagine that contract B does not have the source code for    // contract A, but we do know the address of A and the function to call.    function testCallFoo(address payable _addr) public payable {        // You can send ether and specify a custom gas amount        (bool success, bytes memory data) = _addr.call{value: msg.value, gas: 5000}(            abi.encodeWithSignature("foo(string,uint256)", "call foo", 123)        );        emit Response(success, data);    }    // Calling a function that does not exist triggers the fallback function.    function testCallDoesNotExist(address _addr) public {        (bool success, bytes memory data) = _addr.call(            abi.encodeWithSignature("doesNotExist()")        );        emit Response(success, data);    }}</code></pre><h2 id="Delegatecall"><a href="#Delegatecall" class="headerlink" title="Delegatecall"></a>Delegatecall</h2><p>delegatecall 是一个类似于call 的底层函数</p><p>当合约A 对合约B 执行delegatecall 时，B 的代码与合约A 的存储、msg.sender 和msg.value 一起执行。</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;// NOTE: Deploy this contract firstcontract B {    // NOTE: storage layout must be the same as contract A    uint public num;    address public sender;    uint public value;    function setVars(uint _num) public payable {        num = _num;        sender = msg.sender;        value = msg.value;    }}contract A {    uint public num;    address public sender;    uint public value;    function setVars(address _contract, uint _num) public payable {        // A's storage is set, B is not modified.        (bool success, bytes memory data) = _contract.delegatecall(            abi.encodeWithSignature("setVars(uint256)", _num)        );    }}</code></pre><h2 id="Function-Selector"><a href="#Function-Selector" class="headerlink" title="Function Selector"></a>Function Selector</h2><p>调用函数时，calldata的前4个字节指定调用哪个函数。这4个字节称为函数选择器。</p><p>以下面这段代码为例。它使用 call 在地址 addr 上执行合约的transfer</p><pre><code class="solidity">addr.call(abi.encodeWithSignature("transfer(address,uint256)", 0xSomeAddress, 123))</code></pre><p>从 abi.encodeWithSignature(….) 返回的前 4 个字节是函数选择器</p><p>如果您在代码中预先计算并内联函数选择器，也许可以节省少量的gas？</p><p>以下是函数选择器的计算方式</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract FunctionSelector {    /*    "transfer(address,uint256)"    0xa9059cbb    "transferFrom(address,address,uint256)"    0x23b872dd    */    function getSelector(string calldata _func) external pure returns (bytes4) {        return bytes4(keccak256(bytes(_func)));    }}</code></pre><h2 id="调用其他合约"><a href="#调用其他合约" class="headerlink" title="调用其他合约"></a>调用其他合约</h2><p>合约可以通过两种方式调用其他合约</p><p>最简单的方法是直接调用它，比如 A.foo(x, y, z)</p><p>调用其他合约的另一种方法是使用低级调用</p><p>这种方法不是推荐</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Callee {    uint public x;    uint public value;    function setX(uint _x) public returns (uint) {        x = _x;        return x;    }    function setXandSendEther(uint _x) public payable returns (uint, uint) {        x = _x;        value = msg.value;        return (x, value);    }}contract Caller {    function setX(Callee _callee, uint _x) public {        uint x = _callee.setX(_x);    }    function setXFromAddress(address _addr, uint _x) public {        Callee callee = Callee(_addr);        callee.setX(_x);    }    function setXandSendEther(Callee _callee, uint _x) public payable {        (uint x, uint value) = _callee.setXandSendEther{value: msg.value}(_x);    }}</code></pre><h2 id="合约中常见其他合约"><a href="#合约中常见其他合约" class="headerlink" title="合约中常见其他合约"></a>合约中常见其他合约</h2><p>其他合约可以使用 new 关键字创建合约</p><p>从 0.8.0 开始，new 关键字通过指定 salt 选项来支持 create2 功能</p><p>创建合约时，合约地址是由 创建者地址 以及 全局的已创建合约的计数器 计算得到，但是如果创建时指定了 salt 选项，则合约地址的生成机制变得不一样。是由创建者地址、给定的 salt 值、目标合约的创建字节码以及合约的构造函数的参数 计算得到，这种 salt 方式创建合约的好处是，你可以根据 salt 和合约参数推断出合约的地址，一般可以将 salt 设置为 <code>keccak256(abi.encodePacked(arg0, arg1))</code> ，这样的话，合约的参数决定了 salt，那么合约的参数就直接决定了合约的地址。</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Car {    address public owner;    string public model;    address public carAddr;    constructor(address _owner, string memory _model) payable {        owner = _owner;        model = _model;        carAddr = address(this);    }}contract CarFactory {    Car[] public cars;    function create(address _owner, string memory _model) public {        Car car = new Car(_owner, _model);        cars.push(car);    }    function createAndSendEther(address _owner, string memory _model) public payable {        Car car = (new Car){value: msg.value}(_owner, _model);        cars.push(car);    }    function create2(        address _owner,        string memory _model,        bytes32 _salt    ) public {        Car car = (new Car){salt: _salt}(_owner, _model);        cars.push(car);    }    function create2AndSendEther(        address _owner,        string memory _model,        bytes32 _salt    ) public payable {        Car car = (new Car){value: msg.value, salt: _salt}(_owner, _model);        cars.push(car);    }    function getCar(uint _index)        public        view        returns (            address owner,            string memory model,            address carAddr,            uint balance        )    {        Car car = cars[_index];        return (car.owner(), car.model(), car.carAddr(), address(car).balance);    }}</code></pre><h2 id="Try-Catch"><a href="#Try-Catch" class="headerlink" title="Try Catch"></a>Try Catch</h2><p>try / catch 只能从外部函数调用和合约创建中捕获错误</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;// External contract used for try / catch examplescontract Foo {    address public owner;    constructor(address _owner) {        require(_owner != address(0), "invalid address");        assert(_owner != 0x0000000000000000000000000000000000000001);        owner = _owner;    }    function myFunc(uint x) public pure returns (string memory) {        require(x != 0, "require failed");        return "my func was called";    }}contract Bar {    event Log(string message);    event LogBytes(bytes data);    Foo public foo;    constructor() {        // This Foo contract is used for example of try catch with external call        foo = new Foo(msg.sender);    }    // Example of try / catch with external call    // tryCatchExternalCall(0) =&gt; Log("external call failed")    // tryCatchExternalCall(1) =&gt; Log("my func was called")    function tryCatchExternalCall(uint _i) public {        try foo.myFunc(_i) returns (string memory result) {            emit Log(result);        } catch {            emit Log("external call failed");        }    }    // Example of try / catch with contract creation    // tryCatchNewContract(0x0000000000000000000000000000000000000000) =&gt; Log("invalid address")    // tryCatchNewContract(0x0000000000000000000000000000000000000001) =&gt; LogBytes("")    // tryCatchNewContract(0x0000000000000000000000000000000000000002) =&gt; Log("Foo created")    function tryCatchNewContract(address _owner) public {        try new Foo(_owner) returns (Foo foo) {            // you can use variable foo here            emit Log("Foo created");        } catch Error(string memory reason) {            // catch failing revert() and require()            emit Log(reason);        } catch (bytes memory reason) {            // catch failing assert()            emit LogBytes(reason);        }    }}</code></pre><h2 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h2><p>您可以在 Solidity 中导入本地和外部文件</p><ol><li><p>本地文件</p><p>这是我们的文件夹结构：</p><pre><code>├── Import.sol└── Foo.sol</code></pre><p>Foo.sol</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;struct Point {    uint x;    uint y;}error Unauthorized(address caller);function add(uint x, uint y) pure returns (uint) {    return x + y;}contract Foo {    string public name = "Foo";}</code></pre><p>Import.sol</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;// import Foo.sol from current directoryimport "./Foo.sol";// import {symbol1 as alias, symbol2} from "filename";import {Unauthorized, add as func, Point} from "./Foo.sol";contract Import {    // Initialize Foo.sol    Foo public foo = new Foo();    // Test Foo.sol by getting it's name.    function getFooName() public view returns (string memory) {        return foo.name();    }}</code></pre></li><li><p>外部文件</p><p>您也可以通过简单地复制 url 从 GitHub 导入</p><pre><code class="solidity">// https://github.com/owner/repo/blob/branch/path/to/Contract.solimport "https://github.com/owner/repo/blob/branch/path/to/Contract.sol";// Example import ECDSA.sol from openzeppelin-contract repo, release-v4.5 branch// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/cryptography/ECDSA.solimport "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/cryptography/ECDSA.sol";</code></pre></li></ol><h2 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h2><p>库类似于合约，但不能声明任何状态变量，也不能发送以太币</p><p>如果所有库函数都是内部的，则库被嵌入到合约中</p><p>否则必须在合约之前部署并链接库部署</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;library SafeMath {    function add(uint x, uint y) internal pure returns (uint) {        uint z = x + y;        require(z &gt;= x, "uint overflow");        return z;    }}library Math {    function sqrt(uint y) internal pure returns (uint z) {        if (y &gt; 3) {            z = y;            uint x = y / 2 + 1;            while (x &lt; z) {                z = x;                x = (y / x + x) / 2;            }        } else if (y != 0) {            z = 1;        }        // else z = 0 (default value)    }}contract TestSafeMath {    using SafeMath for uint;    uint public MAX_UINT = 2**256 - 1;    function testAdd(uint x, uint y) public pure returns (uint) {        return x.add(y);    }    function testSquareRoot(uint x) public pure returns (uint) {        return Math.sqrt(x);    }}// Array function to delete element at index and re-organize the array// so that their are no gaps between the elements.library Array {    function remove(uint[] storage arr, uint index) public {        // Move the last element into the place to delete        require(arr.length &gt; 0, "Can't remove from empty array");        arr[index] = arr[arr.length - 1];        arr.pop();    }}contract TestArray {    using Array for uint[];    uint[] public arr;    function testArrayRemove() public {        for (uint i = 0; i &lt; 3; i++) {            arr.push(i);        }        arr.remove(1);        assert(arr.length == 2);        assert(arr[0] == 0);        assert(arr[1] == 2);    }}</code></pre><h2 id="ABI解码"><a href="#ABI解码" class="headerlink" title="ABI解码"></a>ABI解码</h2><p>abi.encode 将数据编码为字节</p><p>abi.decode 将字节解码回数据</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract AbiDecode {    struct MyStruct {        string name;        uint[2] nums;    }    function encode(        uint x,        address addr,        uint[] calldata arr,        MyStruct calldata myStruct    ) external pure returns (bytes memory) {        return abi.encode(x, addr, arr, myStruct);    }    function decode(bytes calldata data)        external        pure        returns (            uint x,            address addr,            uint[] memory arr,            MyStruct memory myStruct        )    {        // (uint x, address addr, uint[] memory arr, MyStruct myStruct) = ...        (x, addr, arr, myStruct) = abi.decode(data, (uint, address, uint[], MyStruct));    }}</code></pre><h2 id="Keccak256"><a href="#Keccak256" class="headerlink" title="Keccak256"></a>Keccak256</h2><p>keccak256 计算输入的 Keccak-256 散列</p><p>一些用例包括：</p><ul><li>从输入创建确定性唯一 ID</li><li>Commit-Reveal 方案</li><li>简化的加密签名（通过签名hash而不是更大的输入）</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract HashFunction {    function hash(        string memory _text,        uint _num,        address _addr    ) public pure returns (bytes32) {        return keccak256(abi.encodePacked(_text, _num, _addr));    }    // Example of hash collision    // Hash collision can occur when you pass more than one dynamic data type    // to abi.encodePacked. In such case, you should use abi.encode instead.    function collision(string memory _text, string memory _anotherText)        public        pure        returns (bytes32)    {        // encodePacked(AAA, BBB) -&gt; AAABBB        // encodePacked(AA, ABBB) -&gt; AAABBB        return keccak256(abi.encodePacked(_text, _anotherText));    }}contract GuessTheMagicWord {    bytes32 public answer =        0x60298f78cc0b47170ba79c10aa3851d7648bd96f2f8e46a19dbc777c36fb0c00;    // Magic word is "Solidity"    function guess(string memory _word) public view returns (bool) {        return keccak256(abi.encodePacked(_word)) == answer;    }}</code></pre><h2 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h2><p>消息可以在链下签名，然后使用智能合约在链上进行验证</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;/* Signature VerificationHow to Sign and Verify# Signing1. Create message to sign2. Hash the message3. Sign the hash (off chain, keep your private key secret)# Verify1. Recreate hash from the original message2. Recover signer from signature and hash3. Compare recovered signer to claimed signer*/contract VerifySignature {    /* 1. Unlock MetaMask account    ethereum.enable()    */    /* 2. Get message hash to sign    getMessageHash(        0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C,        123,        "coffee and donuts",        1    )    hash = "0xcf36ac4f97dc10d91fc2cbb20d718e94a8cbfe0f82eaedc6a4aa38946fb797cd"    */    function getMessageHash(        address _to,        uint _amount,        string memory _message,        uint _nonce    ) public pure returns (bytes32) {        return keccak256(abi.encodePacked(_to, _amount, _message, _nonce));    }    /* 3. Sign message hash    # using browser    account = "copy paste account of signer here"    ethereum.request({ method: "personal_sign", params: [account, hash]}).then(console.log)    # using web3    web3.personal.sign(hash, web3.eth.defaultAccount, console.log)    Signature will be different for different accounts    0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b    */    function getEthSignedMessageHash(bytes32 _messageHash)        public        pure        returns (bytes32)    {        /*        Signature is produced by signing a keccak256 hash with the following format:        "\x19Ethereum Signed Message\n" + len(msg) + msg        */        return            keccak256(                abi.encodePacked("\x19Ethereum Signed Message:\n32", _messageHash)            );    }    /* 4. Verify signature    signer = 0xB273216C05A8c0D4F0a4Dd0d7Bae1D2EfFE636dd    to = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C    amount = 123    message = "coffee and donuts"    nonce = 1    signature =        0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b    */    function verify(        address _signer,        address _to,        uint _amount,        string memory _message,        uint _nonce,        bytes memory signature    ) public pure returns (bool) {        bytes32 messageHash = getMessageHash(_to, _amount, _message, _nonce);        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);        return recoverSigner(ethSignedMessageHash, signature) == _signer;    }    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)        public        pure        returns (address)    {        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);        return ecrecover(_ethSignedMessageHash, v, r, s);    }    function splitSignature(bytes memory sig)        public        pure        returns (            bytes32 r,            bytes32 s,            uint8 v        )    {        require(sig.length == 65, "invalid signature length");        assembly {            /*            First 32 bytes stores the length of the signature            add(sig, 32) = pointer of sig + 32            effectively, skips first 32 bytes of signature            mload(p) loads next 32 bytes starting at the memory address p into memory            */            // first 32 bytes, after the length prefix            r := mload(add(sig, 32))            // second 32 bytes            s := mload(add(sig, 64))            // final byte (first byte of the next 32 bytes)            v := byte(0, mload(add(sig, 96)))        }        // implicitly return (r, s, v)    }}</code></pre><h2 id="节省Gas方法"><a href="#节省Gas方法" class="headerlink" title="节省Gas方法"></a>节省Gas方法</h2><p>节省Gas的方法：</p><ul><li>用 calldata 替换memory</li><li>将状态变量加载到memory</li><li>将 for 循环 i++ 替换为 ++i</li><li>缓存数组元素</li><li>short circuit</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;// gas golfcontract GasGolf {    // start - 50908 gas    // use calldata - 49163 gas    // load state variables to memory - 48952 gas    // short circuit - 48634 gas    // loop increments - 48244 gas    // cache array length - 48209 gas    // load array elements to memory - 48047 gas    uint public total;    // start - not gas optimized    // function sumIfEvenAndLessThan99(uint[] memory nums) external {    //     for (uint i = 0; i &lt; nums.length; i += 1) {    //         bool isEven = nums[i] % 2 == 0;    //         bool isLessThan99 = nums[i] &lt; 99;    //         if (isEven &amp;&amp; isLessThan99) {    //             total += nums[i];    //         }    //     }    // }    // gas optimized    // [1, 2, 3, 4, 5, 100]    function sumIfEvenAndLessThan99(uint[] calldata nums) external {        uint _total = total;        uint len = nums.length;        for (uint i = 0; i &lt; len; ++i) {            uint num = nums[i];            if (num % 2 == 0 &amp;&amp; num &lt; 99) {                _total += num;            }        }        total = _total;    }}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Solidity学习笔记-基础部分&quot;&gt;&lt;a href=&quot;#Solidity学习笔记-基础部分&quot; class=&quot;headerlink&quot; title=&quot;Solidity学习笔记(基础部分)&quot;&gt;&lt;/a&gt;Solidity学习笔记(基础部分)&lt;/h1&gt;&lt;p&gt;本文参考：&lt;a </summary>
      
    
    
    
    
    <category term="Ethereum" scheme="https://zhangzhishun.github.io/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>IPFS and Friends: A Qualitative Comparison of Next Generation Peer-to-Peer Data Networks</title>
    <link href="https://zhangzhishun.github.io/2022/04/28/distributed_storage/IPFS%20and%20Friends:%20A%20Qualitative%20Comparison%20of%20Next%20Generation%20Peer-to-Peer%20Data%20Networks/"/>
    <id>https://zhangzhishun.github.io/2022/04/28/distributed_storage/IPFS%20and%20Friends:%20A%20Qualitative%20Comparison%20of%20Next%20Generation%20Peer-to-Peer%20Data%20Networks/</id>
    <published>2022-04-28T12:43:09.000Z</published>
    <updated>2022-05-05T09:55:03.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在本文中，我们将对下一代数据网络进行技术概述。我们使用选定的数据网络来介绍一般概念和强调新的发展。具体来说，我们提供了IPFS的更深层次的概述，以及Swarm、Hypercore Protocol、SAFE、Storj和Arweave的总体概述。我们确定常见的构建模块，并提供定性比较。从概述中，我们得出了未来关于数据网络的挑战和研究目标。</p><h2 id="I-概述"><a href="#I-概述" class="headerlink" title="I. 概述"></a>I. 概述</h2><p>集中式控制和治理会导致数据孤岛，这可能会影响可访问性、可用性和机密性。例如，数据访问可能会受到审查。与此同时，数据孤岛为数据泄露和数据出售提供了一个有价值的目标，这可能会危及安全和隐私。一般来说，用户会失去自己的控制权，并将其委托给云提供商。</p><p>打破数据竖井和减少信任假设的一个方向是点对点数据网络。这个术语概括了建立在点对点(P2P)网络之上的一系列数据存储方法，包括数据存储、复制、分发和交换等方面。作为典型的P2P网络，对等点可以直接交互，建立覆盖网络，共享资源，并可以做出自治的本地决策。因此，P2P数据网络努力共同管理和共享存储。虽然P2P网络的主要目标和原则在过去二十年中没有改变，但P2P网络随着时间的推移不断发展，提高了可用性和功能。在图1中，我们展示了从第一代到下一代数据网络的发展。</p><p><img src="/images/distributed_storage/image-20220428142211126.png" alt="image-20220428142211126"></p><p>图1 下一代P2P数据网络的先驱技术</p><h3 id="A-第一代数据网络"><a href="#A-第一代数据网络" class="headerlink" title="A. 第一代数据网络"></a>A. 第一代数据网络</h3><p>还有许多不同的旧P2P网络也可以归类为数据网络。1999年随着音频文件共享网络Napster的出现，P2P技术开始流行起来，紧随其后的是Gnutella，它可以共享所有类型的文件。Napster和Gnutella标志着P2P网络的开始，随后出现了许多专注于特定应用领域或新颖网络结构的P2P网络。例如Freenet实现了匿名存储和检索。Chord， CAN和Pastry提供了维护结构化覆盖网络拓扑的协议。特别是BitTorrent受到了用户和研究社区的广泛关注。BitTorrent引入了激励机制来实现帕累托效率，试图提高网络利用率，实现更高水平的鲁棒性。我们认为Napster、Gnutella、Freenet、BitTorrent等网络是第一代P2P数据网络，主要关注文件共享。</p><p>Androutsellis Theotokis和Spinellis提供了P2P内容分发技术的2004年发展概况——提供了对上一代技术的广泛概述。以前的其他工作也提供了对上一代的更仔细的研究，更密切地关注特定的P2P数据网络(例如，FreeNet和Past)或一般的分布式文件系统(例如，Google FS和Hadoop Distributed FS)。</p><p>P2P技术的进步和第一代数据网络的普及，影响了分布式文件系统和内容分发技术的领域。这种趋势也属于一般的数据网络，特别是P2P数据网络。</p><h3 id="B-Transistion阶段"><a href="#B-Transistion阶段" class="headerlink" title="B. Transistion阶段"></a>B. Transistion阶段</h3><p>在P2P文件共享系统中似乎缺失的一个组件是改善文件的长期存储和可用性的方法。随着2008年比特币的引入，P2P思想，特别是联合数据复制得到了新的关注。分布式分类账技术在分布式系统中提供可用性、完整性和复杂的容错能力。特别是，加密货币显示了其在去中心化环境中作为货币激励机制的潜力。这些以及其他的趋势和发展，例如Kademlia和信息中心网络，导致了我们称之为下一代P2P数据网络的发明。</p><h3 id="C-下一代数据网络"><a href="#C-下一代数据网络" class="headerlink" title="C.下一代数据网络"></a>C.下一代数据网络</h3><p>从2014年IPFS的引入开始，我们将下一代数据网络定义为分散共享和存储数据的系统和概念，这是在过去十年中出现的。我们提供下一代P2P数据网络的技术概述。与现有文献相比，我们提供了下一代数据网络，即P2P数据网络的比较概述。我们主要关注独立于区块链的使用的存储和内容共享。<br>在本文中，我们将展示这些新系统是如何构建的，它们如何利用从以前的系统中获得的知识，以及过去十年中新的发展和进步。我们确定这些系统的构建模块、相似性和趋势。虽然有些系统本身是其他应用程序的构建块，例如去中心化应用程序(DApps)，但我们主要关注系统的两个方面:内容分发和分布式存储。此外，我们还提供了激励机制的见解，用于检索或存储文件，或两者兼而有之。由于许多新的数据网络被开发，我们不能提供所有数据网络的全面概述。相反，我们将重点关注几个精选的系统，它们具有复杂或独特的机制、不同的用例以及不同程度的内容和用户隐私。我们的概述侧重于概念和实现细节的抽象，以提取一般的见解。然而，应该指出的是，由于正在进行的开发，系统很容易发生变化。我们的调查论文使用了广泛的来源，包括同行评议的论文、白皮书以及文档、规范和源代码。<br>具体来说，我们关注IPFS、Swarm、Hypercore Protocol、SAFE、Storj和Arweave。特别是IPFS(InterPlanetary File System, IPFS)作为区块链的存储层已经得到了广泛的应用，并成为了一系列研究的对象。此外，我们将这些系统的概述放在前面的系统和研究方向，即BitTorrent、信息中心网络和区块链。通过对比先驱系统，我们概述了数据网络的演变，并能够深入讨论下一代的进展。<br>在此基础上，我们提取了P2P数据网络的构建块和一些独特的方面。虽然所有的系统都允许分布式内容共享和存储，但它们似乎只关注其中的一个方面。也就是说，每个系统的目标都是服务于具有不同需求和关注点的略有不同的目的。这导致了在网络组织、文件查找、分散程度、冗余和隐私方面的不同设计决策。例如，Storj的目标是分布式云存储，而Hypercore协议则专注于分布式大型数据集。同样，IPFS的目标是取代web的客户端-服务器结构，因此需要比BitTorrent更关注数据查找，因为BitTorrent主要是每个文件都位于自己的覆盖网络中。同时，我们在构建数据网络的方法上发现了许多相似之处，例如，使用Kademlia来构建网络或寻找对等点，将文件分割成块，或激励不同的任务来增加功能。<br>其他关于下一代数据网络的研究尤其关注与区块链的交互。Huang等人主要涵盖了IPFS和Swarm, Benisi等人讨论了这些技术，更侧重于区块链方面。Casino等人仔细研究了去中心化存储的不变性及其后果和可能的威胁。然而，由于可伸缩性或延迟问题，一些数据网络明确决定不使用区块链。因此，在我们的调查论文中，我们对数据网络采取了更广泛的视角，着眼于区块链以外的数据网络的设计决策。<br>Naik和Keshavamurthy对最近的P2P网络给出了一个更普遍的观点。他们描述了下一个层次的P2P网络，像BitTorrent和Chord这样的经典网络的演变，并讨论了动荡下的性能方面。值得注意的是，他们对下一级网络的定义与我们的下一代网络的定义不同，因为他们将IPFS定义为“经典的P2P网络”。相反，我们认为，P2P数据网络是随着时间的推移而演变的，融合了新建立的领域的想法，例如，明确的激励机制。</p><h2 id="II-技术介绍"><a href="#II-技术介绍" class="headerlink" title="II. 技术介绍"></a>II. 技术介绍</h2><p>自P2P数据网络首次出现以来，已经过去了20多年。在此期间，这项技术不断发展，并影响了新网络的发展。我们观察到，基本上有三个“时代”的P2P数据网络:它开始于1999-2002年的P2P文件共享和网络，如BitTorrent和Kademlia，我们认为这是第一代。这个时代之后是一个“过渡阶段”，以信息为中心的网络和加密货币等新想法出现了。大约自2014年IPFS的发明以来，我们看到了新一代P2P数据网络的发展。为了更好地理解和欣赏这些影响，我们介绍了奠定基础的重要“先驱”技术，即BitTorrent、Kademlia、Information-Centric Networking、Self-Certifying Names和区块链。</p><h3 id="A-BitTorrent"><a href="#A-BitTorrent" class="headerlink" title="A. BitTorrent"></a>A. BitTorrent</h3><p>BitTorrent协议[6]是一种P2P文件共享协议。它有一个激励结构来控制下载行为，试图实现资源的公平消耗。BitTorrent的目标是提供一种比使用单一服务器更有效的方式来分发文件。这是通过在每次下载时复制文件这一事实实现的，从而使文件分发具有自伸缩性(self-scalable)。<br>文件以种子形式交换。一般来说，每个种子是一个P2P覆盖网络负责一个文件。为了用BitTorrent协议交换文件，需要创建一个.torrent类型的文件，其中包含文件的元数据和一个跟踪器(tracker)。也可以在一个.torrent文件中定义多个文件。种子文件需要被提供，例如，在网络服务器上，文件可以被共享。跟踪器作为种子的引导节点。具有完整文件的对等点称为种子点。仍然没有命中数据块的节点被称为leechers。leecher请求数据块，并同时作为已经下载的块的下载点。<br>BitTorrent如何处理文件的概念概述见图2。角色和他们的交互如下:一个对等体获得.torrent文件，联系.torrent文件中列出的tracker 𝑇，获得一个对等体列表，连接到对等体，成为一个leecher。在图中，对等体𝑆0作为文件的种子，而对等体𝐿𝑖代表请求不同块的leecher。如.torrent文件所示，该文件被分割为𝑐𝑗块。当leecher成功地获得了所有的块后，它就变成了一颗新的种子。Seed𝑆0和leechers为文件建立了torrent网络。其他文件分布在不同的种子网络与可能不同的对等。</p><p><img src="/images/distributed_storage/image-20220428145010491.png" alt="image-20220428145010491">除了集中呈现的跟踪器，还有无跟踪的种子(trackerless torrents)。在无跟踪torrent中，种子是通过一个分布式哈希表(DHT)找到的。客户端从torrent文件中获取密钥，DHT返回可用的torrent对等点列表。BitTorrent客户端可以使用预先确定的节点或由torrent文件提供的节点来引导DHT。<br>使BitTorrent独一无二(可能是成功的)的特性是明确激励对等点交换数据，这是在文件共享策略中最稀有的部分首先和tit-for-tat实现的。最稀有的部分首先描述了BitTorrent的区块选择。它确保了块重叠的最小化，使文件交换对于节点变动更加健壮。最好选择网络中最不常见的块进行下载。针锋相对描述了带宽资源分配机制。在BitTorrent对等点决定谁他们上传数据基于下载的数据从对等点。这应该防止leecher只下载而不提供任何资源给别人。<br>BitTorrent得到了很好的研究，并证明了它的时间考验。尽管它已经很老了，但仍有数百万人在积极地使用[45]来共享文件，并为较新的点对点文件分发系统提供了一个榜样。此外，BitTorrent基金会和Tron基金会开发了BitTorrent Token (BTT)，作为基于区块链的激励层，以增加文件的可用性和持久性。新的激励结构通过收购数据扩大了针锋相对的竞争。报价数据(bid data)决定了对等端为持续服务满足的BTT/byte速率。作为支付的交换，对端被解除阻塞并有资格接收数据。令牌的交换由支付通道处理。</p><h3 id="B-Kademlia"><a href="#B-Kademlia" class="headerlink" title="B. Kademlia"></a>B. Kademlia</h3><p>从今天的角度来看，Kademlia可能是使用最广泛的DHT。正如我们稍后将看到的，大多数P2P数据网络都以某种方式构建在Kademlia之上。Kademlia还影响了P2P文件交换协议，如BitTorrent，它通过使用基于Kademlia的DHT支持无跟踪的torrent。<br>一般来说，Kademlia可以被归类为结构化的覆盖网络，它规定了如何构造和维护P2P网络。为此，对等体被分配一个身份，这个身份决定了它的位置，进而决定了它的邻居。对于邻居选择，使用异或度量。异或度规的优点是它是对称的和单向的。根据它们的XOR距离，节点被分类为𝑘-buckets。bucket被排列成二叉树，其中最短的前缀决定了bucket。如果一个新节点属于一个包含𝑘个节点(包括它自己)的桶，那么这个桶将被分成更小的桶，否则这个新节点将被丢弃。具有8位标识符的示例性Kademlia树如图3所示。</p><p><img src="/images/distributed_storage/image-20220428145024512.png" alt="image-20220428145024512"></p><h3 id="C-Information-Centric-Networking"><a href="#C-Information-Centric-Networking" class="headerlink" title="C. Information-Centric Networking"></a>C. Information-Centric Networking</h3><p>另一个值得一提的前身是信息中心网络(ICN)。尽管ICN不是一个P2P数据网络，但它的一些想法和概念至少与某些数据网络相似。与P2P数据网络不同，ICN提出改变网络层。包的路由和流应该从点对点位置搜索更改为直接从网络请求内容。举个例子，让我们假设我们想要检索一些数据，例如，一个网站，并且我们知道这个网站在example.com是可用的。首先，我们通过DNS请求站点主机的位置，即IP地址。然后，我们建立一个连接来检索网站。在ICN中，我们将直接请求数据，而不会寻址数据所在的主机。任何存储网站的节点都可以立即提供数据。<br>Jacobson等人提出了以内容为中心的网络，其中这些内容请求是interest packet。内容的所有者可以直接用包含该内容的数据包回答感兴趣的数据包。这就需要在基础设施级别上实现流量控制、路由和安全的其他机制。对interest packet进行广播，对数据感兴趣的对等体可以共享资源。目前有多个处理ICN的项目，例如命名数据网络(NDN)。对于Ntorrent，Mastorakis等人提出了一个NDN的扩展，在NDN中实现了一个类似bittorrent的机制。关于ICN的更多一般信息可在中找到。由于数据网络以内容为中心的性质，它们可以被广泛地解释为ICN的覆盖实现。</p><h3 id="D-Self-Certifying-Names"><a href="#D-Self-Certifying-Names" class="headerlink" title="D .Self-Certifying Names"></a>D .Self-Certifying Names</h3><p>从以主机为中心的通信到以内容为中心的通信的变化引入了新的安全问题。此外，当缓存成为网络的主要特征时，需要考虑特定的威胁，例如缓存中毒或针对缓存的拒绝服务攻击。更广泛地说，ICN的安全问题一般包括内容认证、授权和访问控制以及隐私。<br>目前，安全研究的主要焦点在于认证。由于缓存的广泛使用，数据提供者不再一定是对象的原始源(数据所有者)。这需要使接收者能够评估对象的有效性(完整性)、来源(内容来源)和相关性的机制。<br>确保有效性和相关性的一种方法是自我认证名称。可以使用散列指针(或更通用的内容散列)来引用内容，从而启用自认证名称。文件的内容被用作加密哈希函数的输入，例如SHA-3。得到的摘要可以用来识别内容，客户机可以在本地验证文件的完整性。哈希函数的加密特性，最重要的是预图像和抗碰撞，确保没有人可以在不改变摘要的情况下替换或修改输入数据。在这种情况下，名称提供了完整性和相关性，但是，谁负责验证对象，例如，客户端和/或中间端，仍然是值得怀疑的。此外，自我证明的名称本身不能提供出处或证明物体的来源。加密签名可以保证对象来源的真实性，但需要公钥基础设施或信任网络来验证签名。虽然这允许验证对象来源的真实性，但仍然可能发送格式不正确的对象，因此需要确保完整性的机制。通过缓存的内容的寿命需要谨慎的密钥管理，以防止加密凭据被破坏。<br>访问控制也有类似的问题:一旦数据发布，就很难限制访问或撤销发布。加密可能会限制访问，但可能需要带外密钥分发。关于ICN的安全、隐私、访问控制和其他挑战的进一步见解见[53,54]。</p><h3 id="E-区块链"><a href="#E-区块链" class="headerlink" title="E. 区块链"></a>E. 区块链</h3><p>2008年比特币的引入为分布式应用提供了新的可能性。比特币是一种巧妙而复杂的组合，它结合了来自链接时间领域的各种想法——加密、数字现金、P2P网络、拜占庭容错和密码学。比特币带来的关键创新之一是一种开放的共识算法，它可以积极激励同行遵守规则。因此，它使用了在这个过程中生成的硬币的概念，即挖矿。<br>虽然术语区块链通常指整个系统及其协议，但它也指类似于哈希链或哈希树的特定数据结构。也就是说，区块链使用加密散列对链接到其前任的块进行排序。这种链接的数据结构确保了区块链数据(例如事务)的完整性。区块链的一致性由共识算法保证，例如比特币中的Nakamoto共识。有关比特币和区块链的更多细节，请参阅。<br>由于区块链受到诸如可伸缩性等问题的困扰，人们开发了不同的设计来缓解这些问题。不同的设计开辟了一个新的类别，称为分布式分类账技术(DLT)。dlt提供分布式、拜占庭式容错、不可变和有序的日志。不幸的是，由于一系列的可扩展性问题和链上存储容量有限，纯粹基于DLT的数据网络的可行性有限[57,58]。此外，在被设计为交换和价值存储媒介的区块链(即比特币等加密货币)中存储大量数据会导致高额的交易费用。然而，dlt的研究和开发表明了基于区块链的数据网络的可行性，例如Arweave(参见第4 - e节)。<br>然而，一般来说，允许去中心化支付的加密货币可以作为一种激励结构在P2P数据网络中使用。正如我们将在下文中阐述的，这种激励结构可以增加数据网络的健壮性和可用性，从而解决前几代人的弱点。</p><h2 id="III-INTERPLANETARY-FILE-SYSTEM-IPFS"><a href="#III-INTERPLANETARY-FILE-SYSTEM-IPFS" class="headerlink" title="III. INTERPLANETARY FILE SYSTEM (IPFS)"></a>III. INTERPLANETARY FILE SYSTEM (IPFS)</h2><h2 id="IV-RELATED-P2P-DATA-NETWORKS"><a href="#IV-RELATED-P2P-DATA-NETWORKS" class="headerlink" title="IV. RELATED P2P DATA NETWORKS"></a>IV. RELATED P2P DATA NETWORKS</h2><h3 id="A-Swarm"><a href="#A-Swarm" class="headerlink" title="A. Swarm"></a>A. Swarm</h3><p>Swarm是一个由以太坊基金会开发的用于存储和交付内容的P2P分布式平台。它通过不允许任何删除，以及上传和忘记属性来抵抗审查。群是为以太坊构建的，因此在某些方面依赖并共享以太坊的设计方面。Swarm的目标是为web3栈提供去中心化的存储和流媒体功能，这是一个用于共享互动内容的去中心化的、抵制审查的环境。以太坊基金会将Swarm设想为“世界计算机的硬盘”。<br>与IPFS类似的是Swarm使用基于内容的寻址。与IPFS相反的是Swarm中基于内容的寻址也决定了存储位置。为了确保可用性，群控引入了职责范围。责任区域是节点的近邻。责任区域中的节点应该提供块冗余。通过版本控制支持可变性，保持文件的每个版本。提要、专门构造和寻址的块以及以太坊名称服务(ENS)用于查找变异文件。ENS是以太坊改进提案137中定义的标准。它提供了将地址转换为人类可读名称的能力。与IPNS不同，ENS是作为以太坊区块链上的智能合约来实现的。</p><p>图6是云计算的概念概述，我们继续使用作者和审稿人之间交换的调查论文作为运行例子。Swarm会将一个文件分割，也就是将调查分成一些块，这些块被安排在一个所谓的Swarm hash中。Swarm哈希是排列在Merkle树中的块的组合，其中叶节点代表输入数据，中间节点是子节点的引用组合。得到的数据块被上传到网络。群采用Kademlia拓扑结构，邻居由它们的标识距离决定。需要注意的是，除了桶的连接外，Swarm还依赖于一个最近的邻居集合，即该邻居的剩余节点。一个邻居基本上是包含至少三个其他对等节点的桶数量最少的桶。这个最近的邻居集负责复制，并且不一定是对称的。例如，在图6中，𝑁3的最近邻居是𝑁2，𝑁1和𝑁0，而𝑁12的邻居是𝑁8，𝑁9，𝑁10和𝑁11(参见图3)。上传的块被中继，存储和复制在最近的地址。要检索调查，必须使用群根哈希。网络根据内容地址转发请求。</p><p><img src="/images/distributed_storage/image-20220428151148330.png" alt="image-20220428151148330"></p><p>为了保证确保节点行为，Swarm提供了一个激励层。其激励机制基于SWAP、SWEAR和SWINDLE。SWAP (SWarm Accounting Proto- col)处理节点间数据交换的均衡。各节点维护本地计费信息。对等点基本上是在没有利息的情况下从服务节点购买一大块。区块的价格可以在同行之间协商。请求会被处理到某个不平衡的阈值，即块被不平衡地处理，债务变得过高。在达到第一个阈值后，节点希望得到债务的结清以进行进一步的服务。如果达到第二个阈值，则由于未清偿债务，节点断开连接。债务可以用支票结算，支票可以被理解为一种简单的单向支付渠道。SWarm Enforcement And Registration (SWEAR)和Secured With INsurance Deposit Litigation And Escrow (SWINDLE)将确保内容的持久性。此外，Swarm的激励机制有邮票，它提供了一种机制来防止垃圾上传，也提供了一种彩票机制来激励块的持续存储。<br>邮票可通过智能合约批量获取。邮票被附在上传的区块上，并由邮票所有者签名。这可以作为上传区块的付款凭证。只能通过中继或存储节点监控戳记的使用情况。这允许重复使用/过度使用邮票。为了减少过度使用戳记的风险，戳记只用于某些前缀冲突，将戳记限制为特定存储区域中的块。<br>邮票被用于抽奖。彩票为块提供了价值，以防止块的早期删除。通过抽签，存储节点可以获得邮票的部分初始成本。在彩票中选择一个地址区域。临近区域的节点可以申请奖励。通过应用，节点可以证明该区域内块的所有权。节点定义了存储块的价格。在证明拥有这些块之后，拥有最便宜奖品的节点获得奖励。讨论:群提供了复杂的激励概念。与依赖区块链交易相比，用支票结算不平衡检索提供了一种更快、更便宜的结算差异的方法。与彩票一起发行的邮票为储存大块的数据提供了额外的激励。此外，虽然上传内容需要花费成本，但节点可以通过主动为参与者提供块来赚取成本。然而，邮票可以将用户链接到上传的内容。虽然群集提供了一定程度的发送者匿名性，但上传的匿名性可能会限制可用的内容。<br>考虑到分布式块不可变存储(DISC)所确定的存储位置，网络可能面临存储问题。提要可以在网络中提供用户定义的空间，以恢复提要和固定的形式，可能能够减轻这些缺点。<br>总的来说，Swarm显然依赖于以太坊生态系统。虽然这有利于激励结构，但由于以太坊发展积极，用户基础广泛，这也需要用户对以太坊的依赖。虽然有这么庞大的潜在用户群，但对用例或Swarm机制的研究却很少。Swarm和以太坊的连接可能是缺乏研究的一个原因，因为Swarm似乎没有IPFS那么完整，而以太坊本身仍然保留着许多研究机会。</p><h3 id="B-Hypercore-Protocol-Dat"><a href="#B-Hypercore-Protocol-Dat" class="headerlink" title="B. Hypercore Protocol/Dat"></a>B. Hypercore Protocol/Dat</h3><p>Hypercore Protocol(以前的Dat Protocol)支持类似Git的内容和元数据的增量版本。Hypercore协议由多个子组件组成。严格地说，Hypercore是子组件之一，为了简单起见，我们使用这个术语来泛指Hypercore协议。在Hypercore中，数据存储在一个类似于BitTorrent结构的目录中，每个目录处理自己的网络。该协议支持不同的存储模式，每个节点可以决定目录中的哪些数据以及需要存储哪些版本的数据。此外，该协议支持订阅目录中所有/任何文件的实时更改。协议中的所有通信都是加密的。为了查找和读取数据，需要知道一个特定的读键。<br>该协议旨在共享大量可变数据。创建该协议的动机是为了防止科学文献的链接腐烂和内容漂移。该协议只允许随机访问部分数据。<br>Hypercore可以理解为共享一个文件夹。可以对文件夹中的文件进行修改、添加和删除操作。这也包括并允许可变文件。<br>Hypercore的概念概述如图7所示。对于对等发现，Hypercore使用Hyperswarm，一种基于Kademlia的DHT。如果作者想使用Hypercore协议共享调查结果，需要创建Hypercore并添加调查结果。要想被超perswarm发现，就必须加入超perswarm覆盖网络。通过共享公钥𝐾𝑃𝑢𝑏，审阅者可以计算发现密钥𝐾𝐷，并在找到对等点并加入数据网络后解密消息。一旦另一个覆盖网络加入，非结构化的志愿者网络就可以共享数据，调查可以被检索。<br>讨论:Hypercore允许通过交换公钥来共享数据。可以获取特定版本和特定区域的数据。这使得它变得简单，特别是对于大型数据集，并且允许可变数据。该协议专注于共享文件集合，这扩大了协议的可用性。<br>由于加密和发现密钥，该协议确保了机密性。公钥允许计算发现密钥，但不可能逆转公钥。这将阻止其他人读取数据。Hypercore的一个缺点是缺乏公钥以外的其他身份验证机制，这阻止了额外的细粒度访问控制。此外，它仍然泄漏元数据，因为发现密钥只是一个假名。<br>Hypercore没有复制数据的激励机制，数据的持久性依赖于参与者。利用或分析Hypercore/Dat的研究很少。虽然该协议似乎开发得很好，而且可用，但研究似乎侧重于IPFS。</p><h3 id="C-Secure-Access-For-Everyone-SAFE"><a href="#C-Secure-Access-For-Everyone-SAFE" class="headerlink" title="C. Secure Access For Everyone(SAFE)"></a>C. Secure Access For Everyone(SAFE)</h3><p>人人安全访问(SAFE)网络[17,81]被设计为一个完全自主的分散数据和通信网络。甚至认证也遵循自我认证[82]机制，它不依赖于任何集中组件。SAFE的主要目标是提供一个网络，每个人都可以加入并使用它来存储、查看和发布数据，而不会在机器上留下他们活动的痕迹。这将允许参与者以较低的迫害风险发布内容。<br>SAFE支持三种不同的数据类型:Map、Sequence和Blob。数据可以进一步分为公共数据和私有数据。Map和sequence是无冲突的复制数据类型，这对于确保可变数据的一致性很重要。Blob用于不可变数据。SAFE网络中的所有数据都是加密的，包括公共数据。使用的加密算法是自加密[83]，使用文件本身对文件进行加密。也就是说，一个文件被分割成至少三个固定大小的块。每个块使用前一个块的散列和加密，即𝑛−1，其中𝑛是当前块。之后，加密的块会被原始块的串接哈希值混淆。对于SAFE，混淆后的块存储在网络中。对于解密，在加密过程中会创建一个数据映射。数据映射包含关于文件的信息，并将模糊块的散列映射到真实块的散列。对于公共数据，解密密钥由网络提供。私人数据可以删除，而公共数据应该是永久的。因此，可变数据只能是私有的。名称解析系统允许人类可读的地址来检索数据。<br>网络本身是根据基于卡德米利亚的DHT由异或地址组织的。此外，网络被分成几个部分。当一个新的保险库想要加入网络时，新的保险库需要证明它可以提供所需的资源，然后被随机分配一个XOR地址，从而分配给一个节。这些部分是动态维护的。根据网络中保险库的数量，分区并将保险库重新分配到新的分区。对于长得太小的节，可以通过获取新节点或请求重新定位节点来平衡节的大小。更改section会增加保险库的节点年龄。节点年龄是信任的衡量标准，可以失去，然后必须重新赢得。在一个section中，只有一定数量的节点可以做出决策，即长者。长者是该区域中最古老的节点。由长老投票决定是否接受分区内的事件，经一定人数的长老同意并集体签字后生效。网络段中的事件是，例如，加入/离开一个节点或存储一个块。长者的真实性由SectionProofChain保证，SectionProofChain包含长者的群组签名，是证明一个区段有效性的公钥序列。每当长者组发生变化时，序列就会更新和签名。<br>SAFE网络的概念概述如图8所示。考虑到我们正在运行的示例，调查被划分为自加密的块，并用于生成数据地图。在完成自我认证过程后，向网络发送一个PUT请求。当负责存储块的区域中的长者同意后，数据就被存储。下载文件时，需要数据图。数据映射用于GET请求，以获取经过模糊处理的加密块。下载公共数据不需要认证。在获得这些块之后，可以在数据映射的帮助下重新创建文件。<br>在SAFE网络中，存储数据需要使用该网络自身的货币，即Safecoin。客户的安全币平衡由客户经理监控，并在外管局的共识机制的帮助下被批准/拒绝。节点可以通过耕种(即向请求者提供内容)赚取Safecoin。<br>讨论:自我认证、自我加密和网络组织给了用户对其数据的高度控制。中心组件的缺失减少了单点故障。此外，隐私和在一定程度上匿名是SAFE网络的关键特征。网络中仅存储数据时需要鉴权。检索数据通过客户端选择的代理进行中介，该代理提供了匿名通信。Safecoin旨在提供一个激励层，确保网络的可用性和可靠性。<br>Paul等人[84]在2014年首次对SAFE进行了安全分析，涉及机密性、完整性和可用性以及可能的攻击。2015年，Jacob等人[85]从真实性、完整性、保密性、可用性和匿名性等方面分析了网络的安全性。作者解释了如何利用自我认证和去中心化特性来揭示单个实体的个人数据。</p><h3 id="D-Storj"><a href="#D-Storj" class="headerlink" title="D. Storj"></a>D. Storj</h3><p>Storj[18]是一个P2P存储网络。下面我们引用的是3.0版本。它专注于数据的高持久性、低延迟以及存储数据的高安全性和私密性。支持对通信、文件位置和文件进行端到端加密。为了文件的高持久性或换句话说，文件在网络中更好的可用性，Storj使用了擦除码。此外，低带宽消耗也是设计的主要目标之一。该协议假设对象大小为4𝑀𝐵或更多，虽然支持较小的对象大小，但存储过程的效率可能较低。在Storj中，去中心化被解释为没有一个操作者单独负责系统的操作。在一个分散的系统中，信任和拜占庭式的失败假设是重要的。Storj假设没有利他的，总是表现良好的节点，大多数理性节点，只有在盈利时表现出恶意，还有少数拜占庭式恶意节点。<br>Storj的目标是成为去中心化的云存储。Storj Labs Inc.希望为集中式存储提供商提供另一种选择。为此，Storj提供了与Amazon S3应用程序编程接口的兼容性，以提高总体接受度并简化新用户的迁移。由于Storj提供了云存储，用户可以存储和检索数据，以及删除、移动和复制数据。<br>Storj网络由三种节点类型组成:卫星节点、存储节点和上行节点。卫星节点管理文件的存储过程和维护。对元数据甚至文件路径的加密增加了对元数据的额外保护。上行节点是终端用户，需要存储和访问文件。存储节点用于存储数据。存储和上行节点选择与哪些卫星节点合作。这导致了一个类似于BitTorrent的网络，其中卫星成为中心部分。<br>Storj的概念概述如图9所示。为了上传调查论文，作者需要将其分割成片段，然后对片段进行加密。作者要求卫星存储一个片段。卫星检查存储节点的容量并返回足够的候选存储列表。然后，片段被分割成条状，这些条状被擦除编码并排列成片段。然后，这些片段被并行上传至存储节点。</p><p>对于擦除编码，Storj使用Reed-Solomon擦除码[86]。对于erasure code，数据编码为(𝑘，𝑛)erasure code。这意味着，一个对象被编码为𝑛片段，以这种方式只需要𝑘片段就可以重新创建对象。Storj为每个对象选择四个值:𝑘、𝑚、𝑜和𝑛。𝑘表示重建数据所需的最小块数，𝑚是用于修复的缓冲区，𝑜是用于churn的缓冲区，𝑛是总块数。与多次存储数据块相比，Erasure code提供了更高的冗余，开销更小。此外，由于检索文件只需要𝑘片段，因此可以减少文件可用前的延迟。<br>上传完成后，一个包含片段元数据的指针(例如片段的哈希值、存储位置、擦除编码方案)被返回给卫星。对每个部分重复这个步骤，最后一个部分包含关于调查的额外元数据。如需下载调查报告，请提供各部分的指针。这些片段是由存储节点并行请求的。一旦收集到足够多的片段，就可以阅读调查报告了。<br>为了保证理性节点之间的合作，Storj提供了激励机制。奖励系统奖励存储节点存储和提供内容。通过审计和声誉系统对节点进行监控和评估。Storj的一个目标是低延迟，从而避免依赖区块链的激励机制。<br>讨论:与其他P2P数据网络相比，Storj使用了一些独特的概念。特别是，Amazon S3的兼容性可能会促进Storj成为去中心化的存储系统。擦除码增加了存储文件的开销，但在检索文件时，只需要下载必要数量的片段。通过擦除码的存储去中心化，以及足够的存储节点选择和声誉系统的帮助，增加了对数据泄露的保护。<br>卫星节点是网络的重要组成部分，并对网络进行分区，因为在一颗卫星上可用的文件在另一颗卫星上不可用。这促进了卫星形式的集中化。虽然由于加密，卫星无法与可能的第三方共享元数据，但仍然有可能泄露访问模式。<br>虽然已经部署了Storj，并且确实可以使用，但关于该主题的应用程序和研究相当少。De Figueiredo等人[87]分析了Storj网络，并将卫星节点识别为拒绝服务攻击的可能向量。他们修改了存储节点连接处理的实现，在测试环境中成功拿下了一个卫星节点，使得支付和文件检索在一段时间内无法实现。但是，生产系统应该能够抵抗这种攻击。另一项研究也显示了对数据网络的另一种攻击。Zhang等人[88]指出，在Storj v2.0中，可以将未加密的数据上传到存储节点，用于框架存储节点的所有者。尽管如此，Storj提供了隐私保障、弹性、可获取的元数据或每个人都可以部署不同节点的可能性，这些都可以为云存储提供有价值的见解。</p><h3 id="E-Arweave"><a href="#E-Arweave" class="headerlink" title="E. Arweave"></a>E. Arweave</h3><p>Arweave协议[19]利用了一种类似区块链的结构(称为blockweave)，为永久的链上数据存储以及存储支付提供了一种机制。在块组织中，一个块指向直接前一个块和召回块，召回块是基于前一个块的信息确定地选择的。虽然编织是不可改变的，并提供了对其数据的审查阻力，但每个节点都可以决定拒绝接受内容。通过足够多的节点拒绝内容可以防止包含不需要的内容。<br>Arweave使用了一种类似于BitTorrent的“tit-for-tat”的协议Wildfire来为同行排名。通过Wildfire，每个节点维护一个节点列表，并根据节点的响应能力(如响应请求或发送事务)进行评分和排名。这个分数基本上是由最近请求的平均每秒接收字节数决定的。级别高(因此性能最好)的对等点首先并行地接收消息，然后依次接收其余的消息。定期修剪连接到低等级对等体的连接。这激励节点自身高度响应，以尽可能快的速度接收消息。优化节点的资源利用率，减少通信时间。<br>Arweave的核心是基于区块链的网络。虽然野火引入了一个有利于某些连接的排名，但它仍然是一个非结构化的P2P网络。图10给出了Arweave的概念概述以及如何归档/检索文件。为了在Arweave中存档调查论文，有必要将交易发送到网络上。对等点通过将该交易包含在一个块中来确认该交易。如果有人想要阅读调查，网络被要求。如果一个对等点存储了包含调查的块，它可以被返回，调查可以被读取。</p><p><img src="/images/distributed_storage/image-20220428173237462.png" alt="image-20220428173237462">Arweave的目标是提供数据的永久存储，以一种不可变的方式保存和时间戳信息。数据存储在区块组织的链上，因此，是不可变的，只有通过分叉组织才能移除。blockweave为永久网络提供了去中心化存储。<br>blockweave及其数据的存储和维护通过Arweave的加密货币:Arweave代币来确保。代币用于奖励矿工和支付发送交易。<br>讨论:Arweave协议在类似区块链的结构上提供链上存储。这使得存储具有与区块链类似的优点和缺点。Arweave提供时间戳、透明度、激励机制和不可变存储。数据是通过提供匿名数据作者的事务存储的。<br>区块链最大的问题之一是可扩展性。Arweave试图通过区块阴影(一种类似于紧凑块的机制，在比特币改进提案152[89]中有解释)和野火(用于快速块传播，减少分叉概率)来减少这些问题。此外，使用块哈希列表和钱包列表可以降低初始参与成本。在2.0版本中，Arweave引入了一个硬分叉来提高可伸缩性，将数据与事务分离。在事务中不包括数据，而是包括数据的Merkle根。这提高了事务传播速度，因为转发事务不再需要数据。<br>由于存在伪随机召回块，为了使挖掘收益最大化，节点被激励存储大量的块。这增加了数据的复制。然而，并不是每个节点都必须存储每个块或内容，每个节点根据内容过滤器为自己决定存储哪些数据。请求内容可能会变得复杂，因为节点是随机请求的，希望它们存储内容。<br>对Arweave的直接研究很少。然而，这可以解释为新兴的基于区块链的协议的广泛范围和区块链的研究至少可以部分应用于Arweave。</p><h3 id="F-Honorable-Mentions-and-Related-Concepts"><a href="#F-Honorable-Mentions-and-Related-Concepts" class="headerlink" title="F. Honorable Mentions and Related Concepts"></a>F. Honorable Mentions and Related Concepts</h3><p>在我们对选定的P2P数据网络的详细概述之后，我们提供了有关当前一代P2P数据网络的其他系统和概念的其他文献。特别是，一些论文概念为P2P内容共享提供了不同的、复杂的想法。<br>Sia[90]的目标是成为去中心化的云存储平台。一个文件被分割成多个块，这些块被加密，然后通过擦除编码存储在多个存储节点上。块的位置存储为元数据。Sia使用区块链来激励数据的存储和检索。数据存储的条件和持续时间在存储合同中是固定的。数据所有者负责文件运行状况。<br>OSN (Open Storage Network)[91]是一个用于传输和共享研究数据的分布式网络。它可以与专注于大量研究数据的分布式云服务相媲美。数据存储在中央监控和维护的吊舱中。这些OSN吊舱是专门配置的服务器机架，需要高带宽互联网连接。想要为这个网络做出贡献的机构可以安置豆荚。因此，研究人员可以在OSN网络中存储和共享他们的研究数据。OSN吊舱的连接性应保证数据的快速访问。数据可以与选定的参与者共享，也可以通过开放获取。对pods的集中管理和严格的条件将OSN与现有的其他数据网络区分开来，分散和任意参与是这些数据网络的一个关键特征。<br>Fukumitsu等人[92]提出了一种点对点类型的存储系统，在该系统中，即使是重构所存储文件所需的元数据也存储在网络中，可以通过ID、密码和时间戳来检索。作者假设一个非结构化的P2P网络，其中每个节点可以提供不同的服务。节点定期广播有关自身的必要信息，例如提供的服务及其IP地址。该方案的一个重要组成部分是存储在区块链上的存储节点列表。存储节点列表是随机选取的提供存储服务的节点列表。数据按部分存储，存储过程分为两个阶段:存储用户数据和存储重构用户数据所需的数据。用户数据被加密，分成部分，存储在当前可用的存储节点中选择的节点上。可以使用恢复键请求部件。为了重构用户数据，需要解密密钥、存储节点对和恢复密钥。因此，需要将数据复制到其他节点。用户创建ID、密码对，并选择存储列表。数据通过ID、密码和存储列表的散列进行加密。存储节点是从存储列表中确定选择的。部件的恢复键是存储列表的散列和块索引的散列，即ID和密码。该方案允许获取数据，而无需将信息存储在用户设备上。<br>Jia等人[93]提出了一种实现健忘RAM隐藏数据访问模式的机制——oblvp2p。虽然作者提到他们的机制适用于其他点对点系统，但他们关注的是带有跟踪器的类似BitTorrent的系统。<br>Qian等人[94]提出了Garlic Cast，一种改善覆盖网络中匿名性的机制。对等点不直接请求和搜索内容。相反，对等体搜索代理，代理交换和请求内容。对等体及其代理之间的消息是通过安全增强的信息分散算法(IDA)交换的。rda是一种擦除编码形式，其中𝑘的𝑛片段足以重建对象。安全增强的IDA首先对消息进行加密，使用𝑘-threshold IDA将消息和密钥分割为𝑛片段，然后发送cloves，即包含密钥和消息片段的消息。通过随机游走发现代理:丁香被发送给它的邻居，请求对等点作为一个具有随机丁香序列号的代理，每个邻居随机转发丁香，并维护继承者和前任的状态。具有两个具有相同序列号的丁香的对等体可以恢复请求，如果它自愿成为对等体，它将返回一个回复给请求者。<br>其他论文概念利用区块链进行访问控制，并存储数据位置，而不是作为激励机制的补充，如Blockstack[95]，它在区块链上维护元数据，并依赖外部数据存储来实际存储数据。也有使用分布式账本技术进行访问控制的概念。<br>Calypso[96]，它使用基于跳链的身份和访问管理，允许可审计的数据共享。然而，这些系统和仅集中于通过区块链出售数据的系统不在本次调查的范围之内。</p><h2 id="V-DISCUSSION-OF-BUILDING-BLOCKS"><a href="#V-DISCUSSION-OF-BUILDING-BLOCKS" class="headerlink" title="V. DISCUSSION OF BUILDING BLOCKS"></a>V. DISCUSSION OF BUILDING BLOCKS</h2><p><img src="/images/distributed_storage/image-20220428171303982.png" alt="image-20220428171303982"></p><h3 id="A-Performance"><a href="#A-Performance" class="headerlink" title="A. Performance"></a>A. Performance</h3><p>系统性能的研究已经成为一些研究者所追求的研究方向。通过模拟或测试来调查性能、读/写时间、存储开销、文件查找、抗churn阻力，可以用来识别新的用例，并巩固一个系统可能取代集中式系统的断言。IPFS开发人员开发了“Testground”[103]，用于大规模测试和基准测试P2P系统。从这个意义上说，Testground的性能及其对真实系统的复制能力也是一个值得研究的领域。也有其他分析IPFS性能的研究，如读写时延[28,31]，使用IPFS集群进行物联网数据共享[29]，改进系统[30,36]，或分析网络[34,35,37]。Heinisuo等人[32]表明，由于高网络流量消耗电池，IPFS需要改进才能在移动设备上使用。关于IPFS竞争对手的研究还很缺乏。此外，Naik和Keshavamurthy[41]关注的主题是P2P网络的流失。此外，考虑到研究数据的增加，需要研究在Tera-和Petabytes范围内建立大型单一数据集的数据网络的可行性。</p><h3 id="B-Confidentiality-and-Access-Control"><a href="#B-Confidentiality-and-Access-Control" class="headerlink" title="B. Confidentiality and Access Control"></a>B. Confidentiality and Access Control</h3><p>过去和现在的数据网络提供了一些机密性和访问控制，但这些系统是为公共数据而不是为私有数据设计的。需要研究节点在存储数据时所获得的知识。这不仅涉及数据内容的信息，还涉及元数据(如访问模式)。现有的访问控制系统的安全性有待进一步研究。有研究建议使用区块链进行访问控制[22 - 25,64]，但区块链的不变性使得这对于私人和个人数据来说存在问题。关于私有数据的另一个方面是删除数据。虽然防止删除数据有助于抵制审查，但删除个人、恶意或非法数据的可能性可能提高对数据网络的接受程度。例如，Politou等人[102]提出了一种IPFS中删除内容的机制。调查和改进现有系统可以增加对数据网络的信任。增强对机密性的信任和防止未经授权的访问可以打开这些系统来存储私人和个人数据。</p><h3 id="C-Security"><a href="#C-Security" class="headerlink" title="C. Security"></a>C. Security</h3><p>对于安全研究来说，这一领域的工作通常是在发现和修复新的漏洞之间反复进行。此外，研究还涉及利用P2P数据网络与恶意软件交换数据的恶意活动<br>在安全漏洞方面，Prünster等人[33]披露了对IPFS的eclipse攻击，De Figueiredo等人[87]披露了对Storj的测试网络的拒绝服务攻击。此外，不仅需要研究已知的攻击向量，还需要研究新的攻击向量的存在。例如，Storj承认存在“Honest Geppetto”攻击的可能性，即攻击者(诚实地)长时间地操作许多存储节点，有效地控制大部分存储能力。这种控制允许将数据作为“人质”或一般地取下数据，使数据网络无法操作。另一个例子是Frameup[88]，其中未加密的数据存储在存储节点上，这可能会导致法律问题。存储任意数据也可能给存储设备带来风险。安全是研究领域，我们观察IPFS以外的研究。</p><h3 id="D-Anonymity"><a href="#D-Anonymity" class="headerlink" title="D. Anonymity"></a>D. Anonymity</h3><p>除涉及数据安全和隐私的机密性外，保护个人隐私是另一个相关的方面;特别是匿名性，它描述的是无法在一群个体中识别一个个体，即不可链接性[104]。<br>在匿名方面，数据网络中可以保护各种实体:内容创建者、存储节点和请求内容的用户。在上一代数据网络中，特别是Freenet[2]和GNUnet[105]着重于保护不同实体的身份。Balduf等人[70]已经表明，IPFS通过监控数据请求识别内容请求者，从而继续存在隐私问题。<br>由于激励机制和由此产生的个人指控，很难保证匿名，因为至少需要假名。一旦使用了激励机制，有关请求者的信息就得到了。记录交易的分布式分类账，例如Filecoin、Ethereum Swarm、Arweave，可以揭示额外的信息，因此参与者是匿名的。当一个中心组件授权请求和处理激励时，例如Storj中的卫星节点，请求者、存储节点和中心组件相互认识。在激励请求的情况下，显示请求节点和存储节点。请求者的身份可以通过转发策略或代理(如Swarm、SAFE)部分地得到保护。<br>第一代有像Freenet这样的系统，旨在匿名和抵制审查。这一代的匿名性似乎落后于第一代。尽管使用mixnet或Tor进行匿名通信取得了进展[106]，但还没有数据网络提供强匿名性。总之，提供的匿名保证和进一步的增强需要调查。这包括匿名实用程序的权衡和对不同攻击者模型的分析。匿名不仅对保护个人隐私很重要，而且对保证声称的抵制审查也很重要。如果可以很容易地推断出存储节点的身份，那么即使网络保护不被删除，执法部门也有可能执行<br>审查。这是一个值得关注的问题，特别是对于像Swarm这样的系统，存储块的位置是预先确定的，节点身份是与以太坊假名相连的</p><h3 id="E-Naming"><a href="#E-Naming" class="headerlink" title="E. Naming"></a>E. Naming</h3><p>命名，特别是在分布式系统中提供人类可读的名称，是一个已知的挑战。Zooko ‘s Triangle[107]捕捉到了这个问题及其邻近的挑战。它描述了构建分布式命名空间的困难，分布式命名空间是分布式的(没有中央权威)、安全的(清晰的解析)和人类可读的。<br>在所有系统中，数据的寻址要么缺乏分布性(基于跟踪器的BitTorrent和Storj)，要么缺乏人类可读性(无跟踪器的BitTorrent、Hypercore、IPFS、Swarm和SAFE)。BitTorrent是一个很好的例子，跟踪器是一个中央权威，在无跟踪的BitTorrent的情况下，人类可读的种子是用不太可读的信息哈希(种子的哈希)解决的。在Storj的3.0版本中，卫星是一个中心组件。<br>缺乏可读性是自认证数据的结果，其中数据决定了数据的地址或名称。数据变更后，地址也随之变更。因此，通过不同的机制(独立于内容的命名)来支持人类的可读性。Hy- percore是一个例外。在Hypercore中，数据组被绑定到公钥，并且通过版本控制来保护组内的可变性。<br>提供人类可读性的一个解决方案是名称解析。名称解析允许将密钥映射到自我认证的内容。名称解析可以提供人类的可读性，并提供对文件版本控制的支持。然而，由于更新值的可能性和传播的延迟，即使密钥是唯一的，人们也会认为安全性被破坏了。名称解析独立于Zooko ‘s Triangle，宣布内容，并给出模棱两可的字符串含义，应该只用于公共数据，除非名称解析提供访问控制。<br>为此，IPFS、Swarm和SAFE提供了某种命名服务。实际上，IPFS提供了两种命名服务:IPNS和DNSLink，用于不同的目的。IPNS用于将公钥的哈希映射到IPFS CID，允许可变数据。DNSLink使用DNS TXT记录实现域名到IPFS地址的映射。<br>Swarm还提供了两种命名系统:single-owner chunk和ENS[79]。单所有者块提供了基于所有者和标识符的数据标识，提供了一个安全的、非人类可读的键和一个可更新的值。以太坊名称系统类似于DNS，其中一条记录被映射到一个地址。<br>Swartz[108]认为，基于区块链的名称服务提供了Zooko三角形的所有三个属性。任何人都可以在提供去中心化的区块链上注册名称，名称可以是任何提供人类可读性的名称，而防篡改分类帐确保提供安全性的唯一名称。根据这一论点，像Name- coin、Blockstack[95]和ENS这样的系统被开发出来，它们采用了基于区块链的名称系统的思想。虽然这些系统的存在，除了带有ENS的群系统，似乎没有一个系统能解决Zooko的三角形问题。然而，由于缺乏交易最终性和可能的区块链分叉，可以认为基于区块链的系统违反了强大的安全方面，只提供最终安全性。</p><h2 id="VII-CONCLUSION-AND-LESSONS-LEARNED"><a href="#VII-CONCLUSION-AND-LESSONS-LEARNED" class="headerlink" title="VII. CONCLUSION AND LESSONS LEARNED"></a>VII. CONCLUSION AND LESSONS LEARNED</h2><p>第一代P2P数据网络告诉我们，P2P驱动的文件交换是可行的，并且有一些主要的优势，例如，自扩展性。这项技术持续存在的另一个指标是BitTorrent的持续存在和广泛的用户基础。然而，第一代也教会了我们弱点，例如，缺乏长期可用性。下一代数据网络建立在上一代数据网络的基础上并加以改进，利用技术进步和概念来解决弱点。</p><p>在这篇调查论文中，我们研究了新兴的新一代P2P数据网络。特别地，我们调查了新的发展和技术构件。从我们的定性比较中，我们可以得出结论，除了覆盖结构之外，各种数据网络在文件管理、可用性和激励方面探索了不同的解决方案。最值得注意的是，显性激励机制，如使用加密货币或某种代币，似乎无处不在，以确保长期可用性和参与者的参与。我们还看到了不同的度量方法，以确保在面对拒绝服务攻击或超越激励机制的流失时的可用性，即复制、擦除码，甚至两者的结合。此外，由于许多系统在分布式体系结构中结合了命名服务和内容寻址，它们有可能像Zooko的三角形那样协调人类的可读性、安全性和分散性等系统属性。<br>现在一个重要的开放任务是调查和评估各种构建块。特别是，激励机制的设计是出了名的困难。在某种程度上，我们可以将P2P数据网络的不同部署视为一个大型现场测试，在那里我们可以观察某些设计决策的影响。总的来说，无论是作为其他应用的基础，还是作为研究对象本身，P2P数据网络已经成为研究议程的一部分。<br>然而，许多挑战和开放的研究问题仍然存在，例如，调查匿名性，参与者的隐私和访问控制，开放P2P数据网络到更广泛的可能的用例。因此，我们相信新一代的P2P数据网络为未来的研究提供了许多令人兴奋的机会。</p><p>推荐阅读：</p><ol><li><a href="https://www.youtube.com/watch?v=jp0bF9Qu2Jw">Vol 075 别再问我什么叫 BT 种子</a></li><li>原论文链接：<a href="https://ieeexplore.ieee.org/abstract/document/9684521">https://ieeexplore.ieee.org/abstract/document/9684521</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在本文中，我们将对下一代数据网络进行技术概述。我们使用选定的数据网络来介绍一般概念和强调新的发展。具体来说，我们提供了IPFS的更深层次的概</summary>
      
    
    
    
    
    <category term="Distributed Storage" scheme="https://zhangzhishun.github.io/tags/Distributed-Storage/"/>
    
  </entry>
  
  <entry>
    <title>基于Ubuntu20.04搭建单机Fabric2.3.0Raft共识测试网络</title>
    <link href="https://zhangzhishun.github.io/2022/04/17/blockchain/fabric/%E5%9F%BA%E4%BA%8ERaft%E5%85%B1%E8%AF%86%E6%90%AD%E5%BB%BA%E5%8D%95%E6%9C%BAFabric2.3%E7%BD%91%E7%BB%9C/"/>
    <id>https://zhangzhishun.github.io/2022/04/17/blockchain/fabric/%E5%9F%BA%E4%BA%8ERaft%E5%85%B1%E8%AF%86%E6%90%AD%E5%BB%BA%E5%8D%95%E6%9C%BAFabric2.3%E7%BD%91%E7%BB%9C/</id>
    <published>2022-04-17T13:00:00.000Z</published>
    <updated>2022-05-15T02:00:47.450Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="PRIVATE FILE">    <label for="pass">PRIVATE FILE</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1/Bt6NgjzIoLL4li6oQvK23geLdy6Btchpq21ZPlzYYXWpf5xihAbh5LyFPEVYXVtNrzM3bAm8OZXvSdqSM5ocX1lvDdbtZZ23R/gricrL7l5gpKHw6R/JMoi7hNomZxjB+lTnXVpmw5e3+BDxk1uOoV1J9iyn9oHHjgS/IxQ9dWtsf8PZ7ltbr9Umql58LMu8sEuDEoOcHSK+JxOEJjDtxEpQuvWKEBtE5wrgcy5ClGuk3hr6dTAV0n02Z426cdWjtwoeONgpS/MiHg6nrIKBp9dipfhLofKpxPJFXMj/mbiDTCE/9CEUCsX0sid13WMlyr6pixUHJ9HsUEjrucLsXDLBlSy/D5hY/8HrmRKBHn0olecK4bPNhqsPXTMuQMHJopkvo78uulS2eptC7mC+tcr+fogmsjDgX/FfmCi3SPE7B/mee2n6moG9Jf5rBmoSHOTbxbvLPwIY5IPOyHv/+9RoCJQ9KT788ZEoPmVaXXacG4o2pv6J21NqiGRvfYQSVVX62NW8z1rpAKV9pUgD9j33Bhnks2zzmQsuEwTvaUUPXIOJwtcioRI2CgqqmmKVCqg4hbMWsOCt8PW5hbiR0+K3FSTlE/GJdHFfSLrMR+9JeNdaUTmV0LYsbC3pPc5HDk0YYOHjYqklT+gj0lgoR/o+JWZ0Hfddnwad0a8wOUtd5EJ6S5A7N4UJyPNdSGGqVk274dysaNLW407J+C2Q+1Oje4ZkLH5I6S4R0IYGR+1EWgtsDPB+EFymY0ETiqfpcG8MbM3aZb/YuoOJLzAgETrzkUkd4Eb/jKWzbgiwSwdPvMPl2bfHlF3v1+0mrdCNkk4eERgbIRZlnOvHXZBb2TDo+b+D+dQEGyjuRophLFBpT01XvxSF0hbR4Z8cxsNshXLeK24wmyUnOh/N/YnSZ3WOzguwGo3IhsYIbbFbwV+g4uXp/yYqEDgHigU2PcFaFzXP6PMYgO5+l361wU+7E4KWer0JOmn6yD9TX/9AcHRqTxxV3M6ihWGxYamZ/L83OcdaQNQmgGpz5xGbAcYFuQ/qT/vOjd8InmMd7s24M6XuwtseCJ/GtjhqpGx8ND146PknYwbKCmFr/TEsDRKCEMQaHcXecLPYHg8pIw/XX3Myp0442PZKyDoUXosnM/+/HVyQQVVCCssKts1XvGZldKBgxWyxqoMCP/9guYWps7LHGXpahal8SAQS3JC7V8MlYg/lJMUE0UHPJsB7kiwxzco7cgGSAkSsv1I6iwTZgTz+Tgt5J1Pm17JC05EBLi4NssMTYbVBk+kUEy1EYprdJSpGNWq6K5n4WAGCufVlDTddds79rr0wTJlZJPzLelcWAKAXQFROM33CBPIMfsebWpvTWHYR1pxiJG6w57D/npMgJCMSc1fmpvjo6MgrjiZNlGqdOE3xUjfkz2DeEu0L0Q/a10A5hhztn8E7i7PaQdTRqeVf0vLLDcxA56T7kptMRIKfdgttQPq/SjjkShc1zNsEdDaJpqOOQUqCafAaMsJmzuzTNfW9bqdXgSv6F7jGNKGIvzhYXEAZE5cFA+LeJlpRgtgr7BnlahWGZmBV+4tdh0WC50eK85cNXmnbUtebKuRUobaNSWraUMVjkH1Cqg39KNL0/SrxaoxZVOUh45yno30mECKvlWgYMXzFIrPTE4aM3BkWlPPpvAbYXhbeKeoVt2miZkDypOjAMfkCVA83NpENhH3eyfmsi9iV1zfWo5qX/jQ+KGjxU2VxKcYOUHkv9bEcg7u/X9W+GmFSmzXJKifCedDZgF0BiVFCKyrGVBaZh/De1CTPiOBrd4/6fV1ypr+lNSmtoAJF/jmxK6o76kEGiRVEMDT5xFAKOA1fOA/CzNRveunqniO7InQoz00KXi5oVo4DJu582Em0oOdUiZZk6LKlkTFSJB+WH3cCImU45PvCGRk5jylqR32e2CKXdzcSbyaqGqZcSDH0x/vD5WrNZJBfSH+zRWk2NQgTnQcmEt5qNQU7C5cvSnHYELf3F5mF9fyJuNuN8SvyAw5+LOEgPGL4f0o2xCjKRPD0ukCbR1kR2DAXwngOk5RTzF/2KOc8qc2MxhzQ8ILPmaNAGhP08tUi7jz8dvnWPKROTxR39tNjPFGJeYYJtVee50+UlX1g1MuKdw6TelCVIxGMQcM9VqrMvjW1++cFilsy9cJIwsW4/vBETGuf1cAI4y4D+COsJJGPmiVOVHvcdGfIvFKF8rED+4YD39xFAD1f4Lpem9ylXfdyrk3z+/0yz4RDsfbnfC6Wlzz2iu1l5FtBA6prdOsJunae3PGG178Mma5ssE+2tnPTYePY70DNOS8QJfMvcT21m1KIAUtM8F1ou194oAdmSBV6jVbg75GnHQh9TjbNftvT3FQd8otrx/ZwF0zkleuvGKqhpTK+3U0xQUjESTw7k7p+GXSyN2+xzN/5TO3UusaW10EElHOo9OMuzkrcHh96zdM1x4lNmHyS7qaQLGrqA3lmdGQ27QqcFiRH3oK8/alNT7t9JONeWmfzPI6JrMldQIM1/Qj7z/37zT96IS2E8c8KhRlL46sIGfW32lYAM5eTFeQb3KIJ/V+0ZxorK185qjFRqZT4U9E9w+ex1jVSKbH7knRhkLdvB11DfSCQYeyDCQ36xE6iz5Ts8w5IYiZb6w5TBFJWfw5AVSSMX4UgBR3NXEIk9LNXE4UjoTdKMR89jSpGE6Jh+8Behs8DNgr7M0RMHsOOO74kJs6tL6v/+letRONOTvsznu01G2hu/raXBEVak0eNe/ZU297R2CP6nCrgBhVsjRNnceSOIHtfFr5t1VUnHjN4qmTInx/EOptQJOct5zt2fF0o8Mr/TpGshjYRsxC28bkbamqurLVwhD23cdsYRI3vy+8hrTNOmMAoAe9QGV/xTtBBLjSwsyGlYLO0L9nVGAVuQpznkePCWI41V6VbiUeETnJDO/YZlB79aoRj58luTRMVGUvT1fSDjw6FRDWvFHuP/2IWpCG3eon5NrbOf5K+2SzqINrvB6hyqQJnCppnBi/FT4x6WPAoeK6vFPe8hr+wWNAWESfcK58lY8B8k4wqesmdPWhxIhhvDDgnEc8z2kJxcfevGFKH6dqmDe9yOeWydvW0hbLwdCA1Xt2TV005re3Xhv0QZUYWsqWeCsupjpxNpPiq3ozSA9vSwG/OoorR2jbqJOrTEXx49nXf276wQyTKOvpYLPYfoCRTRJ+owIKo5bMOp+0URL+Uo+GLehIE/6yMhYJbjzwcbMSWggyRhl7BH1s+ifE/NwW2V0+hnV66s9Krdj3Zs/DSBcY9iCPihifQq5VH2+unYNc7rb4LFgCwM0dG21cS36Hb/u3vno7YIC7dw2NKkIwYew1dhNfL4lWf1ffviO+ROX+PYnM2r1kVyNpRqUfFZ/79yQMoOm3GyaUq7UfLSfv0ahPv/nPRX/IaecUyV6k2w9x7AkBSKLf0CBOKNcFsn46P53bNqbvuurc126Dj7duBTmYlNDrOnatKRwlW4izrLsiiv0MaHEQnDXbZiein4Rm6RBzC1Jei9yy4ed7VaKKKSzmiE6F756ZP0IUSGeEM0fBtN0pn94eO0gg2veb1Dz/O5K16jmiQ0j3bTtbjxRJnS10ghJEixGRZb42fLx1LMYJbLKg6iMgZrQ9yTjV1q1DntwzXf47y1g8cu5XHW+M+VLiIvaTX2DNnzL0L7H9Gbh9RFxsDF5zGnteulVDiZo8pxnDiaVG5Zw34zJK5haAVRFpCNrOz8ox/xfhHT/sHRN4uLaItC9ULjbYDNKBIIeVMpD7/nwJWJoQvR5q4CEOGIRI8ABB5gXUEth9z1AViw1RxEHMojEw6cbFiwVYcZNKKdwfDCzhbc7f3wW6I0fI/Dgpa2SaqfOZFpHPvTwNfndExzoLA+NK/QoCnCBDhYdBMAJa0tS1+OMvWwWQXVTeeQiCCNGHVrB8iRc75amaPbUdcXaB5cvry1CZVPI85AGuHwdHhnho6bzV8Q5jdKEOZI2wY9qUb5dRTebwUlHHAS3tmEhh2SLS5Q5leU+B9VViCC9V80qmXMPOxI7dOQQbTtBFVe2vmwc8wDsi2IS6ltmVHmGXizefa7WLzzRMRD/kgOqSs+iQgUsO7mGUId+2RSE+y8mojpSKMYA3Ds/66xqUxDRvAIlDC2qjLJ5KRmRF8QSyEOx8DqVivxxMILM7xJlMn3ShvnWICUE7spUWnYloAW05BnqjBmx8By0CKkJGVWVdM3Bszoz/1jc9vIjT2rDeTKtscjwYdtPoQ9OR1kWgiujTJ/3KbkW5s7op4UVBUndSN0B6zi1wmFvtoHDfW2vzjJU8yNxRklDOSS/gZUVGPCUWhvrBu72pZUEHNJzdVgjbLOVP8LG/X4I4OZhMcgJiVOPFZ0PUSfR6UxohAYFfxU322xgXGhgkp6/8RhRob2gdc2Q9xtmBZ2sS3QNd/3XVXgWwWmj2b9ozR6t0QD8NxA7q0Q6usbphX3Ztb5XGn3zcYxxGbARs8iyJcfop3pE/V4WRA5lR7kDlyqosy0UbD+zpbVzRFfnCDX4XWuoLzQS5awRLpCPmHX/JS0OwJLdCqvmlgJGV7rHT4VUWvT98ySmTWrsm2+ok0LlqhAdux02Dl5VaYSwwlTeXOFXG9MLuCEBSpId5HFfSWON5riiQsr74eCeCvYmMINm6UKV+e1A3R/c7FJggsEDP985PR0ODjqjPyy4zDRFswP+utl5laOd1B4TblqQDdHchz2J530Wm188IaBSuH49NwB9BjSmCywO78Ta8u722JOfpcs9+TNBUZl9nQWMQyYKd5kzpFrkmoiaDgpxLjfbXJkfpDepPeTwP+JT5KqA9ItjX+EQl7zLl3TQB52SDUy2ER1b66WO8U1WfZjt+pbX1j/Xg+aLmUl2N9bOICih8WV+rjkzSu+MDfWhCR+1c8+8+MLyDhvt2a+udIy+0YPgetXiv4Njl7UPTQSDtCIltFyLSu4IYfmoQEPkHBcgTZxeJRN4zYtCAUChrAcAA2fXTBtMft+9SQvRQ3O/iH5hjsyGH1WsWo9q/4wZruSfUCcBx0K3eTFimfNo94aOeKsjx7ZiyamwQ9d6MizA9VyN8sKFX1xdsMxXHayCPVN6cdqZP/XM6oVO6tMz/mZDkt+61udqDz8MUykzX0ogOGES2NehjXMw5YE08MnmmkQWzOaGpL0bol/CIxDqqObioj+NBlwz7RgWLFs13O2BKp+5WMN/EmAmdohm0lTYu88RkrncoJhjcJmDSy1Axv+FL0A/gfFdUbpXRrLTicHuopXJUXI9uUD0D7OGpFv9uWz1n+B3+DLLXhQbGbdzfwp6YLvEWoAbzIlvuIIC/IQyZYYkS8Z98m5xPLUpmX+ejilYDk9RBw2O8jgPnzg6zgGHCWRjG0EJHL/+oHeocZPPs1CJ7V3VNjWs+rUQkRQsi14SnLXorlLxVZtR5KkuW1JAF0Hma5hS7ElMDVDLp9IoVmho7X+vmGt5SOezmClBg0DTntI4IbGw5ZA52mRzuCGzlRMUkpjbOIFXwLhzjjBL28HHw4WVpq/Y2PHvN+lrTQXqI8ZZcRvFZlnHBqvQ6LihmXbOjB7iiSYA/9N0NrNNqrTbY2xr1qndxso4I8hVYBy9KrOsMM321lTd5F+eJIeHQ4Dw+gUCK2Xwb7Du7OQgUuY1y/Xa+IDBVzWlU9woB4IdvnXpJbZrrlX8xOqR8JE248ud9hhEOrcqwXeQOR465SePa1Lrn/SxpO9UZUBc7UWeiXo6Ccr2u/hnAiRBCp3N9mRVh3Je7DK8eQGnqQoy5bbhyL3f/zKLOnsGXHbzZHidUz9ucvqYdG5sOywzk7596lmnFJoARJzQNNF91g0uGkOaaBUFd35l5FysZmxeZ2Rx84cpHmfyUmDg1Ozw7PiMer+Fh1ChdZLtQTfsF3EJafCJ03kJ1tU+CSgwHJTj2rMkbYrLWKVzXspnXA++Y2BIUO3s6jji7vVEUWCVrnzTFYZWd145I+8ce9ZLgrULSKANOxx0Iy9Qa07GfPU8X504wWo7JtUx60DZL9LDd8MUS11H6hyM3FWTyO4YvJ2Fban+67R+LWQMHK0wiXiAsZFKuJz3J+V8CXhYLgo/CNkPjOWyqY2DwSrTYiWmGPh1crMCj1TEhC8gJuNO0zXTtqLjxBzboulfCc46eUld3onppOAISk9e0PIRsbsV4Oi4fbzNr6LAoqHQ7Yq0mTdEJXpXx4RBGJj+mn/Ct8ieM4g+FLCT3hJWRczKmLmcXFLOqnWVcZGsQND9urLQa6CMvChs4aKmog8uinmUsn06cT8olXwSv6Uq60/aRjZoGb3UuVGVKQ0BppyjLOPv8WPjsYvi9K59m2XefLmTlDaLBRuWdLY2xZxDko6cYSwWvoIv1h2CxNLjOFRtMrnot7MPmdeEo8mIL71UTruMMQiF1nexNggbbkbs9fwFW3PKDct5nxP3HpJecObJauBRQg998v1Ej1r7jNScep1U3a1qZB/iojXs4OIgnBvek+PwsVgC3eTCGKU+y6jk6DubCfXKmgKEzzetlIJWKnUumImbutURbeLYH2yvSNnK8gkdyRYq6MhsL7Y2ulXHCTkHz1hwCXRr8SdjBXS0ciat85ULGQOK9c8Gne7oPizqheTI33BHqOSvETdM3BjxbUEFl4Qr8GVu6pEh0Ay5cR6PUgBuzZvvqsJFKciXJjAWPWTLjVCNFcL4aB2rrTcocpbpnQ8PRRhDd88QXnLt+ELeX39tlGW5+tGoTxRjivpA70jyY1PStScVBY5mogPxfNOs+29BkiEIXOE1nTVlYFdgbGGpOXiXf4+mgtxXrn+8t6fOs7ujJTTfnaxM6Mbe2PDSSzvahCjo4T1HqA9VWc/V2XBhYflbFoUJggxm1ma4zfFrfrST4qUvuq+kwP1eyvgVJ2XBu1yYggcPMW4CnVimP0DSW5rOlt8D2mZlXo15MGDntJQ9HHuzwqylflRAYRc9YWdH1mjCQQabVkZSkOemj5NXYsd+3vbKaCyO7e0Y2NSrcIbYTK/mKr0Mh0UL+yNZ6csZOviLTxJOhuOrN7DhrTizCulbAIePSeBww8aQhkLhKnMTiWtqoKAHoLm3xyEDfXzWM1yodnA5yDkNR85h6DeKxEhhcefk2aHkUgRUmlaGHQq6tXUuIlZL6GmYNeva9oqaR5UlU0NxF6WBNivHp2XDH47rHfsUYO5Jv3eoZm9rfmGxhG/vytUWA+AUDwJXtNnKjHMj3xkwZGDyUCwM7SkkCUG+cYaiqHx1a8MXtc74xQrxIeuj1Zs83FzC5HtDIllWdW5p0Wror1IVYX8yzxx3HYK/KF7yvR3S3AP3dGnOPpHL2k1twVpP+VhoBsik0Ogqi0Iv9l5ciWyjt6PN9YVBpxtvE143jTckPN2kMozVk1xey1k+TM6QgRq1AsaBVGRuDQKXRNPazPouc8hbFZPrixkIof9bBpip2fnUAVM+3+5p9GTqJ0tnxsGwJuY8H/ZCwaZdn2LVkFNr+X6PfcvO7Y1wsxJ5inAW7YNgKkbEiX+sJIV+aDzlIrGMLZDurxUMvVo9jf98LbWzrcFGydmODA74QwpKFeQyr78EGR/WW0K375icikfiyNMjFJJDKAC35pnv+EZlh7a9/l39wIDn2Rvrd/StiJ/QsKGYVdB+yz6dqRg1G/4nbEyUvfye5/CNSfieIWYvjpFvvzdsvraXnr5iZSPVKgD9nj/bO2bmZj4PKKJtM7MCgkTXMpo3UVRlP9KvR86V24NtSFP4UHOn8E9S4ogfwDaWMC40kyQ2W+Nx/wwIMKPqxjckhmFoDA675sYPklK4+pwrSngOnysrkPQtWdn5eyZ/Izr57isH3OcZKXkCffHGrQ0TVhMT/G6uGSCRDuUIXLJq9ErRWvIqnUq/X/HuRusUo41FQjWhaJc9fGO1Lsp8pPYnuA51T1mnD8nErOvjs/aH7ZEgVvWeDuJzotfLhbDslxNx0Mfwsmb7u4GZkPJApUfEGDRktdzWbLMyWPLOdiVTpg9f20P+rV/cV2vfPql4oubPE35+C8IDPLEEYtEF9WkEgZxM1tjNQ9/wXgZmsQcO6p991aokl18PfvrvxzszGPSJalWUZUpTtu7BZmgczZU8wjyuPgvGs4BEHXReh4rZvM3li38KndCAvlq36rl7cA3umLjL2HuUuUXE/4tZSb5A0gc4VDtDecJ5YEneiVfcIYNZ6Nf7FfmVDieaFZMlpMejjj1Cxaz18wkAZmiRLXfaTP2Zecz69kcIvzUaiR/9mYg43vnYIGxZK69NxIgJ6AiOUXNTRS0YCPIwPxUuOrn7I8gc/CWfgx38sKogPg1MDLrpkgDrFF66vNuhteEOeu984a9yi7cwK6OHoVXnoC7r1W7KlAn14kG02Jzia4anNs8Hq9LpjWJk13pys1vaSV3pN5zdgpguoU4hpxFk7y3tBBx3CFt38cyxDN4COtKSFQuYps0wP8ZILA9jAt3nSEdsq0jqGP0BI1xf8ExVBQBT3HxeNMgt4uTdBnnarXd0NoJ62JVOWwlW8QQMZM/H3jwNjOfBlnQnNXi0iBLNKli2JkIlgSk3QVlic/PsUVZBo7ZYLIEc9RxMkVbYn50zwC+8g7VSzwkTBysHfVEAYoAZG2s8/uot6cNx5CRxtmXLjVnsgnOUYreuLjQd6Uswded47rfbH4gu5E4D87pJH/VLaUNHYp70zJ24r93ojeMRtl78UWb3A5oIxhGjyA+RzH6VYY1vLDxmnhVFlRuANo9uJh8PbT92MLMloyKJCG2g04Wbo0g4AgqxNtAns7x+bZ5QzsLDHo0PrV4ZX/nCIEvYXIJ/4ooMBsBMKt9h578Yluryh9vMO+9yLOGm5LDXCQXcdbgQE3617gFBmjp3V0Pef03DS5oZAjCPN4leI6xrTdUtQXY28pSQcJsM0Oi/9zEHMUL+30kW7qB+zy6ZkHtzJivpNgI34XOV3EZvDS2PS/LFhr18TZNnwjMqn31mlUcU/zZMv4GEMIBF0oxJNCpb2enZGxXvxSPrXn2MWKU6G35BNyRyL/6DA8F9BuT4vGSfOkHVbPs61jf0vBg9kJvHk/erP/GuYTQN91Mpd98gsbe21LTE6HhXPjK6Uqc7K8d6tfdC9OVs8PquvDqFvlv3wjH//dJ6kOhxXtoGNKB/gpU1urrAqVHFvlAM0dj5lq8hQUh3dGAQZbQfb/VggGMfHRkj5KF4qisWl5fNyqeK7Vg42pyLXsfCDSaD1UYM5gs2BZPlQOwExbXRB+U8Y5yAFT6OuDX4de84pAWS03yTTgapx/NL3vr06KlJxMaZZGzIksTbyji8sw3+2iu8nv4ZvLN7m0LDmDDCB7jt/IOp9XPK85WiKtJjQmKmCCggz82GnChsoC0PTIGb1QYIFPKoxT6Wx44BlJAIEQIG8jq4lltpzjiglBL4S/Ez5oS4rylaHVbGwio7WAZA1Dl46Zvpu07zgVD8LqOHZ4ejIgnIocoHIkEIpTZnKkpBhStKKi+lvZhBSdz/UF4uEfwg4hlGam+Ssi7j9CoX3LdDUByT2MqE7IYNz3ZdAiAuMFmpWyQ/9H1dgM0+MWvXvnks7ba4v6qS0i6WPbZn4z2oQjAYOsSWfi3RBjmXJ8bSbBS1gOggjwZxhLnxsg3NQ2LyzNcgm1gXzcYCig1njVpKAkP9Ag3krxFN69IB9Yb1yfSTLza7dK9oRihm6FcY0DKqhznFuwy/UlLp+EygJ+PdU2WUShL5dSVH9InQ7qm6H7ArEZvSINYlsDQH21vdNQ0p/iTJuVDfWK5VWmyv2fviEdZCKlgIdr9UL2rukHm2+kDMuvMCo22OmTv4MZOqC10j/6/igjRdyuROTZwWHnrvSmNVS32KU13B0bQhV3Yvn1XrYyR6RoZ/B/+Jp4aVoEVNtrA8gCaGWQ8zKYdcvf1qZQXkVMIDdsdNcNZCpdbulloWVKSqzg6mtoFChmFxPIuRE1QEo5HqcPHHCJJevjddHekRrrruvtfiHoSN5F5ndvr9V1us1KQrczBxTg12cLGCdlFD6BKNYAebWux+MlCVJdPO8uIsSEL9hpkv92pBYbElYTudMLkpQi9r+yvhdriNCoiv9GOI8cxm2Mp0tVCo2sUd9duayK7toh2zrP1SKMsDRaU28M1lH5AAy466TWt7yysEw+DBnTdgEfRzrEOAIRsBJFiqh6HKmFyz7Hp0m1TE3y946wmzxMAS1p3Zpk25PK+hf1vnoSBzxxt1VHcyGluWYhcCNlGoKddGayqUegpEaWxiAujOiBi+3ymdmLpvri+yoDJpXF26rPxUK5WoNJPTfzOmqyQ7cnk7b/mh9ikS5CK38l/JXgEACiocL7IZytafV8jKNd6rR6WhupN5CFGcYJSoqRtw3wZuwuZwHGcl4CRMxs7mPCRUWVgPcx8W97TB9pKCUYszVO8fupSmqs25CiTvt1T9GfjAJbhQKjVHzCJ8H0MiEHawgGnnaJG7p8rotHQi1HTPs1zqvONzhUzXJCJ9e70oEhIW/1D9I4bShpFrI55/8EzPUAfwOQcfViySsWsAExp/fUDjVEGyO6hiolyqHKaSsnMqyODCxMAmXEH6/1pvfRQTICGze/2c7dSro8xFxYmPifv5yRRkH/MfnJvA5PZTLBfNaWUDs6tV3WzUoruJxpiP24Cpnk3txRoTEw/r2rs/FsKUziXKMHfzDokp3gLTyXbrokWlA4Uze1554xkQF8bVtBllpyNX6SqboR7WV/2FsY2FNxy0yePf4VI/0m6LRy3t4nakiG7W6RuJdx2w1TtSL+kD8KAwe3E4nK8qIWiNgUv9N9HK51A77gG/iZNTjgSAgYewlcTyt6op41S/VKjdXSFQUm36LOCkvpWnTcE9yVjoqGHQmFgZtrvneiJyXWaWHcxoUsGOvM4/slbIj/BY5cux2aKJ2p99op3B8mcbPtvpa51d1lKLe6RCU2xb+vhIjJFKxrIk3eOGNwFlkIJEvYT6yuEpmjYfuPNhC6FDP46oIxkOwoTnF3pSZPNlVHu23wHGNxgmoKeOQvw0JXUDeBBru/fzotCWmHISbskphdDiJbA+duvfru6SUKX4HsgTuN4rz6t3hiTOwme1xzXcjsnF/kD3ACTmMhtDVgzV+aSd8Pfl24ljhjFz8b9YZytptsgUWPUqasgyafdHYdD7OQkyTymGVQSZJxYRuM+mGc4RHzE+MDGu/FQYK80kwj0edM83OJFhpKHbJPPggPT26g7aK4NItjvYWSFWbr7W4+xJjgT0FevHXxxbIHpz3U+gQaN6SvUGvNMM4+A+MqtfGvzgFaiOYqv+ZeNO4fEYWR9xlH3/gr7bwHp3KFzEGiTSfYYc35LtYULsD5rtjCGKJkC1aw+RXUvPzEpWQdZVMARTNEYYDb4OvHCelXRQ/LpVXnqEPahk58elhXA6fzLhX7MHZbHuwJTC/GkjviW+8Wfyizg/13HQbumTKEtIFcR+pkg0ijZ9x8voML1kMm1wqnxw4zGoQ7s4wzmvi0tBMgxubOFQCa4T+BYBeQLsQA+Xw7a5f9KNS9Ua/AbrIMCeQf7Leiui20l4nQo4Blr/0+k9W828IRYysYCj0a022Ks5+pCRskWWYLkjTjUbKtI7df2XstPuUfFO6B/UY0tK3MvNnS4iciL6Nb6U8LnT555cCkixTnnf8Pw2tVhhM4KczU3Nzumc2awxeCalWdUOSSnsK/WRG8h+z0jk1uP4dCUn6+PHHhC8Lj6W5dxhc/TraQIkz9+FHAICHW/DIMdC1Nq5J+gZVW//Hhl8/93y7YrZfLg18ewjcMzTfLBDZhLBK9ZI2XoC+Miu3rB6menzj5PdD+rm8CSO8MIu/3pDUfSRqjm+13zTGCRq3Z30wU3MjN9/ZaVb0c9firDnlrcnLLWui48nBO6pa03qVb2Nsx4PmWyLx7vF3ez5OVeLdkL89klSL57RbD5ireAaYSNyo6cR5ClZ2I/jKaFeeOi0H0gZxV/T7yWWgLhrwACEfnPfjFpcKiwpIquGExdYAb6+9+XO28WOSHFv0VAjQikzCDi5PTymHl4V9Ru8W0aw+MAlBClLupLxa9vitbWZEjzzmQIql62yzdLeMil8IVM2PQ7C7WLwY4rAQpxzlkAXxgBuiNaH2eHnwrpducLYuLU1bD7dcAM49EYezCya3uBHqZiuIPM39mcQmUmR6B/NPhOKAGTk6/XB381HSj/K0Mr2jk9OaE8CpvCo1e4nqaYEKnGFX6FUsEA1ytbMANogMYiTHGVuXRdxMAaSLnGEeGnuO/zG/XfmVehopnMdvc2z0P7zLLHSC2321Gi9tgZRVqs7JPkUcfhJOPXHs2yPdmV9VGaRM4VZFk=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">The article has been encrypted, please enter your password to view.&lt;br&gt;</summary>
    
    
    
    
    <category term="部署文档" scheme="https://zhangzhishun.github.io/tags/%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/"/>
    
    <category term="Fabric" scheme="https://zhangzhishun.github.io/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Arweave – 一种类区块链的区块编织结构（Lightpaper）</title>
    <link href="https://zhangzhishun.github.io/2022/04/12/blockchain/arweave/Arweave_%E4%B8%80%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%8C%BA%E5%9D%97%E7%BC%96%E7%BB%87%E7%BB%93%E6%9E%84(Lightpaper)/"/>
    <id>https://zhangzhishun.github.io/2022/04/12/blockchain/arweave/Arweave_%E4%B8%80%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%8C%BA%E5%9D%97%E7%BC%96%E7%BB%87%E7%BB%93%E6%9E%84(Lightpaper)/</id>
    <published>2022-04-12T03:20:30.000Z</published>
    <updated>2022-04-27T02:35:55.473Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="http://ipfsdrop.com/docs/whitepaper/arweave-lightpaper/">http://ipfsdrop.com/docs/whitepaper/arweave-lightpaper/</a></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>经典的区块链在数据存储方面存在几个众所周知的主要问题。这些问题需要将新的第三方协议集成到现有区块链的上层，因为费用太高，无法进行链上存储。因此，对于经典的区块链来说，访问内容始终会产生成本，而且内容永远不会永久存储­。随着对数据存储的需求呈指数增长，对可扩展的分布式低成本数据存储协议的需求是必要的。</p><p>在这项工作中，我们介绍Arweave——一种类区块链的区块编织结构。区块编织是一个平台­，致力于首次以经济高效的方式提供可扩展的链上存储。随着系统中存储的数据量的增加，达成共识所需的哈希值减少，从而降低了存储数据的成本。该协议现有的REST API使得在区块编织上层构建去中心化的应用程序­十分简单，反映了Arweave对开发者社区的关注及其推动采用新兴和新颖协议的能力。</p><p>在本文中，我们还介绍了新颖的概念­诸如「区块阴影（block-shadowing）」——一种灵活的交易区块分配算法——­改进了其他区块链的现有“分片”技术­优化网络拓扑，并带来新的共识机制，称为访问证明（Proof of Access）。</p><h2 id="1-导语（Introduction）"><a href="#1-导语（Introduction）" class="headerlink" title="1. 导语（Introduction）"></a>1. 导语（Introduction）</h2><p>在这个信息时代，我们常常屈服于一种幻想，即信息被读取­可用，它永远不会被更改或丢失。从根本上讲这是不正确的[7]。在互联网上，我们建立了一个巨大的去中心化信息传播系统­信息，我们还没有建立一个对应的­永久知识存储系统。现代历史有非常多的例子——­从图书馆和档案馆的大火[9，10，3，8]到专制国家的书籍燃烧（焚书坑儒）[12，11]，重要信息的构建和丢失。当我们在互联网上查询信息时­，我们依赖于被允许访问被集中存储的该数据。­拥有此信息的服务器的访问­所有者可以随时撤消该许可。同样，由于在Internet上提供信息需要支付服务器费用和维护费用，因此当资金不足时，网站通常会轻易地消失。</p><p>更进一步，许多政府正在采取越来越多的步骤来审查和删除对互联网上政治敏感信息的访问[13、5、4]。与媒体和新闻机构一样，我们曾经拥有实体和不可撤销的副本，现在我们­单纯地访问信息，然后将其丢弃。随着时间的推移，媒体组织更新其文章的内容已变得司空见惯。虽然这提供了一些­与以前的系统相比，它具有许多优点，最显着的是，它可以传播有关展开情况的实时更新，还可以使重要的上下文丢失或变得模糊。</p><h2 id="2-背景（Background）"><a href="#2-背景（Background）" class="headerlink" title="2. 背景（Background）"></a>2. 背景（Background）</h2><p>所有区块链创新都站在巨人的肩膀上，包括比特币本身，数据结构交响曲，分布式网络工作和密码学。我们也试图扩大空间，解决现有区块链网络的特定缺点，即存储，并采用一种新颖的交易速度方法。如今，大多数区块链技术都坚持认为，“全节点”必须维护整个区块链的副本以验证未来的交易，而使之成为可能的Merkle数据结构本身就是一项了不起的壮举，并增加了无与伦比的安全性，我们认为围绕此过程的一些性能增强可以减轻整个节点的同步负担，在第4节中介绍了解决块，节点和钱包同步的几种技术。</p><p>当涉及到存储数据时，完整的区块链要求可能甚至是现有区块链技术的障碍。在以太坊（一种去中心化的世界计算机）的情况下，使用其本机令牌的存储成本令人难以置信。 Arweave的主要动机是以与以太坊中表示的方式相同的方式实现永久，不变的存储。但是，高昂的费用使这种存储变得越来越不切实际。虽然可以在以太坊上存储数据，但是由于数据存储成本，先前的尝试是不切实际的。</p><p>其他区块链技术专注于改善节点之间的共识算法，特别是Stellar Lumens和APo和Neo等dPos架构。尽管这可以提高事务处理速度，但存储负担仍然是许多此类网络将面临的长期障碍。通过首先专注于解决存储问题，我们体验了一些性能增强功能，这些性能增强功能可用于促进高吞吐量货币交易。</p><h2 id="3-激励（Motivation）"><a href="#3-激励（Motivation）" class="headerlink" title="3. 激励（Motivation）"></a>3. 激励（Motivation）</h2><p>我们已经设计并实现了一个区块链网络，其中永久性的低成本存储已成为现实。将存储访问权纳入共识，并结合新颖的交易捆绑方法和任意大小的块，可创建高吞吐量的加密货币，该加密货币将比其他加密货币（如比特币[10]和以太坊[12]）有所改善。过去，档案（互联网或其他方式）通常由单个机构（甚至是个人）维护，因此容易受到两种主要形式的操纵。首先是通过在文档存储过程中修改文档[2]。第二个问题是，文档在进入存储之前可能已经被伪造或修改过[1]。例如，许多归因于苏格拉底的作品被认为是他的门徒们写的[6]。 Arweave解决了这两个问题。一旦将文档存储在组织上，就将其与组织上的每个其他块加密链接。这确保了任何尝试更改文档内容的尝试都会被网络检测到并拒绝。以这种方式，不可能破坏组织上的信息。 Arweave是Internet上可浏览的姊妹网络，可提供Internet迫切需要但目前缺乏的长期，永久数据存储功能。</p><p>Arweave系统的关键组件旨在让开发人员轻松构建与网络数据交互，创建和使用的应用程序。这些使用与语言无关的REST API构建的应用程序将充当网络中侦听网络的节点。这些应用程序的功能将是广泛而多样的，从分散和不变的社交网络到讨论网站和新闻聚合器。为了向编织提交信息，将需要少量令牌。这些代币将用于支付矿工在维护组织和网络方面的工作，以及抑制垃圾邮件的传播。这代表了对典型集中式存储系统的极大改进。同样，它使个人有能力确保自己关心的信息能够长期存在。随着网络和文档将增强令牌的价值，维持织法的动机也会增加。随着这些影响的加剧，我们期望Arweave代币将成为信息时代的宝贵资产。与大量重要文件密不可分且内在联系。</p><h2 id="4-技术（Technology）"><a href="#4-技术（Technology）" class="headerlink" title="4. 技术（Technology）"></a>4. 技术（Technology）</h2><p>Arweave建立在四项核心技术的基础上，这些技术可以共同在新的区块链上创建低成本，高吞吐量的永久存储。 这些创新是：</p><ul><li>区块编织（Blockweave）</li><li>访问证明（Proof of Access）</li><li>野火（Wildfire）</li><li>区块阴影（Blockshadows）</li></ul><p>虽然这些技术相互交织，但是每种技术在创建适用于快速事务处理和低成本永久性存储的新型网络方面都发挥着关键作用。</p><h3 id="4-1-区块编织（Blockweave）"><a href="#4-1-区块编织（Blockweave）" class="headerlink" title="4.1 区块编织（Blockweave）"></a>4.1 区块编织（Blockweave）</h3><p>大多数区块链的一个众所周知的特性是，必须存储每个区块以作为“完整节点”参与验证交易。 Arweave并非如此。</p><p>取而代之的是，Arweave引入了两个新概念，这些概念允许节点在不拥有整个链条的情况下完成关键的网络功能。这些概念中的第一个是块哈希列表，它是所有先前块的哈希的列表。这样可以验证旧块，并有效评估潜在的新块。这些概念的第二个是钱包列表，这是系统中所有活动钱包的列表。这样就可以在不占用最后一次交易使用的区块的情况下验证交易。使用这些由网络同步并可以由矿工下载的区块链列表和钱包列表，节点几乎可以立即加入网络并参与对组织的挖掘。</p><p>此外，Arweave使用“持续验证”系统，而不是让每个矿工在进入网络时都验证从基因块到当前块的整个块结构。当矿工加入Arweave网络时，他们将下载当前区块并从当前区块中检索区块哈希和钱包列表。由于这些区块链和钱包列表已通过每个区块的持续进行进行了连续验证，因此新矿工可以立即开始参与，而无需验证整个组织。当然，完全编织验证可用于希望执行该验证的任何节点。通过这种方式，矿工无需查找与钱包相关联的先前交易即可验证新交易。取而代之的是，矿工将只需要验证交易是否已由钱包拥有者的私钥正确签名。为了防止召回块伪造攻击，块哈希表的哈希将与每个新块一起分发。</p><p>Arweave - 一种类区块链的区块编织结构（Lightpaper）</p><p><img src="/images/arweave/image-20220412232151857.png" alt="image-20220412232151857">图1：blockweave数据结构的示意图，展示了到前一个区块和回调区块的链接。</p><h3 id="4-2-访问证明（Proof-of-Access）"><a href="#4-2-访问证明（Proof-of-Access）" class="headerlink" title="4.2 访问证明（Proof of Access）"></a>4.2 访问证明（Proof of Access）</h3><p>Arweaves共识机制基于访问证明（PoA）和工作证明（PoW）。虽然典型的PoW系统仅依赖于前一个块才能生成每个连续的块，但PoA算法会合并来自随机选择的前一个块的数据。结合区块编织数据结构，矿工不需要存储所有区块（形成一个区块链），而是可以存储任何先前的区块（由PoA和野火推动），从而形成区块编织，即区块编织。通过获取当前块的哈希值并计算其相对于当前块高度的模数，可以选择要合并到下一个块中的“调用块”。</p><p>调用块中的事务与在当前块中找到的事务一起进行哈希处理，以生成下一个块。当矿工找到合适的哈希后，他们会将新块与回调区块一起分发给网络的其他成员。这使网络的其他成员，即使没有自己的回调区块副本的那些成员，也可以独立地验证新块是否有效。</p><h3 id="4-3-野火（Wildfire）"><a href="#4-3-野火（Wildfire）" class="headerlink" title="4.3 野火（Wildfire）"></a>4.3 野火（Wildfire）</h3><p>作为数据存储系统，Arweave不仅需要存储大量信息的能力，而且还需要以最方便的方式提供对该数据的访问。此外，Arweave系统的重要组成部分是在请求时对数据进行无成本的访问。随后，Arweave增加了一层激励措施，以鼓励矿工自由共享数据。</p><p>Wildfire是一种系统，它通过使网络上数据请求的快速满足成为参与的必要部分，从而解决了分散式网络中数据共享的问题。 Wildfire通过在每个节点本地创建一个排名系统来进行工作，该排名系统确定新块和事务向对等对象分发的速度如何，基于它们对请求进行响应并接受来自其他对象的数据的速度。对等体按其等级顺序服务，而性能不佳的对等体则被从网络中黑名单中删除。从经济上激励同伴，使他们在彼此的排名中保持良好的位置，以便他们可以花费最大的时间进行有效的挖掘。</p><p>Arweave - 一种类区块链的区块编织结构（Lightpaper）</p><p><img src="/images/arweave/image-20220412232319579.png" alt="image-20220412232319579"></p><p>图2：野火系统示意图。 每个节点根据这些对等点之前对它们的表现进行评估，对其对等点进行排名。<br>这极大地鼓励系统中的节点以对其他对等方尽可能最友好的方式运行，而不会给正在接收数据的人，甚至可能是一次性请求的那些人带来代价。 更进一步，它创建了一种网络拓扑，该拓扑适合于最有效的全局路由，因为首选了允许在系统中快速传输新数据的连接。 实际上，野火机制构建了一个网络拓扑，该拓扑映射了Internet的底层物理连接基础，以适应其架构随时间的变化。 总体而言，野火系统可确保新块的高速分发，并以较短的延迟保持数据可用。</p><h3 id="4-4-区块阴影（Blockshadows）"><a href="#4-4-区块阴影（Blockshadows）" class="headerlink" title="4.4 区块阴影（Blockshadows）"></a>4.4 区块阴影（Blockshadows）</h3><p>在传统的区块链系统中，当挖掘一个新块时，无论一个节点已经拥有多少块数据，每个完整的块都会分配到网络中的每个节点。这不仅浪费大量数据，而且极大地降低了网络就块达成共识的速度。因此，Arweave引入了一种新技术，即块影子，它不仅可以最大程度地减少数据浪费，而且可以实现快速的块共识和巨大的事务吞吐量。</p><p>Blockshadowing的工作原理是部分取消来自块的事务，并且仅在节点之间发送最小的块“影子”，该影子允许对等方重建完整的块，而不是传输完整的块本身。这些区块影子专门包含钱包列表和哈希列表的哈希，并且代替区块内的交易，仅包含交易哈希的列表。根据这一信息（可能只有几千字节），一个已经在该区块中拥有所有交易的节点以及一个最新的哈希和钱包列表可以重建几乎任意大小的整个区块。为了促进这一点，节点还将立即彼此共享事务，但是只有在它们高度确定网络中的其他节点也具有事务处理后，才尝试将事务放置在一个块中。</p><p>这个区块集散系统的结果是一个快速，灵活的区块分配系统，该系统可以使交易以尽可能快的速度在网络上分布，并且可以以接近网络的速度达成共识。此外，该系统可确保当网络使用率很高时，交易费用不会显着增加，并且乐观的100mbps网络上的交易吞吐量的理论限制为每秒约5000笔交易。</p><h3 id="4-5-民主内容政策（Democratic-Content-Policy）"><a href="#4-5-民主内容政策（Democratic-Content-Policy）" class="headerlink" title="4.5 民主内容政策（Democratic Content Policy）"></a>4.5 民主内容政策（Democratic Content Policy）</h3><p>为了支持网络中各个参与者的自由以控制他们存储的内容，并允许整个网络以民主方式拒绝受到广泛谴责的内容，Arweave软件提供了一个黑名单系统。每个节点主节点都有一个（可选）黑名单，其中包含例如它不希望存储的某些数据的哈希值或子字符串，并且永远不会写入与此匹配的磁盘内容。这些黑名单可以由个人建立，也可以通过协作建立，也可以从其他来源导入。</p><p>在本地级别，这些黑名单允许节点控制自己的内容，但是这些本地拒绝的总和也会创建网络范围的内容拒绝。超过一半以上的网络拒绝的内容不仅会被这些单个节点中的每一个拒绝，而且还将被整个网络整体拒绝。这创建了一个民主的全网络内容拒绝系统，该系统可以将各种文化和观点中的黑名单合并为一个普遍删除的微小的特定内容黑名单。这个接近普遍，民主的黑名单使网络不受少数行为者的干扰，同时仍允许其以民主方式保护自己的自由。</p><h2 id="4-6-讨论（Discussion）"><a href="#4-6-讨论（Discussion）" class="headerlink" title="4.6 讨论（Discussion）"></a>4.6 讨论（Discussion）</h2><h3 id="4-6-1-存储池（Storage-Pools）"><a href="#4-6-1-存储池（Storage-Pools）" class="headerlink" title="4.6.1 存储池（Storage Pools）"></a>4.6.1 存储池（Storage Pools）</h3><p>对Arweave的一种潜在的理论攻击已经变得非常大，那就是矿工可能会合作维护一个组织的单个副本，他们都可以使用这些副本来检索召回块。 虽然这种行为乍看起来似乎是问题，但事实并非如此。 如果此类“存储池”被大部分矿工雇用，那么其他矿工存储稀有矿块的动机就会增加。 这是因为，如果集中存储区不可用，则当将来该稀有块成为撤回块时，具有稀有块副本的矿工将很可能获得奖励。 这种自私的行为为网络提供了风险抵销功能，该功能会随着数据丢失（由集中存储池引起）的可能性增长而扩展。</p><h2 id="5-构建App（Building-Apps）"><a href="#5-构建App（Building-Apps）" class="headerlink" title="5. 构建App（Building Apps）"></a>5. 构建App（Building Apps）</h2><p>可以使用简单的REST API构建使用组织的应用程序。 REST端点是HTTP，可以直接访问网络，因此任何Arweave钱包都可以读取和写入数据。 客户只需要通过Chrome扩展程序或具有Arweave钱包集成功能的本机应用程序将其Arweave钱包带入网站，即可从网络读取数据或向网络写入数据。 可以在组织之上构建几种体系结构。</p><h3 id="5-1-客户端-服务器架构（Client-Server-Architecture）"><a href="#5-1-客户端-服务器架构（Client-Server-Architecture）" class="headerlink" title="5.1 客户端-服务器架构（Client-Server Architecture）"></a>5.1 客户端-服务器架构（Client-Server Architecture）</h3><p>传统的Web或本机应用程序具有客户端-服务器体系结构。在云上运行的服务器将被“启用Arweave”，与一个或多个Arweave节点进行交互，代表客户端读取和写入数据。这些服务可以是将客户端作为访问者的网站，也可以是将客户端请求传递给开发人员操作的服务器的本机应用程序。这些服务器将需要维护AR令牌的浮动，以确保可以处理写入数据的请求。使用该架构从编织读取数据仍然是免费的。</p><p>该架构的获利潜力很简单。开发人员将需要通过广告，每月订阅或直接付款来获得更大的价值，而不是使用其为存储提供动力的AR令牌数量。永久性不可变存储有许多应用。例如，存储抗量子，加密的法律案例文件，身份或医疗记录。尽管某些法规需要适应敏感信息的存储，地理范围和被遗忘的权利，但也可以通过加密和密钥管理来缓解这种情况。几个创收模型可以在组织的顶部分层，其主要价值主张是链上永久不可变的存储。</p><h3 id="5-2-无服务器架构（Serverless-Architecture）"><a href="#5-2-无服务器架构（Serverless-Architecture）" class="headerlink" title="5.2 无服务器架构（Serverless Architecture）"></a>5.2 无服务器架构（Serverless Architecture）</h3><p>客户端可以通过启用Arweave的浏览器访问应用程序，而应用程序可以自身运行。由于浏览器的普及和Web技术的普及，使用HTML / CSS / JS将这些应用程序存储为标准前端Web应用程序是最有意义的。但是，如果客户端的本机应用程序包含针对不同语言（例如LLVM字节码）或脚本语言（如Python）的解释器/解析器，则它们可以在客户端上运行，并且可能会受益于Web应用程序中的相同可升级性。</p><p>开发人员不仅可以将无服务器的应用程序部署到Arweave，而且这些应用程序还可以将持久性和可证明状态写入网络。由于Arweave没有施加特定的数据结构，因此开发人员可以自由地以对他们来说最有意义的格式存储数据。如果该应用程序最好通过高度优化的Merkle结构（例如以太坊虚拟机（EVM）中找到的结构）来满足，则可以轻松地将其实现。如果开发人员正在寻找更多的文本Blob样式存储，那么这也是微不足道的。</p><p>无服务器应用程序非常有趣，因为它们可以写入自己的数据。例如，基于分布式计算将允许训练神经网络存储其结果，并可能与其他网络共享其结果模型。</p><h3 id="5-3-基于事件的（Event-Based）"><a href="#5-3-基于事件的（Event-Based）" class="headerlink" title="5.3 基于事件的（Event Based）"></a>5.3 基于事件的（Event Based）</h3><p>在Twitter成立之初，便有了蓬勃发展的家庭手工业应用程序生态系统，而开发人员则在“ firehost” API的基础上开发，这些API将推文流化为任何愿意付费访问的人。 情况已不再如此，在Facebook Cambridge Analytica惨败之后，这些向客户提供数据分析的服务的许多“可信赖的合作伙伴”都被任意关闭。</p><p>Arweave是一个分散的公共数据网络，因此，除了被民主拒绝的内容外，它永远不会审查数据访问或数据本身。 这意味着开发人员可以自由地在Arweave之上进行构建，并且可以使用REST API侦听传入的数据。 触发事件后，侦听器将触发订阅了这些事件的客户端的相应函数调用。 开发人员不必担心会受到限制或关闭，因为网络受到激励以向他们提供对数据馈送的可靠访问。</p><h3 id="5-4-无信任和可证明（Trustless-and-Provable）"><a href="#5-4-无信任和可证明（Trustless-and-Provable）" class="headerlink" title="5.4 无信任和可证明（Trustless and Provable）"></a>5.4 无信任和可证明（Trustless and Provable）</h3><p>可以对应用程序体系结构进行设计，以便轻松实现需要存储并保证防篡改的信息。 此外，可证明公平的运行时代码可以存储在组织上，并由客户端直接解释。 客户端使用内容的事务ID，可以在计算之前验证编织中的有效负载，并确保它们运行的代码既不受信任又可以证明是公平的，即与其他客户端运行的代码相同。 这为服务于其他区块链网络的无信任随机数生成器和其他基于oracle的服务开辟了有趣的可能性。</p><h2 id="6-用例（Use-Cases）"><a href="#6-用例（Use-Cases）" class="headerlink" title="6. 用例（Use Cases）"></a>6. 用例（Use Cases）</h2><p>永久存储有几个用例。 具体而言，法规要求将文件存档长达一定年限。 可证明的媒体报道，学术研究和不变的记录在我们回声室和假新闻泛滥的现代世界中变得越来越重要。</p><h3 id="6-1-真实性（Authenticity）"><a href="#6-1-真实性（Authenticity）" class="headerlink" title="6.1 真实性（Authenticity）"></a>6.1 真实性（Authenticity）</h3><p>法律体系常常与文件真实性的诉讼纠缠在一起。 Arweave通过提供来自作者的任何数字内容的不确定且可验证的存储来解决此问题。 2017年，特拉华州裁定在法院诉讼程序中可以接受区块链证据。 这些记录可能会大大加快有关艺术归属和知识财产之争的争议。 对于创意经济而言，效果是双重的，使艺术家可以将自己的作品立即转让给他人，并避免琐碎的诉讼。</p><h2 id="7-结论（Conclusion）"><a href="#7-结论（Conclusion）" class="headerlink" title="7. 结论（Conclusion）"></a>7. 结论（Conclusion）</h2><p>我们提出了一个新的区块链网络，该网络支持低成本的不可变数据存储和高吞吐量的加密货币。通过使用一种称为blockweave的类似于区块链的新数据结构，可以实现Arweave协议。通过区块隐藏灵活的大小交易区块分配；一种新的共识机制，即减少对工作证明的依赖度，称为访问证明；以及称为Wildfire的自我优化网络拓扑。就像比特币网络一样，我们在隔离方面的技术进步并不是十分复杂。但是，当结合起来形成整个网络时，紧急行为非常强大。从测试网的结果可以看出，在公共的，无许可的和分散的网络协议上，安全，可靠和不变的数据存储是可能的。除了数据存储期限外，任意大小的块都使安全的高吞吐量加密货币成为可能，而无需诉诸复杂的共识机制，例如dBFT或dPoS。</p><p>Arweave通过其REST API紧密地连接到Internet的结构中，并且正在使用Arweave主网建立一些创收业务。 Arweave与其他流行的加密货币之间的桥梁，安全的计算和智能合约协议将使低成本和永久性的数据存储轻松集成到分散式应用程序的技术堆栈中。一个全面全球化的信息和金融交流世界需要永久记录。通过结合加密技术和分布式系统，我们为这些永久记录提供了基础。我们希望Arweave将成为现有互联网协议（例如，万维网）的必要伴侣。与他人合作，建立更加开放和透明的未来。</p><h2 id="8-引用（Reference）"><a href="#8-引用（Reference）" class="headerlink" title="8. 引用（Reference）"></a>8. 引用（Reference）</h2><ol><li>Aweave白皮书地址：<a href="https://www.arweave.org/files/arweave-lightpaper.pdf">https://www.arweave.org/files/arweave-lightpaper.pdf</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载：&lt;a href=&quot;http://ipfsdrop.com/docs/whitepaper/arweave-lightpaper/&quot;&gt;http://ipfsdrop.com/docs/whitepaper/arweave-lightpaper/&lt;/a&gt;&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    
    <category term="Arweave" scheme="https://zhangzhishun.github.io/tags/Arweave/"/>
    
  </entry>
  
  <entry>
    <title>常用密码学库</title>
    <link href="https://zhangzhishun.github.io/2022/03/28/cryptography/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <id>https://zhangzhishun.github.io/2022/03/28/cryptography/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%93%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-28T15:29:15.000Z</published>
    <updated>2022-05-15T02:00:47.450Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="PRIVATE FILE">    <label for="pass">PRIVATE FILE</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1/BFpFQsJwplOjxyxBowW//dpNWtX+ajBBMhX23ewEk0OyciT9chtYqJ+vP73g94aTSBqyeUiBnJ4eu71m8JXdYVkqnYREa+N2OAH3TRPDypgu0UnyLBSMjiXeJwcRwquJ/lhAltZIa6LBwcfb0Nv5eC+A0Z50AGVL0a6GO2vEjJcL4+eH3Yw1u2pqC/9etYZ5sXqld68Lm6fZ7qUkM3HFN5uytr4qcc1mlntuXqEMuK1JhJVZBYhN6P7ZfFwexepQgxO7GCvhSBtPCecICAa1LpdQrpepBzRCucelsFAxYSmu5ueIaIaSlpp9MgD5KLAGIHGJ/yWYrlkEJdmzLsCf3QagNUbssA2VeY722HJgVvyHb0N8EFGmwNbax0ykKguTQSUXBSOoPAWYyl69X0Y2UrEpJImiow1n6SoMtF6DeTv6jxYOVmfz5KP0FQz5sINu4qSvgD9kkDBzbTWPSmOpSY53i/2Ssy1g9xjwoHFo+1BxnxevqT8DvsrPNrD2zkCCzMAWgyMxthlW99gdSl9kQ+PxqD7NAgjXU8QHjnBj9kP09oVzgBTz7S0Npn7X05rMs7FDTn8xfm8gGL4dvTx6cBl6udTRFS2VVDAxli0uSV5OGFxHGQhJbrgvFAauXHD12WQUJMs6c7g/gkwNp8L15PN0ER3T80udOUz2c7PatVcsuPICS+/z09VOBzceKaVny58CGBT4O2ExALp4FanpONxxcI8+EjLG1HWKDy6PfVOOwVIWPzatTlRSZaaLPL1UxIDS6ED2z46pKT7agNFuN6c3s89V/GkkhOM07p5AB0630uB2ZPnafgduvX1/aJ96acx/jClB1ClGQsPWzq8GTn692MH2OP6wZoWztaIszvpcZAJyESk0dNVOWg94gnAc+tpHcf/jk+hTOdykLsT4cv3WSYEFEHzYepb2bzZY4q61wsba+9nic1Gww7Oqe+q5xnMrh7FFlWAHbuXkT8x93GhYUD5XFICLBJeSevl69BytHMl0NEviAa7glUoHKOuyJfmmqHoT43BbuyIfqZ98uNgArTbVXb1pmYZJZ0nwHBGy/mIAbdlDPoMmymUvs7DjQBFxMCS1vsnNftgsFzhlB3iXyVITDhbihL1qTfA97Ou6TbSXEMG+zYMaY5f8rBev2HS+1dKB0zOx4Xbult3SnkqNFmkeq9jqamYUJW6f9jHbGTH31adycXnrblPq7hkrIL9HkyTEKCybQCNP/wRfzBrGrxiDei0a8+WaiJ1JqUA9c+At05Wk5eqcXALfZCesHSkSFDpWdccXVG3sOTCO3/imjKjo/P75A9A1L6JfrnT2xv6uXOnhzj0AwfPeY29RwJ+vWrmXCd9lL02UdMV3eYX5iyxlakla8yXWcGplg7uiyJhMKDJpNBEi8FC4R73QX5c4xNNlPWyPjhhzX972KJK0PdTMmrFlpp3jA+IcWgiT5m19tUyjwuJDqBduA0Tz+fKCnAABeYMWKg1Nb9OuquIXWivRCQ0v+qkPAWn5I2R++04cguoEmiudBQVc1o3Yy64AmezvfV96o2pi2HBmq4W/L6ORSWZ442jeFDVO39nGC01Rh3q9GM2y6qj6xrriUYUI4gmdYvTekH4DvLaBf5kmhB8Pymu2GclFr8FG8ynO33LPH01RmRKEOo0PNUgxKwORDVJc4e/QWC482iMR9YHQSvEVlkqxlwUzavgS+LW0E9FocnYku0dtC1xJ2+49lEg2tV3wLQRSIv7SdF8XjBQjYGTBuHDZJM2XzdDKtSM3E82/VyDzI1bfmsdbwz2+jBbi3b7pY88BPQ7/1URfx7OLf1J6PMItudP5GF+Z/+msM2Gno8D5ifM0caFqefccADrmNqHu3Bw==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">The article has been encrypted, please enter your password to view.&lt;br&gt;</summary>
    
    
    
    
    <category term="密码学" scheme="https://zhangzhishun.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>30分钟创建一条区块链(二)</title>
    <link href="https://zhangzhishun.github.io/2022/03/05/blockchain/other/30%E5%88%86%E9%92%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%BA%8C)/"/>
    <id>https://zhangzhishun.github.io/2022/03/05/blockchain/other/30%E5%88%86%E9%92%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%BA%8C)/</id>
    <published>2022-03-05T12:57:53.000Z</published>
    <updated>2022-04-27T02:35:55.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将区块链API化"><a href="#将区块链API化" class="headerlink" title="将区块链API化"></a>将区块链API化</h2><p>在这个区块链中，我们想要实现三个API，分别是</p><ul><li>/api/mine：节点使用这个方法来挖掘新的区块</li><li>/api/transactions/new: 账户使用这个方法来建立新的交易</li><li>/api/chain: 返回当前的区块链</li></ul><p>为了复用我们在上篇写好的代码，我们首先安装express.js，并创建一个新文件 app.js。express是一个基于node的http框架，它可以允许我们接受通过http协议传输的节点信息。我们还需要body-parser帮助我们解码节点发送过来的信息。</p><h2 id="实现分布式共识"><a href="#实现分布式共识" class="headerlink" title="实现分布式共识"></a>实现分布式共识</h2><p>以上我们已经实现了一个单机版的区块链了，但区块链之所以有用，是因为它能被部署到多个节点上去，并且所有节点都能够相互更新，实现分布式的共识。这样的机制保证了我们能够抵御double spending attack以及确保只有一条区块链在运行。</p><p>为了实现我们的分布式共识，我们首先需要知道网络上其他的节点在哪里。仿照Ethereum的 Node Discovery Protocol，我们可以做一个类似的搜索节点的功能和节点注册功能</p><pre><code class="javascript">_app.post('/api/nodes/register', (req, res) =&gt; {    // 注册节点    let newNode = _.pick(req.body, ['ip', 'port']);    neighbors.push(newNode);    console.log('new node detected. Node info: ' + JSON.stringify(newNode));    res.send({        message: 'Node ' + newNode.ip + ':' + newNode.port + ' is added to my network'    });});</code></pre><h3 id="共识实现-解决冲突链"><a href="#共识实现-解决冲突链" class="headerlink" title="共识实现: 解决冲突链"></a>共识实现: 解决冲突链</h3><p>知道了附近的节点在哪，我们就可以开始实现我们的共识算法。共识算法的第一部分需要我们能够辨别出最长且有效的链，我们可以通过在之前写的区块链模型里加入新的函数实现。</p><p>在 <code>app.js</code>中，我们可以在每次挖矿之后都向附近的节点广播，以解决冲突链。首先我们需要建立一个新的端点 <code>/api/nodes/resolve</code>。建立好端点之后我们需要在挖矿之后对所有的邻居进行广播。</p><p>这样setup之后，我们的节点在每一次挖矿的时候都会对附近的邻居进行广播并寻求consensus。当然，我们还可以设定定时任务来更高频的进行广播。另外，我们也没有对收到的chain进行电子验证，没有动态化的寻找相邻节点，没有将每一个transaction广播，以及一系列可以完善的地方，不过在这篇教程当中我们就不继续下去了。</p><pre><code class="javascript">_app.get('/api/mine', (req, res) =&gt; {    // 挖矿    myChain.createBlock();    let p = new Promise((resolve) =&gt; resolve());    for (let i of neighbors) {        let resolveUri = 'http://' + i.ip + ':' + i.port + '/api/nodes/resolve';        console.log("send resolve to: " + resolveUri);        p.then(() =&gt; rp({            uri: resolveUri,            method: 'POST',            json: true,            body: {'chain': myChain}        })).then((res) =&gt; {            // 同步最长链            myChain.resolveChain(JSON.parse(res.body)["chain"]);        });    }    p.then(() =&gt; {        res.send({            message: 'A new block is mined, and conflict is resolved',            content: myChain.lastBlock()        });    });});</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上我们实现了一个简单的区块链，虽然这个区块链简陋且不安全，但是我们能够成功将它部署到多个节点上，实现了最基本的区块链的功能。</p><p>完整代码：<a href="https://github.com/zhangzhishun/sugar-blockchain-js">代码</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mp.weixin.qq.com/s/6jwIj_m86dpGk62biEJyIA">30分钟自己写一条区块链(一)</a></li><li><a href="https://mp.weixin.qq.com/s/UbLx2mHEb9OyPeJBwP2bvg">30分钟自己写一条区块链(二)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;将区块链API化&quot;&gt;&lt;a href=&quot;#将区块链API化&quot; class=&quot;headerlink&quot; title=&quot;将区块链API化&quot;&gt;&lt;/a&gt;将区块链API化&lt;/h2&gt;&lt;p&gt;在这个区块链中，我们想要实现三个API，分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/api/mine</summary>
      
    
    
    
    
    <category term="部署文档" scheme="https://zhangzhishun.github.io/tags/%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/"/>
    
    <category term="Other" scheme="https://zhangzhishun.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>30分钟创建一条区块链(一)</title>
    <link href="https://zhangzhishun.github.io/2022/02/28/blockchain/other/30%E5%88%86%E9%92%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%B8%80)/"/>
    <id>https://zhangzhishun.github.io/2022/02/28/blockchain/other/30%E5%88%86%E9%92%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%B8%80)/</id>
    <published>2022-02-28T01:10:53.000Z</published>
    <updated>2022-04-27T02:35:55.483Z</updated>
    
    <content type="html"><![CDATA[<p>如何从技术上实现一条区块链？<br>首先，这里假定读者有基本的编程能力，虽然本文用了Javascript来写，但掌握任意一门编程语言的读者阅读起来应该不会有任何难度。</p><h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>我们首先需要安装最新版的Node.js</p><h2 id="第一步，搭建区块链模型"><a href="#第一步，搭建区块链模型" class="headerlink" title="第一步，搭建区块链模型"></a>第一步，搭建区块链模型</h2><p>我们首先来搭一个能够新建区块，创建交易的区块链的模型。</p><pre><code class="javascript">'use strict';//定义一个class，叫BlockChain，每一个区块链都是这个class的实例class BlockChain {    constructor() {        this.chain = []; // 储存所有区块        this.difficulty = 4; // 挖矿的难度    }    isProofValid(tentativeBlock) {        // 这里我们判断newProof是不是一个合法的proof的方法是    }    createBlock(transaction, previousHash = undefined) {        // 创造一个新区块    }    createTransaction(sender, receiver, value) {        // 创建一个交易    }    static hash(block) {        // 对一个区块进行哈希:    }    lastBlock() {        // 取得链上的最后一个区块    }    miner() {        // 挖矿程序    }}</code></pre><p>这里要解释一下区块(block)和交易(transaction)各自长什么样，虽然不同区块链的区块模型有很大差异，但最基本的一些元素都是相通的。一个最基本的区块大概长下面这样：</p><pre><code class="javascript">var block = {       timestamp: 1516245715528,     id: 0,    proof: 786453290000,    previousBlockHash: "12f79cda4fb3f084531de2034e6b4acf",    transactions: [{        sender: "0xca35b7d915458ef540ade6068dfe2f44e8fa733c",        receiver: "0x14723a09acff6d2a60dcdf7aa4aff308fddc160c",        value: 100    }]}</code></pre><p>可以看到，一个区块包含了它被挖出来的时间戳(timestamp)，它在区块链里的位置(id)，它的证明(proof, 更多的会在之后讲到)，前一个区块的整体哈希值(previousBlockHash)，包含的交易(transactions)。 作为一个最基本的交易模型，每一个交易只包含了发送者的地址(sender)，接受者的地址(receiver)，以及这次交易的价值(value)。</p><h2 id="第二步，实现基本功能"><a href="#第二步，实现基本功能" class="headerlink" title="第二步，实现基本功能"></a>第二步，实现基本功能</h2><p>工具函数<br>这里我们首先实现一个工具函数Hash(block), 它会帮助我们将一个区块进行哈希。这个函数会在我们进行挖矿(发掘新区块)的时候用到。</p><pre><code class="javascript">static hash(block) {    // 对一个区块进行哈希:    // 现将block 转换成base64    // 将得到的结果进行SHA哈希    const blockStr = JSON.stringify(block);    const blockB64 = new Buffer(blockStr).toString("base64");    const newHash = crypto.createHash("sha256");    newHash.update(blockB64);    return newHash.digest("hex");}</code></pre><p>这个函数将一个区块，也就是一个Javascript object，哈希成一段字符串。我们使用了crypto这个工具，在最新版的Node.js里面已经是内置了，所以我们并不需要安装它。</p><p>创建一个新交易<br>下一步，我们实现创建新交易的方法。</p><pre><code class="javascript">createTransaction(sender, receiver, value) {    // 创建一个交易    // 根据提供的sender, receiver地址，以及转账的价值，建立一个交易    // 并把它加入到我们的区块链里    const transaction = {        sender: sender,        receiver: receiver,        value: value    };    this._packTransactions.push(transaction);    return this.miner();}</code></pre><p>非常直观，我们只是创建了一个object，加入到区块链里并返回而已。</p><p>创建一个新区块<br>我们现在来实现创建一个区块的代码。当我们的区块链连一个区块也没有的时候，我们需要建立第一个区块(genesis block)，这一点我们在constructor里面实现。</p><pre><code class="javascript">constructor() {    this.chain = []; // 储存所有区块    this.difficulty = 4; // 挖矿的难度    this.createBlock(["Genesis Block"], 1); // 创建第一个区块    this._packTransactions = []; // 当前需要打包的数据}createBlock(transaction, previousHash = undefined) {    // 创造一个新区块    // 一开始的proof是0，不一定是有效的，所以我们需要mineProof来找到有效的proof    let block = {        timestamp: Date.now(),        id: this.chain.length,        proof: 0,        previousBlockHash: previousHash || this.constructor.hash(this.lastBlock()),        transactions: transaction    };    const hash = this.mineProof(block);    this.chain.push(block);    return hash;}</code></pre><p>在创建一个新区块的时候，我们用了当前时间的时间戳，以现在区块链的长度作为id，初始的proof设置为0(proof会在下一步详细讲到)，并将上一个区块整体进行哈希并赋值给previousBlockHash。在创建genesis 区块的时候，我们将previousBlockHash设置为1。 为了便于理解，我们建立新区块的时候没有附上任何交易，实际的情况是矿工可以自主选择包含哪些交易，并需要对这些交易进行处理得到一个默克尔树。</p><h2 id="理解挖矿：找到有效的Proof"><a href="#理解挖矿：找到有效的Proof" class="headerlink" title="理解挖矿：找到有效的Proof"></a>理解挖矿：找到有效的Proof</h2><p>读者朋友们应该都听说过工作量证明(Proof of Work)，POW是区块链中用来创造区块的核心算法或者机制。POW本身的目的是为了找到一个数字来解决一个数学问题，而找到这个数字的难度是越来越高的，但一旦找到之后，要证明它解决了这个数学问题又是非常容易的，任何人都能很快做到。 当然除了Proof of Work之外，我们还有Proof of Space, Proof of Stake，在代码里我们就用proof来代表找到的这个数字。 那么这个数学问题到底是什么呢？我们用一个例子来回答。</p><p>给定一个数字A，我们想找到数字B，使得Hash(A<em>B)的结果C的最后1位等于0。也就是说，C可以是Hash(A</em>B)=2ba83…6d0，因为它的最后一位是0。</p><h2 id="实现挖矿"><a href="#实现挖矿" class="headerlink" title="实现挖矿"></a>实现挖矿</h2><p>知道了如何挖矿之后，我们将上面的代码融合到我们的区块链模型里。</p><pre><code class="javascript">    isProofValid(tentativeBlock) {        // 这里我们判断newProof是不是一个合法的proof的方法是        // 将整个区块进行哈希        // 如果得到的散列值指的最后n位都是0，那么这是一个valid proof        // 其中，n = difficulty        const result = this.constructor.hash(tentativeBlock);        return result.substr(result.length - this.difficulty) === '0'.repeat(this.difficulty);    }    mineProof(tentativeBlock) {        console.log("miner block start: " + JSON.stringify(tentativeBlock));        while (!this.isProofValid(tentativeBlock)) {            tentativeBlock.proof += 1; // 如果不是可用的proof，我们就接着枚举        }        const hash = this.constructor.hash(tentativeBlock);        console.log("miner block success. Hash: " + hash);        return hash;    }    createBlock(transaction, previousHash = undefined) {        // 创造一个新区块        // 一开始的proof是0，不一定是有效的，所以我们需要mineProof来找到有效的proof        let block = {            timestamp: Date.now(),            id: this.chain.length,            proof: 0,            previousBlockHash: previousHash || this.constructor.hash(this.lastBlock()),            transactions: transaction        };        const hash = this.mineProof(block);        this.chain.push(block);        return hash;    }    miner() {        // 挖矿程序        if (this._packTransactions.length &gt; 0) {            const hash = this.createBlock([this._packTransactions[this._packTransactions.length - 1]]);            if (hash) {                this._packTransactions.pop();                return hash            }        }    }</code></pre><p>完整代码：<a href="https://github.com/zhangzhishun/sugar-blockchain-js/blob/master/blockchain.js">blockchain</a></p><p>参考：</p><ol><li><a href="https://mp.weixin.qq.com/s/6jwIj_m86dpGk62biEJyIA">30分钟自己写一条区块链(一)</a></li><li><a href="https://mp.weixin.qq.com/s/UbLx2mHEb9OyPeJBwP2bvg">30分钟自己写一条区块链(二)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何从技术上实现一条区块链？&lt;br&gt;首先，这里假定读者有基本的编程能力，虽然本文用了Javascript来写，但掌握任意一门编程语言的读者阅读起来应该不会有任何难度。&lt;/p&gt;
&lt;h2 id=&quot;开发准备&quot;&gt;&lt;a href=&quot;#开发准备&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="部署文档" scheme="https://zhangzhishun.github.io/tags/%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/"/>
    
    <category term="Other" scheme="https://zhangzhishun.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>NFT框架 0xcert ERC721源码分析</title>
    <link href="https://zhangzhishun.github.io/2022/02/26/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-0xcert-ERC721%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://zhangzhishun.github.io/2022/02/26/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-0xcert-ERC721%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-02-26T02:25:11.000Z</published>
    <updated>2022-05-18T13:17:43.888Z</updated>
    
    <content type="html"><![CDATA[<p>ERC721官方简介是：A standard interface for non-fungible tokens, also known as deeds.也叫非同质代币，或者不可置换代币（NFTs）。提到ERC721，一个好理解的例子就是<a href="https://link.segmentfault.com/?enc=C1N3804jiPfa4j/kbVqQeA==.qKJ3FJzSnC5Qcs2rB15IvrOOttPxdU0dtue8Pk75gJ0=">CryptoKitties迷恋猫</a> ,每一只猫都是独一无二的拥有不同基因，有收藏价值属性。ERC721对于虚拟资产收藏品领域会有很好的应用价值和市场需求。</p><p>ERC721是以太坊和 Wanchain 区块链的<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md">ERC-721不可替代令牌标准的完整参考实现。</a>它还与其他 EVM 兼容链兼容，如 Binance Smart Chain (BSC)、Avalanche (AVAX) 等。这是一个开源项目，完成了<a href="https://hardhat.org/">Hardhat</a>测试。</p><p>此项目的目的是为任何想要在以太坊和 Wanchain 区块链上使用和开发不可替代代币的人提供一个良好的起点。您可以使用经过多次审核的代码，而不是自己重新实现 ERC-721，此实现比 ERC-721 标准更具限制性，因为它不支持<code>payable</code>开箱即用的函数调用。但是，您可以自己添加它。</p><p>合约列表：</p><ul><li><a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token.sol"><code>nf-token.sol</code></a>：这是基本的 ERC-721 token实现（支持 ERC-165）。</li><li><a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token-metadata.sol"><code>nf-token-metadata.sol</code></a>：这为代币合约实现了可选的 ERC-721 元数据功能。它实现了一个token名称、一个符号和一个指向公开暴露的 ERC-721 JSON 元数据文件的不同 URI。</li><li><a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token-enumerable.sol"><code>nf-token-enumerable.sol</code></a>：这实现了对枚举的可选 ERC-721 支持。如果您想知道代币的总供应量、按索引查询代币等，这很有用</li></ul><p>合约类、接口之间的继承关系：</p><p><img src="/images/open-zeppelin-erc721/image-20220226171652608.png" alt="image-20220226171652608"></p><h2 id="1-SupportsInterface"><a href="#1-SupportsInterface" class="headerlink" title="1. SupportsInterface"></a>1. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/utils/supports-interface.sol">SupportsInterface</a></h2><p>实现检测智能合约接口的标准。</p><p>例如在合约的构造函数定义如下内容指定检测标准：</p><pre><code class="javascript">supportedInterfaces[0x01ffc9a7] = true; // ERC165supportedInterfaces[0x780e9d63] = true; // ERC721EnumerablesupportedInterfaces[0x5b5e139f] = true; // ERC721MetadatasupportedInterfaces[0x80ac58cd] = true; // ERC721</code></pre><p>源码：</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./erc165.sol";/** * @dev Implementation of standard for detect smart contract interfaces. */contract SupportsInterface is  ERC165{  /**   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.   */  mapping(bytes4 =&gt; bool) internal supportedInterfaces;  /**   * @dev Contract constructor.   */  constructor()  {    supportedInterfaces[0x01ffc9a7] = true; // ERC165  }  /**   * @dev Function to check which interfaces are suported by this contract.   * @param _interfaceID Id of the interface.   * @return True if _interfaceID is supported, false otherwise.   */  function supportsInterface(    bytes4 _interfaceID  )    external    override    view    returns (bool)  {    return supportedInterfaces[_interfaceID];  }}</code></pre><h2 id="2-ERC721"><a href="#2-ERC721" class="headerlink" title="2. ERC721"></a>2. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/erc721.sol">ERC721</a></h2><p>ERC721合约定义了基本的接口方法：</p><ul><li><p>safeTransferFrom：转移代币所有权</p></li><li><p>transferFrom：转移代币所有权</p></li><li><p>setApprovalForAll：授权operator具有所有代币的控制权</p></li><li><p>balanceOf：返回owner的代币数量</p></li><li><p>ownerOf：根据tokenId返回代币持有者address</p></li><li><p>getApproved：查询tokenId的授权人operator address</p></li><li><p>approve 授权tokenId给地址to</p></li><li><p>isApprovedForAll：查询一个地址是否为另一个地址的授权操作者。</p></li></ul><p>源码：</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/** * @dev ERC-721 non-fungible token standard. * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md. */interface ERC721{  /**   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any   * number of NFTs may be created and assigned without emitting Transfer. At the time of any   * transfer, the approved address for that NFT (if any) is reset to none.   */  event Transfer(    address indexed _from,    address indexed _to,    uint256 indexed _tokenId  );  /**   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero   * address indicates there is no approved address. When a Transfer event emits, this also   * indicates that the approved address for that NFT (if any) is reset to none.   */  event Approval(    address indexed _owner,    address indexed _approved,    uint256 indexed _tokenId  );  /**   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage   * all NFTs of the owner.   */  event ApprovalForAll(    address indexed _owner,    address indexed _operator,    bool _approved  );  /**   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this   * function checks if `_to` is a smart contract (code size &gt; 0). If so, it calls   * `onERC721Received` on `_to` and throws if the return value is not   * `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.   * @dev Transfers the ownership of an NFT from one address to another address. This function can   * be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   * @param _data Additional data with no specified format, sent in call to `_to`.   */  function safeTransferFrom(    address _from,    address _to,    uint256 _tokenId,    bytes calldata _data  )    external;  /**   * @notice This works identically to the other function with an extra data parameter, except this   * function just sets data to ""   * @dev Transfers the ownership of an NFT from one address to another address. This function can   * be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   */  function safeTransferFrom(    address _from,    address _to,    uint256 _tokenId  )    external;  /**   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else   * they may be permanently lost.   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero   * address. Throws if `_tokenId` is not a valid NFT.  This function can be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   */  function transferFrom(    address _from,    address _to,    uint256 _tokenId  )    external;  /**   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is   * the current NFT owner, or an authorized operator of the current owner.   * @param _approved The new approved NFT controller.   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.   * @param _tokenId The NFT to approve.   */  function approve(    address _approved,    uint256 _tokenId  )    external;  /**   * @notice The contract MUST allow multiple operators per owner.   * @dev Enables or disables approval for a third party ("operator") to manage all of   * `msg.sender`'s assets. It also emits the ApprovalForAll event.   * @param _operator Address to add to the set of authorized operators.   * @param _approved True if the operators is approved, false to revoke approval.   */  function setApprovalForAll(    address _operator,    bool _approved  )    external;  /**   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are   * considered invalid, and this function throws for queries about the zero address.   * @notice Count all NFTs assigned to an owner.   * @param _owner Address for whom to query the balance.   * @return Balance of _owner.   */  function balanceOf(    address _owner  )    external    view    returns (uint256);  /**   * @notice Find the owner of an NFT.   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are   * considered invalid, and queries about them do throw.   * @param _tokenId The identifier for an NFT.   * @return Address of _tokenId owner.   */  function ownerOf(    uint256 _tokenId  )    external    view    returns (address);  /**   * @notice Throws if `_tokenId` is not a valid NFT.   * @dev Get the approved address for a single NFT.   * @param _tokenId The NFT to find the approved address for.   * @return Address that _tokenId is approved for.   */  function getApproved(    uint256 _tokenId  )    external    view    returns (address);  /**   * @notice Query if an address is an authorized operator for another address.   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.   * @param _owner The address that owns the NFTs.   * @param _operator The address that acts on behalf of the owner.   * @return True if approved for all, false otherwise.   */  function isApprovedForAll(    address _owner,    address _operator  )    external    view    returns (bool);}</code></pre><h2 id="3-ERC721Metadata"><a href="#3-ERC721Metadata" class="headerlink" title="3. ERC721Metadata"></a>3. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/erc721-metadata.sol">ERC721Metadata</a></h2><p>ERC-721不可替代令牌标准的可选元数据扩展。</p><p>主要方法：</p><ul><li>name：返回NFT的描述性名称</li><li>symbol：返回NFT的缩写名称</li><li>tokenURI：返回_tokenId对应的资源URI</li></ul><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/** * @dev Optional metadata extension for ERC-721 non-fungible token standard. * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md. */interface ERC721Metadata{  /**   * @dev Returns a descriptive name for a collection of NFTs in this contract.   * @return _name Representing name.   */  function name()    external    view    returns (string memory _name);  /**   * @dev Returns a abbreviated name for a collection of NFTs in this contract.   * @return _symbol Representing symbol.   */  function symbol()    external    view    returns (string memory _symbol);  /**   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file   * that conforms to the "ERC721 Metadata JSON Schema".   * @return URI of _tokenId.   */  function tokenURI(uint256 _tokenId)    external    view    returns (string memory);}</code></pre><h2 id="4-ERC721Enumerable"><a href="#4-ERC721Enumerable" class="headerlink" title="4. ERC721Enumerable"></a>4. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/erc721-enumerable.sol">ERC721Enumerable</a></h2><p>ERC-721不可替代令牌标准的可选枚举扩展。</p><p>主要方法：</p><ul><li>totalSupply：返回由此契约跟踪的有效nft的计数（代币总量），其中每个nft都有一个分配的、可查询的所有者，且所有者不等于零地址</li><li>tokenByIndex：返回第index的NFT的tokenId。没有指定排序顺序。</li><li>tokenOfOwnerByIndex：返回分配给指定人的第index的NFT的tokenId。没有指定排序顺序</li></ul><p>源码：</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/** * @dev Optional enumeration extension for ERC-721 non-fungible token standard. * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md. */interface ERC721Enumerable{  /**   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an   * assigned and queryable owner not equal to the zero address.   * @return Total supply of NFTs.   */  function totalSupply()    external    view    returns (uint256);  /**   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.   * @param _index A counter less than `totalSupply()`.   * @return Token id.   */  function tokenByIndex(    uint256 _index  )    external    view    returns (uint256);  /**   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is   * not specified. It throws if `_index` &gt;= `balanceOf(_owner)` or if `_owner` is the zero address,   * representing invalid NFTs.   * @param _owner An address where we are interested in NFTs owned by them.   * @param _index A counter less than `balanceOf(_owner)`.   * @return Token id.   */  function tokenOfOwnerByIndex(    address _owner,    uint256 _index  )    external    view    returns (uint256);}</code></pre><h2 id="5-NFToken"><a href="#5-NFToken" class="headerlink" title="5. NFToken"></a>5. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token.sol">NFToken</a></h2><p>ERC721 标准基本实现</p><p>主要方法：</p><ul><li>safeTransferFrom：将NFT的所有权从一个地址转移到另一个地址。此功能可更改为payable</li><li>transferFrom：将指定的token所有权转移给另外一个地址，不鼓励使用这个方法，尽量使用<code>safeTransferFrom</code></li><li>approve：批准另一个人address来交易指定的代币，0 address 表示没有授权的地址，给定的时间内，一个token只能有一个批准的地址，只有token的持有者或者授权的操作人才可以调用。此功能可更改为payable</li><li>setApprovalForAll：设置或者取消对操作人的授权，一个操作人可以代表他们转让发送者的所有token</li><li>balanceOf：获取持有者的代币总数</li><li>ownerOf：根据token ID获取持有者</li><li>getApproved：获取token被授权的地址，如果没有设置地址则为0</li><li>isApprovedForAll：查询是否操作人被指定的持有者授权，要查询的授权人地址，要查询的授权操作人地址</li></ul><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./erc721.sol";import "./erc721-token-receiver.sol";import "../utils/supports-interface.sol";import "../utils/address-utils.sol";/** * @dev Implementation of ERC-721 non-fungible token standard. */contract NFToken is  ERC721,  SupportsInterface{  using AddressUtils for address;  /**   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.   * Based on 0xcert framework error codes.   */  string constant ZERO_ADDRESS = "003001";  string constant NOT_VALID_NFT = "003002";  string constant NOT_OWNER_OR_OPERATOR = "003003";  string constant NOT_OWNER_APPROVED_OR_OPERATOR = "003004";  string constant NOT_ABLE_TO_RECEIVE_NFT = "003005";  string constant NFT_ALREADY_EXISTS = "003006";  string constant NOT_OWNER = "003007";  string constant IS_OWNER = "003008";  /**   * @dev Magic value of a smart contract that can receive NFT.   * Equal to: bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")).   */  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;  /**   * @dev A mapping from NFT ID to the address that owns it.   */  mapping (uint256 =&gt; address) internal idToOwner;  /**   * @dev Mapping from NFT ID to approved address.   */  mapping (uint256 =&gt; address) internal idToApproval;   /**   * @dev Mapping from owner address to count of their tokens.   */  mapping (address =&gt; uint256) private ownerToNFTokenCount;  /**   * @dev Mapping from owner address to mapping of operator addresses.   */  mapping (address =&gt; mapping (address =&gt; bool)) internal ownerToOperators;  /**   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.   * @param _tokenId ID of the NFT to validate.   */  modifier canOperate(    uint256 _tokenId  )  {    address tokenOwner = idToOwner[_tokenId];    require(      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],      NOT_OWNER_OR_OPERATOR    );    _;  }  /**   * @dev Guarantees that the msg.sender is allowed to transfer NFT.   * @param _tokenId ID of the NFT to transfer.   */  modifier canTransfer(    uint256 _tokenId  )  {    address tokenOwner = idToOwner[_tokenId];    require(      tokenOwner == msg.sender      || idToApproval[_tokenId] == msg.sender      || ownerToOperators[tokenOwner][msg.sender],      NOT_OWNER_APPROVED_OR_OPERATOR    );    _;  }  /**   * @dev Guarantees that _tokenId is a valid Token.   * @param _tokenId ID of the NFT to validate.   */  modifier validNFToken(    uint256 _tokenId  )  {    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);    _;  }  /**   * @dev Contract constructor.   */  constructor()  {    supportedInterfaces[0x80ac58cd] = true; // ERC721  }  /**   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this   * function checks if `_to` is a smart contract (code size &gt; 0). If so, it calls   * `onERC721Received` on `_to` and throws if the return value is not   * `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.   * @dev Transfers the ownership of an NFT from one address to another address. This function can   * be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   * @param _data Additional data with no specified format, sent in call to `_to`.   */  function safeTransferFrom(    address _from,    address _to,    uint256 _tokenId,    bytes calldata _data  )    external    override  {    _safeTransferFrom(_from, _to, _tokenId, _data);  }  /**   * @notice This works identically to the other function with an extra data parameter, except this   * function just sets data to "".   * @dev Transfers the ownership of an NFT from one address to another address. This function can   * be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   */  function safeTransferFrom(    address _from,    address _to,    uint256 _tokenId  )    external    override  {    _safeTransferFrom(_from, _to, _tokenId, "");  }  /**   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else   * they may be permanently lost.   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero   * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   */  function transferFrom(    address _from,    address _to,    uint256 _tokenId  )    external    override    canTransfer(_tokenId)    validNFToken(_tokenId)  {    address tokenOwner = idToOwner[_tokenId];    require(tokenOwner == _from, NOT_OWNER);    require(_to != address(0), ZERO_ADDRESS);    _transfer(_to, _tokenId);  }  /**   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is   * the current NFT owner, or an authorized operator of the current owner.   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.   * @param _approved Address to be approved for the given NFT ID.   * @param _tokenId ID of the token to be approved.   */  function approve(    address _approved,    uint256 _tokenId  )    external    override    canOperate(_tokenId)    validNFToken(_tokenId)  {    address tokenOwner = idToOwner[_tokenId];    require(_approved != tokenOwner, IS_OWNER);    idToApproval[_tokenId] = _approved;    emit Approval(tokenOwner, _approved, _tokenId);  }  /**   * @notice This works even if sender doesn't own any tokens at the time.   * @dev Enables or disables approval for a third party ("operator") to manage all of   * `msg.sender`'s assets. It also emits the ApprovalForAll event.   * @param _operator Address to add to the set of authorized operators.   * @param _approved True if the operators is approved, false to revoke approval.   */  function setApprovalForAll(    address _operator,    bool _approved  )    external    override  {    ownerToOperators[msg.sender][_operator] = _approved;    emit ApprovalForAll(msg.sender, _operator, _approved);  }  /**   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are   * considered invalid, and this function throws for queries about the zero address.   * @param _owner Address for whom to query the balance.   * @return Balance of _owner.   */  function balanceOf(    address _owner  )    external    override    view    returns (uint256)  {    require(_owner != address(0), ZERO_ADDRESS);    return _getOwnerNFTCount(_owner);  }  /**   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are   * considered invalid, and queries about them do throw.   * @param _tokenId The identifier for an NFT.   * @return _owner Address of _tokenId owner.   */  function ownerOf(    uint256 _tokenId  )    external    override    view    returns (address _owner)  {    _owner = idToOwner[_tokenId];    require(_owner != address(0), NOT_VALID_NFT);  }  /**   * @notice Throws if `_tokenId` is not a valid NFT.   * @dev Get the approved address for a single NFT.   * @param _tokenId ID of the NFT to query the approval of.   * @return Address that _tokenId is approved for.   */  function getApproved(    uint256 _tokenId  )    external    override    view    validNFToken(_tokenId)    returns (address)  {    return idToApproval[_tokenId];  }  /**   * @dev Checks if `_operator` is an approved operator for `_owner`.   * @param _owner The address that owns the NFTs.   * @param _operator The address that acts on behalf of the owner.   * @return True if approved for all, false otherwise.   */  function isApprovedForAll(    address _owner,    address _operator  )    external    override    view    returns (bool)  {    return ownerToOperators[_owner][_operator];  }  /**   * @notice Does NO checks.   * @dev Actually performs the transfer.   * @param _to Address of a new owner.   * @param _tokenId The NFT that is being transferred.   */  function _transfer(    address _to,    uint256 _tokenId  )    internal    virtual  {    address from = idToOwner[_tokenId];    _clearApproval(_tokenId);    _removeNFToken(from, _tokenId);    _addNFToken(_to, _tokenId);    emit Transfer(from, _to, _tokenId);  }  /**   * @notice This is an internal function which should be called from user-implemented external   * mint function. Its purpose is to show and properly initialize data structures when using this   * implementation.   * @dev Mints a new NFT.   * @param _to The address that will own the minted NFT.   * @param _tokenId of the NFT to be minted by the msg.sender.   */  function _mint(    address _to,    uint256 _tokenId  )    internal    virtual  {    require(_to != address(0), ZERO_ADDRESS);    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);    _addNFToken(_to, _tokenId);    emit Transfer(address(0), _to, _tokenId);  }  /**   * @notice This is an internal function which should be called from user-implemented external burn   * function. Its purpose is to show and properly initialize data structures when using this   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned   * NFT.   * @dev Burns a NFT.   * @param _tokenId ID of the NFT to be burned.   */  function _burn(    uint256 _tokenId  )    internal    virtual    validNFToken(_tokenId)  {    address tokenOwner = idToOwner[_tokenId];    _clearApproval(_tokenId);    _removeNFToken(tokenOwner, _tokenId);    emit Transfer(tokenOwner, address(0), _tokenId);  }  /**   * @notice Use and override this function with caution. Wrong usage can have serious consequences.   * @dev Removes a NFT from owner.   * @param _from Address from which we want to remove the NFT.   * @param _tokenId Which NFT we want to remove.   */  function _removeNFToken(    address _from,    uint256 _tokenId  )    internal    virtual  {    require(idToOwner[_tokenId] == _from, NOT_OWNER);    ownerToNFTokenCount[_from] -= 1;    delete idToOwner[_tokenId];  }  /**   * @notice Use and override this function with caution. Wrong usage can have serious consequences.   * @dev Assigns a new NFT to owner.   * @param _to Address to which we want to add the NFT.   * @param _tokenId Which NFT we want to add.   */  function _addNFToken(    address _to,    uint256 _tokenId  )    internal    virtual  {    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);    idToOwner[_tokenId] = _to;    ownerToNFTokenCount[_to] += 1;  }  /**   *&nbsp;@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable   * extension to remove double storage (gas optimization) of owner NFT count.   * @param _owner Address for whom to query the count.   * @return Number of _owner NFTs.   */  function _getOwnerNFTCount(    address _owner  )    internal    virtual    view    returns (uint256)  {    return ownerToNFTokenCount[_owner];  }  /**   * @dev Actually perform the safeTransferFrom.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   * @param _data Additional data with no specified format, sent in call to `_to`.   */  function _safeTransferFrom(    address _from,    address _to,    uint256 _tokenId,    bytes memory _data  )    private    canTransfer(_tokenId)    validNFToken(_tokenId)  {    address tokenOwner = idToOwner[_tokenId];    require(tokenOwner == _from, NOT_OWNER);    require(_to != address(0), ZERO_ADDRESS);    _transfer(_to, _tokenId);    if (_to.isContract())    {      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);    }  }  /**   * @dev Clears the current approval of a given NFT ID.   * @param _tokenId ID of the NFT to be transferred.   */  function _clearApproval(    uint256 _tokenId  )    private  {    delete idToApproval[_tokenId];  }}</code></pre><h2 id="6-NFTokenMetadata"><a href="#6-NFTokenMetadata" class="headerlink" title="6. NFTokenMetadata"></a>6. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token-metadata.sol">NFTokenMetadata</a></h2><p>ERC-721不可替代令牌标准的可选元数据实现，继承NFToken并实现了ERC721Metadata接口</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./nf-token.sol";import "./erc721-metadata.sol";/** * @dev Optional metadata implementation for ERC-721 non-fungible token standard. */contract NFTokenMetadata is  NFToken,  ERC721Metadata{  /**   * @dev A descriptive name for a collection of NFTs.   */  string internal nftName;  /**   * @dev An abbreviated name for NFTokens.   */  string internal nftSymbol;  /**   * @dev Mapping from NFT ID to metadata uri.   */  mapping (uint256 =&gt; string) internal idToUri;  /**   * @notice When implementing this contract don't forget to set nftName and nftSymbol.   * @dev Contract constructor.   */  constructor()  {    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata  }  /**   * @dev Returns a descriptive name for a collection of NFTokens.   * @return _name Representing name.   */  function name()    external    override    view    returns (string memory _name)  {    _name = nftName;  }  /**   * @dev Returns an abbreviated name for NFTokens.   * @return _symbol Representing symbol.   */  function symbol()    external    override    view    returns (string memory _symbol)  {    _symbol = nftSymbol;  }  /**   * @dev A distinct URI (RFC 3986) for a given NFT.   * @param _tokenId Id for which we want uri.   * @return URI of _tokenId.   */  function tokenURI(    uint256 _tokenId  )    external    override    view    validNFToken(_tokenId)    returns (string memory)  {    return _tokenURI(_tokenId);  }  /**   * @notice This is an internal function that can be overriden if you want to implement a different   * way to generate token URI.   * @param _tokenId Id for which we want uri.   * @return URI of _tokenId.   */  function _tokenURI(    uint256 _tokenId  )    internal    virtual    view    returns (string memory)  {    return idToUri[_tokenId];  }  /**   * @notice This is an internal function which should be called from user-implemented external   * burn function. Its purpose is to show and properly initialize data structures when using this   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned   * NFT.   * @dev Burns a NFT.   * @param _tokenId ID of the NFT to be burned.   */  function _burn(    uint256 _tokenId  )    internal    override    virtual  {    super._burn(_tokenId);    delete idToUri[_tokenId];  }  /**   * @notice This is an internal function which should be called from user-implemented external   * function. Its purpose is to show and properly initialize data structures when using this   * implementation.   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.   * @param _tokenId Id for which we want URI.   * @param _uri String representing RFC 3986 URI.   */  function _setTokenUri(    uint256 _tokenId,    string memory _uri  )    internal    validNFToken(_tokenId)  {    idToUri[_tokenId] = _uri;  }}</code></pre><h2 id="7-NFTokenEnumerable"><a href="#7-NFTokenEnumerable" class="headerlink" title="7. NFTokenEnumerable"></a>7. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token-enumerable.sol">NFTokenEnumerable</a></h2><p>ERC-721不可替代令牌标准的可选枚举实现，继承NFToken并实现了ERC721Enumerable接口</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./nf-token.sol";import "./erc721-enumerable.sol";/** * @dev Optional enumeration implementation for ERC-721 non-fungible token standard. */contract NFTokenEnumerable is  NFToken,  ERC721Enumerable{  /**   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.   * Based on 0xcert framework error codes.   */  string constant INVALID_INDEX = "005007";  /**   * @dev Array of all NFT IDs.   */  uint256[] internal tokens;  /**   * @dev Mapping from token ID to its index in global tokens array.   */  mapping(uint256 =&gt; uint256) internal idToIndex;  /**   * @dev Mapping from owner to list of owned NFT IDs.   */  mapping(address =&gt; uint256[]) internal ownerToIds;  /**   * @dev Mapping from NFT ID to its index in the owner tokens list.   */  mapping(uint256 =&gt; uint256) internal idToOwnerIndex;  /**   * @dev Contract constructor.   */  constructor()  {    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable  }  /**   * @dev Returns the count of all existing NFTokens.   * @return Total supply of NFTs.   */  function totalSupply()    external    override    view    returns (uint256)  {    return tokens.length;  }  /**   * @dev Returns NFT ID by its index.   * @param _index A counter less than `totalSupply()`.   * @return Token id.   */  function tokenByIndex(    uint256 _index  )    external    override    view    returns (uint256)  {    require(_index &lt; tokens.length, INVALID_INDEX);    return tokens[_index];  }  /**   * @dev returns the n-th NFT ID from a list of owner's tokens.   * @param _owner Token owner's address.   * @param _index Index number representing n-th token in owner's list of tokens.   * @return Token id.   */  function tokenOfOwnerByIndex(    address _owner,    uint256 _index  )    external    override    view    returns (uint256)  {    require(_index &lt; ownerToIds[_owner].length, INVALID_INDEX);    return ownerToIds[_owner][_index];  }  /**   * @notice This is an internal function which should be called from user-implemented external   * mint function. Its purpose is to show and properly initialize data structures when using this   * implementation.   * @dev Mints a new NFT.   * @param _to The address that will own the minted NFT.   * @param _tokenId of the NFT to be minted by the msg.sender.   */  function _mint(    address _to,    uint256 _tokenId  )    internal    override    virtual  {    super._mint(_to, _tokenId);    tokens.push(_tokenId);    idToIndex[_tokenId] = tokens.length - 1;  }  /**   * @notice This is an internal function which should be called from user-implemented external   * burn function. Its purpose is to show and properly initialize data structures when using this   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned   * NFT.   * @dev Burns a NFT.   * @param _tokenId ID of the NFT to be burned.   */  function _burn(    uint256 _tokenId  )    internal    override    virtual  {    super._burn(_tokenId);    uint256 tokenIndex = idToIndex[_tokenId];    uint256 lastTokenIndex = tokens.length - 1;    uint256 lastToken = tokens[lastTokenIndex];    tokens[tokenIndex] = lastToken;    tokens.pop();    // This wastes gas if you are burning the last token but saves a little gas if you are not.    idToIndex[lastToken] = tokenIndex;    idToIndex[_tokenId] = 0;  }  /**   * @notice Use and override this function with caution. Wrong usage can have serious consequences.   * @dev Removes a NFT from an address.   * @param _from Address from wich we want to remove the NFT.   * @param _tokenId Which NFT we want to remove.   */  function _removeNFToken(    address _from,    uint256 _tokenId  )    internal    override    virtual  {    require(idToOwner[_tokenId] == _from, NOT_OWNER);    delete idToOwner[_tokenId];    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];    uint256 lastTokenIndex = ownerToIds[_from].length - 1;    if (lastTokenIndex != tokenToRemoveIndex)    {      uint256 lastToken = ownerToIds[_from][lastTokenIndex];      ownerToIds[_from][tokenToRemoveIndex] = lastToken;      idToOwnerIndex[lastToken] = tokenToRemoveIndex;    }    ownerToIds[_from].pop();  }  /**   * @notice Use and override this function with caution. Wrong usage can have serious consequences.   * @dev Assigns a new NFT to an address.   * @param _to Address to wich we want to add the NFT.   * @param _tokenId Which NFT we want to add.   */  function _addNFToken(    address _to,    uint256 _tokenId  )    internal    override    virtual  {    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);    idToOwner[_tokenId] = _to;    ownerToIds[_to].push(_tokenId);    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;  }  /**   *&nbsp;@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable   * extension to remove double storage(gas optimization) of owner NFT count.   * @param _owner Address for whom to query the count.   * @return Number of _owner NFTs.   */  function _getOwnerNFTCount(    address _owner  )    internal    override    virtual    view    returns (uint256)  {    return ownerToIds[_owner].length;  }}</code></pre><h2 id="8-Ownable"><a href="#8-Ownable" class="headerlink" title="8. Ownable"></a>8. <a href="https://github.com/nibbstack/erc721/blob/master/src/contracts/ownership/ownable.sol">Ownable</a></h2><p>合同有一个所有者地址，并提供基本的授权控制，简化了用户权限的实现。此合同基于以下源代码: <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/access/Ownable.sol">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/access/Ownable.sol</a></p><pre><code class="javascriptscript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/** * @dev The contract has an owner address, and provides basic authorization control whitch * simplifies the implementation of user permissions. This contract is based on the source code at: * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol */contract Ownable{  /**   * @dev Error constants.   */  string public constant NOT_CURRENT_OWNER = "018001";  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = "018002";  /**   * @dev Current owner address.   */  address public owner;  /**   * @dev An event which is triggered when the owner is changed.   * @param previousOwner The address of the previous owner.   * @param newOwner The address of the new owner.   */  event OwnershipTransferred(    address indexed previousOwner,    address indexed newOwner  );  /**   * @dev The constructor sets the original `owner` of the contract to the sender account.   */  constructor()  {    owner = msg.sender;  }  /**   * @dev Throws if called by any account other than the owner.   */  modifier onlyOwner()  {    require(msg.sender == owner, NOT_CURRENT_OWNER);    _;  }  /**   * @dev Allows the current owner to transfer control of the contract to a newOwner.   * @param _newOwner The address to transfer ownership to.   */  function transferOwnership(    address _newOwner  )    public    onlyOwner  {    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);    emit OwnershipTransferred(owner, _newOwner);    owner = _newOwner;  }}</code></pre><p>OpenZeppelin ERC721源码分析到这里就结束了。</p><p>参考：</p><ol><li><a href="https://github.com/nibbstack/erc721/tree/2.6.1">ERC721源码v2.6.1</a></li><li><a href="https://segmentfault.com/a/1190000016070774">ERC721源码分析</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ERC721官方简介是：A standard interface for non-fungible tokens, also known as deeds.也叫非同质代币，或者不可置换代币（NFTs）。提到ERC721，一个好理解的例子就是&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="NFT" scheme="https://zhangzhishun.github.io/tags/NFT/"/>
    
    <category term="0xcert" scheme="https://zhangzhishun.github.io/tags/0xcert/"/>
    
  </entry>
  
  <entry>
    <title>基于以太坊的战艇游戏(Layer2)源码解析</title>
    <link href="https://zhangzhishun.github.io/2022/02/24/blockchain/layer2/%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%88%98%E8%89%87%E6%B8%B8%E6%88%8F(Layer2)/"/>
    <id>https://zhangzhishun.github.io/2022/02/24/blockchain/layer2/%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%88%98%E8%89%87%E6%B8%B8%E6%88%8F(Layer2)/</id>
    <published>2022-02-24T03:20:30.000Z</published>
    <updated>2022-04-27T02:35:55.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于以太坊的战艇游戏-Layer2-源码解析"><a href="#基于以太坊的战艇游戏-Layer2-源码解析" class="headerlink" title="基于以太坊的战艇游戏(Layer2)源码解析"></a>基于以太坊的战艇游戏(Layer2)源码解析</h1><h2 id="一、游戏介绍"><a href="#一、游戏介绍" class="headerlink" title="一、游戏介绍"></a>一、游戏介绍</h2><p>每一个玩家都可以看到上图所示的页面。该页面分为两部分，下面部分表示当前玩家的棋盘信息，开始的时候，该玩家随机选择两个格子，用于放置两个战舰；上面部分显示对方玩家的棋盘信息，除了对方玩家的战舰位置。开始的时候，上面部分的棋盘是空的。游戏开始之后，两个玩家轮流猜测对方的战舰的位置，每一次只能猜一个方格。如果对方的战舰不在所猜测的方格中，那么就会在对应位置显示一个水花的图像；反之，则出现一团火的图像。因为双方看不到对方的棋盘，因此，每一次都需要对方玩家回复“所猜测的方格是否有战舰”（我们可以采用密码学的技术检测出对方是否撒谎）。当某一个玩家率先猜中了对方两个战舰的位置，该玩家就赢了，并可以收取自己和对方的赌注。</p><h2 id="二、涉及技术"><a href="#二、涉及技术" class="headerlink" title="二、涉及技术"></a>二、涉及技术</h2><p>使用的编程技术有：</p><ul><li>HTML； Javascript; CCS; (网页前端)</li><li>Web3 （提供了调用智能合约的js接口）</li><li>ganache-cli （在本地模拟以太坊节点）</li><li>remix （以太坊智能合约的IDE）</li><li>Solidity （智能合约编程语言）</li></ul><h2 id="三、技术概括"><a href="#三、技术概括" class="headerlink" title="三、技术概括"></a>三、技术概括</h2><p>下图显示，如果使用layer1的区块链技术，每走一步棋都需要向区块链发布一个交易。</p><p><img src="/images/battle-ship-layer2/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5neWlodWFp,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>下图所示的正是我们使用的方式。</p><p><img src="/images/battle-ship-layer2/watermark,type_W5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5neWlodWFp,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>一个问题：如何检测对方玩家撒谎？<br>具体为，每一个玩家在游戏开始前都需要随机指定两个格子，表示两个战舰的位置，如果某玩家中途变卦，不承认自己所指定的那两个格子呢？再者，当前玩家猜测对方玩家战舰所在的方格位置，对方玩家需要回复该方格下是否有战舰，如果对方玩家不诚信呢？我们使用了Merkle<br>tree进行commit（承诺）。介绍merkle tree（形如下图）不属于本文的范围。</p><p>根据密码学中的hash函数的特点，任意一个节点的变化都会导致根节点变化。并且，我们能够很容易证明某一个节点是否属于该merkle tree。</p><p><img src="/images/battle-ship-layer2/watermark,type_oZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5neWlodWFp,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>这里，我们对两位玩家的所有的游戏方格分别生成两棵merkle tree，叶子节点表示方格的编号。这里为了保密性，在编号后面合并一个随机数（合并后的数据作为hash函数的输入）。</p><p>因此，解决方法是，在玩家指定两个战舰的位置之后，需要生成一棵merkle<br>tree，并向对方发送根节点。该根节点便是对方的承诺，且它不会泄露战舰的位置信息。在游戏过程中，如果要揭露某一个方格下是否存在战舰，需要将对应编号的叶子节点和从该节点到根节点的路径信息发送给对方。若对方能够构造出相同的根节点，证明该玩家是诚信的。（这里涉及到了密码学hash函数的知识）。</p><p>另一个问题：如果一个玩家a中途离开，怎么办？ 当前实现的功能：需要玩家b向智能合约中提交一个控告。为了回应该控告，玩家a要在一分钟之内调用智能合约，取消掉该控告。如果一分钟之后玩家a不回复，那么玩家b就可以取走所有的赌注。</p><h2 id="四、区块链和智能合约的作用"><a href="#四、区块链和智能合约的作用" class="headerlink" title="四、区块链和智能合约的作用"></a>四、区块链和智能合约的作用</h2><p>在这个游戏中，智能合约充当了裁判的角色：若某个玩家撒谎或者中途离开，那么智能合约就会把赌注给另一个玩家。因此，本质上区块链中的智能合约解决了信用问题，并且，重要的是，不需要依赖任何可信的第三方。游戏玩家不需要相信任何人：不用担心对方不诚信，不用担心游戏平台和对方玩家勾结；不用担心自己的赌注莫名奇妙就被取走；不用担心游戏平台宕机。</p><p>下图表示的是智能合约的fields，也即是智能合约需要保存的数据。我们保存了两个玩家的地址，赌注的数量，游戏状态，最终赢家的地址，两个merkle tree的跟节点，超时不回复的数据等等。</p><p>该项目还实现了下述功能：</p><ul><li>Forfeit Game，表示当前玩家放弃该游戏，包括赌注。（已实现）</li><li>Claim Win，在当前玩家猜中对方两个战舰之后，点击该按钮就可以取走所有的赌注。（已实现）</li><li>Accuse<br>Cheating，原本的功能是当发现对方玩家撒谎时，将撒谎的数据发布到智能合约中，让智能合约裁决。如果读者想要实现该功能，需要注意，某一个玩家在向对方发送数据前，需要对该数据签名，以避免耍赖。因此，当某一个玩家要求智能合约裁决时，智能合约需要验证相关签名。（未实现）</li><li>Accuse Timeout，控告对方玩家中途离开；（已实现）</li><li>Respond to Accusation， 当当前玩家被控告时，该玩家需要在一分钟内点击该按钮，表示自己在线，来回复控告。（已实现）</li><li>claim timeout winnings，如果被告人没有在一分钟之内回复，就可以点击该按钮来取走所有的赌注。（已实现）</li></ul><h2 id="五、源码分析"><a href="#五、源码分析" class="headerlink" title="五、源码分析"></a>五、源码分析</h2><h3 id="1-构造Merkle树"><a href="#1-构造Merkle树" class="headerlink" title="1. 构造Merkle树"></a>1. 构造Merkle树</h3><p>使用JavaScript代码实现构造树，首先计算每个位置否存在舰艇+随机数组合后取sha3，作为每个位置的hash，然后每两个页节点取一次hash，循环最终形成一个根节点。</p><p><img src="/images/battle-ship-layer2/merkle.png" alt="img"></p><p>最终构造后的merkle树为5层，每层节点数为1、2、4、8、16</p><p>内容如下：</p><p><img src="/images/battle-ship-layer2/image-20220223205315073.png" alt="image-20220223205315073"></p><p>JS代码：</p><pre><code class="javascript">/* build_merkle  builds a Merkle Tree from the given initial_board and nonces  \args:    initial_board - [[]] - 初始化甲板作为矩阵传递，二维数组，对应横纵坐标，值为是否含有舰艇（bool）    nonces - [[Uint32]] - 随机值矩阵*/function build_merkle(initial_board, nonces) {    check_correct_sizes(initial_board, nonces);    let merkle = [[]];    // add all leaf nodes    for (let i = 0; i &lt; BOARD_LEN; i++) {        for (let j = 0; j &lt; BOARD_LEN; j++) {            merkle[0].push(                web3.utils.keccak256(                    web3.utils.fromAscii(JSON.stringify(initial_board[i][j]) + JSON.stringify(nonces[i][j]))                )            );        }    }    // build tree from leaves    // while, current level of merkle has length &gt; 1, add more levels    let curr_level = 0;    while (merkle[curr_level].length &gt; 1) {        merkle.push([]);        curr_level += 1;        // build new layer of tree        for (let i = 0; i + 1 &lt; merkle[curr_level - 1].length; i += 2) {            // have new_node represent another node in the Merkle tree            let new_node = web3.utils.keccak256(merkle[curr_level - 1][i] + merkle[curr_level - 1][i + 1].substring(2), {encoding: 'hex'});            // finalize finally computes the hash for every argument passed in update            merkle[curr_level].push(new_node);        }        // if this most recent merkle level has an odd length, we need        // to just hoist the last element into the next level        if (merkle[curr_level - 1].length % 2 !== 0) {            merkle[curr_level].push(merkle[curr_level - 1][merkle[curr_level - 1].length - 1]);        }    }    return merkle;}</code></pre><h3 id="2-猜测舰艇位置"><a href="#2-猜测舰艇位置" class="headerlink" title="2. 猜测舰艇位置"></a>2. 猜测舰艇位置</h3><p>首先发送猜测给对手，对手回应是否猜中，如果猜中了猜测者发起合约验证。</p><p>JS代码：</p><pre><code class="javascript">// function called when a user guesses a squareasync function guess_square(i, j, player, opponent, callback) {    // 签名    let signed_guess = await player.build_guess(i, j);    // 发送签名和猜测给对手获取对手回应是否猜中、随机数、merkle验证使用的节点数组    let [opening, nonce, proof] = await opponent.respond_to_guess(i, j, signed_guess);    // 更新页面    $('#' + opponent.my_name + ' &gt; .my-board #' + i + '-' + j)        .css('background-image', 'url(' + (opening ? EXPLOSION_IMG : SPLASH_IMG) + ')');    // interpret response    await player.receive_response_to_guess(i, j, [opening, nonce, proof]);    // return if the guess hit a ship    callback(opening);}</code></pre><p>respond_to_guess方法获取nonce, proof方法，JS代码：</p><pre><code class="javascript">/* 获取零知识证明需要的节点hash  /args:    initial_board - matrix representing my-board state    nonces - nonces for your board    guess - [i, j] - guess building proof for*/function get_proof_for_board_guess(initial_board, nonces, guess) {    let merkle_tree = build_merkle(initial_board, nonces);    let index_in_merkle = guess[0] * BOARD_LEN + guess[1];    let proof = [];    for (let i = 0; i &lt; merkle_tree.length - 1; i++) {        let merkle_group = Math.floor(index_in_merkle / Math.pow(2, i)); // goodod        let index_in_group = merkle_group % 2;        let sibling = Math.min(merkle_group - index_in_group + (index_in_group + 1) % 2, merkle_tree[i].length - 1);        if (sibling == merkle_group) continue;        proof.push(merkle_tree[i][sibling]);    }    return proof;}</code></pre><p>验证是否击中，Solidity代码：</p><pre><code class="solidity">// 验证单个单板上的单个点的证明// args:// - opening_nonce - 对应于web3.utils.fromAscii(JSON.stringify(open) + JSON.stringify(nonce)));// - proof - sha256哈希表，对应于 get_proof_for_board_guess()的输出// - guess - [i, j] - guess开口对应（guess that opening corresponds to）// - commit - board的默克尔根function verify_opening(bytes memory opening_nonce, bytes32[] memory proof, uint guess_leaf_index, bytes32 commit) public pure returns (bool result) {    bytes32 curr_commit = keccak256(opening_nonce); // see if this changes hash    uint index_in_leaves = guess_leaf_index;    uint curr_proof_index = 0;    uint i = 0;    while (curr_proof_index &lt; proof.length) {        // 对于默克尔树的当前层级，猜测的节点在哪个组的索引(相当于默克尔树下一层级parent的索引)        // index of which group the guess is in for the current level of Merkle tree        // (equivalent to index of parent in next level of Merkle tree)        uint group_in_level_of_merkle = index_in_leaves / (2**i);        // Merkle分组（两个为一组分组）索引数，只有(0, 1)        uint index_in_group = group_in_level_of_merkle % 2;        // 当前默克尔层级的最大节点索引        uint max_node_index = ((BOARD_LEN * BOARD_LEN + (2**i) - 1) / (2**i)) - 1;        // curr_commit的同级索引        uint sibling = group_in_level_of_merkle - index_in_group + (index_in_group + 1) % 2;        i++;        if (sibling &gt; max_node_index) continue;        if (index_in_group % 2 == 0) {            curr_commit = keccak256(merge_bytes32(curr_commit, proof[curr_proof_index]));            curr_proof_index++;        } else {            curr_commit = keccak256(merge_bytes32(proof[curr_proof_index], curr_commit));            curr_proof_index++;        }    }    return (curr_commit == commit);}</code></pre><h3 id="3-判定赢"><a href="#3-判定赢" class="headerlink" title="3. 判定赢"></a>3. 判定赢</h3><p>leaf_index_check_p2中记录着已经击中了多少舰艇</p><p>Solidity代码：</p><pre><code class="solidity">// 宣布你赢了比赛// 如果你击中了2个舰艇，然后这个函数会转移赢钱给你和结束游戏。function claim_win() public{    assert(msg.sender == p1 || msg.sender == p2);    bool    isP1Win = true;    if (msg.sender == p2) {        isP1Win = false;    }    if (isP1Win) {        require(leaf_index_check_p2.length &gt;= 2);        winner = p1;    } else {        require(leaf_index_check_p1.length &gt;= 2);        winner = p2;    }    // transfer all the tokens from this contract to the winner (i.e., msg sender)    msg.sender.transfer(address(this).balance);    state = 2;}</code></pre><h3 id="4-控告对手作弊"><a href="#4-控告对手作弊" class="headerlink" title="4. 控告对手作弊"></a>4. 控告对手作弊</h3><p>调用上面的verify_opening方法验证是否满足Merkle树，不满足说明对方作弊。</p><p>Solidity代码：</p><pre><code class="solidity">// 控告对手作弊 — 如果是真的，你就赢了。// opening_nonce - 对应于JS中的web3.utils.fromAscii(JSON.stringify(opening) + JSON.stringify(nonce))// proof - 一个sha256哈希列表，你可以从get_proof_for_board_guess(这是发送者认为是一个谎言)// guess_leaf_index - 猜测船只位置的索引// owner - 这艘船所在的board的所有者的地址function accuse_cheating (    bytes memory opening_nonce,    bytes32[] memory proof,    uint256 guess_leaf_index,    address owner) public returns (bool result) {    assert((msg.sender == p1 &amp;&amp; owner == p2) || (msg.sender == p2 &amp;&amp; owner == p1));    bytes32 com = merkle_root_p1;    if(owner == p2){        com = merkle_root_p2;    }    if(!verify_opening(opening_nonce, proof, guess_leaf_index, com)){        msg.sender.transfer(address(this).balance);        state = 2;        winner = msg.sender;        return true;    }    return false;}</code></pre><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ol><li>源代码提供：<a href="https://blog.csdn.net/liangyihuai/article/details/116459829">https://blog.csdn.net/liangyihuai/article/details/116459829</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于以太坊的战艇游戏-Layer2-源码解析&quot;&gt;&lt;a href=&quot;#基于以太坊的战艇游戏-Layer2-源码解析&quot; class=&quot;headerlink&quot; title=&quot;基于以太坊的战艇游戏(Layer2)源码解析&quot;&gt;&lt;/a&gt;基于以太坊的战艇游戏(Layer2)源码</summary>
      
    
    
    
    
    <category term="Ethereum" scheme="https://zhangzhishun.github.io/tags/Ethereum/"/>
    
    <category term="Layer2" scheme="https://zhangzhishun.github.io/tags/Layer2/"/>
    
  </entry>
  
  <entry>
    <title>雪崩共识</title>
    <link href="https://zhangzhishun.github.io/2022/02/08/blockchain/avalanche/%E9%9B%AA%E5%B4%A9%E5%85%B1%E8%AF%86/"/>
    <id>https://zhangzhishun.github.io/2022/02/08/blockchain/avalanche/%E9%9B%AA%E5%B4%A9%E5%85%B1%E8%AF%86/</id>
    <published>2022-02-08T03:20:30.000Z</published>
    <updated>2022-04-27T02:35:55.474Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.引言</strong></p><p>Avalanche主网正式上线，OKEx也已经上架Avalanche原生代币AVAX，曾获得“共识协议3.0”之称的Avalanche重回大众视野，为何Avalanche一举一动受到如此大的市场关注？</p><p>这一切要从2015年5月说起，康奈尔大学出现了一篇《从“雪花”到“雪崩”：一种新型的亚稳态共识协议族》的论文，在市场上引发了雪崩式的迅速反响，成为可以和中本聪的PoW机制、以太坊智能合约相媲美的颠覆性技术创新。</p><p><strong>2.结合早期协议优点并改进缺点</strong></p><p>正如康奈尔大学教授埃米·冈·瑟勒（Emin Gun Sirer）所言：“Avalanche描述了一种新的共识协议，它将中本聪共识协议与经典共识协议相结合，这是一次重大的突破”。在此之前，经典共识协议和中本聪共识协议是早期两类解决分布式系统拜占庭问题的主要共识协议。</p><p>分布式系统中的共识问题一直是计算机科学领域的重要话题，而拜占庭将军问题则是重中之重。战争时期，在军队可能有叛徒和间谍的情况下忠诚的将军如何达成一致的意见，这便是拜占庭将军问题。经典共识协议由图灵奖得主兰伯特提出，具有强一致性、高效的特点，但也有通信成本高、节点无法自由进出的缺点。</p><p><strong>图1：经典共识协议（PBFT）工作原理</strong></p><p><img src="https://hx24.huoxing24.com/image/crawler/2020/09/28/1601261161638216.jpg" alt="拜占庭">资料来源：《区块链技术指南》，OKEx Research</p><p>而著名的中本聪共识协议则创造性地用概率保证实际运行的共识，解决了节点无法自由进出的问题，但是成本高昂问题仍未被解决。</p><p><strong>图2：中本聪共识协议工作原理</strong></p><p><img src="https://hx24.huoxing24.com/image/crawler/2020/09/28/1601261161662703.jpg" alt="拜占庭">资料来源：OKEx Research</p><p>Avalanche共识协议则结合了两类协议的优点：借鉴了中本聪协议概率性安全保障的设计，同时加入了BFT属性，增加系统的效率和安全性。</p><p><strong>3.Avalanche原理：“雪花”到“雪崩”的层层完善</strong></p><p>正如Avalanche白皮书提到的“雪花”到“雪崩”过程，Avalanche的4个子协议组成正是从最简单的Slush协议，到Snowflake、Snowball 和 Avalanch，逐步完善，形成了“雪花”到“雪崩”的质变。</p><p><strong>3.1. “雪泥”Slush 协议：万物之初</strong></p><p>Slush协议是最基础的“雪泥”，通过多次随机抽样来达成共识。为便于理解，这里我们以投票确认颜色为例。节点达成共识的步骤如下：</p><p>（1）初始状态时所有的节点均未着色；</p><p>（2）当节点A收到信息时，未着色的节点将信息颜色设为自己的颜色，并询问其他节点的颜色；</p><p>（3）未着色的节点B收到询问，将自己染成相同颜色并回复；已着色的节点C收到询问会回复自己的颜色；</p><p>（4）节点A收到多个响应后，如果大多数颜色和自己的一直，则不改变颜色，否则改变颜色，即以大多数其他节点的颜色反馈来校正自己的颜色。</p><p>Slush协议就已经解决了经典共识协议通讯成本高的问题，还用部分抽样等方式避免了中本聪共识协议高能耗的问题。后续协议的改进主要为了提升共识协议安全性。</p><p><strong>3.2. “雪花”Snowflake协议：初步改善</strong></p><p>在拜占庭节点存在的情况下，Slush不能提供强大的安全保证。为此，Snowflake作为升级版协议引入了计数器（Counter）来增加系统的安全性。</p><p>具体而言，网络中的攻击节点故意散播错误的颜色，可能导致Slush某一轮统计得到错误的颜色，而Snowflake的计数器统计了某种颜色连续出现的次数，只有某种颜色连续出现多次，节点才会改变自己的颜色。如此避免了拜占庭节点带来的干扰，确保了系统的安全性和活跃度。</p><p><strong>3.3. “雪球”Snowball协议：深入升级</strong></p><p>Snowball在Snowflake的基础上更进一步地。引入了类似信誉积分的制度——信任度，以提高安全性。</p><p>具体而言，Snowflake协议的改进如下：</p><p>（1）每成功查询一次，节点就为该颜色的信任度加1分；</p><p>（2）节点会切换为信任度较高的颜色。</p><p>Snowball协议不仅比Snowflake更难遭受攻击，而且更容易推广到多命令协议。</p><p><strong>3.4. “雪崩”Avalanche协议：量变到质变</strong></p><p>终极Boss“雪崩”——Avalanche又在Snowball的基础上增加了有向无循环图（DAG）来记录所有的交易状态。在DAG中，如果想给从创世点到某节点路径上的所有节点都投票只需要给该节点投票，大大提高了效率。其次，DAG有着类似于区块链的链式结构记录交易信息，使得过去的交易信息很难被篡改，进一步提升了安全性。</p><p>图3：DAG示意图</p><p><img src="https://hx24.huoxing24.com/image/crawler/2020/09/28/1601261161723758.jpg" alt="拜占庭">资料来源：《区块链新共识算法 Snowflake to Avalanche》，OKEx Research</p><p><strong>3.5. Avalanche协议：集前期协议之大成</strong></p><p>吸取了早期两个共识协议的优点，并经过4个协议层次递进、逐步改善，Avalanche协议具有许多优良特性。</p><p>（1）高效的可扩展性：轻量级，可扩展，低延迟；</p><p>（2）高拜占庭容错：即使网络中有超过50%的节点是拜占庭节点，网络依然是安全的;</p><p>（3）静态绿色：与PoW机制不同，Avalanche协议不会浪费任何资源;</p><p>（4）低通信成本：Avalanche协议比传统共识协议的通讯复杂度更低。</p><p><strong>4. 零确认交易与Avalanche协议</strong></p><p>Avalanche刚面世时，人们还没有发现Avalanche协议与零确认交易之间有什么关系。然而在2018年12月左右，BCH社区的技术人员Chris Pacia发表一篇文章，认为可以使用Avalanche协议来保证零确认交易的安全性，一时起千层浪，引发了市场的广泛兴趣。</p><p>Avalanche协议的确认需要多次抽样，为缩短确认时间，则抽样次数必须受到限制，这意味着，恶意节点超过一定比例后，在有限抽样里诚实节点无法达成共识。为此，Chris Pacia认为可以引入PoW机制来保护网络的安全，防止黑客的攻击节点数量太多。</p><p><strong>5. Avalanche现状：众望所归</strong></p><p>自2018年Avalanche白皮书发布以来，受到了广泛的首肯心折，许多VC相竞为之折腰。2019 年，雪崩协议Ava获得了 a16z、Polychain Capital 等机构 600 万美元融资。2020年6月，AVA Lab又完成了一笔1200万美元的代币私募融资，同年7月，又获得IOSG Ventures的战略投资，并就中国市场未来发展达成独家战略合作协议。根据最新消息，AVA的公募于7月8日开启。</p><p><strong>6. 结语</strong></p><p>Avalanche结合了早期两种共识协议的优点并改进其缺点，具有高拓展性、静态绿色以及低通信成本的优点。同时，从Slush到Avalanche层层递进、逐步完善，引入计数器、可信度、DAG等，日臻完善。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.avalabs.org/whitepapers">Avalanche writepaper</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1.引言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Avalanche主网正式上线，OKEx也已经上架Avalanche原生代币AVAX，曾获得“共识协议3.0”之称的Avalanche重回大众视野，为何Avalanche一举一动受到如此大的市场关注？&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="共识算法" scheme="https://zhangzhishun.github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="Avalanche" scheme="https://zhangzhishun.github.io/tags/Avalanche/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s Avalanche?</title>
    <link href="https://zhangzhishun.github.io/2022/02/07/blockchain/avalanche/What&#39;s%20Avalanche/"/>
    <id>https://zhangzhishun.github.io/2022/02/07/blockchain/avalanche/What&#39;s%20Avalanche/</id>
    <published>2022-02-07T03:20:30.000Z</published>
    <updated>2022-04-27T02:35:55.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-Avalanche"><a href="#What-is-Avalanche" class="headerlink" title="What is Avalanche?"></a>What is Avalanche?</h1><p>Avalanche is an open-source platform for launching decentralized applications and enterprise blockchain deployments in one interoperable, highly scalable ecosystem. Avalanche is the first decentralized smart contracts platform built for the scale of global finance, with near-instant transaction finality. Ethereum developers can quickly build on Avalanche as Solidity works out-of-the-box.</p><p>A key difference between Avalanche and other decentralized networks is the <font color="red">consensus protocol</font>. Over time, people have come to a false understanding that blockchains have to be slow and not scalable. The Avalanche protocol employs a novel approach to consensus to achieve its <font color="red">strong safety guarantees, quick finality, and high-throughput</font> without compromising decentralization.</p><h1 id="Consensus-protocol"><a href="#Consensus-protocol" class="headerlink" title="Consensus protocol"></a>Consensus protocol</h1><p><img src="https://docs.avax.network/assets/images/Consensus-protocol-comparison-aa555b20f36947d6a5ff869d8758fa6e.png" alt="image"></p><p>Protocols in the Avalanche family operate through repeated sub-sampled voting. When a <a href="http://support.avalabs.org/en/articles/4064704-what-is-a-blockchain-validator">validator</a> is determining whether a <a href="http://support.avalabs.org/en/articles/4587384-what-is-a-transaction">transaction</a> should be accepted or rejected, it asks a small, random subset of validators whether they think the transaction should be accepted or rejected. If the queried validator thinks the transaction is invalid, has already rejected the transaction, or prefers a conflicting transaction, it replies that it thinks the transaction should be rejected. Otherwise, it replies that it thinks the transaction should be accepted.</p><p>If a sufficiently large portion (<em>alpha</em> α) of the validators sampled reply that they think the transaction should be accepted, the validator prefers to accept the transaction. That is, when it is queried about the transaction in the future, it will reply that it thinks the transaction should be accepted. Similarly, the validator will prefer to reject the transaction if a sufficiently large portion of the validators replies that they think the transaction should be rejected.</p><p>The validator repeats this sampling process until <em>alpha</em> of the validators queried reply the same way (accept or reject) for <em>beta</em> β consecutive rounds.</p><p>In the common case when a transaction has no conflicts, finalization happens very quickly. When conflicts exist, honest validators quickly cluster around conflicting transactions, entering a positive feedback loop until all correct validators prefer that transaction. This leads to the acceptance of non-conflicting transactions and the rejection of conflicting transactions.</p><p><img src="https://docs.avax.network/assets/images/howavalancheconsensusworks-a37dc2bdf67c7c2997dcbfd01ee28e64.png" alt="image"></p><p>It is guaranteed (with high probability based on system parameters) that if any honest validator accepts or rejects a transaction, all honest validators will accept or reject that transaction.</p><h2 id="Key-Features"><a href="#Key-Features" class="headerlink" title="Key Features"></a>Key Features</h2><h3 id="Speed"><a href="#Speed" class="headerlink" title="Speed"></a>Speed</h3><p>Uses a novel consensus protocol, developed by a team of Cornell computer scientists, and is able to permanently confirm transactions in under <font color="red">1 second</font>.</p><h3 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h3><p>Capable of <font color="red">4,500 transactions per second</font>–an order of magnitude greater than existing blockchains.</p><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p><font color="red">Ensures stronger security guarantees well</font>-above the 51% standard of other networks.</p><h3 id="Flexibility"><a href="#Flexibility" class="headerlink" title="Flexibility"></a>Flexibility</h3><p><font color="red">Easily</font> create custom blockchains and decentralized apps that contain almost any arbitrary logic.</p><h3 id="Sustainability"><a href="#Sustainability" class="headerlink" title="Sustainability"></a>Sustainability</h3><p>Uses energy-efficient <font color="red">proof-of-stake</font> consensus algorithm rather than proof-of-work.</p><h3 id="Smart-Contract-Support"><a href="#Smart-Contract-Support" class="headerlink" title="Smart Contract Support"></a>Smart Contract Support</h3><p>Supports the creation of <font color="red">Solidity smart contracts</font> and your favorite Ethereum tools like Remix, Metamask, Truffle, and more.</p><h3 id="Private-and-Public-Blockchains"><a href="#Private-and-Public-Blockchains" class="headerlink" title="Private and Public Blockchains"></a>Private and Public Blockchains</h3><p>Create your own public or private blockchains.</p><h3 id="Designed-for-Finance"><a href="#Designed-for-Finance" class="headerlink" title="Designed for Finance"></a>Designed for Finance</h3><p>Native support for easily creating and trading <font color="red">digital smart assets</font> with complex, custom rulesets.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><p><a href="https://docs.avax.network/">Avalanche website</a></p></li><li><p><a href="https://github.com/ava-labs/avalanchego">Avalanche source code</a></p></li><li><p><a href="https://academy.binance.com/zh/articles/what-is-avalanche-avax">What’s is Avalanche?</a></p></li><li><p><a href="https://www.avalabs.org/whitepapers">Avalanche writepaper</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;What-is-Avalanche&quot;&gt;&lt;a href=&quot;#What-is-Avalanche&quot; class=&quot;headerlink&quot; title=&quot;What is Avalanche?&quot;&gt;&lt;/a&gt;What is Avalanche?&lt;/h1&gt;&lt;p&gt;Avalanch</summary>
      
    
    
    
    
    <category term="Avalanche" scheme="https://zhangzhishun.github.io/tags/Avalanche/"/>
    
  </entry>
  
  <entry>
    <title>Docker方式搭建以太坊网络-私有链</title>
    <link href="https://zhangzhishun.github.io/2022/01/29/blockchain/ethereum/Docker%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A---%E7%A7%81%E6%9C%89%E9%93%BE/"/>
    <id>https://zhangzhishun.github.io/2022/01/29/blockchain/ethereum/Docker%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A---%E7%A7%81%E6%9C%89%E9%93%BE/</id>
    <published>2022-01-29T11:29:23.000Z</published>
    <updated>2022-04-27T02:35:55.474Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及的知识和技术有：</p><ul><li>Docker：一种时下流行的容器</li><li>geth：以太坊客户端的go实现</li><li>truffle：以太坊合约部署工具</li></ul><h2 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h2><p>此处需要补充一点的是，如果您使用的是虚拟机、云主机或者老破小机器，需要确保分配给主机的内存至少2GB。因为以太坊为了抵御比特大陆这样的ASIC矿机对算力的垄断，采用了和比特币完全不同的PoW算法——ethash。该算法的特点是算力不敏感，内存敏感。该算法目前需要在内存创建大约1GB的DAG用来做PoW运算，且DAG会随着区块的增加呈阶梯状增长，因此建议至少给挖矿节点的宿主机器分配至少2GB的内存，且保留扩大内存容量的灵活性。</p><h2 id="获取geth镜像"><a href="#获取geth镜像" class="headerlink" title="获取geth镜像"></a>获取geth镜像</h2><p>docker hub上有现成的geth镜像。直接获取：</p><pre><code class="bash">docker pull ethereum/client-go:v1.8.12</code></pre><h2 id="创建Docker网络"><a href="#创建Docker网络" class="headerlink" title="创建Docker网络"></a>创建Docker网络</h2><p>旧版本的docker容器相互之间是依靠link建立关系。<br>新版本docker推荐创建自有网路，再将需要互联的容器配置到相同的网络中。<br>于是，我们创建一个名为“ethnet“的网络。该网络配置如下：</p><ul><li>子网172.19.0.0/16<ul><li>IP段172.19.0.0</li><li>掩码255.255.0.0</li><li>IP范围172.19.0.1~172.19.255.254</li><li>IP广播172.19.255.255</li></ul></li></ul><pre><code class="bash">docker network create -d bridge --subnet=172.19.0.0/16 ethnetdocker network ls</code></pre><h1 id="配置以太坊网络"><a href="#配置以太坊网络" class="headerlink" title="配置以太坊网络"></a>配置以太坊网络</h1><p>运行如下命令进入一个容器：</p><pre><code class="bash">docker run -it --rm --network ethnet --ip 172.19.0.50 -v /opt/docker-project/eth/workspace:/workspace --entrypoint /bin/sh ethereum/client-go:v1.8.12</code></pre><blockquote><p>–network ethnet参数指定了该容器加入刚才创建的ethnet网络<br> –ip 172.19.0.50指定了一个固定IP给该容器。</p></blockquote><h2 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h2><p>首先，在容器内的/workspace目录创建目录和文件</p><p>执行以下命令：</p><pre><code class="bash">mkdir -p /workspacedappmkdir -p /workspace/dapp/minermkdir -p /workspace/dapp/datatouch /workspace/dapp/genesis.json</code></pre><p>然后运行如下命令创建账户：</p><pre><code class="bash">geth -datadir /workspace/dapp/miner/data account new</code></pre><p>输入两次password，获得地址。将地址记录下来，后面要用到。</p><blockquote><p>重复如上步骤可以创建多个账户。</p></blockquote><h2 id="创建创世区块"><a href="#创建创世区块" class="headerlink" title="创建创世区块"></a>创建创世区块</h2><p>编辑刚才创建的文件</p><pre><code class="bash">vi /workspace/dapp/data/genesis.json</code></pre><p>文件内容：</p><pre><code class="json">{  "config": {    "chainId": 88,    "homesteadBlock": 0,    "eip155Block": 0,    "eip158Block": 0  },  "alloc"      : {    "b126d89780d2221ceffe5c94efd9ca6a005a9f0c": {"balance": "100000000000000000000"},    "93415bb68da6816c581537a4fa74727ddf6f4f4d": {"balance": "1000000000000000000"},    "fa5773a704ee9e91e60ffb8fe4207e934f70619f": {"balance": "1000000000000000000"}  },  "coinbase"   : "0x0000000000000000000000000000000000000000",  "difficulty" : "0x400",  "extraData"  : "",  "gasLimit"   : "0x2fefd8",  "nonce"      : "0x0000000000000000",  "mixhash"    :  "0x0000000000000000000000000000000000000000000000000000000000000000",  "parentHash" :  "0x0000000000000000000000000000000000000000000000000000000000000000",  "timestamp"  : "0x00"}</code></pre><ul><li>genesis.json是用来创建创世区块的配置文件</li><li>加入同一私链的节点必须使用同一配置文件</li><li>chainid是私链网络的标识，可以是任意数字。</li><li>即使chainid相同，如果genesis.json配置不一样，也将是两个不兼容的网络</li><li>alloc下面列举了4个账户地址，分别是上一步创建并记录下来的地址。</li><li>balance是创世区块为每个账户分配的初始以太币。这里看似分配了很多，其实单位是wei。1eth=10^18wei。也就是除了第一个账户给了100eth外，其它几个账户分别只拥有1eth。这里给第一个账户多分点，是因为我们之后需要用它来部署合约。</li></ul><h2 id="完成以太坊网络配置"><a href="#完成以太坊网络配置" class="headerlink" title="完成以太坊网络配置"></a>完成以太坊网络配置</h2><p>此时可以退出刚才的容器。由于我们运行容器是加了–rm参数，刚才的容器会被删除，但宿主机的/workspace下的文件会被保存下来。</p><h1 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h1><p>上述步骤只是配置好了一个以太坊私有网络，并没有真正创建网络。我们知道，以太坊网络是一个分布式的网络，有了矿工，才有的网络。于是，我们首先得有一个矿工。</p><h2 id="创建“主”矿工节点"><a href="#创建“主”矿工节点" class="headerlink" title="创建“主”矿工节点"></a>创建“主”矿工节点</h2><p>我们接下来打算创建的矿工节点，成为“主”矿工，因为它需要拥有如下特性：</p><ul><li>它是一个容器，并且是持久的容器</li><li>它会自动读取genesis.json文件，并初始化以太坊网络</li><li>它能够连接其它节点（容器）</li><li>它能够接受各种rpc调用，并能够部署合约</li><li>它已经配置好挖矿账户，可以一键挖矿</li></ul><p>于是，我们按照这个要求，开始一步步创建矿工节点。</p><h3 id="创建entrypoint脚本"><a href="#创建entrypoint脚本" class="headerlink" title="创建entrypoint脚本"></a>创建entrypoint脚本</h3><p>创建一个文件：</p><pre><code class="bash">vi /opt/docker-project/eth/workspace/dapp/init.sh</code></pre><p> 文件内容如下：</p><pre><code class="bash">#!/bin/shgeth -datadir ~/data/ init /workspace/dapp/data/genesis.jsonif [  $# -lt 1 ]; then   exec "/bin/sh"else  exec /bin/sh -c "$@"fi</code></pre><blockquote><p>该脚本的功能是让以太坊节点（容器）自动初始化以太坊网络，并且接受一个自动运行脚本作为输入。</p></blockquote><h3 id="创建自动运行脚本"><a href="#创建自动运行脚本" class="headerlink" title="创建自动运行脚本"></a>创建自动运行脚本</h3><p>创建一个文件：</p><pre><code class="bash">vi /opt/docker-project/eth/workspace/dapp/mine.sh</code></pre><p>内容如下：</p><pre><code class="bash">#!/bin/shaccount='b126d89780d2221ceffe5c94efd9ca6a005a9f0c'cp -r /workspace/dapp/miner/data/keystore/* ~/data/keystore/geth -datadir ~/data/ --networkid 88 --rpc --rpcaddr "172.19.0.50" --rpcapi admin,eth,miner,web3,personal,net,txpool --unlock ${account} --etherbase ${account} console</code></pre><ul><li>第一行命令是将刚才生成的账户私钥文件拷贝到容器的home目录下。因为/workspace是宿主目录挂载的，并不是linux文件系统，直接将datadir指定到该目录会导致geth报错。</li><li>第二行命令是启动以太坊节点的命令。<ul><li>–networkid 88指定了networkid，这个必须与genesis.json内设置保持一致</li><li>–rpc –rpcaddr “172.19.0.50” –rpcapi …. 这些参数表示该节点接受rpc，并且指定了rpc的协议</li><li>–unlock “0x…” 加入该参数会需要用户输入账户密码。密码校验后会解锁该账户。账户解锁后，该节点就能使用此账户的私钥进行签名加密等动作，用以进行交易、发布合约等。</li><li>–etherbase 参数指定了挖矿收益账户</li></ul></li></ul><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><pre><code class="bash">chmod +x /opt/docker-project/eth/workspace/dapp/init.shchmod +x /opt/docker-project/eth/workspace/dapp/mine.shdocker run -it --name=miner --network ethnet --ip 172.19.0.50 --hostname node -v /opt/docker-project/eth/workspace:/workspace --entrypoint /workspace/dapp/init.sh ethereum/client-go:v1.8.12 /workspace/dapp/mine.sh</code></pre><blockquote><p>该命令会创建一个持久化的容器。容器的entrypoint和自动运行脚本指定为我们刚创建的那两个脚本。</p></blockquote><p>如果报错：</p><pre><code class="bash">Fatal: Failed to unlock account (no key for given address or file)</code></pre><p>可能原因是没有修改上面的mine.sh脚本的account参数为第一个账户地址</p><h2 id="创建“从”矿工节点"><a href="#创建“从”矿工节点" class="headerlink" title="创建“从”矿工节点"></a>创建“从”矿工节点</h2><p>只有一个节点的网络，怎么看都不像“分布式”网络。所以我们需要创建更多的节点来形成一个“分布式网络”。我们称这些节点叫做“从”矿工。<br> 这类矿工不需要交易，不需要发布合约，因此不需要unlock账户，也不需要接受rpc。它们只知道埋头挖矿。</p><h3 id="创建自动运行脚本-1"><a href="#创建自动运行脚本-1" class="headerlink" title="创建自动运行脚本"></a>创建自动运行脚本</h3><p>“从”矿工节点和“主”矿工节点共享entrypoint，以保证它们创建出完全相同的网络。<br> 只有自动运行脚本不太一样，</p><pre><code class="bash">vi /opt/docker-project/eth/workspace/dapp/node.sh</code></pre><p>文件内容：</p><pre><code class="bash">#!/bin/shcp -r /workspace/dapp/miner/data/keystore/* ~/data/keystore/geth -datadir ~/data/ --networkid 88 console </code></pre><p>创建容器:</p><pre><code class="bash">chmod +x /opt/docker-project/eth/workspace/dapp/node.shdocker run -it --name=node1 --network ethnet --ip 172.19.0.51 --hostname node1 -v /opt/docker-project/eth/workspace:/workspace --entrypoint /workspace/dapp/init.sh ethereum/client-go:v1.8.12 /workspace/dapp/node.sh</code></pre><h1 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h1><p>以上创建出了多个以太坊节点，运行在同一网络下。每个节点都可以执行如下操作。供参考。</p><h2 id="节点发现"><a href="#节点发现" class="headerlink" title="节点发现"></a>节点发现</h2><h3 id="查看节点信息"><a href="#查看节点信息" class="headerlink" title="查看节点信息"></a>查看节点信息</h3><pre><code class="bash">geth -datadir ~/data/ --networkid 88 console&gt;admin.nodeInfo.enode# 输出"enode://708b66364c83af2d3725c309f2bdc0e7d4e395c6ac7310e1a1147b9dfe084649e6c6a3ce6c483c51ab6e924f6abade647246c2b57ecc49d9a573cea896cdf0e6@[::]:30303"</code></pre><h3 id="配置静态节点文件"><a href="#配置静态节点文件" class="headerlink" title="配置静态节点文件"></a>配置静态节点文件</h3><p>~/data/geth/static-nodes.json</p><pre><code class="json">[    "enode://&lt;node public key&gt;@&lt;node IP address&gt;:&lt;node port&gt;"]</code></pre><h3 id="查看连接上的节点"><a href="#查看连接上的节点" class="headerlink" title="查看连接上的节点"></a>查看连接上的节点</h3><pre><code class="bash">geth -datadir ~/data/ --networkid 88 console&gt;admin.peers</code></pre><h3 id="动态添加节点"><a href="#动态添加节点" class="headerlink" title="动态添加节点"></a>动态添加节点</h3><pre><code class="bash">&gt;admin.addPeer("enode://&lt;node public key&gt;@&lt;node IP address&gt;:&lt;node port&gt;")</code></pre><h2 id="挖矿-1"><a href="#挖矿-1" class="headerlink" title="挖矿"></a>挖矿</h2><p>启动miner容器</p><pre><code class="bash">&gt;miner.start(1)</code></pre><ul><li>参数1指定了挖矿的线程数。</li><li>首次启动节点会消耗大约20~30分钟产生DAG</li><li>某开始挖矿后，其它节点将会收到新区块并打印</li></ul><h1 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h1><h2 id="创建truffle镜像"><a href="#创建truffle镜像" class="headerlink" title="创建truffle镜像"></a>创建truffle镜像</h2><p>由于没有找到好用的truffle镜像，我自己创建了一个。Dockerfile内容如下：</p><pre><code class="ruby">FROM alpine:3.8MAINTAINER Cary Tan hbuzzs@163.comENV PS1='[truffle@docker $PWD]\$ 'RUN echo "http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.8/main" &gt; /etc/apk/repositories \      &amp;&amp; echo "http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.8/community" &gt;&gt; /etc/apk/repositories \      &amp;&amp; apk update \          &amp;&amp; apk add curl \      &amp;&amp; apk add npm \      &amp;&amp; apk add git \      &amp;&amp; mkdir -p /workspace \      &amp;&amp; npm config set registry https://registry.npm.taobao.org \      &amp;&amp; npm install -g truffleWORKDIR /workspaceCMD /bin/sh</code></pre><p>也可使用他人上传的镜像：</p><pre><code class="bash">docker pull txcary/truffle:180806# 这个镜像没有curl 需要安装apk add curl</code></pre><h2 id="新建truffle工程"><a href="#新建truffle工程" class="headerlink" title="新建truffle工程"></a>新建truffle工程</h2><pre><code class="bash">mkdir -p /opt/docker-project/truffle/workspace/VanTokencd /opt/docker-project/truffle/workspace/VanTokengit clone https://github.com/trufflesuite/truffle-init-bare.git</code></pre><h2 id="启动truffle容器"><a href="#启动truffle容器" class="headerlink" title="启动truffle容器"></a>启动truffle容器</h2><pre><code class="bash">docker run -it --rm -v /opt/docker-project/truffle/workspace:/workspace --network ethnet txcary/truffle:180806</code></pre><h3 id="测试节点RPC"><a href="#测试节点RPC" class="headerlink" title="测试节点RPC"></a>测试节点RPC</h3><pre><code class="bash">curl 172.19.0.50:8545 -X POST --data '{"id":1,"jsonrpc":"2.0","method":"eth_accounts", "params":[]}' -H "Content-Type: application/json"curl 172.19.0.50:8545 -X POST --data '{"id":1,"jsonrpc":"2.0","method":"eth_getBalance", "params":["0x4c283287839fd441b8c8d18771321bc06a81edae","latest"]}' -H "Content-Type: application/json"</code></pre><ul><li>第一条命令获取节点上的账户</li><li>第二条命令获取账户余额</li><li>如果这两条命令成功了，说明以太坊私有网络搭建成功，并且节点rpc调用成功</li></ul><h3 id="修改truffle-js"><a href="#修改truffle-js" class="headerlink" title="修改truffle.js"></a>修改truffle.js</h3><pre><code class="javascript">module.exports = {        networks: {            development: {                host: "172.19.0.50",                port: 8545,                network_id: 88,                gas: 2900000,                gasPrice: 10000000000            }        }};</code></pre><ul><li>gas使用默认值会导致超限错误，研究半天不知道为什么。要是搞明白的可以给我留言，谢谢！</li><li>gasPrice为默认值</li></ul><h2 id="编写合约Migrations-sol（truffle内置）"><a href="#编写合约Migrations-sol（truffle内置）" class="headerlink" title="编写合约Migrations.sol（truffle内置）"></a>编写合约Migrations.sol（truffle内置）</h2><pre><code class="solidity">pragma solidity &gt;=0.4.22 &lt;0.6.0;contract Migrations {    address public owner;    uint public lastCompletedMigration;    modifier restricted() {        if (msg.sender == owner) _;    }    constructor() public {        owner = msg.sender;    }    function setCompleted(uint completed) public restricted {        lastCompletedMigration = completed;    }    function upgrade(address newAddress) public restricted {        Migrations upgraded = Migrations(newAddress);        upgraded.setCompleted(lastCompletedMigration);    }}</code></pre><h2 id="新建部署脚本"><a href="#新建部署脚本" class="headerlink" title="新建部署脚本"></a>新建部署脚本</h2><p>deploy_contracts.js</p><pre><code class="javascript">var contractsName = artifacts.require("./Storage.sol");module.exports = function(deployer) {  deployer.deploy(contractsName);};</code></pre><h2 id="编译合约"><a href="#编译合约" class="headerlink" title="编译合约"></a>编译合约</h2><pre><code class="bash">truffle compile</code></pre><h2 id="部署合约-1"><a href="#部署合约-1" class="headerlink" title="部署合约"></a>部署合约</h2><pre><code class="bash">truffle migrate --network development --verbose-rpc</code></pre><p>部署成功</p><p><img src="/images/eth_network_set_up/image-20220204103544178.png" alt="image-20220204103544178"></p><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><ul><li><a href="https://www.jianshu.com/p/7994db7a2b89?from=singlemessage">https://www.jianshu.com/p/7994db7a2b89?from=singlemessage</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文涉及的知识和技术有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker：一种时下流行的容器&lt;/li&gt;
&lt;li&gt;geth：以太坊客户端的go实现&lt;/li&gt;
&lt;li&gt;truffle：以太坊合约部署工具&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;主机配置&quot;&gt;&lt;a href=&quot;#主机配置&quot; </summary>
      
    
    
    
    
    <category term="部署文档" scheme="https://zhangzhishun.github.io/tags/%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/"/>
    
    <category term="Ethereum" scheme="https://zhangzhishun.github.io/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法分析</title>
    <link href="https://zhangzhishun.github.io/2022/01/18/data_struct_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://zhangzhishun.github.io/2022/01/18/data_struct_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2022-01-18T02:29:15.000Z</published>
    <updated>2022-04-27T02:35:55.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法分析"><a href="#数据结构与算法分析" class="headerlink" title="数据结构与算法分析"></a>数据结构与算法分析</h1><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>了解算法分析方法（第二章-13）</li><li>精通表、栈和队列（第三章-27）、树（第四章-40）、散列（第五章-36）、优先队列、堆（第六章-28）、排序（第七章-50）、不相交集类（第八章-17）</li><li>精通图论（第九章-38）、算法设计技巧（第十章-50）、红黑树（第十二章第二节-5）</li></ul><h1 id="第-2-章-算法分析方法"><a href="#第-2-章-算法分析方法" class="headerlink" title="第 2 章 算法分析方法"></a>第 2 章 算法分析方法</h1><h2 id="2-4-运行时间计算"><a href="#2-4-运行时间计算" class="headerlink" title="2.4 运行时间计算"></a>2.4 运行时间计算</h2><h3 id="2-4-1-一般法则"><a href="#2-4-1-一般法则" class="headerlink" title="2.4.1 一般法则"></a>2.4.1 一般法则</h3><ol><li>法则1 —— for循环</li></ol><p>一个for循环的运行时间至多是该for循环内部那些语句（包括测试）的运行时间乘以迭代的次数</p><ol><li>法则2 —— 嵌套的for循环</li></ol><p>在一组嵌套循环内部的一条语句的运行时间为该语句的运行时间乘以该组所有的for循环的大小的乘积</p><ol><li>法则3 —— 顺序语句</li></ol><p>将各个语句的运行时间求和即可。这意味着其中的最大值就是所得的运行时间。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled.png" alt="Untitled"></p><ol><li>法则4 —— if/else语句</li></ol><p>一个if/else语句的运行时间从不超过判断的运行时间再加上S1和S2中运行时间长者的总的运行时间。</p><h1 id="第-3-章-表、栈和队列"><a href="#第-3-章-表、栈和队列" class="headerlink" title="第 3 章 表、栈和队列"></a>第 3 章 表、栈和队列</h1><h2 id="3-1-抽象数据类型"><a href="#3-1-抽象数据类型" class="headerlink" title="3.1 抽象数据类型"></a>3.1 抽象数据类型</h2><p>抽象数据类型（ADT）是带有一组操作的一些对象的集合。</p><h2 id="3-2-表ADT"><a href="#3-2-表ADT" class="headerlink" title="3.2 表ADT"></a>3.2 表ADT</h2><p>我们称形如$A_0$$,A_1,A_2,…,A_{N-1}$的为表，该表大小为N</p><h3 id="3-2-1-表的简单数组实现"><a href="#3-2-1-表的简单数组实现" class="headerlink" title="3.2.1 表的简单数组实现"></a>3.2.1 表的简单数组实现</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%201.png" alt="Untitled"></p><h3 id="3-2-2-简单链表"><a href="#3-2-2-简单链表" class="headerlink" title="3.2.2 简单链表"></a>3.2.2 简单链表</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%202.png" alt="Untitled"></p><h2 id="3-6-栈ADT"><a href="#3-6-栈ADT" class="headerlink" title="3.6 栈ADT"></a>3.6 栈ADT</h2><h3 id="3-6-1-栈模型"><a href="#3-6-1-栈模型" class="headerlink" title="3.6.1 栈模型"></a>3.6.1 栈模型</h3><p>栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做站的顶（top）。</p><p>栈的基本操作有push（进栈）、pop（出栈）</p><p>栈有时又叫LIFO（后进先出）表</p><h3 id="3-6-3-应用"><a href="#3-6-3-应用" class="headerlink" title="3.6.3 应用"></a>3.6.3 应用</h3><ul><li>平衡符号</li><li>后缀表达式</li><li>方法调用</li></ul><h2 id="3-7-队列ADT"><a href="#3-7-队列ADT" class="headerlink" title="3.7 队列ADT"></a>3.7 队列ADT</h2><h3 id="3-7-1-队列模型"><a href="#3-7-1-队列模型" class="headerlink" title="3.7.1 队列模型"></a>3.7.1 队列模型</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%203.png" alt="Untitled"></p><h1 id="第-4-章-树"><a href="#第-4-章-树" class="headerlink" title="第 4 章 树"></a>第 4 章 树</h1><h2 id="4-1-预备知识"><a href="#4-1-预备知识" class="headerlink" title="4.1 预备知识"></a>4.1 预备知识</h2><h2 id="4-2-二叉树"><a href="#4-2-二叉树" class="headerlink" title="4.2 二叉树"></a>4.2 二叉树</h2><h2 id="4-3-查找树ADT-——-二叉查找树"><a href="#4-3-查找树ADT-——-二叉查找树" class="headerlink" title="4.3 查找树ADT ——  二叉查找树"></a>4.3 查找树ADT ——  二叉查找树</h2><h2 id="4-4-AVL树"><a href="#4-4-AVL树" class="headerlink" title="4.4 AVL树"></a>4.4 AVL树</h2><p>AVL树是带有平衡条件的二叉查找树</p><p>特点：</p><ul><li>本身首先是一棵二叉搜索树。</li><li>每个节点的左右子树的高度之差的绝对值（平衡因子）最多为1</li></ul><h3 id="4-4-1-单旋转"><a href="#4-4-1-单旋转" class="headerlink" title="4.4.1 单旋转"></a>4.4.1 单旋转</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%204.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%205.png" alt="Untitled"></p><h3 id="4-4-2-双旋转"><a href="#4-4-2-双旋转" class="headerlink" title="4.4.2 双旋转"></a>4.4.2 双旋转</h3><h2 id="4-5-伸展树"><a href="#4-5-伸展树" class="headerlink" title="4.5 伸展树"></a>4.5 伸展树</h2><p>伸展树保证从空树开始连续M次对树的操作最多花费*O(M log N)*时间</p><p>伸展树基于这样的事实：对于二叉查找树来说，每次操作最坏情形时间*O(N)*并不坏，只要它相对不常发生就行。</p><h2 id="4-6-树的遍历"><a href="#4-6-树的遍历" class="headerlink" title="4.6 树的遍历"></a>4.6 树的遍历</h2><ul><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层序遍历</li></ul><h2 id="4-7-B-树"><a href="#4-7-B-树" class="headerlink" title="4.7 B+树**"></a>4.7 B+树**</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%206.png" alt="Untitled"></p><p>阶为M的B+树的特性：</p><ul><li>数据项存储在树叶上</li><li>非叶子节点存储直到M-1个关键字以指示搜索的方向；关键字i代表子树i+1中的最小的关键字</li><li>树的根或者是一片树叶，或者其儿子数在2和M之间</li><li>除根外，所有非树叶节点的儿子数在<code>⌈M/2⌉</code>和<code>M</code>之间</li><li>所有的树叶都在相同的深度上并有<code>⌈L/2⌉</code>和<code>L</code> 之间个数据项</li></ul><p>B树与B+树不同点：</p><ul><li>单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。</li><li>所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。</li><li>所有的叶子节点形成了一个有序链表，更加便于查找。</li></ul><h1 id="第-5-章-散列"><a href="#第-5-章-散列" class="headerlink" title="第 5 章 散列"></a>第 5 章 散列</h1><h2 id="5-1-一般想法"><a href="#5-1-一般想法" class="headerlink" title="5.1 一般想法"></a>5.1 一般想法</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%207.png" alt="Untitled"></p><h2 id="5-2-散列函数"><a href="#5-2-散列函数" class="headerlink" title="5.2 散列函数"></a>5.2 散列函数</h2><p>如果关键字是整数一般合理的方法就是直接返回<em>key mod Tablesize</em></p><p>如果关键字是字符串，</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%208.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%209.png" alt="Untitled"></p><h2 id="5-3-分离链接法"><a href="#5-3-分离链接法" class="headerlink" title="5.3 分离链接法"></a>5.3 分离链接法</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2010.png" alt="Untitled"></p><p>分离链接法：其做法是将散列到同一个值的所有元素保留到一个表中</p><h2 id="5-4-不同链表的散列表"><a href="#5-4-不同链表的散列表" class="headerlink" title="5.4 不同链表的散列表"></a>5.4 不同链表的散列表</h2><h3 id="5-4-1-线性探测法"><a href="#5-4-1-线性探测法" class="headerlink" title="5.4.1 线性探测法"></a>5.4.1 线性探测法</h3><p>在线性探测法中，函数f是i的线性函数，典型情形是$f(i) = i$</p><h3 id="5-4-2-平方探测法"><a href="#5-4-2-平方探测法" class="headerlink" title="5.4.2 平方探测法"></a>5.4.2 平方探测法</h3><p>平方探测是消除线性探测中一次聚集问题的冲突解决方法。</p><p>平方探测就是冲突函数为二次的探测方法，流行的选择是$f(i)=i^2$</p><p>定理：如果使用平方探测，且表的大小是素数，那么当表至少有一半是空的时候总能够插入一个新元素</p><h3 id="5-4-3-双散列"><a href="#5-4-3-双散列" class="headerlink" title="5.4.3 双散列"></a>5.4.3 双散列</h3><p>对于双散列，一种流行的选择是$f(i)=i*hash_2(x)$</p><h2 id="5-5-再散列"><a href="#5-5-再散列" class="headerlink" title="5.5 再散列"></a>5.5 再散列</h2><p>建立另外一个大约两倍大的表（而且使用一个相关的新散列函数），扫描整个原始散列表，计算每个（未删除的）元素的新散列值并将其插入到新表中</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2011.png" alt="Untitled"></p><h2 id="5-6-标准库中的散列表"><a href="#5-6-标准库中的散列表" class="headerlink" title="5.6 标准库中的散列表"></a>5.6 标准库中的散列表</h2><h2 id="5-7-最坏情形下O-1-访问的散列表"><a href="#5-7-最坏情形下O-1-访问的散列表" class="headerlink" title="5.7 最坏情形下O(1)访问的散列表"></a>5.7 最坏情形下O(1)访问的散列表</h2><h3 id="5-7-1-完美散列"><a href="#5-7-1-完美散列" class="headerlink" title="5.7.1 完美散列"></a>5.7.1 完美散列</h3><h3 id="5-7-2-布谷鸟散列"><a href="#5-7-2-布谷鸟散列" class="headerlink" title="5.7.2 布谷鸟散列"></a>5.7.2 布谷鸟散列</h3><p>在布谷鸟散列中，假设有N个项。我们维护两个分别超过半空的表，且有两个独立的散列函数，可以把每个项分配到每个表中的一个位置。布谷鸟散列保持不变的是一个项总会被存储在这两个位置之一。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2012.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2013.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2014.png" alt="Untitled"></p><h3 id="5-7-3-跳房子散列"><a href="#5-7-3-跳房子散列" class="headerlink" title="5.7.3 跳房子散列"></a>5.7.3 跳房子散列</h3><p>跳房子散列的思路是用事先确定的、对计算机的底层体系结构而言是最优的一个常数，给探测序列的最大长度加个上界。这样做可以给出常数集的最坏查询时间，并且与布谷鸟散列一样，查询可以并行化，以同时检查可用位置的有限集。</p><h2 id="5-8-通用散列法"><a href="#5-8-通用散列法" class="headerlink" title="5.8 通用散列法"></a>5.8 通用散列法</h2><h1 id="第-6-章-优先队列（堆）"><a href="#第-6-章-优先队列（堆）" class="headerlink" title="第 6 章 优先队列（堆）"></a>第 6 章 优先队列（堆）</h1><h2 id="6-1-模型"><a href="#6-1-模型" class="headerlink" title="6.1 模型"></a>6.1 模型</h2><p>优先队列是允许至少下列两种操作的数据结构：插入和删除最小者。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2015.png" alt="Untitled"></p><h2 id="6-2-一些简单的实现"><a href="#6-2-一些简单的实现" class="headerlink" title="6.2 一些简单的实现"></a>6.2 一些简单的实现</h2><ol><li>使用简单链表</li><li>使用二叉查找树</li></ol><h2 id="6-3-二叉堆"><a href="#6-3-二叉堆" class="headerlink" title="6.3 二叉堆"></a>6.3 二叉堆</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2016.png" alt="Untitled"></p><h3 id="6-3-1-结构性质"><a href="#6-3-1-结构性质" class="headerlink" title="6.3.1 结构性质"></a>6.3.1 结构性质</h3><p>堆是一个完全二叉树</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2017.png" alt="Untitled"></p><ol><li>插入</li></ol><p>为将一个元素X插入到堆中，我们在一个可用位置创建一个空穴，否则该堆将不是完全熟，如果可以放在该空穴中而不破坏堆的序，那么插入完成。否则我们把空穴的父节点上的元素移入该空穴中，这样空穴就朝着根的方向上冒一步。继续该过程直到X能被放入空穴中为止。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2018.png" alt="Untitled"></p><ol><li>删除最小元</li></ol><p>删除最小元以类似于插入的方式处理。当删除一个最小元时，要在跟节点建立一个空穴。由于现在堆少了一个元素，因此堆中最后一个元素X必须移动到该堆的某个地方。如果X可以被放倒空穴中，那么deleteMin完成，否则我们将空穴的两个儿子中较小者移入空穴，这样就把空穴向下推了一层，重复该步骤直到X可以被放入空穴中。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2019.png" alt="Untitled"></p><h2 id="6-4-优先队列的应用"><a href="#6-4-优先队列的应用" class="headerlink" title="6.4 优先队列的应用"></a>6.4 优先队列的应用</h2><h2 id="6-5-d-堆"><a href="#6-5-d-堆" class="headerlink" title="6.5 d-堆"></a>6.5 d-堆</h2><p>d-堆是二叉堆的简单推广，就像一个二叉堆，只是所有的节点都有d个儿子（因此，二叉堆是2-堆）</p><h2 id="6-6-左式堆"><a href="#6-6-左式堆" class="headerlink" title="6.6 左式堆"></a>6.6 左式堆</h2><p>左式堆像二叉堆那样也具有结构性和有序性。左式堆具有相同的堆序性质，左式堆也是二叉树，左式堆和叉二树唯一的区别是：左式堆不是理想平衡的，而实际上趋向于非常不平衡。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2020.png" alt="Untitled"></p><h2 id="6-7-斜堆"><a href="#6-7-斜堆" class="headerlink" title="6.7 斜堆"></a>6.7 斜堆</h2><p>斜堆是左式堆的自调节形式，实现起来极其简单。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2021.png" alt="Untitled"></p><h2 id="6-8-二项队列"><a href="#6-8-二项队列" class="headerlink" title="6.8 二项队列"></a>6.8 二项队列</h2><h3 id="6-8-1-二项队列结构"><a href="#6-8-1-二项队列结构" class="headerlink" title="6.8.1 二项队列结构"></a>6.8.1 二项队列结构</h3><p>一个二项队列不是一颗堆序的树，而是堆序的树的集合，称为森林。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2022.png" alt="Untitled"></p><h1 id="第-7-章-排序"><a href="#第-7-章-排序" class="headerlink" title="第 7 章 排序"></a>第 7 章 排序</h1><h2 id="7-2-插入排序"><a href="#7-2-插入排序" class="headerlink" title="7.2 插入排序"></a>7.2 插入排序</h2><p>插入排序由N-1趟排序组成。对于p=1到N-1趟，插入排序保证从位置0到位置p上的元素为已排序状态。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2023.png" alt="Untitled"></p><p>时间复杂度：$O(N^2)$</p><p>定理：通过交换相邻元素进行排序的任何算法平均都需要$Ω(N^2)$时间</p><h2 id="7-4-希尔排序"><a href="#7-4-希尔排序" class="headerlink" title="7.4 希尔排序"></a>7.4 希尔排序</h2><p>定理：使用希尔排序最坏情形运行时间为$O(N^2)$</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2024.png" alt="Untitled"></p><h2 id="7-5-堆排序"><a href="#7-5-堆排序" class="headerlink" title="7.5 堆排序"></a>7.5 堆排序</h2><p>优先队列可以用以$O(NlogN)$时间的排序。基于该思想的算法叫做堆排序。</p><h2 id="7-6-归并排序"><a href="#7-6-归并排序" class="headerlink" title="7.6 归并排序"></a>7.6 归并排序</h2><p>归并排序以O(NlogN)最坏情形时间运行。它是递归算法一个好的实例。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2025.png" alt="Untitled"></p><h2 id="7-7-快速排序"><a href="#7-7-快速排序" class="headerlink" title="7.7 快速排序"></a>7.7 快速排序</h2><p>快速排序是事件中一种快速的排序算法，在C++或对Java基本类型的排序汇总特别有用。平均运行时间是$O(NlogN)$。</p><h1 id="第-9-章-图论"><a href="#第-9-章-图论" class="headerlink" title="第 9 章 图论"></a>第 9 章 图论</h1><h2 id="9-1-定义"><a href="#9-1-定义" class="headerlink" title="9.1 定义"></a>9.1 定义</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2026.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2027.png" alt="Untitled"></p><h2 id="9-2-拓扑排序"><a href="#9-2-拓扑排序" class="headerlink" title="9.2 拓扑排序"></a>9.2 拓扑排序</h2><h2 id="9-3-最短路径算法"><a href="#9-3-最短路径算法" class="headerlink" title="9.3 最短路径算法"></a>9.3 最短路径算法</h2><h3 id="9-3-1-无权最短路径"><a href="#9-3-1-无权最短路径" class="headerlink" title="9.3.1 无权最短路径"></a>9.3.1 无权最短路径</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2028.png" alt="Untitled"></p><h2 id="未完"><a href="#未完" class="headerlink" title="未完"></a>未完</h2><h1 id="第-9-章-算法设计技巧"><a href="#第-9-章-算法设计技巧" class="headerlink" title="第 9 章 算法设计技巧"></a>第 9 章 算法设计技巧</h1><h2 id="10-1-贪婪算法"><a href="#10-1-贪婪算法" class="headerlink" title="10.1 贪婪算法"></a>10.1 贪婪算法</h2><p>贪婪算法分阶段地工作，在每一个阶段可以认为所做决定是好的。而不考虑将来的后果。</p><h2 id="10-2-分治算法"><a href="#10-2-分治算法" class="headerlink" title="10.2 分治算法"></a>10.2 分治算法</h2><p>分治算法由两部分组成：</p><ul><li>分：递归解决较小的问题</li><li>治：然后从子问题的解构建原问题的解</li></ul><h2 id="10-3-动态规划"><a href="#10-3-动态规划" class="headerlink" title="10.3 动态规划"></a>10.3 动态规划</h2><p>将递归算法重新写成非递归算法，让后者把那些子问题的答案系统第记录在一个表内，利用这种方法的一种技巧叫做动态规划</p><h2 id="10-4-随机数算法"><a href="#10-4-随机数算法" class="headerlink" title="10.4 随机数算法"></a>10.4 随机数算法</h2><h2 id="10-5-回溯算法"><a href="#10-5-回溯算法" class="headerlink" title="10.5 回溯算法"></a>10.5 回溯算法</h2><h1 id="第-12-章-高级数据结构及其实现"><a href="#第-12-章-高级数据结构及其实现" class="headerlink" title="第 12 章 高级数据结构及其实现"></a>第 12 章 高级数据结构及其实现</h1><h2 id="12-2-红黑树"><a href="#12-2-红黑树" class="headerlink" title="12.2 红黑树"></a>12.2 红黑树</h2><p>对红黑树的操作在最坏情形下花费O(logN)时间</p><p>红黑树是具有下列着色性质的二叉查找树：</p><ul><li>每一个节点或者着成红色，或者着成黑色</li><li>根是黑色的</li><li>如果一个节点是红色，那么它的子节点必须是黑色的</li><li>从一个节点到一个null引用的每一条路径必须包含相同数目的黑色节点</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构与算法分析&quot;&gt;&lt;a href=&quot;#数据结构与算法分析&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法分析&quot;&gt;&lt;/a&gt;数据结构与算法分析&lt;/h1&gt;&lt;h1 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="https://zhangzhishun.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>IPFS原理深入分析</title>
    <link href="https://zhangzhishun.github.io/2022/01/18/distributed_storage/IPFS%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <id>https://zhangzhishun.github.io/2022/01/18/distributed_storage/IPFS%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</id>
    <published>2022-01-18T02:29:15.000Z</published>
    <updated>2022-04-28T06:15:52.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="〇、目标"><a href="#〇、目标" class="headerlink" title="〇、目标"></a>〇、目标</h1><ol><li>熟悉IPFS概念</li><li>熟悉IPFS上传文件、下载文件过程</li></ol><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="2-BACKGROUND"><a href="#2-BACKGROUND" class="headerlink" title="2. BACKGROUND"></a>2. BACKGROUND</h2><h3 id="Distributed-Hash-Tables-DHTs"><a href="#Distributed-Hash-Tables-DHTs" class="headerlink" title="Distributed Hash Tables(DHTs)"></a>Distributed Hash Tables(DHTs)</h3><ol><li><p>Kademlia DHT</p><p> 优点</p><ul><li>【通信性能】通过大规模网络高效查找:查询平均需要通信$log_2(n)$向上取整节点。(例如，一个由10,000,000个节点组成的网络需要20个跳数)</li><li>【通信性能】低协调开销:优化了发送给其他节点的控制消息的数量</li><li>【安全】通过选择长期存在的节点来抵抗各种攻击</li><li>【应用】在对等应用程序中广泛使用，包括Gnutella和BitTorrent，形成了超过2000万个节点的网络。</li></ul></li><li><p>Coral DSHT</p><p> 优点</p><ul><li>【通信性能】Kademlia将值存储在id与键最接近(使用XOR-distance)的节点中。这并不考虑应用程序数据的局域性，忽略可能已经拥有数据的远节点，并不管最近节点是否需要这份数据而去强制它们存储数据。这浪费了大量的存储和带宽。相反，Coral在能够提供数据块的对等节点存储地址信息</li><li>【通信性能】Coral将DHT API从get_value(key)放宽为get_any_values(key) (DSHT中的“sloppy”)。这仍然工作直到Coral用户只需要一个(工作)peer，而不是完整的列表。作为交换，Coral只能将值的子集分发到最近的节点，从而避免了热点(当一个键变得流行时，会重载所有最近的节点)</li><li>【通信性能】Coral根据区域和大小组织了一个称为簇的独立DSHT层次结构。这使得节点可以首先查询其区域内的对等节点，在不查询远处节点的情况下查找附近的数据，大大减少了查找的延迟</li></ul></li><li><p>S/Kademlia DHT</p><p>S/Kademlia扩展了Kademlia以两种特别重要的方式来抵御恶意攻击:</p><ul><li>【安全】S/Kademlia提供了安全的NodeId生成方案，并防止女巫攻击。它要求节点创建一个PKI密钥对，从密钥对中获得自己的身份，并对彼此的消息进行签名。一种方案包括一个工作证明加密谜题，以使生成女巫攻击的成本很高</li><li>【安全】S/Kademlia节点在不相交的路径上查找值，以确保在网络中存在大量对手的情况下，诚实的节点可以相互连接。即使对抗分数高达一半的节点S/Kademlia实现了0.85的成功率，</li></ul></li></ol><h3 id="Block-Exchanges-BitTorrentc"><a href="#Block-Exchanges-BitTorrentc" class="headerlink" title="Block Exchanges - BitTorrentc"></a>Block Exchanges - BitTorrentc</h3><p>BitTorrent（简称BT）是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。</p><p>BitTorrent是一个广泛成功的点对点文件处理系统，它成功地协调了互不信任的点(群)网络，在相互分发文件的过程中进行合作。BitTorrent及其生态系统中IPFS设计的关键特性包括:</p><ol><li>BitTorrent的数据交换协议使用了一种类似于tit-for-tat的策略，奖励那些相互贡献的节点，惩罚那些只窃取别人资源的节点</li><li>BitTorrent同行跟踪文件片段的可用性，优先发送最罕见的片段。这减轻了种子的负担，使非种子同伴能够相互交易</li><li>BitTorrent标准的tit-for-tat易受某些利用带宽共享策略的攻击。PropShare是一种不同的对等带宽分配策略，它能更好地抵抗利用策略，并提高群的性能</li></ol><h3 id="Version-Control-Systems-Git"><a href="#Version-Control-Systems-Git" class="headerlink" title="Version Control Systems - Git"></a>Version Control Systems - Git</h3><p>版本控制系统提供了对随时间变化的文件建模的工具，并有效地分发不同的版本。流行的版本控制系统Git提供了一个功能强大的Merkle dag对象模型，它以分布式友好的方式捕获对文件系统树的更改。</p><ol><li>不可变对象代表Files (blob)、Directories (tree)和Changes (commit)</li><li>对象是内容寻址的，通过其内容的加密散列</li><li>与其他物体的链接被嵌入，形成一个默克尔DAG。这提供了许多有用的完整性和工作流属性</li><li>大多数版本化元数据(分支、标签等)都是简单的指针引用，因此创建和更新的成本很低</li><li>版本更改仅更新引用或添加对象</li><li>将版本更改分发给其他用户只是简单地传输对象和更新远程引用</li></ol><h3 id="Self-Certified-Filesystems-SFS"><a href="#Self-Certified-Filesystems-SFS" class="headerlink" title="Self-Certified Filesystems - SFS"></a>Self-Certified Filesystems - SFS</h3><p>SFS[12,11]提出了两种引人注目的实现：</p><ul><li>分布式信任链</li><li>平等共享的全局命名空间</li></ul><p>SFS引入了一种用于构建自认证文件系统的技术:</p><p>使用以下scheme：</p><p><code>/sfs/&lt;Location&gt;:&lt;HostID&gt;</code></p><p>其中Location是服务器的网络地址，并且:HostID = hash(public_key || Location)</p><p>因此SFS文件系统的名称证明了它的服务器。用户可以验证服务器提供的公钥，协商共享密钥，并确保所有流量的安全。所有SFS实例共享一个全局命名空间，其中的名称分配是加密的，不受任何集中主体的限制。</p><h2 id="3-IPFS-DESIGN"><a href="#3-IPFS-DESIGN" class="headerlink" title="3. IPFS DESIGN"></a>3. IPFS DESIGN</h2><p>IPFS协议被划分为负责不同功能的子协议堆栈</p><h3 id="3-1-身份——管理节点身份的生成和更新"><a href="#3-1-身份——管理节点身份的生成和更新" class="headerlink" title="3.1 身份——管理节点身份的生成和更新"></a>3.1 身份——管理节点身份的生成和更新</h3><p>节点由一个NodeId标识，这是一个公钥的加密哈希，是用S/Kademlia的静态加密谜题创建的。节点存储它们的公钥和私钥(使用密码短语加密)。用户可以在每次启动时自由实例化一个新的节点标识，尽管这样会损失已积累的网络利益。节点被激励保持不变</p><h3 id="3-2-网络——管理与其他对等体的连接，使用各种底层网络协议。可配置的"><a href="#3-2-网络——管理与其他对等体的连接，使用各种底层网络协议。可配置的" class="headerlink" title="3.2 网络——管理与其他对等体的连接，使用各种底层网络协议。可配置的"></a>3.2 网络——管理与其他对等体的连接，使用各种底层网络协议。可配置的</h3><p>IPFS网络栈特性:</p><ul><li>传输:IPFS可以使用任何传输协议，最适合于WebRTC数据通道(用于浏览器连接)或uTP(LEDBAT)</li><li>可靠性:如果底层网络不提供，IPFS可以使用uTP (LEDBAT[14])或SCTP[15]提供可靠性</li><li>连通性:IPFS也使用ICE NAT穿越技术</li><li>完整性:可选地使用哈希校验和检查消息的完整性</li><li>真实性:可选地检查mes- sage的真实性，通过使用发送方的特权密钥进行数字签名。</li></ul><h3 id="3-3-路由——维护定位特定对等体和对象的信息。响应本地和远程查询。默认为DHT，但可切换"><a href="#3-3-路由——维护定位特定对等体和对象的信息。响应本地和远程查询。默认为DHT，但可切换" class="headerlink" title="3.3 路由——维护定位特定对等体和对象的信息。响应本地和远程查询。默认为DHT，但可切换"></a>3.3 路由——维护定位特定对等体和对象的信息。响应本地和远程查询。默认为DHT，但可切换</h3><p>IPFS节点需要一个路由系统，它可以找到其他节点的网络地址，以及可以为特定对象服务的节点。IPFS使用S/Kademlia和Coral DSHT实现这一点。IPFS的对象大小和使用模式类似于Coral和Mainline，因此IPFS DHT根据其大小对存储的值进行区分。小值(等于或小于1KB)直接存储在DHT上。对于较大的值，DHT存储引用，这些引用是可以为块提供服务的节点的nodeid</p><h3 id="3-4-块交换——一个新的块交换协议-BitSwap-，它管理有效的块分配。以市场为模型，对数据复制的激励很弱。可切换的贸易策略"><a href="#3-4-块交换——一个新的块交换协议-BitSwap-，它管理有效的块分配。以市场为模型，对数据复制的激励很弱。可切换的贸易策略" class="headerlink" title="3.4 块交换——一个新的块交换协议(BitSwap)，它管理有效的块分配。以市场为模型，对数据复制的激励很弱。可切换的贸易策略"></a>3.4 块交换——一个新的块交换协议(BitSwap)，它管理有效的块分配。以市场为模型，对数据复制的激励很弱。可切换的贸易策略</h3><p>在IPFS中，数据分发是通过使用BitTorrent启发的协议BitSwap与对等点交换块来实现的。像BitTorrent一样，BitSwap对等体正在寻找一组块(want_list)，并有另一组块交换(have_list)。与BitTorrent不同，BitSwap并不局限于一个torrent中的区块。BitSwap操作是一个持久的市场，节点可以获取他们需要的块，而不管这些块是什么文件的一部分。这些块可以来自文件系统中完全不相关的文件。节点聚集在一起进行交易。</p><h3 id="3-5-对象——一个Merkle-DAG，由具有链接的内容定位的不可变对象组成。用于表示任意的数据结构，例如文件层次结构和通信系统"><a href="#3-5-对象——一个Merkle-DAG，由具有链接的内容定位的不可变对象组成。用于表示任意的数据结构，例如文件层次结构和通信系统" class="headerlink" title="3.5 对象——一个Merkle DAG，由具有链接的内容定位的不可变对象组成。用于表示任意的数据结构，例如文件层次结构和通信系统"></a>3.5 对象——一个Merkle DAG，由具有链接的内容定位的不可变对象组成。用于表示任意的数据结构，例如文件层次结构和通信系统</h3><p>DHT和BitSwap允许IPFS形成一个大规模的点对点系统，用于快速、可靠地存储和分发块。在这些之上，IPFS构建了一个Merkle DAG，一个有向无环图，其中对象之间的链接是嵌入源中的目标的加密散列。这是Git数据结构的一般化。</p><p>默克尔DAG为IPFS提供了许多有用的属性：</p><ol><li>内容寻址:所有内容由其多哈希校验和唯一标识，包括链接</li><li>抗篡改:所有内容都通过校验和进行验证。如果数据被篡改或损坏，IPFS会检测到它</li><li>重复数据删除:所有包含相同内容的对象都是相同的，且只存储一次。对于索引对象，如git树和提交，或数据的公共部分，这尤其有用。</li></ol><h3 id="3-6-文件——受Git启发的文件版本的文件系统层次结构"><a href="#3-6-文件——受Git启发的文件版本的文件系统层次结构" class="headerlink" title="3.6 文件——受Git启发的文件版本的文件系统层次结构"></a>3.6 文件——受Git启发的文件版本的文件系统层次结构</h3><p>IPFS还定义了一组对象，用于在Merkle DAG之上对版本化的文件系统建模。该对象模型类似于Git s:</p><ol><li>块:一个可变大小的数据块</li><li>列表:块或其他列表的集合</li><li>树:块、列表或其他树的集合</li><li>提交:树版本历史中的快照。</li></ol><h3 id="3-7-命名——一个自认证的可变名称系统"><a href="#3-7-命名——一个自认证的可变名称系统" class="headerlink" title="3.7 命名——一个自认证的可变名称系统"></a>3.7 命名——一个自认证的可变名称系统</h3><p>到目前为止，IPFS堆栈形成了一个点对点块交换，构造了一个对象的内容寻址DAG。它用于发布和检索不可变对象。它甚至可以跟踪这些对象的版本历史。但是，缺少一个关键组件:可变命名。没有它，所有新内容的通信都必须在带外进行，发送IPFS链接。需要的是在同一路径上检索可变状态的某种方法。值得说明的是，如果可变数据是必要的，我们最终努力建立一个不可变的默克尔DAG。考虑一下来自Merkle DAG的IPFS属性:对象可以(a)通过其散列检索，(b)完整性检查，(c)链接到其他对象，以及(d)无限期缓存。在某种意义上:对象是永久的。这些是高性能分布式系统的关键属性，在分布式系统中，数据跨网络链路移动的代价很高。对象内容寻址构建了一个具有(a)显著带宽优化、(b)不可信内容服务、(c)永久链接和(d)对任何对象及其引用进行完全永久备份的能力的web。Merkle DAG(不可变的内容寻址对象)和命名(指向Merkle DAG的可变指针)瞬时出现在许多成功的分布式系统中。这包括Git版本控制系统，它有不可变对象和可变引用;和Plan， UNIX的分布式继承者，及其可变的Fossil和不可变的Venti文件系统。LBFS也使用可变索引和不可变块。</p><h2 id="4-IPFS共识"><a href="#4-IPFS共识" class="headerlink" title="4. IPFS共识"></a>4. IPFS共识</h2><p>IPFS创新的采用了一种混合共识机制——复制证明（PoRep）+时空证明（PoSt）+ 预期共识(EC)</p><ol><li>复制证明：共识机制中的核心因素，尽管IPFS的网络协议、共识、其他算法都基本定型，但是复制证明仍然处于不断完善的方案中。</li><li>时空证明:（PoSt)提出了证明链（proof-chain）的数据结构，证明链把一些的挑战（challenge）和证明（proof）链接起来形成。在证明链的基础上添加上时间段，这样就得到了一段时间内的矿工存储数据的证明，这就是时空证明（Proof of Spacetime，PoSt）。PoSt可以证明在该段时间内矿工存储了特定的数据，并且利用时间戳锚定这些证明链，这样即使验证者（verifier）不在线，也可以在未来的某个时间内利用时空证明去验证该矿工生成了证明链，PoSt会被提交到链上用来产生新的Block。</li><li>预期共识:（Expected Consensus，EC）是在每一轮里面选举出来一名或者多名矿工来创建新的区块，矿工赢得选举的可能性跟矿工当前的有效存储（算力）成正比。IPFS把矿工在网络中的当前存储数据相对于整个网络的存储比例转化为矿工投票权（voting power of the miner）。无论在该周期里，选举出来的是一名还是多名矿工，被选举出来的矿工都需要创建新的区块，并把新的区块对网络进行广播。 尽管链中的区块是线性的，但是IPFS的区块数据结构采用的DAG（有向无环图），可以在同一时间产生多个区块（所以Filecoin的交易要比BTC的有效的多，这也是为什么把Filecoin叫做“可能的blockchain 3.0”的原因） </li></ol><p>Filecoin首创的混合共识机制，从根本上定义了Filecoin是一个合理高效、去中心化的系统，并体现出Filecoin的公平性、保密性和公开可验证性</p><h1 id="二、上传文件"><a href="#二、上传文件" class="headerlink" title="二、上传文件"></a>二、上传文件</h1><p><img src="/images/ipfs/upload_file.png" alt="img.png"></p><h2 id="1-生成默克尔DAG的结构"><a href="#1-生成默克尔DAG的结构" class="headerlink" title="1. 生成默克尔DAG的结构"></a>1. 生成默克尔DAG的结构</h2><p>生成的结构有两种Layout：balanced和trickle的。这里介绍默认的balanced结构，首先生成root作为根节点，然后将文件分割，默认按照256KB大小读取一个chunk，生成叶子节点，依次生成node1，node2，root节点会有Link指向挂在root节点的叶子节点node1和node2。root节点下面能够Link的叶子节点数量是有限的，IPFS中默认设置的是174个（定义的Link的总的大小是8KB，每个Link的大小是34 + 8 + 5【sha256 multihash + size + no name + protobuf framing】，默认的Link的个数为8192/47约等于174）。</p><p><img src="/images/ipfs/image-1.png" alt="/images/ipfs/image-1.png"></p><p>如下图所示，超过174个后则会新创建一个new root节点，并Link到old root，新的chunk作为node3（这里用node3简约了，实际上是第175个节点）被new root直接Link。</p><p><img src="/images/ipfs/image-4.png" alt="/images/ipfs/image-4.png"></p><p>当继续有新的chunk添加时，则会生成node34作为node3和node4的父节点，node34含有两个Link分别链接到node3和node4。</p><p><img src="/images/ipfs/image-5.png" alt="/images/ipfs/image-5.png"></p><p>IPFS在init的时候会生成.ipfs目录，如下图所示，其中blocks则为文件块存储的目录，datastore为leveldb数据库，其中存储了文件系统的根哈希等，存储相关的配置关联在.ipfs目录下面的config文件。</p><p><img src="/images/ipfs/image-6.png" alt="/images/ipfs/image-6.png"></p><h2 id="2-对块进行存储"><a href="#2-对块进行存储" class="headerlink" title="2. 对块进行存储"></a>2. 对块进行存储</h2><ul><li>如下图所示，一个Block存储时，首先由dagService（实现了DAGService接口）调用Add进行添加；</li><li>之后由blockService（实现了BlockService接口）调用AddBlock添加该Block；</li><li>再调用arccache的Put，arccache是对存储的Block做arc策略的缓存；</li><li>再之后由VerifBS调用Put进行存储，VerifyBS主要对CID的合法性进行校验，合法则进行Put；</li><li>接着blockstore（实现了Blockstore接口）调用Put进行存储，Put函数中会对CID进行转化，调用dshelp的CidToDsKey方法将CID转化成存储的Key；</li><li>再接着调用keytransform.Datastore的Put，Put函数中会将前缀拼上，这时Key加上了前缀/blocks；</li><li>然后调用measure的Put函数，measure是对mount的封装；</li><li>之后调用mount的Put函数，mount和IPFS的config配置文件中结构对应，根据key去查找对应的datastore，由于前缀是/blocks则可以找到对应的measure；</li><li>调用该measure的Put函数；</li><li>最后调用flatfs的Put函数，由Put函数调用doPut最终调用encode函数将完整的block写入的目录指定为/home/test/.ipfs/blocks/WD，其中WD来自于blocks/CIQFSQATUBIEIFDECKTNGHOKPOEE7WUPM5NNNSJCCDROMM6YHEKTWDY中的倒数第三第二个字符。这样该Block则写入了该目录下面的文件中。</li></ul><p><img src="/images/ipfs/image-7.png" alt="/images/ipfs/image-7.png"></p><p><img src="/images/ipfs/image-9.png" alt="/images/ipfs/image-9.png"></p><h1 id="三、下载文件"><a href="#三、下载文件" class="headerlink" title="三、下载文件"></a>三、下载文件</h1><p><img src="/images/ipfs/download_file.png" alt="img.png"></p><ol><li>检查本地的blockstore中是否存在请求的数据，如果存在则直接从本地返回；否则会向对等节点发送block hash列表；</li><li>对等节点通过DHT和路由层算法，找到每个block hash所在的节点，将文件返回来；</li><li>本地节点在接收block文件的同时缓存一份到本地的blockstore中</li><li>更新DHT</li><li>组装block文件，返回至用户端</li></ol><h1 id="附：资料"><a href="#附：资料" class="headerlink" title="附：资料"></a>附：资料</h1><ol><li>IPFS白皮书：<a href="https://github.com/ipfs/papers/raw/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf">https://github.com/ipfs/papers/raw/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf</a></li><li>上传/下载文件过程：<ul><li><a href="https://www.jianshu.com/p/9eb1e5f83e13">https://www.jianshu.com/p/9eb1e5f83e13</a></li><li><a href="https://www.chaindesk.cn/witbook/24/449">https://www.chaindesk.cn/witbook/24/449</a></li></ul></li><li><a href="https://www.jiabaotz.com/finance/79470.html">IPFS/Filecoin的共识机制有哪些特点？</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;〇、目标&quot;&gt;&lt;a href=&quot;#〇、目标&quot; class=&quot;headerlink&quot; title=&quot;〇、目标&quot;&gt;&lt;/a&gt;〇、目标&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;熟悉IPFS概念&lt;/li&gt;
&lt;li&gt;熟悉IPFS上传文件、下载文件过程&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;一</summary>
      
    
    
    
    
    <category term="Distributed Storage" scheme="https://zhangzhishun.github.io/tags/Distributed-Storage/"/>
    
  </entry>
  
  <entry>
    <title>Go语言核心编程</title>
    <link href="https://zhangzhishun.github.io/2022/01/17/go/Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <id>https://zhangzhishun.github.io/2022/01/17/go/Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-17T02:29:15.000Z</published>
    <updated>2022-04-27T02:35:55.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-Core-Programming"><a href="#Go-Core-Programming" class="headerlink" title="Go Core Programming"></a>Go Core Programming</h1><h1 id="第-1-章-基础知识"><a href="#第-1-章-基础知识" class="headerlink" title="第 1 章 基础知识"></a>第 1 章 基础知识</h1><h2 id="1-1-语言简介"><a href="#1-1-语言简介" class="headerlink" title="1.1 语言简介"></a>1.1 语言简介</h2><h3 id="1-1-1-Go语言的诞生背景"><a href="#1-1-1-Go语言的诞生背景" class="headerlink" title="1.1.1 Go语言的诞生背景"></a>1.1.1 Go语言的诞生背景</h3><ul><li><strong>当前编程语言对并发的支持不是很好</strong>，不能很好地发挥多核CPU的威力</li><li>程序规模越来越大，<strong>编译速度越来越慢</strong></li><li>现有的<strong>编程语言设计越来越复杂</strong>，某些特性的实现不怎么优雅</li></ul><h3 id="1-1-3-Go语言的特性"><a href="#1-1-3-Go语言的特性" class="headerlink" title="1.1.3 Go语言的特性"></a>1.1.3 Go语言的特性</h3><p><img src="/images/go_core_programming/Untitled.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%201.png" alt="Untitled"></p><h2 id="1-3-Go词法单元"><a href="#1-3-Go词法单元" class="headerlink" title="1.3 Go词法单元"></a>1.3 Go词法单元</h2><h3 id="1-3-1-token"><a href="#1-3-1-token" class="headerlink" title="1.3.1 token"></a>1.3.1 token</h3><p>token是构成源程序的基本不可再分割的单元。</p><p>编译器编译源程序的第一步就是将源程序分割成一个个独立的token，这个过程就是词法分析。</p><p>Go语言的token可以分为关键字、标识符、操作符、分隔符和字面常量</p><p><img src="/images/go_core_programming/Untitled%202.png" alt="Untitled"></p><h3 id="1-3-2-标识符"><a href="#1-3-2-标识符" class="headerlink" title="1.3.2 标识符"></a>1.3.2 标识符</h3><ol><li>标识符用来标识变量、类型、常量等语法对象的符号名称，其在语法分析时作为一个token存在。</li><li>标识符分为两类：<ul><li>语言设计者预留的标识符：语言设计者确定，包括语言的预声明标识符及保留字</li><li>编程者可以自定义的标识符：用户定义的变量名、常量名、函数名等</li></ul></li><li>标识符规则：开头一个字符必须是字母或下划线，区分大小写</li><li><strong>关键字（keywords，25个）</strong></li></ol><p><img src="/images/go_core_programming/Untitled%203.png" alt="Untitled"></p><ol><li><strong>内置数据类型标识符（20个）</strong></li></ol><p><img src="/images/go_core_programming/Untitled%204.png" alt="Untitled"></p><ol><li><strong>内置函数（15个）</strong></li></ol><p><img src="/images/go_core_programming/Untitled%205.png" alt="Untitled"></p><ol><li><strong>常量值标识符（4个）</strong></li></ol><p><img src="/images/go_core_programming/Untitled%206.png" alt="Untitled"></p><p>空白标识符： <code>_</code></p><h3 id="1-3-3-操作符（operators）和分隔符（delimiters）"><a href="#1-3-3-操作符（operators）和分隔符（delimiters）" class="headerlink" title="1.3.3 操作符（operators）和分隔符（delimiters）"></a>1.3.3 操作符（operators）和分隔符（delimiters）</h3><p>操作符包括运算符、现式的分隔符、其他语法辅助符号</p><h3 id="1-3-4-字面常量"><a href="#1-3-4-字面常量" class="headerlink" title="1.3.4 字面常量"></a>1.3.4 字面常量</h3><ol><li>Go的字面量出现在两个地方：<ul><li>用于常量和变量的初始化</li><li>用在表达式里或函数调用实参</li></ul></li><li>字面量分类：<ul><li>整型字面量</li><li>浮点型字面量</li><li>复数类型字面量</li><li>字符型字面量</li><li>字符串字面量</li></ul></li></ol><h2 id="1-4-变量和常量"><a href="#1-4-变量和常量" class="headerlink" title="1.4 变量和常量"></a>1.4 变量和常量</h2><h3 id="1-4-1-变量"><a href="#1-4-1-变量" class="headerlink" title="1.4.1 变量"></a>1.4.1 变量</h3><h3 id="1-4-2-常量"><a href="#1-4-2-常量" class="headerlink" title="1.4.2 常量"></a>1.4.2 常量</h3><h2 id="1-5-基本数据类型"><a href="#1-5-基本数据类型" class="headerlink" title="1.5 基本数据类型"></a>1.5 基本数据类型</h2><p>Go内置七类基本数据类型：</p><p><img src="/images/go_core_programming/Untitled%207.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%208.png" alt="Untitled"></p><h2 id="1-5-4-复数类型"><a href="#1-5-4-复数类型" class="headerlink" title="1.5.4 复数类型"></a>1.5.4 复数类型</h2><p>Go语言内置的复数类型有两种，分别是complex64和complex128。复数的字面量表示和数学表示法一样。</p><p><img src="/images/go_core_programming/Untitled%209.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2010.png" alt="Untitled"></p><h3 id="1-5-6-rune类型"><a href="#1-5-6-rune类型" class="headerlink" title="1.5.6 rune类型"></a>1.5.6 rune类型</h3><p>Go内置两种字符类型：</p><ul><li>bute的字节类类型（byte是uint的别名）</li><li>表示Uniocode编码的字符rune（rune是int32类型的别名）</li></ul><h2 id="1-6-复合数据类型"><a href="#1-6-复合数据类型" class="headerlink" title="1.6 复合数据类型"></a>1.6 复合数据类型</h2><ol><li>复合数据类型就是由其他类型组合而成的类型。</li><li>Go基本的复合数据类型有：<ul><li><p>指针</p></li><li><p>数据</p></li><li><p>切片</p></li><li><p>字典（map）</p></li><li><p>通道</p></li><li><p>结构</p></li><li><p>接口</p><p><img src="/images/go_core_programming/Untitled%2011.png" alt="Untitled"></p></li></ul></li></ol><h3 id="1-6-1-指针"><a href="#1-6-1-指针" class="headerlink" title="1.6.1 指针"></a>1.6.1 指针</h3><ol><li>Go支持指针，声明类型为 <code>*T</code> ，Go支持多级指针 <code>**T</code> 。通过在变量名前加 <code>&amp;</code> 获取变量的地址。</li><li>指针的特点：<ul><li>在赋值语句中，<code>*T</code> 出现在 <code>=</code> 左边表示指针声明，<code>*T</code> 出现在 <code>=</code> 右边表示取指针指向的值（varName为变量名）。示例：<pre><code class="go">var a = 11p := &amp;a // *p和a的值都是11</code></pre></li><li>结构体指针访问结构体字段仍然使用 <code>.</code> 点操作符，Go语言没有 <code>-&gt;</code> 操作符，例如：<pre><code class="go">type User struct {    name string    age int}andes := User {    name: "andes",    age: 10,}p := &amp;andesfmt.Println(p.name) // p.name通过"."操作符访问成员变量</code></pre></li><li>Go不支持指针的运算  Go由于支持垃圾回收，如果支持指针运算则会给垃圾回收的实现带来很多不便。例如：  <img src="/images/go_core_programming/Untitled%2012.png" alt="Untitled"></li><li>函数中允许返回局部变量的地址  Go编译器使用”栈逃逸“机制将这种局部变量的空间分配在堆上，例如：  <img src="/images/go_core_programming/Untitled%2013.png" alt="Untitled"></li></ul></li></ol><h3 id="1-6-2-数组"><a href="#1-6-2-数组" class="headerlink" title="1.6.2 数组"></a>1.6.2 数组</h3><ol><li>数组的类型名是<code>[n]elementType</code>，n是数组长度，elementType是数组元素类型。</li></ol><p><img src="/images/go_core_programming/Untitled%2014.png" alt="Untitled"></p><ol><li>数组的特点：<ul><li>数组创建完长度就固定了，不可以再追加元素了</li><li>数组是值类型的，数组赋值或作为函数参数都是值拷贝</li><li>数组长度是数组类型的组成部分，<code>[10]int</code>和<code>[20]int</code>是不同的类型</li><li>可以根据数组创建切片</li></ul></li><li>数组相关操作：<ul><li><p>数组元素访问</p><p><img src="/images/go_core_programming/Untitled%2015.png" alt="Untitled"></p></li><li><p>数组长度</p><p><img src="/images/go_core_programming/Untitled%2016.png" alt="Untitled"></p></li></ul></li></ol><h3 id="1-6-3-切片"><a href="#1-6-3-切片" class="headerlink" title="1.6.3 切片"></a>1.6.3 切片</h3><p>Go语言的数组的定长性和值拷贝限制了其使用场景，Gp提供了另一种数据类型slice（切片），这是一种变长数组，其数据结构中有指向数组的指针，所以是一种引用类型。</p><p>例如：</p><pre><code class="go">type slice struct {    array unsafe.Pointer    len int    cap int}</code></pre><p>Go为切片维护三个元素：</p><ul><li>指向底层数组的指针</li><li>切片的元素数量</li><li>底层数组的容量</li></ul><p><img src="/images/go_core_programming/Untitled%2017.png" alt="Untitled"></p><ol><li>切片的创建<ul><li>由数组创建：创建语法<code>array[b:e]</code> ，表示创建一个包含e-b各元素额的切片，第一个元素是<code>array[b]</code>，最后一个元素是<code>array[e-1]</code> 。例如：  <img src="/images/go_core_programming/Untitled%2018.png" alt="Untitled"></li><li>通过内置函数<code>make</code>创建切片。<code>make</code>创建的切片各元素被默认为输出华为切片元素类型的零值。  <img src="/images/go_core_programming/Untitled%2019.png" alt="Untitled">  <img src="/images/go_core_programming/Untitled%2020.png" alt="Untitled"></li></ul><ol><li>切片支持的操作<ul><li>内置函数<code>len()</code>返回切片长度</li><li>内置函数<code>cap()</code>返回切片底层数组容量</li><li>内置函数<code>append()</code>对切片追加元素</li><li>内置函数<code>copy()</code>用于复制一个切片</li></ul></li></ol></li></ol><h3 id="1-6-4-map"><a href="#1-6-4-map" class="headerlink" title="1.6.4 map"></a>1.6.4 map</h3><p>Go语言内置的字典类型叫map。</p><p><code>map</code>类型的格式是：<code>map[K]T</code> ，其中K可以是任意可以进行比较的类型，T是值类型。</p><p><code>map</code>也是一种引用类型。</p><ol><li><code>map</code>的创建<ul><li>使用字面量创建，例如：  <img src="/images/go_core_programming/Untitled%2021.png" alt="Untitled"></li><li>使用内置的make函数创建，例如  <img src="/images/go_core_programming/Untitled%2022.png" alt="Untitled">  <img src="/images/go_core_programming/Untitled%2023.png" alt="Untitled"></li></ul></li><li><code>map</code>支持的操作<ul><li><p><code>map</code>的单个键值访问格式为<code>mapName[key]</code></p></li><li><p>可以使用<code>range</code>遍历一个<code>map</code>类型的变量，但不能保证每次迭代元素的顺序</p></li><li><p>删除<code>map</code>中的某个键值，<code>delete(mapName,key)</code> 。<code>delete</code>是内置函数，用来删除<code>map</code>中的某个键值对</p></li><li><p>可以使用内置的<code>len()</code> 函数返回<code>map</code>中的键值对数量</p><p>注意：</p></li><li><p>Go内置的<code>map</code>不是并发安全的，并发安全的<code>map</code>可以使用标准包<code>sync</code>中的map</p></li><li><p>不要直接修改<code>map value</code>内某个元素的值，如果想修改<code>map</code>的某个键值，则必须整理赋值</p></li></ul></li></ol><h3 id="1-6-5-struct"><a href="#1-6-5-struct" class="headerlink" title="1.6.5 struct"></a>1.6.5 struct</h3><p>Go中的struct类型和C类似，中文翻译为结构，由多个不同类型元素组合而成。</p><ul><li>struct结构中的类型可以是任意类型</li><li>struct的存储空间是连续的，其字段按照声明时的顺序存放（注意字段值之间有对齐要求）</li></ul><p>struct有两种形式：</p><ul><li>struct类型字面量</li><li>使用type声明的自定义struct类型</li></ul><ol><li>strct类型字面量 struct类型字面量的声明格式如下： <img src="/images/go_core_programming/Untitled%2024.png" alt="Untitled"></li><li>自定义struct类型 自定义struct类型声明格式如下： <img src="/images/go_core_programming/Untitled%2025.png" alt="Untitled"></li><li>struct类型变量的初始化，示例： <img src="/images/go_core_programming/Untitled%2026.png" alt="Untitled"></li><li>其他复合类型<ul><li>接口（Interface）</li><li>通道（chan）</li></ul></li></ol><h2 id="1-7-控制结构"><a href="#1-7-控制结构" class="headerlink" title="1.7 控制结构"></a>1.7 控制结构</h2><p>程序执行从本质上来说就是两种模式：顺序和跳转</p><h3 id="1-7-1-if-语句"><a href="#1-7-1-if-语句" class="headerlink" title="1.7.1 if 语句"></a>1.7.1 if 语句</h3><h3 id="1-7-2-switch-语句"><a href="#1-7-2-switch-语句" class="headerlink" title="1.7.2 switch 语句"></a>1.7.2 switch 语句</h3><h3 id="1-7-3-for-语句"><a href="#1-7-3-for-语句" class="headerlink" title="1.7.3 for 语句"></a>1.7.3 for 语句</h3><h3 id="1-7-4-标签和跳转"><a href="#1-7-4-标签和跳转" class="headerlink" title="1.7.4 标签和跳转"></a>1.7.4 标签和跳转</h3><ol><li>标签 Go语言使用标签（Lable）来标识一个语句的位置，用于goto、break、continue语句的跳转。标签的语法是： <img src="/images/go_core_programming/Untitled%2027.png" alt="Untitled"></li><li>goto goto语句用于函数的内部跳转，需要配合标签一起使用： <img src="/images/go_core_programming/Untitled%2028.png" alt="Untitled"> goto特点：<ul><li>goto语句只能在函数内跳转</li><li>goto语句不能跳过内部变量声明语句，这些变量在goto语句的标签语句处有事可见的</li><li>goto语句只能调到同级作用域或者上层作用域，不能跳到内部作用域</li></ul></li><li>break break用于函数内跳出for、switch、select语句的执行，有两种使用格式：<ul><li>单独使用：用于跳出break当前所在的for、switch、select语句的执行</li><li>和标签一起使用：用于跳出标签所标识的for、switch、select语句的执行，可用于跳出多重循环，但标签和break必须在同一个函数内，例如：  <img src="/images/go_core_programming/Untitled%2029.png" alt="Untitled"></li></ul></li><li>continue continue用于跳出for循环的本次迭代，跳到for循环的下一次迭代的post语句处执行，有两种使用格式：<ul><li><p>单独使用：跳出continue当前所在的for循环的本次迭代</p></li><li><p>和标签一起使用：跳出标签所标示的for语句的本次迭代，但标签和continue必须在同一个函数内，例如：</p><p><img src="/images/go_core_programming/Untitled%2030.png" alt="Untitled"></p></li></ul></li><li>return和函数调用 return语句也能引发控制流程的跳转，用于函数和方法的退出。</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p><code>slice</code> 和 <code>array</code> 区别</p><ul><li>创建方式不同：数组<code>var identifier [len]type</code> ；切片<code>var slice3 = []int{}</code></li><li><code>slice</code>的<code>array</code>实际上是数组的指针，所以作为函数参数传递时不同：数组传递的是数组的副本；<code>slice</code>传递的是数组的指针</li><li>长度是否固定：数组长度固定；切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大</li></ul></li><li><p>struct能不能比较？<a href="https://juejin.cn/post/6881912621616857102">https://juejin.cn/post/6881912621616857102</a> </p></li><li><p>slice，len，cap，共享，扩容</p></li><li><p>for 循环遍历 slice 有什么问题</p><ul><li>for rang A，是对A的值拷贝，问题代码：<pre><code class="go">func TestName(t *testing.T) {    s :=[]int{1,2,3,4}    m :=make(map[int]*int)    for k,v:=range s{        m[k]= &amp;v    }    for key, value := range m {        fmt.Printf("map[%v]=%v\n", key, *value)    }    fmt.Println(m)}</code></pre>  改正：<pre><code class="go">func TestName(t *testing.T) {    s := []int{1, 2, 3, 4}    m := make(map[int]*int)    for k, v := range s {        // 这里变动        n := v        m[k] = &amp;n    }    for key, value := range m {        fmt.Printf("map[%v]=%v\n", key, *value)    }    fmt.Println(m)}</code></pre></li></ul></li><li><p>请你说说golang的CSP思想</p></li><li><p>进程，协程，线程各自的优缺点</p></li></ol><h1 id="第-2-章-函数"><a href="#第-2-章-函数" class="headerlink" title="第 2 章 函数"></a>第 2 章 函数</h1><p>Go中的函数：</p><ul><li>函数是一种类型，函数类型变量可以向其他类型变量一样使用，可以作为其它函数的参数或返回值，也可以直接调用执行</li><li>函数支持多值返回</li><li>支持闭包</li><li>函数支持可变参数</li></ul><h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><h3 id="2-1-1-函数定义"><a href="#2-1-1-函数定义" class="headerlink" title="2.1.1 函数定义"></a>2.1.1 函数定义</h3><p>包括如下几个部分：</p><ul><li>函数声明关键字func</li><li>函数名</li><li>参数列表</li><li>返回列表和函数体</li></ul><p>函数的特点：</p><ul><li>函数可以没有输入参数，也可以没有返回值（默认返回0）</li><li>多个相邻的相同类型的参数可以使用简写模式</li><li>支持有名的返回值，参数名就相当于函数体内最外层的局部变量，命名返回值变量会被初始化成类型零值</li><li>不支持默认值参数</li><li>不支持函数重载</li><li>不支持函数嵌套，严格的说是不支持命名函数的嵌套定义，但支持嵌套匿名函数</li></ul><h3 id="2-1-2-多值返回"><a href="#2-1-2-多值返回" class="headerlink" title="2.1.2 多值返回"></a>2.1.2 多值返回</h3><p>习惯用法：如果多值返回之有错误类型，则一般将错误类型作为最后一个返回值</p><h3 id="2-1-3-实参到形参的传递"><a href="#2-1-3-实参到形参的传递" class="headerlink" title="2.1.3 实参到形参的传递"></a>2.1.3 实参到形参的传递</h3><p>Go函数实参到形参的传递永远是值拷贝。有时函数调用后实参指向的值发生了变化，那是因为参数传递的是指针值的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本，二者指向同一地址。</p><h3 id="2-1-4-不定参数"><a href="#2-1-4-不定参数" class="headerlink" title="2.1.4 不定参数"></a>2.1.4 不定参数</h3><p>Go支持不定数据的形式参数，声明使用<code>param ...type</code> .</p><p>不定参数特点：</p><ul><li>所有的不定参数类型必须是相同的</li><li>不定参数必须是函数的最后一个参数</li><li>不定参数在函数体内相当于切片，对切片的操作同样适合对不定参数的操作</li><li>切片可以作为参数传递给不定参数，切片名后要加上”…”</li><li>形参为不定参数的函数和形参为切片的函数类型不相同</li></ul><h2 id="2-2-函数签名和匿名函数"><a href="#2-2-函数签名和匿名函数" class="headerlink" title="2.2 函数签名和匿名函数"></a>2.2 函数签名和匿名函数</h2><h3 id="2-2-1-函数签名"><a href="#2-2-1-函数签名" class="headerlink" title="2.2.1 函数签名"></a>2.2.1 函数签名</h3><p>函数类型又叫函数签名，可以使用fmt.Printf的%T格式化参数打印函数的类型</p><h3 id="2-2-2-匿名函数"><a href="#2-2-2-匿名函数" class="headerlink" title="2.2.2 匿名函数"></a>2.2.2 匿名函数</h3><p>Go提供两种函数：有名函数和匿名函数</p><p>匿名函数可以直接复制给函数变量，可以当做实参，也可以作为返回值，还可以直接被调用。</p><h2 id="2-3-defer"><a href="#2-3-defer" class="headerlink" title="2.3 defer"></a>2.3 defer</h2><p>Go提供了defer关键字，可以注册多个延迟调用，这些调用以先进后出的顺序在函数返回前被执行。这有点类似于Java语言中异常处理的finaly语句。</p><p>defer常用语保证一些资源最终一定能够得到回收和释放。</p><p>特点：</p><ul><li>defer后面必须是函数或方法的调用，不能是语句</li><li>defer函数的实参在注册时通过值拷贝传递进去</li><li>defer语句必须先注册后才能执行</li></ul><p>优势：可以在一定程度上避免资源泄露</p><p>缺点：</p><ul><li>defer会推迟资源的释放</li><li>defer不要写在循环语句里面</li><li>defer最好不要对有名返回值参数进行操作</li></ul><h2 id="2-4-闭包"><a href="#2-4-闭包" class="headerlink" title="2.4 闭包"></a>2.4 闭包</h2><p>闭包是由函数及其相关引用环境组合而成的实体。</p><p><code>闭包 = 函数 + 引用环境</code></p><ol><li>闭包对闭包外的环境引入是直接引用，编译器检测到闭包会将闭包引用的外部变量分配到堆上</li><li>如果函数返回的闭包引用了该函数的局部变量（参数或函数内部变量）<ol><li>多次调用该函数返回的多个闭包所引用的外部变量是多个副本，原因是每次调用函数都会为局部变量分配内存</li><li>用一个闭包函数多次，如果该闭包修改了其引用的外部变量，则每一次调用该闭包对该外包变量都有影响，因为闭包函数共享外部引用</li></ol></li></ol><h3 id="2-4-2-闭包的价值"><a href="#2-4-2-闭包的价值" class="headerlink" title="2.4.2 闭包的价值"></a>2.4.2 闭包的价值</h3><p>对象是附有行为的数据，闭包是附有数据的行为。</p><h2 id="2-5-panic和recover"><a href="#2-5-panic和recover" class="headerlink" title="2.5 panic和recover"></a>2.5 panic和recover</h2><p>panic用来主动抛出错误</p><p>recover用来捕获panic抛出的错误</p><h3 id="2-5-1-基本概念"><a href="#2-5-1-基本概念" class="headerlink" title="2.5.1 基本概念"></a>2.5.1 基本概念</h3><p><img src="/images/go_core_programming/Untitled%2031.png" alt="Untitled"></p><p>引发panic的情况：</p><ul><li>程序主动调用panic函数</li><li>程序产生运行时错误，由运行时检测并抛出</li></ul><p>recover用来捕获panic，阻止panic继续向上传递</p><h3 id="2-5-2-使用场景"><a href="#2-5-2-使用场景" class="headerlink" title="2.5.2 使用场景"></a>2.5.2 使用场景</h3><ul><li>程序遇到了无法正常执行下去的错误，主动调用panic函数结束程序运行</li><li>在调试程序时，通过主动调用panic实现快速退出，panic打印出的堆栈能够更快的定位错误</li></ul><h2 id="2-6-错误处理"><a href="#2-6-错误处理" class="headerlink" title="2.6 错误处理"></a>2.6 错误处理</h2><h3 id="2-6-1-error"><a href="#2-6-1-error" class="headerlink" title="2.6.1 error"></a>2.6.1 error</h3><p>Go语言内置错误接口类型error</p><p>错误处理的最佳实践：</p><ul><li>在多个返回值的函数中，error通常作为函数最后一个返回值</li><li>如果一个函数返回error类型变量，则先用if语句处理<code>error != nil</code> 的异常场景，正常逻辑放到if语句块后面保持代码平坦</li><li>defer语句应该放到err判断的后面，不然有可能产生panic</li><li>在错误逐级向上传递的过程中，错误信息应该不断地丰富和完善，而不是简单抛出下层调用的错误</li></ul><pre><code class="go">func deferDemo() error {    err := createResource1()    if err != nil {        return ERR_CREATE_RESOURCE1_FAILED    }    defer func() {        if err != nil {            destroyResource1()        }    }()}</code></pre><h3 id="2-6-2-错误和异常"><a href="#2-6-2-错误和异常" class="headerlink" title="2.6.2 错误和异常"></a>2.6.2 错误和异常</h3><p>Go程序需要处理的错误类型：</p><ul><li>运行时错误：无法避免，可以recover这些panic</li><li>程序逻辑错误</li></ul><p>error和panic应该遵循如下原则：</p><ul><li>程序发生的错误导致程序不能容错继续执行，此时程序应该主动调用panic或由运行时抛出panic</li><li>程序虽然发生错误，但是程序能够容错继续执行，此时应该使用错误返回值的方式处理错误，或者在可能发生运行时错误的非关键分支上使用recover捕获panic</li></ul><pre><code class="go">func TestName(t *testing.T) {    height := []int{2,3,4,5,18,17,6}    defer func() {        if err := recover(); err != nil {            fmt.Println(err)        }    }()    print(height[10])}</code></pre><h2 id="2-7-底层实现"><a href="#2-7-底层实现" class="headerlink" title="2.7 底层实现"></a>2.7 底层实现</h2><h1 id="第-3-章-类型系统"><a href="#第-3-章-类型系统" class="headerlink" title="第 3 章 类型系统"></a>第 3 章 类型系统</h1><h2 id="3-1-类型简介"><a href="#3-1-类型简介" class="headerlink" title="3.1 类型简介"></a>3.1 类型简介</h2><h3 id="3-1-1-命名类型和未命名类型"><a href="#3-1-1-命名类型和未命名类型" class="headerlink" title="3.1.1 命名类型和未命名类型"></a>3.1.1 命名类型和未命名类型</h3><p>命名类型：可以通过标识符来表示（3.2节详细介绍）</p><p>未命名类型：一个类型由预声明类型、关键字和操作符组合而成，又称为类型字面量。例如：数组（array）、切片（slice）、字典（map）、通道（channel）、指针（pointer）、函数字面量（function）、结构（struct）和接口（interface）都属于类型字面量</p><h3 id="3-1-2-底层类型"><a href="#3-1-2-底层类型" class="headerlink" title="3.1.2 底层类型"></a>3.1.2 底层类型</h3><p>所有“类型”都有一个underlying type（底层类型）。底层类型的规则如下：</p><ul><li>预声明类型（Pre-declared types）和类型字面量（type literals）的底层类型是他们自身</li><li>自定义类型type newtype oldtype中的newtype的底层是逐层递归向下查找的，知道查到的oldtype是预声明类型（Pre-declared types）或类型字面量（type literals）为止。</li></ul><h3 id="3-1-3-类型相同和类型赋值"><a href="#3-1-3-类型相同和类型赋值" class="headerlink" title="3.1.3 类型相同和类型赋值"></a>3.1.3 类型相同和类型赋值</h3><p><strong>类型相同</strong></p><p>Go是强类型的语言，编译器在编译时会进行严格的类型校验。两个命名类型是否相同的判断：</p><ul><li>两个命名类型相同的条件是两个类型声明的语句完全相同</li><li>命名类型和未命令类型永远不相同</li><li>两个未命名类型相同的条件是他们的类型声明字面量的结构相同，并且内部元素的类型相同</li><li>通过类型别名语句声明的两个类型相同</li></ul><p><strong>类型可直接赋值</strong></p><p>类型为T1的变量a可以赋值给类型为T2的变量b，称为类型T1可以赋值给类型T2，伪代码：</p><pre><code class="go">var b T2 = a</code></pre><p>a可以赋值给变量b必须要满足如下条件中的一个：</p><ul><li>T1和T2的类型相同</li><li>T1和T2具有相同的底层类型，并且T1和T2里面至少有一个是未命名类型</li><li>T2是接口类型，T1是具体类型，T1的方法集是T2方法集的超级</li><li>T1和T2都是通道类型，他们拥有相同的元素类型，并且T1和T2至少有一个是未命名类型</li><li>a是预声明标识符nil，T2是pointer、function、slice、map、channel、interface类型中的一个</li><li>a是一个字面常量值，可以用来表示类型T的值</li></ul><h3 id="3-1-4-类型强制转换"><a href="#3-1-4-类型强制转换" class="headerlink" title="3.1.4 类型强制转换"></a>3.1.4 类型强制转换</h3><p>由于Go是强类型的语言，如果不满足自动转换的条件，则必须进行强制类型转换。</p><p>非常量类型的变量x可以强制转化并传递给类型T，需要满足如下任一条件：</p><ul><li>x可以直接赋值给T类型变量</li><li>x类型和T具有相同的底层类型</li><li>x的类型和T都是未命名的指针类型，并且指针指向的类型具有相同的底层类型</li><li>x的类型和T都是整型或者都是浮点型</li><li>x的类型和T都是复数类型</li><li>x是整数值或[]byte类型的值，T是string类型</li><li>x是一个字符串，T是[]byte或[]rune</li></ul><h2 id="3-2-类型方法"><a href="#3-2-类型方法" class="headerlink" title="3.2 类型方法"></a>3.2 类型方法</h2><h3 id="3-2-1-自定义类型"><a href="#3-2-1-自定义类型" class="headerlink" title="3.2.1 自定义类型"></a>3.2.1 自定义类型</h3><p>自定义类型都是命名类型</p><p><img src="/images/go_core_programming/Untitled%2032.png" alt="Untitled"></p><p>自定义struct类型</p><h3 id="3-2-2-方法"><a href="#3-2-2-方法" class="headerlink" title="3.2.2 方法"></a>3.2.2 方法</h3><p><img src="/images/go_core_programming/Untitled%2033.png" alt="Untitled"></p><p>类型方法有如下特点：</p><ul><li>可以为命名类型增加方法（除了接口），非命名类型不能自定义方法</li><li>为类型增加方法有一个限制，就是方法的定义必须和类型的定义在同一个包中</li><li>方法的命名空间可见性和变量一样，大写开头的方法可也在包外被访问，否则只能在包内可见</li><li>使用type定义的自定义类型是一个新类型，新类型不能调用原有类型的方法，但是底层类型支持的运算可以被新类型继承</li></ul><p><img src="/images/go_core_programming/Untitled%2034.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2035.png" alt="Untitled"></p><h2 id="3-3-方法调用"><a href="#3-3-方法调用" class="headerlink" title="3.3 方法调用"></a>3.3 方法调用</h2><h3 id="3-3-1-一般调用"><a href="#3-3-1-一般调用" class="headerlink" title="3.3.1 一般调用"></a>3.3.1 一般调用</h3><p><img src="/images/go_core_programming/Untitled%2036.png" alt="Untitled"></p><h3 id="3-3-2-方法值"><a href="#3-3-2-方法值" class="headerlink" title="3.3.2 方法值"></a>3.3.2 方法值</h3><p><img src="/images/go_core_programming/Untitled%2037.png" alt="Untitled"></p><h3 id="3-3-3-方法表达式"><a href="#3-3-3-方法表达式" class="headerlink" title="3.3.3 方法表达式"></a>3.3.3 方法表达式</h3><p>方法表达式相当于提供一种语法将类型方法调用显示第转换为函数调用，接受者必须显示地传递进去。</p><h3 id="3-3-4-方法集"><a href="#3-3-4-方法集" class="headerlink" title="3.3.4 方法集"></a>3.3.4 方法集</h3><p>命名类型方法接受者有两种类型，一个是值类型，另一个是指针类型，这个和函数是一样的，前者的形参是值类型，后者的形参是指针类型。</p><p>无论接受者是什么类型，方法和函数的实参传递都是值拷贝，如果接受者是值类型，则传递的是值的副本；如果接受者是指针类型，则传递的是指针的副本</p><h3 id="3-3-5-值调用和表达式调用的方法集"><a href="#3-3-5-值调用和表达式调用的方法集" class="headerlink" title="3.3.5 值调用和表达式调用的方法集"></a>3.3.5 值调用和表达式调用的方法集</h3><h2 id="3-4-组合和方法集"><a href="#3-4-组合和方法集" class="headerlink" title="3.4 组合和方法集"></a>3.4 组合和方法集</h2><p>结构类型为Go提供了强大的类型扩展，主要体现在两个方面：</p><ul><li>struct可以嵌入任意其他类型的字段</li><li>struct可以嵌套自身的指针类型的字段</li></ul><h3 id="3-4-1-组合"><a href="#3-4-1-组合" class="headerlink" title="3.4.1 组合"></a>3.4.1 组合</h3><p>因为Go没有继承的语义，结构和字段之间是“has a”的关系而不是“is a”的关系，没有父子概念，仅仅是整体和局部的概念，所以后续统称这种嵌套的结构和字段的关系为组合</p><h3 id="3-4-2-组合的方法集"><a href="#3-4-2-组合的方法集" class="headerlink" title="3.4.2 组合的方法集"></a>3.4.2 组合的方法集</h3><h2 id="3-5-函数类型"><a href="#3-5-函数类型" class="headerlink" title="3.5 函数类型"></a>3.5 函数类型</h2><h1 id="第-4-章-接口（未看）"><a href="#第-4-章-接口（未看）" class="headerlink" title="第 4 章 接口（未看）"></a>第 4 章 接口（未看）</h1><h1 id="第-5-章-并发"><a href="#第-5-章-并发" class="headerlink" title="第 5 章 并发"></a>第 5 章 并发</h1><h2 id="5-1-并发基础"><a href="#5-1-并发基础" class="headerlink" title="5.1 并发基础"></a>5.1 并发基础</h2><h3 id="5-1-1-并发和并行"><a href="#5-1-1-并发和并行" class="headerlink" title="5.1.1 并发和并行"></a>5.1.1 并发和并行</h3><ol><li>并行就是在任一粒度的时间内都具备同时执行的能力：例如多机</li><li>并发是在规定的时间内多个请求都得到执行和处理，强调的是给外界的感受，实际上内部可能是分时操作的</li></ol><h3 id="5-1-2-goroutine"><a href="#5-1-2-goroutine" class="headerlink" title="5.1.2 goroutine"></a>5.1.2 goroutine</h3><p>Go语言的并发执行体称为goroutine，通过go关键字来启动一个goroutine。</p><p>goroutine特性：</p><ul><li>go的执行是非阻塞的，不会等待</li><li>go后面的函数的返回值会被忽略</li><li>调度器不能保证多个goroutine的执行次序</li><li>没有父子goroutine的概念，所有goroutne是平等地被调用和执行的</li><li>Go程序在执行时会单独为main函数创建一个goroutine，遇到其他go关键字时再去创建其他的goroutinue</li><li>Go没有暴露goroutine id给用户，所以不能在一个goroutine里面显式地操作另一个goroutine，不过runtime包提供了一些函数访问和设置goroutine的相关信息</li></ul><ol><li>func GOMAXPROCS</li></ol><p>设置或查询可以并发执行的goroutine数目</p><pre><code class="go">package goroutine_testimport (    "runtime"    "testing")func TestName(t *testing.T) {    // 获取GOMAXPROCS    println("GOMAXPROCS=",runtime.GOMAXPROCS(0))    // 设置GOMAXPROCS    runtime.GOMAXPROCS(2)    // 获取GOMAXPROCS    println("GOMAXPROCS=",runtime.GOMAXPROCS(0))}</code></pre><ol><li>func Goexit</li></ol><p>结束当前goroutinue的运行。Goexit不会产生panic。</p><ol><li>fun Gosched</li></ol><p>放弃当前调度执行机会，将当前goroutinue放到队列中等待下次被调度</p><h3 id="5-1-3-chan"><a href="#5-1-3-chan" class="headerlink" title="5.1.3 chan"></a>5.1.3 chan</h3><ol><li>chan是Go语言里面的一个关键字，是channel的简写，通道。通道是Go通过通信来共享内容的载体。</li><li>通道类型：<ul><li><p>有缓冲的通道：主要用于通信</p></li><li><p>无缓冲的通道：既可以用于通信，也可以用于两个goroutinue的同步</p><p><img src="/images/go_core_programming/Untitled%2038.png" alt="Untitled"></p><pre><code class="go">func TestName(t *testing.T) {  println("NumGoroutinue=", runtime.NumGoroutine())  c := make(chan struct{})  ci := make(chan int, 100)  go func(i chan struct{}, j chan int) {      for i := 0; i &lt; 10; i++ {          ci &lt;- i      }      close(ci)      // 写通道      c &lt;- struct{}{}  }(c, ci)  // NumGoroutinue可以返回当前程序的goroutinue数目  println("NumGoroutinue=", runtime.NumGoroutine())  // 读通道c，通过通道进行同步等待  &lt;-c  // 此时ci通道已经关闭，匿名函数启动的goroutinue已经退出  println("NumGoroutinue=", runtime.NumGoroutine())  for v := range ci {      println(v)  }}</code></pre></li></ul></li><li>操作不同状态的chan会引发三种行为<ul><li>panic<ul><li>向已经关闭的通道写数据会导致panic。由写入者关闭通道能最大程度地避免向已经关闭的通道写数据而导致panic</li><li>重复关闭的通道会导致panic</li></ul></li><li>阻塞<ul><li>向未初始化的通道写数据或读数据都会导致当前goroutine的永久阻塞</li><li>向缓冲区已满的通道写入数据会导致goroutinue阻塞</li><li>通道中没有数据，读取该通道会导致goroutinue阻塞</li></ul></li><li>非阻塞<ul><li>读者已经关闭的通道不会引发阻塞而是立即返回通道元素类型的零值，可以使用comma，ok语法判断通道是否已经关闭</li><li>向有缓冲且没有满的通道读/写不会引发阻塞</li></ul></li></ul></li></ol><h3 id="5-1-4-WaitGroup"><a href="#5-1-4-WaitGroup" class="headerlink" title="5.1.4 WaitGroup"></a>5.1.4 WaitGroup</h3><p>sync包提供了多个goroutine同步的机制，主要是通过WaitGroup实现的。</p><h3 id="5-1-5-select"><a href="#5-1-5-select" class="headerlink" title="5.1.5 select"></a>5.1.5 select</h3><p>select用于多路监听多个通道</p><ul><li>当监听的通道没有状态是可读或可写的，select是阻塞的</li><li>监听的通道中有一个状态是可读或可写的，则select就不会阻塞，而是进入处理就绪通道的分支流程</li><li>如果监听的通道有多个可读或可写的状态，则select随机选取一个处理</li></ul><pre><code class="go">import "testing"func TestName(t *testing.T) {    ch := make(chan int, 2)    go func(chan int) {        for {            select {            case ch &lt;- 0:            case ch &lt;- 1:            }        }    }(ch)    for i := 0; i &lt; 10; i++ {        println(&lt;-ch)    }}</code></pre><h3 id="5-1-6-扇入（Fan-in）和扇出（Fan-out）"><a href="#5-1-6-扇入（Fan-in）和扇出（Fan-out）" class="headerlink" title="5.1.6 扇入（Fan in）和扇出（Fan out）"></a>5.1.6 扇入（Fan in）和扇出（Fan out）</h3><p>扇入：将多路通道聚合到一条通道中处理，Go最简单的扇入就是使用select聚合多条通道服务</p><p>扇出：将一条通道发散到多条通道中处理，Go语言里面具体实现就是使用go关键字启动多个goroutine并发处理 </p><pre><code class="go">import (    "fmt"    "sync"    "testing")var wg sync.WaitGroupfunc TestWaitGroup(t *testing.T) {    for i := 0; i &lt; 10; i++ {        wg.Add(1)        go func(i int) {            defer wg.Done()            fmt.Printf("go func: %d\n", i)        }(i)    }    wg.Wait()    println("success!")}</code></pre><h3 id="5-1-7-通知退出机制"><a href="#5-1-7-通知退出机制" class="headerlink" title="5.1.7 通知退出机制"></a>5.1.7 通知退出机制</h3><p>读取已经关闭的通道不会引起阻塞，也不会导致panic，而是立即返回该通道存储类型的零值。</p><p>关闭select监听的某个通道能使select立即感知这种通知，然后进行相应的处理，这就是所谓的退出通知机制。</p><p>下面通过一个随机数生成器的示例掩饰退出通知机制，下游的消费者不需要随机数时显式地通知生产者停止生产：</p><pre><code class="go">import (    "fmt"    "math/rand"    "runtime"    "testing")func GenerateIntA(done chan struct{}) chan int {    ch := make(chan int)    go func() {    Lable:        for {            select {            case ch &lt;- rand.Int():            case &lt;-done:                break Lable            }        }        close(ch)    }()    return ch}func TestNotiExit(t *testing.T) {    println("NumGoroutine=", runtime.NumGoroutine())    done := make(chan struct{})    ch := GenerateIntA(done)    println("NumGoroutine=", runtime.NumGoroutine())    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    close(done)    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    println("NumGoroutine=", runtime.NumGoroutine())}</code></pre><h2 id="5-2-并发范式"><a href="#5-2-并发范式" class="headerlink" title="5.2 并发范式"></a>5.2 并发范式</h2><h3 id="5-2-1-生成器"><a href="#5-2-1-生成器" class="headerlink" title="5.2.1 生成器"></a>5.2.1 生成器</h3><ol><li>最简单的带缓冲的生成器</li></ol><pre><code class="go">import (    "fmt"    "math/rand"    "testing")func GenerateInt() chan int {    ch := make(chan int, 3)    go func() {        for {            ch &lt;- rand.Int()        }    }()    return ch}func TestGenerateInt(t *testing.T) {    ch := GenerateInt()    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)}</code></pre><ol><li>多个goroutinue增强型生成器</li></ol><p><img src="/images/go_core_programming/Untitled%2039.png" alt="Untitled"></p><ol><li>有时希望生成器能够自动退出，可以借助Go通道的退出通知机制实现，例如：</li></ol><p><img src="/images/go_core_programming/Untitled%2040.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2041.png" alt="Untitled"></p><ol><li>融合并发、缓冲、退出通知等多重特性的生成器</li></ol><pre><code class="go">package genericimport (    "fmt"    "math/rand"    "testing")func GenerateIntA(done chan struct{}) chan int {    fmt.Println("GenerateIntA")    ch := make(chan int, 5)    go func() {    Lable:        for {            select {            case ch &lt;- rand.Int():            case &lt;-done:                break Lable            }        }        close(ch)    }()    return ch}func GenerateIntB(done chan struct{}) chan int {    fmt.Println("GenerateIntB")    ch := make(chan int, 5)    go func() {    Lable:        for {            select {            case ch &lt;- rand.Int():            case &lt;-done:                break Lable            }        }        close(ch)    }()    return ch}func GenerateInt(done chan struct{}) chan int {    ch := make(chan int)    send := make(chan struct{})    go func() {    Lable:        for {            select {            case ch &lt;- &lt;-GenerateIntA(send):            case ch &lt;- &lt;-GenerateIntB(send):            case &lt;-done:                send &lt;- struct{}{}                send &lt;- struct{}{}                break Lable            }        }        close(ch)    }()    return ch}func Test(t *testing.T)  {    done := make(chan struct{})    ch := GenerateInt(done)    for i := 0; i &lt; 10; i++ {        fmt.Println(&lt;-ch)    }    done &lt;- struct{}{}    fmt.Println("stop generate")}</code></pre><h3 id="5-2-2-管道"><a href="#5-2-2-管道" class="headerlink" title="5.2.2 管道"></a>5.2.2 管道</h3><p>通道可以分为两个方向，一个是读另一个是写，加入一个函数的输入参数和输出参数都是相同的chan类型，则该函数可以调用自己，最终形成一个调用链。这很像UNIX系统的管道，是一个有类型的管道</p><h3 id="5-2-3-每个请求一个goroutine"><a href="#5-2-3-每个请求一个goroutine" class="headerlink" title="5.2.3 每个请求一个goroutine"></a>5.2.3 每个请求一个goroutine</h3><p>来一个请求或任务就启动一个goroutine去处理，典型的就是Go中的HTTP server服务。</p><h3 id="5-2-4-固定worker工作池"><a href="#5-2-4-固定worker工作池" class="headerlink" title="5.2.4 固定worker工作池"></a>5.2.4 固定worker工作池</h3><p>程序中除了主要的main goroutine，还开启了如下几类goroutine：</p><ul><li>初始化任务的goroutine</li><li>分发任务的goroutine</li><li>等待所有worker结束通知，然后关闭结果通道的goroutine</li></ul><p>程序采用三个通道，分别是：</p><ul><li>传递task任务的通道</li><li>传递task结果的通道</li><li>接收worker处理完任务后所发送通知的通道</li></ul><p>计算多个整数的和样例代码：</p><pre><code class="go">package mainimport (    "fmt"    "math/rand"    "time")// 工作池的goroutine数目const NUMBER = 10// 工作任务type task struct {    // 存放数据    data int    // 任务结果    result chan&lt;- int}// 任务处理：计算begin和end的和// 执行结果写入结果chan resultfunc (t *task) do() {    // 模拟计算耗时    r := rand.Intn(1000)    fmt.Println("Sleep:", r, "ms")    time.Sleep(time.Duration(r) * time.Millisecond)    // 模拟任务结果就是任务数据    t.result &lt;- t.data}func main() {    workers := NUMBER    taskChan := make(chan task, 10)    resultChan := make(chan int, 10)    done := make(chan struct{}, 10)    // 初始化task的goroutine    go InitTask(taskChan, resultChan, 100)    // 分发任务到NUMBER个goroutine池    DistributeTask(taskChan, workers, done)    // 获取各个goroutine处理完任务的通知并关闭结果通道    go CloseResult(done, resultChan, workers)    // 通过结果通道获取结果并汇总    sum := ProcessResult(resultChan)    fmt.Println("sum=", sum)}// 初始化待处理task chanfunc InitTask(taskChan chan&lt;- task, r chan int, p int) {    for i := 0; i &lt;= p; i++ {        taskChan &lt;- task{            data:   i,            result: r,        }    }    close(taskChan)}// 读取task chan并分发到worker goroutine处理，总的数量是workersfunc DistributeTask(taskChan &lt;-chan task, works int, done chan struct{}) {    for i := 0; i &lt; works; i++ {        go ProcessTask(taskChan, done)    }}// 工作goroutine处理具体工作，并将处理结果发送到结果chanfunc ProcessTask(taskChan &lt;-chan task, done chan struct{}) {    for t := range taskChan {        t.do()    }    done &lt;- struct{}{}}// 通过done channel同步等待所有工作goroutine的结束，然后关闭结果chanfunc CloseResult(done chan struct{}, resultChan chan int, workers int) {    for i := 0; i &lt; workers; i++ {        &lt;-done    }    close(done)    close(resultChan)}// 读取结果通道，汇总结果func ProcessResult(resultChan chan int) int {    sum := 0    for r := range resultChan {        sum += r    }    return sum}</code></pre><p><img src="/images/go_core_programming/Untitled%2042.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2043.png" alt="Untitled"></p><h3 id="5-2-5-future模式"><a href="#5-2-5-future模式" class="headerlink" title="5.2.5 future模式"></a>5.2.5 future模式</h3><p>用处：子调用相互之间没有依赖，如果串行调用则耗时会很长，此时可以使用Go并发编程中的future模式</p><p>工作原理：</p><ol><li>使用chan作为函数参数</li><li>启动goroutine调用安徽省农户</li><li>通过chan传递如参数</li><li>做其他可以并行处理的事情</li><li>通过chan异步获取结果</li></ol><pre><code class="go">package mainimport (    "fmt"    "time")// 一个查询结构体// 这里的sql和result是一个简单的抽象，具体的应用可能是更复杂的数据类型type query struct {    // 参数Channel    sql chan string    // 结果Channel    result chan string}// 执行Queryfunc execQuery(q query) {    // 启动协程    go func() {        // 获取输入        sql := &lt;-q.sql        // 访问数据库        // 输出结果通道        q.result &lt;- "result from " + sql    }()}func main() {    // 初始化Query    q := query{make(chan string, 1), make(chan string, 1)}    // 执行Query，注意执行的时候无需准备参数    go execQuery(q)    // 发送参数    q.sql &lt;- "select * from table"    // 做其他事情    time.Sleep(1 * time.Second)    // 获取结果    fmt.Println(&lt;-q.result)}</code></pre><p><img src="/images/go_core_programming/Untitled%2044.png" alt="Untitled"></p><h2 id="5-3-context标准库"><a href="#5-3-context标准库" class="headerlink" title="5.3 context标准库"></a>5.3 context标准库</h2><p>Go中的goroutine之间没有父与子的关系，没有所谓的子进程退出后的通知机制，goroutine之间平行地被调度，多个goroutine如何协作工作设计通信、同步、通知和退出四个方面</p><ul><li>通信：chan通道是goroutine之间通信的基础（通信指程序的数据通道）</li><li>同步：不带缓冲的chan提供了一个天然的同步等待机制；sync.WaitGroup也为多个goroutine协同工作提供一种同步等待机制</li><li>通知：这个通知和上面通信的数据不一样，通知不是业务数据，而是管理、控制流数据。在输入端绑定两个chan，一个用于业务流数据，另一个用于异常通知数据，然后使用select收敛进行处理</li><li>退出：借助通道和select的广播机制实现退出</li></ul><h3 id="5-3-1-context的设计目的"><a href="#5-3-1-context的设计目的" class="headerlink" title="5.3.1 context的设计目的"></a>5.3.1 context的设计目的</h3><ul><li>退出通知机制：通知可以传递给整个goroutine调用树上的每一个goroutine</li><li>数据传递：数据可以传递给整个goroutine调用树上的每一个goroutine</li></ul><h3 id="5-3-2-基本数据结构"><a href="#5-3-2-基本数据结构" class="headerlink" title="5.3.2 基本数据结构"></a>5.3.2 基本数据结构</h3><p>context工作机制：第一个创建 Context goroutine被称为 root 节点。 root 节点负责创建一个实现context接口的具体对象，并将该对象作为参数传递到其新拉起的goroutine，下游的 goroutine 继续封装该对象，再传递到更下游的goroutine，Context 对象在传递的过程中最终形成一个树状的数据结构，这样通过位于 root 节点（树的根节点） Context 对象就能遍历整个 Context 对象树，通知和消息就可以通过 root 节点传递出去，实现了上游 goroutine 下游 goroutine 的消息传递。</p><p><strong>Context接口</strong></p><p>Context作为参数传递</p><p><img src="/images/go_core_programming/Untitled%2045.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2046.png" alt="Untitled"></p><p><strong>canceler接口</strong></p><p>conceler规定了取消通知的Context具体类型需要实现的接口</p><p><img src="/images/go_core_programming/Untitled%2047.png" alt="Untitled"></p><p><strong>empty Context结构</strong></p><p>实现了Context接口但不具备任何功能，其存在的目的是作为Context对象树的根（root节点）</p><p><strong>cancelCtx</strong></p><p>cancelCtx是一个实现了Context耳机口的具体类型，同时实现了conceler接口</p><p><strong>timerCtx</strong></p><p>timerCtx是一个实现了Context接口的具体类型，内部封装cancelCtx类型实例，同时有一个deadlinebianl,yonglaishixian定时退出通知</p><p><strong>valueCtx</strong></p><p>valueCtx是一个实现了Context接口的具体类型，内部封装了Context接口类型，同时封装了一个k/v的存储遍历，valueCtx可以用来传递通知信息</p><p><img src="/images/go_core_programming/Untitled%2048.png" alt="Untitled"></p><h3 id="5-3-3-API函数"><a href="#5-3-3-API函数" class="headerlink" title="5.3.3 API函数"></a>5.3.3 API函数</h3><p>以下两个函数是构造Context取消树的根节点对象，根节点对象用作后续With包装函数的实参：</p><ul><li>func Background() Context</li><li>func TODO() Context</li></ul><h3 id="5-3-6-使用Context传递数据的争议"><a href="#5-3-6-使用Context传递数据的争议" class="headerlink" title="5.3.6 使用Context传递数据的争议"></a>5.3.6 使用Context传递数据的争议</h3><p>使用context传递数据的坏处：</p><ul><li>传递的都是interface{}类型的值，编译器不能进行严格的类型校验</li><li>从interface{}到具体类型需要使用类型断言和接口查询，有一定的运行期开销和性能损失</li><li>值在传递过程中有可能被后续的服务覆盖且不易被发现</li><li>传递信息不简明。较晦涩；不能通过代码或文档一眼看到传递的是什么，不利于后续维护</li></ul><p>context应该传递什么数据：</p><ul><li>日志信息</li><li>调低是信息</li><li>不影响业务主逻辑的可选数据</li></ul><h2 id="5-4-并发模型"><a href="#5-4-并发模型" class="headerlink" title="5.4 并发模型"></a>5.4 并发模型</h2><h3 id="5-4-1-CSP简介"><a href="#5-4-1-CSP简介" class="headerlink" title="5.4.1 CSP简介"></a>5.4.1 CSP简介</h3><p>CSP基本思想：将并发系统抽象为Channel和Process两部分，Channel用来传递消息，Process用于执行，Channel和Process之间相互独立，没有从属关系，消息的发送和接收有严格的时序限制。</p><p>Go中Channel就是通道，Process就是goroutine</p><h3 id="5-4-2-调度模型"><a href="#5-4-2-调度模型" class="headerlink" title="5.4.2 调度模型"></a>5.4.2 调度模型</h3><p>协程是一种用户态的轻量级线程，写成的调度完全由用户态程序控制，协程拥有自己的寄存器上下文和栈。</p><p>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候恢复先前保存的寄存器上下文和栈，每个内核线程可以对应多个用户协程，当一个协程执行体阻塞了，调度器会调度另一个携程执行，最大效率地利用操作系统分给系统线程的时间片。</p><p>好处：</p><ul><li>控制了系统线程数，保证每个线程的运行时间片充足</li><li>调度层能进行用户态的切换，不会导致单个协程阻塞整个程序的情况，尽量减少上下文切换，提升运行效率</li></ul><p>由此可见，协程是一种非常高效、理想的执行模型。Go的并发执行模型就是一种变种的协程模型。</p><h3 id="5-4-3-并发和调度"><a href="#5-4-3-并发和调度" class="headerlink" title="5.4.3 并发和调度"></a>5.4.3 并发和调度</h3><p>goroutine好处：</p><ul><li>goroutine可以在用户空间调度，避免了内核态和用户态的切换导致的成本</li><li>goroutine是语言原生支持的，提供了非常简洁的语法，屏蔽了大部分复杂底层实现</li><li>goroutine更小的占空间允许用户创建成千上万的实例</li></ul><p>goroutinue调度模型：</p><ol><li>实体G（Goroutine）</li></ol><p>G是Go运行时对goroutine的抽象描述，G中存放并发执行的代码入口地址、上下文、运行环境（关联的P和M）、运行栈等执行相关的元信息</p><ol><li>实体M（Machine）</li></ol><p>M代表OS内核线程，是操作系统层面调度和执行的实体。M仅负责执行，M不停地被唤醒或创建，然后执行。M启动时进入的是运行时的管理代码，有这段代码获取G和P资源，然后执行调度。另外Go</p><p>语言运行时会单独创建一个监控线程，负责对程序的内存、调度等信息进行监控和控制</p><ol><li>实体P（Processor）</li></ol><p>P代表M运行G所需的资源，是对资源的一种抽象和管理，P不是一段代码实体，而是一个管理的数据结构，P主要是降低M管理调度G的复杂性，增加一个简洁的控制层数据结构。</p><p><img src="/images/go_core_programming/Untitled%2049.png" alt="Untitled"></p><p><strong>m0和g0</strong></p><p>m0和g0是启动程序后的主线程，这个m对应的信息会存放在全局变量m0种，m0负责执行初始化操作和启动第一个g，之后m0就和其他m一样了。</p><p><img src="/images/go_core_programming/Untitled%2050.png" alt="Untitled"></p><h1 id="第-7-章-语言陷阱"><a href="#第-7-章-语言陷阱" class="headerlink" title="第 7 章 语言陷阱"></a>第 7 章 语言陷阱</h1><h2 id="7-1-多值赋值和短变量声明"><a href="#7-1-多值赋值和短变量声明" class="headerlink" title="7.1 多值赋值和短变量声明"></a>7.1 多值赋值和短变量声明</h2><h3 id="7-1-1-多值赋值"><a href="#7-1-1-多值赋值" class="headerlink" title="7.1.1 多值赋值"></a>7.1.1 多值赋值</h3><p>非法：</p><p><img src="/images/go_core_programming/Untitled%2051.png" alt="Untitled"></p><p>多值赋值语义：</p><ul><li>对左侧操作数中的表达式、索引值进行计算和确定，首先确定左侧的操作数的地址，然后对右侧的赋值表达式进行计算，如果发现右侧的表达式计算引用了左侧的变量，则创建临时变量进行值拷贝，最后完成计算</li><li>从左到右的顺序依次赋值</li></ul><p>示例：</p><pre><code class="go">import (    "fmt"    "testing")func Test(t *testing.T) {    x := []int{1, 2, 3}    i := 0    i, x[i] = 1, 2    fmt.Println(i, x) // 1 [2 2 3]    x = []int{1, 2, 3}    i = 0    x[i], i = 2, 1    fmt.Println(i, x) // 1 [2 2 3]    x = []int{1, 2, 3}    i = 0    x[i], i = 2, x[i] // set tmp=x[0],x[0]=2,i=tmp ==&gt; i=1    fmt.Println(i, x) // 1 [2 2 3]    x[0], x[0] = 1, 2    fmt.Println(x[0]) // 2}</code></pre><h3 id="7-1-2-短变量的声明和赋值"><a href="#7-1-2-短变量的声明和赋值" class="headerlink" title="7.1.2 短变量的声明和赋值"></a>7.1.2 短变量的声明和赋值</h3><p>约定：</p><ul><li>使用“:=”操作符，变量的定义和初始化同时完成</li><li>变量名后不要跟任何类型名，Go编译器完全靠右边的值进行推导</li><li>支持多值短变量声明赋值</li><li>只能用在函数和类型方法的内部</li></ul><p><img src="/images/go_core_programming/Untitled%2052.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2053.png" alt="Untitled"></p><h2 id="7-2-range复用临时变量"><a href="#7-2-range复用临时变量" class="headerlink" title="7.2 range复用临时变量"></a>7.2 range复用临时变量</h2><p><img src="/images/go_core_programming/Untitled%2054.png" alt="Untitled"></p><p>结果打印的都是9，原因：</p><ul><li>for range下的迭代变量i的值是共用的</li><li>main函数所在的goiroutinue和后续启动的goroutines存在竞争关系</li></ul><p>正确写法：</p><p><img src="/images/go_core_programming/Untitled%2055.png" alt="Untitled"></p><h2 id="7-3-defer陷阱"><a href="#7-3-defer陷阱" class="headerlink" title="7.3 defer陷阱"></a>7.3 defer陷阱</h2><p>对带defer的函数返回整体上有三个步骤</p><ul><li>执行return的值拷贝，将return语句返回的值复制到函数返回值栈区（如果只有一个return，不带任何变量或值，则此步骤不做任何动作）</li><li>执行defer语句，多个defer按照FILO顺序执行</li><li>执行调整RET指令</li></ul><h2 id="7-4-切片困惑"><a href="#7-4-切片困惑" class="headerlink" title="7.4 切片困惑"></a>7.4 切片困惑</h2><h3 id="7-4-1-数组"><a href="#7-4-1-数组" class="headerlink" title="7.4.1 数组"></a>7.4.1 数组</h3><p>Go的数组是有固定个相同类型元素的数据结构，底层采用连续的内存空间存放，数组一旦声明后大小就不可改变了。</p><p>Go中的数组是一种基本类型。数组的类型不仅包括其元素类型，也包括其大小，[2]int和[5]int是两个完全不同的数组类型</p><p><img src="/images/go_core_programming/Untitled%2056.png" alt="Untitled"></p><p>数组名无论作为函数实参还是作为struct嵌入字段，或者数组之间的直接赋值都是值拷贝</p><h3 id="7-4-2-切片"><a href="#7-4-2-切片" class="headerlink" title="7.4.2 切片"></a>7.4.2 切片</h3><p><strong>切片创建</strong></p><ol><li>通过数组创建</li></ol><p>array[b:e]创建一个包括e-b个元素的切片，包含b，不包含e</p><ol><li>make</li></ol><p>make([]T, len, cap)中的T是切片元素类型，len是长度，cap是底层数组的容量。cap是可选参数</p><ol><li>直接声明</li></ol><p><img src="/images/go_core_programming/Untitled%2057.png" alt="Untitled"></p><p>切片数据结构</p><p><img src="/images/go_core_programming/Untitled%2058.png" alt="Untitled"></p><p>多个切片共享一个底层数组，其中一个切片的append操作可能引发如下两种情况：</p><ul><li>append追加的元素没有超过底层数组的容量，此种append操作会直接操作共享的底层数组，如果其他切片有引用数组被覆盖的原色，则会导致其他切片的值也会隐式地发生变化</li><li>append追加的元素加上原来的元素如果超出底层数组的容量，则此种append操作会重新申请新数组，并将原来数组的值复制到新数组</li></ul><p>由于有这种二义性，所以在使用切片过程中应该尽量避免多个切面共享底层数组，可以使用copy进行显式的复制</p><h2 id="7-5-值、指针和引用"><a href="#7-5-值、指针和引用" class="headerlink" title="7.5 值、指针和引用"></a>7.5 值、指针和引用</h2><h3 id="7-5-1-传值还是传引用"><a href="#7-5-1-传值还是传引用" class="headerlink" title="7.5.1 传值还是传引用"></a>7.5.1 传值还是传引用</h3><p>Go只有一种参数传递规则：值拷贝，含义：</p><ul><li>函数参数传递时使用的是值拷贝</li><li>实例赋值给接口变量，接口对实例的引用是值拷贝</li></ul><p>有时在明明是值拷贝的地方结果却修改了变量的内容，有以下两种情况：</p><ul><li>直接传递的是指针，指针传递同样是值拷贝，但指针和指针副本的值指向的地址是同一地方，所以能修改实参值</li><li>参数是负荷数据类型，这些复合数据类型内部有指针类型的元素，此时参数的值bi拷贝并不影响指针的指向</li></ul><h3 id="7-5-2-函数名的意义"><a href="#7-5-2-函数名的意义" class="headerlink" title="7.5.2 函数名的意义"></a>7.5.2 函数名的意义</h3><ul><li>类型信息</li><li>函数的执行代码的起始位置</li><li>可以通过函数名进行函数调用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go-Core-Programming&quot;&gt;&lt;a href=&quot;#Go-Core-Programming&quot; class=&quot;headerlink&quot; title=&quot;Go Core Programming&quot;&gt;&lt;/a&gt;Go Core Programming&lt;/h1&gt;&lt;h1 i</summary>
      
    
    
    
    
    <category term="Go" scheme="https://zhangzhishun.github.io/tags/Go/"/>
    
  </entry>
  
</feed>
