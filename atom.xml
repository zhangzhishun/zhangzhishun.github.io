<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sugar&#39;s blog</title>
  
  <subtitle>一杯糖不加咖啡 Sugar 区块链博客 计算机博客</subtitle>
  <link href="https://zhangzhishun.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhangzhishun.github.io/"/>
  <updated>2022-05-05T08:53:39.108Z</updated>
  <id>https://zhangzhishun.github.io/</id>
  
  <author>
    <name>Sugar</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Solidity学习笔记(基础部分)</title>
    <link href="https://zhangzhishun.github.io/2022/05/05/blockchain/ethereum/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://zhangzhishun.github.io/2022/05/05/blockchain/ethereum/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-05-05T11:29:23.000Z</published>
    <updated>2022-05-05T08:53:39.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Solidity学习笔记-基础部分"><a href="#Solidity学习笔记-基础部分" class="headerlink" title="Solidity学习笔记(基础部分)"></a>Solidity学习笔记(基础部分)</h1><p>本文参考：<a href="https://solidity-by-example.org/">https://solidity-by-example.org/</a></p><p>推荐视频课程：<a href="https://www.bilibili.com/video/BV1St411a7Pk">https://www.bilibili.com/video/BV1St411a7Pk</a></p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><pre><code class="solidity">// SPDX-License-Identifier: MIT// compiler version must be greater than or equal to 0.8.13 and less than 0.9.0pragma solidity ^0.8.13;contract HelloWorld {    string public greet = "Hello World!";}</code></pre><h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><p>这是一个简单的合约，用于获取、增加、减少账户余额</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Counter {    uint public count;    // Function to get the current count    function get() public view returns (uint) {        return count;    }    // Function to increment count by 1    function inc() public {        count += 1;    }    // Function to decrement count by 1    function dec() public {        // This function will fail if count = 0        count -= 1;    }}</code></pre><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>在这里介绍四种数据类型：</p><ul><li>boolean</li><li>uint</li><li>int</li><li>address</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Primitives {    bool public boo = true;    /*    uint stands for unsigned integer, meaning non negative integers    different sizes are available        uint8   ranges from 0 to 2 ** 8 - 1        uint16  ranges from 0 to 2 ** 16 - 1        ...        uint256 ranges from 0 to 2 ** 256 - 1    */    uint8 public u8 = 1;    uint public u256 = 456;    uint public u = 123; // uint is an alias for uint256    /*    Negative numbers are allowed for int types.    Like uint, different ranges are available from int8 to int256        int256 ranges from -2 ** 255 to 2 ** 255 - 1    int128 ranges from -2 ** 127 to 2 ** 127 - 1    */    int8 public i8 = -1;    int public i256 = 456;    int public i = -123; // int is same as int256    // minimum and maximum of int    int public minInt = type(int).min;    int public maxInt = type(int).max;    address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;    /*    In Solidity, the data type byte represent a sequence of bytes.     Solidity presents two type of bytes types :     - fixed-sized byte arrays     - dynamically-sized byte arrays.          The term bytes in Solidity represents a dynamic array of bytes.      It’s a shorthand for byte[] .    */    bytes1 a = 0xb5; //  [10110101]    bytes1 b = 0x56; //  [01010110]    // Default values    // Unassigned variables have a default value    bool public defaultBoo; // false    uint public defaultUint; // 0    int public defaultInt; // 0    address public defaultAddr; // 0x0000000000000000000000000000000000000000}</code></pre><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>Solidity 中有 3 种类型的变量</p><ul><li>local<ul><li>函数内定义</li><li>不存储在区块链</li></ul></li><li>state<ul><li>函数外定义</li><li>存储在区块链</li></ul></li><li>global (保存区块链的信息)</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Variables {    // State variables are stored on the blockchain.    string public text = "Hello";    uint public num = 123;    function doSomething() public {        // Local variables are not saved to the blockchain.        uint i = 456;        // Here are some global variables        uint timestamp = block.timestamp; // Current block timestamp        address sender = msg.sender; // address of the caller    }}</code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是不能被修改的</p><p>它们的值是硬编码的，使用常量可以节省 gas 成本</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Constants {    // coding convention to uppercase constant variables    address public constant MY_ADDRESS = 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc;    uint public constant MY_UINT = 123;}</code></pre><h2 id="不可变变量"><a href="#不可变变量" class="headerlink" title="不可变变量"></a>不可变变量</h2><p>不可变变量就像常量。不可变变量的值可以在构造函数中设置，但之后不能修改。</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Immutable {    // coding convention to uppercase constant variables    address public immutable MY_ADDRESS;    uint public immutable MY_UINT;    constructor(uint _myUint) {        MY_ADDRESS = msg.sender;        MY_UINT = _myUint;    }}</code></pre><h2 id="读取和写入状态变量"><a href="#读取和写入状态变量" class="headerlink" title="读取和写入状态变量"></a>读取和写入状态变量</h2><p>要写入或更新状态变量，您需要发送交易</p><p>但是您可以免费读取状态变量，无需任何交易费用</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract SimpleStorage {    // State variable to store a number    uint public num;    // You need to send a transaction to write to a state variable.    function set(uint _num) public {        num = _num;    }    // You can read from a state variable without sending a transaction.    function get() public view returns (uint) {        return num;    }}</code></pre><h2 id="以太坊单位：Ether-and-Wei"><a href="#以太坊单位：Ether-and-Wei" class="headerlink" title="以太坊单位：Ether and Wei"></a>以太坊单位：Ether and Wei</h2><p>交易使用以太币支付，类似于一美元等于 100 美分，1eth等于 10^18wei</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract EtherUnits {    uint public oneWei = 1 wei;    // 1 wei is equal to 1    bool public isOneWei = 1 wei == 1;    uint public oneEther = 1 ether;    // 1 ether is equal to 10^18 wei    bool public isOneEther = 1 ether == 1e18;}</code></pre><h2 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h2><ol><li><p>一次交易需要支付多少eth？</p><p>您支付的 gas spent * gas price 的eth数量，其中：</p><ul><li>gas是一个计算单位</li><li>gas花费是交易中使用的 gas 总量</li><li>gas price是您愿意为每 gas 支付多少 ether </li></ul><p>具有更高 gas 价格的交易有更高的优先级被包含在一个块中，未使用的Gas将被退还</p></li><li><p>Gas限制</p><p>您可以花费的 gas 量有 2 个上限：</p><ul><li>gas limit（您愿意为交易使用的最大 gas 量，由您设置）</li><li>块 gas 限制（一个块中允许的最大 gas 量，由区块链网络设置）</li></ul></li></ol><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Gas {    uint public i = 0;    // Using up all of the gas that you send causes your transaction to fail.    // State changes are undone.    // Gas spent are not refunded.    function forever() public {        // Here we run a loop until all of the gas are spent        // and the transaction fails        while (true) {            i += 1;        }    }}</code></pre><h2 id="If-Else"><a href="#If-Else" class="headerlink" title="If / Else"></a>If / Else</h2><p>Solidity 支持条件语句 if、else if 和 else</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract IfElse {    function foo(uint x) public pure returns (uint) {        if (x &lt; 10) {            return 0;        } else if (x &lt; 20) {            return 1;        } else {            return 2;        }    }    function ternary(uint _x) public pure returns (uint) {        // if (_x &lt; 10) {        //     return 1;        // }        // return 2;        // shorthand way to write if / else statement        return _x &lt; 10 ? 1 : 2;    }}</code></pre><h2 id="For、While循环"><a href="#For、While循环" class="headerlink" title="For、While循环"></a>For、While循环</h2><p>Solidity 支持 for、while 和 do while 循环，不要编写无界循环，因为这可能会达到 gas 限制，导致您的交易失败</p><p>由于上述原因，很少使用 while 和 do while 循环</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Loop {    function loop() public {        // for loop        for (uint i = 0; i &lt; 10; i++) {            if (i == 3) {                // Skip to next iteration with continue                continue;            }            if (i == 5) {                // Exit loop with break                break;            }        }        // while loop        uint j;        while (j &lt; 10) {            j++;        }    }}</code></pre><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>Mapping是使用语法映射（keyType =&gt; valueType）创建的</p><p>keyType可以是任何内置值类型、字节、字符串或合约地址</p><p>valueType可以是任何类型，包括另一个Mapping或数组</p><p>Mappings不可迭代</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Mapping {    // Mapping from address to uint    mapping(address =&gt; uint) public myMap;    function get(address _addr) public view returns (uint) {        // Mapping always returns a value.        // If the value was never set, it will return the default value.        return myMap[_addr];    }    function set(address _addr, uint _i) public {        // Update the value at this address        myMap[_addr] = _i;    }    function remove(address _addr) public {        // Reset the value to the default value.        delete myMap[_addr];    }}contract NestedMapping {    // Nested mapping (mapping from address to another mapping)    mapping(address =&gt; mapping(uint =&gt; bool)) public nested;    function get(address _addr1, uint _i) public view returns (bool) {        // You can get values from a nested mapping        // even when it is not initialized        return nested[_addr1][_i];    }    function set(        address _addr1,        uint _i,        bool _boo    ) public {        nested[_addr1][_i] = _boo;    }    function remove(address _addr1, uint _i) public {        delete nested[_addr1][_i];    }}</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组可以具有编译时固定大小或动态大小</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Array {    // Several ways to initialize an array    uint[] public arr;    uint[] public arr2 = [1, 2, 3];    // Fixed sized array, all elements initialize to 0    uint[10] public myFixedSizeArr;    function get(uint i) public view returns (uint) {        return arr[i];    }    // Solidity can return the entire array.    // But this function should be avoided for    // arrays that can grow indefinitely in length.    function getArr() public view returns (uint[] memory) {        return arr;    }    function push(uint i) public {        // Append to array        // This will increase the array length by 1.        arr.push(i);    }    function pop() public {        // Remove last element from array        // This will decrease the array length by 1        arr.pop();    }    function getLength() public view returns (uint) {        return arr.length;    }    function remove(uint index) public {        // Delete does not change the array length.        // It resets the value at index to it's default value,        // in this case 0        delete arr[index];    }    function examples() external {        // create array in memory, only fixed size can be created        uint[] memory a = new uint[](5);    }}</code></pre><h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><p>Solidity 支持枚举，它们对于跟踪状态很有用。枚举可以在合约之外声明</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Enum {    // Enum representing shipping status    enum Status {        Pending,        Shipped,        Accepted,        Rejected,        Canceled    }    // Default value is the first element listed in    // definition of the type, in this case "Pending"    Status public status;    // Returns uint    // Pending  - 0    // Shipped  - 1    // Accepted - 2    // Rejected - 3    // Canceled - 4    function get() public view returns (Status) {        return status;    }    // Update status by passing uint into input    function set(Status _status) public {        status = _status;    }    // You can update to a specific enum like this    function cancel() public {        status = Status.Canceled;    }    // delete resets the enum to its first value, 0    function reset() public {        delete status;    }}</code></pre><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>您可以通过创建结构体来定义自己的类型</p><p>它们对于将相关数据组合在一起很有用</p><p>结构体可以在合约之外声明并在另一个合约中导入</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Todos {    struct Todo {        string text;        bool completed;    }    // An array of 'Todo' structs    Todo[] public todos;    function create(string memory _text) public {        // 3 ways to initialize a struct        // - calling it like a function        todos.push(Todo(_text, false));        // key value mapping        todos.push(Todo({text: _text, completed: false}));        // initialize an empty struct and then update it        Todo memory todo;        todo.text = _text;        // todo.completed initialized to false        todos.push(todo);    }    // Solidity automatically created a getter for 'todos' so    // you don't actually need this function.    function get(uint _index) public view returns (string memory text, bool completed) {        Todo storage todo = todos[_index];        return (todo.text, todo.completed);    }    // update text    function update(uint _index, string memory _text) public {        Todo storage todo = todos[_index];        todo.text = _text;    }    // update completed    function toggleCompleted(uint _index) public {        Todo storage todo = todos[_index];        todo.completed = !todo.completed;    }}</code></pre><h2 id="数据存储位置"><a href="#数据存储位置" class="headerlink" title="数据存储位置"></a>数据存储位置</h2><p>变量被声明为 storage、memory 或 calldata 以明确指定数据的位置：</p><ul><li>storage：变量是状态变量（存储在区块链上）</li><li>memory：变量在内存中，在调用函数时存在，在声明要存储在内存中（临时）的变量（函数参数以及函数内部的逻辑）时应使用memory</li><li>calldata：一个不可修改、非持久性的区域，用于存储函数参数。在声明外部函数的动态参数时必须使用 calldata，calldata 是存储函数参数的不可修改、非持久性区域</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract DataLocations {    uint[] public arr;    mapping(uint =&gt; address) map;    struct MyStruct {        uint foo;    }    mapping(uint =&gt; MyStruct) myStructs;    function f() public {        // call _f with state variables        _f(arr, map, myStructs[1]);        // get a struct from a mapping        MyStruct storage myStruct = myStructs[1];        // create a struct in memory        MyStruct memory myMemStruct = MyStruct(0);    }    function _f(        uint[] storage _arr,        mapping(uint =&gt; address) storage _map,        MyStruct storage _myStruct    ) internal {        // do something with storage variables    }    // You can return memory variables    function g(uint[] memory _arr) public returns (uint[] memory) {        // do something with memory array    }    function h(uint[] calldata _arr) external {        // do something with calldata array    }}</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>有几种方法可以从函数中输出</p><p>公共函数不能接受某些数据类型作为输入或输出(例如Mapping)</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Function {    // Functions can return multiple values.    function returnMany()        public        pure        returns (            uint,            bool,            uint        )    {        return (1, true, 2);    }    // Return values can be named.    function named()        public        pure        returns (            uint x,            bool b,            uint y        )    {        return (1, true, 2);    }    // Return values can be assigned to their name.    // In this case the return statement can be omitted.    function assigned()        public        pure        returns (            uint x,            bool b,            uint y        )    {        x = 1;        b = true;        y = 2;    }    // Use destructuring assignment when calling another    // function that returns multiple values.    function destructuringAssignments()        public        pure        returns (            uint,            bool,            uint,            uint,            uint        )    {        (uint i, bool b, uint j) = returnMany();        // Values can be left out.        (uint x, , uint y) = (4, 5, 6);        return (i, b, j, x, y);    }    // Cannot use map for either input or output    // Can use array for input    function arrayInput(uint[] memory _arr) public {}    // Can use array for output    uint[] public arr;    function arrayOutput() public view returns (uint[] memory) {        return arr;    }}</code></pre><h2 id="View、Pure修饰函数"><a href="#View、Pure修饰函数" class="headerlink" title="View、Pure修饰函数"></a>View、Pure修饰函数</h2><p>Getter功能的函数可以声明为 view 或 pure</p><p>View 函数声明不会更改状态</p><p>Pure 函数声明不会更改或读取任何状态变量</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract ViewAndPure {    uint public x = 1;    // Promise not to modify the state.    function addToX(uint y) public view returns (uint) {        return x + y;    }    // Promise not to modify or read from the state.    function add(uint i, uint j) public pure returns (uint) {        return i + j;    }}</code></pre><h2 id="Error异常"><a href="#Error异常" class="headerlink" title="Error异常"></a>Error异常</h2><p>Error异常将撤消事务期间对状态所做的所有更改</p><p>您可以通过调用 require、revert 或 assert 来抛出异常</p><ul><li><p>require用于在执行之前验证输入和条件</p></li><li><p>revert 类似于 require，有关详细信息，请参阅下面的代码</p></li><li><p>assert 用于检查不应为假的代码。断言失败可能意味着存在Bug</p></li></ul><p>使用自定义错误来节省Gas</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Error {    function testRequire(uint _i) public pure {        // Require should be used to validate conditions such as:        // - inputs        // - conditions before execution        // - return values from calls to other functions        require(_i &gt; 10, "Input must be greater than 10");    }    function testRevert(uint _i) public pure {        // Revert is useful when the condition to check is complex.        // This code does the exact same thing as the example above        if (_i &lt;= 10) {            revert("Input must be greater than 10");        }    }    uint public num;    function testAssert() public view {        // Assert should only be used to test for internal errors,        // and to check invariants.        // Here we assert that num is always equal to 0        // since it is impossible to update the value of num        assert(num == 0);    }    // custom error    error InsufficientBalance(uint balance, uint withdrawAmount);    function testCustomError(uint _withdrawAmount) public view {        uint bal = address(this).balance;        if (bal &lt; _withdrawAmount) {            revert InsufficientBalance({balance: bal, withdrawAmount: _withdrawAmount});        }    }}</code></pre><h2 id="Modifier函数"><a href="#Modifier函数" class="headerlink" title="Modifier函数"></a>Modifier函数</h2><p>Modifier是可以在函数调用之前和/或之后运行的代码</p><p>Modifier可用于：</p><ul><li>限制访问</li><li>验证输入</li><li>防止重入黑客攻击</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract FunctionModifier {    // We will use these variables to demonstrate how to use    // modifiers.    address public owner;    uint public x = 10;    bool public locked;    constructor() {        // Set the transaction sender as the owner of the contract.        owner = msg.sender;    }    // Modifier to check that the caller is the owner of    // the contract.    modifier onlyOwner() {        require(msg.sender == owner, "Not owner");        // Underscore is a special character only used inside        // a function modifier and it tells Solidity to        // execute the rest of the code.        _;    }    // Modifiers can take inputs. This modifier checks that the    // address passed in is not the zero address.    modifier validAddress(address _addr) {        require(_addr != address(0), "Not valid address");        _;    }    function changeOwner(address _newOwner) public onlyOwner validAddress(_newOwner) {        owner = _newOwner;    }    // Modifiers can be called before and / or after a function.    // This modifier prevents a function from being called while    // it is still executing.    modifier noReentrancy() {        require(!locked, "No reentrancy");        locked = true;        _;        locked = false;    }    function decrement(uint i) public noReentrancy {        x -= i;        if (i &gt; 1) {            decrement(i - 1);        }    }}</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件允许记录日志到以太坊区块链</p><p>事件的一些用例是：</p><ul><li>监听事件和更新用户界面</li><li>一种廉价的存储形式</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Event {    // Event declaration    // Up to 3 parameters can be indexed.    // Indexed parameters helps you filter the logs by the indexed parameter    event Log(address indexed sender, string message);    event AnotherLog();    function test() public {        emit Log(msg.sender, "Hello World!");        emit Log(msg.sender, "Hello EVM!");        emit AnotherLog();    }}</code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造函数是在创建合约时执行的可选函数</p><p>以下是如何将参数传递给构造函数的示例</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;// Base contract Xcontract X {    string public name;    constructor(string memory _name) {        name = _name;    }}// Base contract Ycontract Y {    string public text;    constructor(string memory _text) {        text = _text;    }}// There are 2 ways to initialize parent contract with parameters.// Pass the parameters here in the inheritance list.contract B is X("Input to X"), Y("Input to Y") {}contract C is X, Y {    // Pass the parameters here in the constructor,    // similar to function modifiers.    constructor(string memory _name, string memory _text) X(_name) Y(_text) {}}// Parent constructors are always called in the order of inheritance// regardless of the order of parent contracts listed in the// constructor of the child contract.// Order of constructors called:// 1. X// 2. Y// 3. Dcontract D is X, Y {    constructor() X("X was called") Y("Y was called") {}}// Order of constructors called:// 1. X// 2. Y// 3. Econtract E is X, Y {    constructor() Y("Y was called") X("X was called") {}}</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Solidity 支持多重继承</p><p>合约可以使用is关键字继承其他合约</p><p>要被子合约覆盖的函数必须声明为virtual</p><p>要覆盖父函数的函数必须使用关键字override</p><p>继承的顺序很重要</p><p>你必须按照从“最基础”到“最衍生”（“most base-like” to “most derived”）的顺序列出父合约</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;/* Graph of inheritance    A   / \  B   C / \ /F  D,E*/contract A {    function foo() public pure virtual returns (string memory) {        return "A";    }}// Contracts inherit other contracts by using the keyword 'is'.contract B is A {    // Override A.foo()    function foo() public pure virtual override returns (string memory) {        return "B";    }}contract C is A {    // Override A.foo()    function foo() public pure virtual override returns (string memory) {        return "C";    }}// Contracts can inherit from multiple parent contracts.// When a function is called that is defined multiple times in// different contracts, parent contracts are searched from// right to left, and in depth-first manner.contract D is B, C {    // D.foo() returns "C"    // since C is the right most parent contract with function foo()    function foo() public pure override(B, C) returns (string memory) {        return super.foo();    }}contract E is C, B {    // E.foo() returns "B"    // since B is the right most parent contract with function foo()    function foo() public pure override(C, B) returns (string memory) {        return super.foo();    }}// Inheritance must be ordered from “most base-like” to “most derived”.// Swapping the order of A and B will throw a compilation error.contract F is A, B {    function foo() public pure override(A, B) returns (string memory) {        return super.foo();    }}</code></pre><h2 id="覆盖继承的合约状态变量"><a href="#覆盖继承的合约状态变量" class="headerlink" title="覆盖继承的合约状态变量"></a>覆盖继承的合约状态变量</h2><p>与函数不同，状态变量不能通过在子合约中重新声明来覆盖</p><p>让我们学习如何正确覆盖继承的状态变量</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract A {    string public name = "Contract A";    function getName() public view returns (string memory) {        return name;    }}// Shadowing is disallowed in Solidity 0.6// This will not compile// contract B is A {//     string public name = "Contract B";// }contract C is A {    // This is the correct way to override inherited state variables.    constructor() {        name = "Contract C";    }    // C.getName returns "Contract C"}</code></pre><h2 id="调用父合约"><a href="#调用父合约" class="headerlink" title="调用父合约"></a>调用父合约</h2><p>可以直接调用父合约，也可以使用关键字 super 调用</p><p>使用关键字 super 会调用所有的直接父合约</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;/* Inheritance tree   A /  \B   C \ /  D*/contract A {    // This is called an event. You can emit events from your function    // and they are logged into the transaction log.    // In our case, this will be useful for tracing function calls.    event Log(string message);    function foo() public virtual {        emit Log("A.foo called");    }    function bar() public virtual {        emit Log("A.bar called");    }}contract B is A {    function foo() public virtual override {        emit Log("B.foo called");        A.foo();    }    function bar() public virtual override {        emit Log("B.bar called");        super.bar();    }}contract C is A {    function foo() public virtual override {        emit Log("C.foo called");        A.foo();    }    function bar() public virtual override {        emit Log("C.bar called");        super.bar();    }}contract D is B, C {    // Try:    // - Call D.foo and check the transaction logs.    //   Although D inherits A, B and C, it only called C and then A.    // - Call D.bar and check the transaction logs    //   D called C, then B, and finally A.    //   Although super was called twice (by B and C) it only called A once.    function foo() public override(B, C) {        super.foo();    }    function bar() public override(B, C) {        super.bar();    }}</code></pre><h2 id="变量可见约束"><a href="#变量可见约束" class="headerlink" title="变量可见约束"></a>变量可见约束</h2><p>函数和状态变量必须声明它们是否可以被其他合约访问</p><p>函数可以声明为：</p><ul><li><p>public：任何合约和账户都可以调用</p></li><li><p>private：只在定义函数的合约内部</p></li><li><p>internal：仅继承内部函数的内部合约</p></li><li><p>external：只有其他合约和账户可以调用</p></li></ul><p>状态变量可以声明为公共的、私有的或内部的，但不能声明为外部的</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Base {    // Private function can only be called    // - inside this contract    // Contracts that inherit this contract cannot call this function.    function privateFunc() private pure returns (string memory) {        return "private function called";    }    function testPrivateFunc() public pure returns (string memory) {        return privateFunc();    }    // Internal function can be called    // - inside this contract    // - inside contracts that inherit this contract    function internalFunc() internal pure returns (string memory) {        return "internal function called";    }    function testInternalFunc() public pure virtual returns (string memory) {        return internalFunc();    }    // Public functions can be called    // - inside this contract    // - inside contracts that inherit this contract    // - by other contracts and accounts    function publicFunc() public pure returns (string memory) {        return "public function called";    }    // External functions can only be called    // - by other contracts and accounts    function externalFunc() external pure returns (string memory) {        return "external function called";    }    // This function will not compile since we're trying to call    // an external function here.    // function testExternalFunc() public pure returns (string memory) {    //     return externalFunc();    // }    // State variables    string private privateVar = "my private variable";    string internal internalVar = "my internal variable";    string public publicVar = "my public variable";    // State variables cannot be external so this code won't compile.    // string external externalVar = "my external variable";}contract Child is Base {    // Inherited contracts do not have access to private functions    // and state variables.    // function testPrivateFunc() public pure returns (string memory) {    //     return privateFunc();    // }    // Internal function call be called inside child contracts.    function testInternalFunc() public pure override returns (string memory) {        return internalFunc();    }}</code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>您可以通过声明接口与其他合约交互</p><p>接口：</p><ul><li>不能实现任何函数</li><li>可以从其他接口继承</li><li>所有声明的函数必须是外部的</li><li>不能声明构造函数</li><li>不能声明状态变量</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Counter {    uint public count;    function increment() external {        count += 1;    }}interface ICounter {    function count() external view returns (uint);    function increment() external;}contract MyContract {    function incrementCounter(address _counter) external {        ICounter(_counter).increment();    }    function getCount(address _counter) external view returns (uint) {        return ICounter(_counter).count();    }}// Uniswap exampleinterface UniswapV2Factory {    function getPair(address tokenA, address tokenB)        external        view        returns (address pair);}interface UniswapV2Pair {    function getReserves()        external        view        returns (            uint112 reserve0,            uint112 reserve1,            uint32 blockTimestampLast        );}contract UniswapExample {    address private factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;    address private dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;    address private weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;    function getTokenReserves() external view returns (uint, uint) {        address pair = UniswapV2Factory(factory).getPair(dai, weth);        (uint reserve0, uint reserve1, ) = UniswapV2Pair(pair).getReserves();        return (reserve0, reserve1);    }}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Solidity学习笔记-基础部分&quot;&gt;&lt;a href=&quot;#Solidity学习笔记-基础部分&quot; class=&quot;headerlink&quot; title=&quot;Solidity学习笔记(基础部分)&quot;&gt;&lt;/a&gt;Solidity学习笔记(基础部分)&lt;/h1&gt;&lt;p&gt;本文参考：&lt;a </summary>
      
    
    
    
    
    <category term="Ethereum" scheme="https://zhangzhishun.github.io/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>IPFS and Friends: A Qualitative Comparison of Next Generation Peer-to-Peer Data Networks</title>
    <link href="https://zhangzhishun.github.io/2022/04/28/distributed_storage/IPFS%20and%20Friends:%20A%20Qualitative%20Comparison%20of%20Next%20Generation%20Peer-to-Peer%20Data%20Networks/"/>
    <id>https://zhangzhishun.github.io/2022/04/28/distributed_storage/IPFS%20and%20Friends:%20A%20Qualitative%20Comparison%20of%20Next%20Generation%20Peer-to-Peer%20Data%20Networks/</id>
    <published>2022-04-28T12:43:09.000Z</published>
    <updated>2022-05-05T09:55:03.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在本文中，我们将对下一代数据网络进行技术概述。我们使用选定的数据网络来介绍一般概念和强调新的发展。具体来说，我们提供了IPFS的更深层次的概述，以及Swarm、Hypercore Protocol、SAFE、Storj和Arweave的总体概述。我们确定常见的构建模块，并提供定性比较。从概述中，我们得出了未来关于数据网络的挑战和研究目标。</p><h2 id="I-概述"><a href="#I-概述" class="headerlink" title="I. 概述"></a>I. 概述</h2><p>集中式控制和治理会导致数据孤岛，这可能会影响可访问性、可用性和机密性。例如，数据访问可能会受到审查。与此同时，数据孤岛为数据泄露和数据出售提供了一个有价值的目标，这可能会危及安全和隐私。一般来说，用户会失去自己的控制权，并将其委托给云提供商。</p><p>打破数据竖井和减少信任假设的一个方向是点对点数据网络。这个术语概括了建立在点对点(P2P)网络之上的一系列数据存储方法，包括数据存储、复制、分发和交换等方面。作为典型的P2P网络，对等点可以直接交互，建立覆盖网络，共享资源，并可以做出自治的本地决策。因此，P2P数据网络努力共同管理和共享存储。虽然P2P网络的主要目标和原则在过去二十年中没有改变，但P2P网络随着时间的推移不断发展，提高了可用性和功能。在图1中，我们展示了从第一代到下一代数据网络的发展。</p><p><img src="/images/distributed_storage/image-20220428142211126.png" alt="image-20220428142211126"></p><p>图1 下一代P2P数据网络的先驱技术</p><h3 id="A-第一代数据网络"><a href="#A-第一代数据网络" class="headerlink" title="A. 第一代数据网络"></a>A. 第一代数据网络</h3><p>还有许多不同的旧P2P网络也可以归类为数据网络。1999年随着音频文件共享网络Napster的出现，P2P技术开始流行起来，紧随其后的是Gnutella，它可以共享所有类型的文件。Napster和Gnutella标志着P2P网络的开始，随后出现了许多专注于特定应用领域或新颖网络结构的P2P网络。例如Freenet实现了匿名存储和检索。Chord， CAN和Pastry提供了维护结构化覆盖网络拓扑的协议。特别是BitTorrent受到了用户和研究社区的广泛关注。BitTorrent引入了激励机制来实现帕累托效率，试图提高网络利用率，实现更高水平的鲁棒性。我们认为Napster、Gnutella、Freenet、BitTorrent等网络是第一代P2P数据网络，主要关注文件共享。</p><p>Androutsellis Theotokis和Spinellis提供了P2P内容分发技术的2004年发展概况——提供了对上一代技术的广泛概述。以前的其他工作也提供了对上一代的更仔细的研究，更密切地关注特定的P2P数据网络(例如，FreeNet和Past)或一般的分布式文件系统(例如，Google FS和Hadoop Distributed FS)。</p><p>P2P技术的进步和第一代数据网络的普及，影响了分布式文件系统和内容分发技术的领域。这种趋势也属于一般的数据网络，特别是P2P数据网络。</p><h3 id="B-Transistion阶段"><a href="#B-Transistion阶段" class="headerlink" title="B. Transistion阶段"></a>B. Transistion阶段</h3><p>在P2P文件共享系统中似乎缺失的一个组件是改善文件的长期存储和可用性的方法。随着2008年比特币的引入，P2P思想，特别是联合数据复制得到了新的关注。分布式分类账技术在分布式系统中提供可用性、完整性和复杂的容错能力。特别是，加密货币显示了其在去中心化环境中作为货币激励机制的潜力。这些以及其他的趋势和发展，例如Kademlia和信息中心网络，导致了我们称之为下一代P2P数据网络的发明。</p><h3 id="C-下一代数据网络"><a href="#C-下一代数据网络" class="headerlink" title="C.下一代数据网络"></a>C.下一代数据网络</h3><p>从2014年IPFS的引入开始，我们将下一代数据网络定义为分散共享和存储数据的系统和概念，这是在过去十年中出现的。我们提供下一代P2P数据网络的技术概述。与现有文献相比，我们提供了下一代数据网络，即P2P数据网络的比较概述。我们主要关注独立于区块链的使用的存储和内容共享。<br>在本文中，我们将展示这些新系统是如何构建的，它们如何利用从以前的系统中获得的知识，以及过去十年中新的发展和进步。我们确定这些系统的构建模块、相似性和趋势。虽然有些系统本身是其他应用程序的构建块，例如去中心化应用程序(DApps)，但我们主要关注系统的两个方面:内容分发和分布式存储。此外，我们还提供了激励机制的见解，用于检索或存储文件，或两者兼而有之。由于许多新的数据网络被开发，我们不能提供所有数据网络的全面概述。相反，我们将重点关注几个精选的系统，它们具有复杂或独特的机制、不同的用例以及不同程度的内容和用户隐私。我们的概述侧重于概念和实现细节的抽象，以提取一般的见解。然而，应该指出的是，由于正在进行的开发，系统很容易发生变化。我们的调查论文使用了广泛的来源，包括同行评议的论文、白皮书以及文档、规范和源代码。<br>具体来说，我们关注IPFS、Swarm、Hypercore Protocol、SAFE、Storj和Arweave。特别是IPFS(InterPlanetary File System, IPFS)作为区块链的存储层已经得到了广泛的应用，并成为了一系列研究的对象。此外，我们将这些系统的概述放在前面的系统和研究方向，即BitTorrent、信息中心网络和区块链。通过对比先驱系统，我们概述了数据网络的演变，并能够深入讨论下一代的进展。<br>在此基础上，我们提取了P2P数据网络的构建块和一些独特的方面。虽然所有的系统都允许分布式内容共享和存储，但它们似乎只关注其中的一个方面。也就是说，每个系统的目标都是服务于具有不同需求和关注点的略有不同的目的。这导致了在网络组织、文件查找、分散程度、冗余和隐私方面的不同设计决策。例如，Storj的目标是分布式云存储，而Hypercore协议则专注于分布式大型数据集。同样，IPFS的目标是取代web的客户端-服务器结构，因此需要比BitTorrent更关注数据查找，因为BitTorrent主要是每个文件都位于自己的覆盖网络中。同时，我们在构建数据网络的方法上发现了许多相似之处，例如，使用Kademlia来构建网络或寻找对等点，将文件分割成块，或激励不同的任务来增加功能。<br>其他关于下一代数据网络的研究尤其关注与区块链的交互。Huang等人主要涵盖了IPFS和Swarm, Benisi等人讨论了这些技术，更侧重于区块链方面。Casino等人仔细研究了去中心化存储的不变性及其后果和可能的威胁。然而，由于可伸缩性或延迟问题，一些数据网络明确决定不使用区块链。因此，在我们的调查论文中，我们对数据网络采取了更广泛的视角，着眼于区块链以外的数据网络的设计决策。<br>Naik和Keshavamurthy对最近的P2P网络给出了一个更普遍的观点。他们描述了下一个层次的P2P网络，像BitTorrent和Chord这样的经典网络的演变，并讨论了动荡下的性能方面。值得注意的是，他们对下一级网络的定义与我们的下一代网络的定义不同，因为他们将IPFS定义为“经典的P2P网络”。相反，我们认为，P2P数据网络是随着时间的推移而演变的，融合了新建立的领域的想法，例如，明确的激励机制。</p><h2 id="II-技术介绍"><a href="#II-技术介绍" class="headerlink" title="II. 技术介绍"></a>II. 技术介绍</h2><p>自P2P数据网络首次出现以来，已经过去了20多年。在此期间，这项技术不断发展，并影响了新网络的发展。我们观察到，基本上有三个“时代”的P2P数据网络:它开始于1999-2002年的P2P文件共享和网络，如BitTorrent和Kademlia，我们认为这是第一代。这个时代之后是一个“过渡阶段”，以信息为中心的网络和加密货币等新想法出现了。大约自2014年IPFS的发明以来，我们看到了新一代P2P数据网络的发展。为了更好地理解和欣赏这些影响，我们介绍了奠定基础的重要“先驱”技术，即BitTorrent、Kademlia、Information-Centric Networking、Self-Certifying Names和区块链。</p><h3 id="A-BitTorrent"><a href="#A-BitTorrent" class="headerlink" title="A. BitTorrent"></a>A. BitTorrent</h3><p>BitTorrent协议[6]是一种P2P文件共享协议。它有一个激励结构来控制下载行为，试图实现资源的公平消耗。BitTorrent的目标是提供一种比使用单一服务器更有效的方式来分发文件。这是通过在每次下载时复制文件这一事实实现的，从而使文件分发具有自伸缩性(self-scalable)。<br>文件以种子形式交换。一般来说，每个种子是一个P2P覆盖网络负责一个文件。为了用BitTorrent协议交换文件，需要创建一个.torrent类型的文件，其中包含文件的元数据和一个跟踪器(tracker)。也可以在一个.torrent文件中定义多个文件。种子文件需要被提供，例如，在网络服务器上，文件可以被共享。跟踪器作为种子的引导节点。具有完整文件的对等点称为种子点。仍然没有命中数据块的节点被称为leechers。leecher请求数据块，并同时作为已经下载的块的下载点。<br>BitTorrent如何处理文件的概念概述见图2。角色和他们的交互如下:一个对等体获得.torrent文件，联系.torrent文件中列出的tracker 𝑇，获得一个对等体列表，连接到对等体，成为一个leecher。在图中，对等体𝑆0作为文件的种子，而对等体𝐿𝑖代表请求不同块的leecher。如.torrent文件所示，该文件被分割为𝑐𝑗块。当leecher成功地获得了所有的块后，它就变成了一颗新的种子。Seed𝑆0和leechers为文件建立了torrent网络。其他文件分布在不同的种子网络与可能不同的对等。</p><p><img src="/images/distributed_storage/image-20220428145010491.png" alt="image-20220428145010491">除了集中呈现的跟踪器，还有无跟踪的种子(trackerless torrents)。在无跟踪torrent中，种子是通过一个分布式哈希表(DHT)找到的。客户端从torrent文件中获取密钥，DHT返回可用的torrent对等点列表。BitTorrent客户端可以使用预先确定的节点或由torrent文件提供的节点来引导DHT。<br>使BitTorrent独一无二(可能是成功的)的特性是明确激励对等点交换数据，这是在文件共享策略中最稀有的部分首先和tit-for-tat实现的。最稀有的部分首先描述了BitTorrent的区块选择。它确保了块重叠的最小化，使文件交换对于节点变动更加健壮。最好选择网络中最不常见的块进行下载。针锋相对描述了带宽资源分配机制。在BitTorrent对等点决定谁他们上传数据基于下载的数据从对等点。这应该防止leecher只下载而不提供任何资源给别人。<br>BitTorrent得到了很好的研究，并证明了它的时间考验。尽管它已经很老了，但仍有数百万人在积极地使用[45]来共享文件，并为较新的点对点文件分发系统提供了一个榜样。此外，BitTorrent基金会和Tron基金会开发了BitTorrent Token (BTT)，作为基于区块链的激励层，以增加文件的可用性和持久性。新的激励结构通过收购数据扩大了针锋相对的竞争。报价数据(bid data)决定了对等端为持续服务满足的BTT/byte速率。作为支付的交换，对端被解除阻塞并有资格接收数据。令牌的交换由支付通道处理。</p><h3 id="B-Kademlia"><a href="#B-Kademlia" class="headerlink" title="B. Kademlia"></a>B. Kademlia</h3><p>从今天的角度来看，Kademlia可能是使用最广泛的DHT。正如我们稍后将看到的，大多数P2P数据网络都以某种方式构建在Kademlia之上。Kademlia还影响了P2P文件交换协议，如BitTorrent，它通过使用基于Kademlia的DHT支持无跟踪的torrent。<br>一般来说，Kademlia可以被归类为结构化的覆盖网络，它规定了如何构造和维护P2P网络。为此，对等体被分配一个身份，这个身份决定了它的位置，进而决定了它的邻居。对于邻居选择，使用异或度量。异或度规的优点是它是对称的和单向的。根据它们的XOR距离，节点被分类为𝑘-buckets。bucket被排列成二叉树，其中最短的前缀决定了bucket。如果一个新节点属于一个包含𝑘个节点(包括它自己)的桶，那么这个桶将被分成更小的桶，否则这个新节点将被丢弃。具有8位标识符的示例性Kademlia树如图3所示。</p><p><img src="/images/distributed_storage/image-20220428145024512.png" alt="image-20220428145024512"></p><h3 id="C-Information-Centric-Networking"><a href="#C-Information-Centric-Networking" class="headerlink" title="C. Information-Centric Networking"></a>C. Information-Centric Networking</h3><p>另一个值得一提的前身是信息中心网络(ICN)。尽管ICN不是一个P2P数据网络，但它的一些想法和概念至少与某些数据网络相似。与P2P数据网络不同，ICN提出改变网络层。包的路由和流应该从点对点位置搜索更改为直接从网络请求内容。举个例子，让我们假设我们想要检索一些数据，例如，一个网站，并且我们知道这个网站在example.com是可用的。首先，我们通过DNS请求站点主机的位置，即IP地址。然后，我们建立一个连接来检索网站。在ICN中，我们将直接请求数据，而不会寻址数据所在的主机。任何存储网站的节点都可以立即提供数据。<br>Jacobson等人提出了以内容为中心的网络，其中这些内容请求是interest packet。内容的所有者可以直接用包含该内容的数据包回答感兴趣的数据包。这就需要在基础设施级别上实现流量控制、路由和安全的其他机制。对interest packet进行广播，对数据感兴趣的对等体可以共享资源。目前有多个处理ICN的项目，例如命名数据网络(NDN)。对于Ntorrent，Mastorakis等人提出了一个NDN的扩展，在NDN中实现了一个类似bittorrent的机制。关于ICN的更多一般信息可在中找到。由于数据网络以内容为中心的性质，它们可以被广泛地解释为ICN的覆盖实现。</p><h3 id="D-Self-Certifying-Names"><a href="#D-Self-Certifying-Names" class="headerlink" title="D .Self-Certifying Names"></a>D .Self-Certifying Names</h3><p>从以主机为中心的通信到以内容为中心的通信的变化引入了新的安全问题。此外，当缓存成为网络的主要特征时，需要考虑特定的威胁，例如缓存中毒或针对缓存的拒绝服务攻击。更广泛地说，ICN的安全问题一般包括内容认证、授权和访问控制以及隐私。<br>目前，安全研究的主要焦点在于认证。由于缓存的广泛使用，数据提供者不再一定是对象的原始源(数据所有者)。这需要使接收者能够评估对象的有效性(完整性)、来源(内容来源)和相关性的机制。<br>确保有效性和相关性的一种方法是自我认证名称。可以使用散列指针(或更通用的内容散列)来引用内容，从而启用自认证名称。文件的内容被用作加密哈希函数的输入，例如SHA-3。得到的摘要可以用来识别内容，客户机可以在本地验证文件的完整性。哈希函数的加密特性，最重要的是预图像和抗碰撞，确保没有人可以在不改变摘要的情况下替换或修改输入数据。在这种情况下，名称提供了完整性和相关性，但是，谁负责验证对象，例如，客户端和/或中间端，仍然是值得怀疑的。此外，自我证明的名称本身不能提供出处或证明物体的来源。加密签名可以保证对象来源的真实性，但需要公钥基础设施或信任网络来验证签名。虽然这允许验证对象来源的真实性，但仍然可能发送格式不正确的对象，因此需要确保完整性的机制。通过缓存的内容的寿命需要谨慎的密钥管理，以防止加密凭据被破坏。<br>访问控制也有类似的问题:一旦数据发布，就很难限制访问或撤销发布。加密可能会限制访问，但可能需要带外密钥分发。关于ICN的安全、隐私、访问控制和其他挑战的进一步见解见[53,54]。</p><h3 id="E-区块链"><a href="#E-区块链" class="headerlink" title="E. 区块链"></a>E. 区块链</h3><p>2008年比特币的引入为分布式应用提供了新的可能性。比特币是一种巧妙而复杂的组合，它结合了来自链接时间领域的各种想法——加密、数字现金、P2P网络、拜占庭容错和密码学。比特币带来的关键创新之一是一种开放的共识算法，它可以积极激励同行遵守规则。因此，它使用了在这个过程中生成的硬币的概念，即挖矿。<br>虽然术语区块链通常指整个系统及其协议，但它也指类似于哈希链或哈希树的特定数据结构。也就是说，区块链使用加密散列对链接到其前任的块进行排序。这种链接的数据结构确保了区块链数据(例如事务)的完整性。区块链的一致性由共识算法保证，例如比特币中的Nakamoto共识。有关比特币和区块链的更多细节，请参阅。<br>由于区块链受到诸如可伸缩性等问题的困扰，人们开发了不同的设计来缓解这些问题。不同的设计开辟了一个新的类别，称为分布式分类账技术(DLT)。dlt提供分布式、拜占庭式容错、不可变和有序的日志。不幸的是，由于一系列的可扩展性问题和链上存储容量有限，纯粹基于DLT的数据网络的可行性有限[57,58]。此外，在被设计为交换和价值存储媒介的区块链(即比特币等加密货币)中存储大量数据会导致高额的交易费用。然而，dlt的研究和开发表明了基于区块链的数据网络的可行性，例如Arweave(参见第4 - e节)。<br>然而，一般来说，允许去中心化支付的加密货币可以作为一种激励结构在P2P数据网络中使用。正如我们将在下文中阐述的，这种激励结构可以增加数据网络的健壮性和可用性，从而解决前几代人的弱点。</p><h2 id="III-INTERPLANETARY-FILE-SYSTEM-IPFS"><a href="#III-INTERPLANETARY-FILE-SYSTEM-IPFS" class="headerlink" title="III. INTERPLANETARY FILE SYSTEM (IPFS)"></a>III. INTERPLANETARY FILE SYSTEM (IPFS)</h2><h2 id="IV-RELATED-P2P-DATA-NETWORKS"><a href="#IV-RELATED-P2P-DATA-NETWORKS" class="headerlink" title="IV. RELATED P2P DATA NETWORKS"></a>IV. RELATED P2P DATA NETWORKS</h2><h3 id="A-Swarm"><a href="#A-Swarm" class="headerlink" title="A. Swarm"></a>A. Swarm</h3><p>Swarm是一个由以太坊基金会开发的用于存储和交付内容的P2P分布式平台。它通过不允许任何删除，以及上传和忘记属性来抵抗审查。群是为以太坊构建的，因此在某些方面依赖并共享以太坊的设计方面。Swarm的目标是为web3栈提供去中心化的存储和流媒体功能，这是一个用于共享互动内容的去中心化的、抵制审查的环境。以太坊基金会将Swarm设想为“世界计算机的硬盘”。<br>与IPFS类似的是Swarm使用基于内容的寻址。与IPFS相反的是Swarm中基于内容的寻址也决定了存储位置。为了确保可用性，群控引入了职责范围。责任区域是节点的近邻。责任区域中的节点应该提供块冗余。通过版本控制支持可变性，保持文件的每个版本。提要、专门构造和寻址的块以及以太坊名称服务(ENS)用于查找变异文件。ENS是以太坊改进提案137中定义的标准。它提供了将地址转换为人类可读名称的能力。与IPNS不同，ENS是作为以太坊区块链上的智能合约来实现的。</p><p>图6是云计算的概念概述，我们继续使用作者和审稿人之间交换的调查论文作为运行例子。Swarm会将一个文件分割，也就是将调查分成一些块，这些块被安排在一个所谓的Swarm hash中。Swarm哈希是排列在Merkle树中的块的组合，其中叶节点代表输入数据，中间节点是子节点的引用组合。得到的数据块被上传到网络。群采用Kademlia拓扑结构，邻居由它们的标识距离决定。需要注意的是，除了桶的连接外，Swarm还依赖于一个最近的邻居集合，即该邻居的剩余节点。一个邻居基本上是包含至少三个其他对等节点的桶数量最少的桶。这个最近的邻居集负责复制，并且不一定是对称的。例如，在图6中，𝑁3的最近邻居是𝑁2，𝑁1和𝑁0，而𝑁12的邻居是𝑁8，𝑁9，𝑁10和𝑁11(参见图3)。上传的块被中继，存储和复制在最近的地址。要检索调查，必须使用群根哈希。网络根据内容地址转发请求。</p><p><img src="/images/distributed_storage/image-20220428151148330.png" alt="image-20220428151148330"></p><p>为了保证确保节点行为，Swarm提供了一个激励层。其激励机制基于SWAP、SWEAR和SWINDLE。SWAP (SWarm Accounting Proto- col)处理节点间数据交换的均衡。各节点维护本地计费信息。对等点基本上是在没有利息的情况下从服务节点购买一大块。区块的价格可以在同行之间协商。请求会被处理到某个不平衡的阈值，即块被不平衡地处理，债务变得过高。在达到第一个阈值后，节点希望得到债务的结清以进行进一步的服务。如果达到第二个阈值，则由于未清偿债务，节点断开连接。债务可以用支票结算，支票可以被理解为一种简单的单向支付渠道。SWarm Enforcement And Registration (SWEAR)和Secured With INsurance Deposit Litigation And Escrow (SWINDLE)将确保内容的持久性。此外，Swarm的激励机制有邮票，它提供了一种机制来防止垃圾上传，也提供了一种彩票机制来激励块的持续存储。<br>邮票可通过智能合约批量获取。邮票被附在上传的区块上，并由邮票所有者签名。这可以作为上传区块的付款凭证。只能通过中继或存储节点监控戳记的使用情况。这允许重复使用/过度使用邮票。为了减少过度使用戳记的风险，戳记只用于某些前缀冲突，将戳记限制为特定存储区域中的块。<br>邮票被用于抽奖。彩票为块提供了价值，以防止块的早期删除。通过抽签，存储节点可以获得邮票的部分初始成本。在彩票中选择一个地址区域。临近区域的节点可以申请奖励。通过应用，节点可以证明该区域内块的所有权。节点定义了存储块的价格。在证明拥有这些块之后，拥有最便宜奖品的节点获得奖励。讨论:群提供了复杂的激励概念。与依赖区块链交易相比，用支票结算不平衡检索提供了一种更快、更便宜的结算差异的方法。与彩票一起发行的邮票为储存大块的数据提供了额外的激励。此外，虽然上传内容需要花费成本，但节点可以通过主动为参与者提供块来赚取成本。然而，邮票可以将用户链接到上传的内容。虽然群集提供了一定程度的发送者匿名性，但上传的匿名性可能会限制可用的内容。<br>考虑到分布式块不可变存储(DISC)所确定的存储位置，网络可能面临存储问题。提要可以在网络中提供用户定义的空间，以恢复提要和固定的形式，可能能够减轻这些缺点。<br>总的来说，Swarm显然依赖于以太坊生态系统。虽然这有利于激励结构，但由于以太坊发展积极，用户基础广泛，这也需要用户对以太坊的依赖。虽然有这么庞大的潜在用户群，但对用例或Swarm机制的研究却很少。Swarm和以太坊的连接可能是缺乏研究的一个原因，因为Swarm似乎没有IPFS那么完整，而以太坊本身仍然保留着许多研究机会。</p><h3 id="B-Hypercore-Protocol-Dat"><a href="#B-Hypercore-Protocol-Dat" class="headerlink" title="B. Hypercore Protocol/Dat"></a>B. Hypercore Protocol/Dat</h3><p>Hypercore Protocol(以前的Dat Protocol)支持类似Git的内容和元数据的增量版本。Hypercore协议由多个子组件组成。严格地说，Hypercore是子组件之一，为了简单起见，我们使用这个术语来泛指Hypercore协议。在Hypercore中，数据存储在一个类似于BitTorrent结构的目录中，每个目录处理自己的网络。该协议支持不同的存储模式，每个节点可以决定目录中的哪些数据以及需要存储哪些版本的数据。此外，该协议支持订阅目录中所有/任何文件的实时更改。协议中的所有通信都是加密的。为了查找和读取数据，需要知道一个特定的读键。<br>该协议旨在共享大量可变数据。创建该协议的动机是为了防止科学文献的链接腐烂和内容漂移。该协议只允许随机访问部分数据。<br>Hypercore可以理解为共享一个文件夹。可以对文件夹中的文件进行修改、添加和删除操作。这也包括并允许可变文件。<br>Hypercore的概念概述如图7所示。对于对等发现，Hypercore使用Hyperswarm，一种基于Kademlia的DHT。如果作者想使用Hypercore协议共享调查结果，需要创建Hypercore并添加调查结果。要想被超perswarm发现，就必须加入超perswarm覆盖网络。通过共享公钥𝐾𝑃𝑢𝑏，审阅者可以计算发现密钥𝐾𝐷，并在找到对等点并加入数据网络后解密消息。一旦另一个覆盖网络加入，非结构化的志愿者网络就可以共享数据，调查可以被检索。<br>讨论:Hypercore允许通过交换公钥来共享数据。可以获取特定版本和特定区域的数据。这使得它变得简单，特别是对于大型数据集，并且允许可变数据。该协议专注于共享文件集合，这扩大了协议的可用性。<br>由于加密和发现密钥，该协议确保了机密性。公钥允许计算发现密钥，但不可能逆转公钥。这将阻止其他人读取数据。Hypercore的一个缺点是缺乏公钥以外的其他身份验证机制，这阻止了额外的细粒度访问控制。此外，它仍然泄漏元数据，因为发现密钥只是一个假名。<br>Hypercore没有复制数据的激励机制，数据的持久性依赖于参与者。利用或分析Hypercore/Dat的研究很少。虽然该协议似乎开发得很好，而且可用，但研究似乎侧重于IPFS。</p><h3 id="C-Secure-Access-For-Everyone-SAFE"><a href="#C-Secure-Access-For-Everyone-SAFE" class="headerlink" title="C. Secure Access For Everyone(SAFE)"></a>C. Secure Access For Everyone(SAFE)</h3><p>人人安全访问(SAFE)网络[17,81]被设计为一个完全自主的分散数据和通信网络。甚至认证也遵循自我认证[82]机制，它不依赖于任何集中组件。SAFE的主要目标是提供一个网络，每个人都可以加入并使用它来存储、查看和发布数据，而不会在机器上留下他们活动的痕迹。这将允许参与者以较低的迫害风险发布内容。<br>SAFE支持三种不同的数据类型:Map、Sequence和Blob。数据可以进一步分为公共数据和私有数据。Map和sequence是无冲突的复制数据类型，这对于确保可变数据的一致性很重要。Blob用于不可变数据。SAFE网络中的所有数据都是加密的，包括公共数据。使用的加密算法是自加密[83]，使用文件本身对文件进行加密。也就是说，一个文件被分割成至少三个固定大小的块。每个块使用前一个块的散列和加密，即𝑛−1，其中𝑛是当前块。之后，加密的块会被原始块的串接哈希值混淆。对于SAFE，混淆后的块存储在网络中。对于解密，在加密过程中会创建一个数据映射。数据映射包含关于文件的信息，并将模糊块的散列映射到真实块的散列。对于公共数据，解密密钥由网络提供。私人数据可以删除，而公共数据应该是永久的。因此，可变数据只能是私有的。名称解析系统允许人类可读的地址来检索数据。<br>网络本身是根据基于卡德米利亚的DHT由异或地址组织的。此外，网络被分成几个部分。当一个新的保险库想要加入网络时，新的保险库需要证明它可以提供所需的资源，然后被随机分配一个XOR地址，从而分配给一个节。这些部分是动态维护的。根据网络中保险库的数量，分区并将保险库重新分配到新的分区。对于长得太小的节，可以通过获取新节点或请求重新定位节点来平衡节的大小。更改section会增加保险库的节点年龄。节点年龄是信任的衡量标准，可以失去，然后必须重新赢得。在一个section中，只有一定数量的节点可以做出决策，即长者。长者是该区域中最古老的节点。由长老投票决定是否接受分区内的事件，经一定人数的长老同意并集体签字后生效。网络段中的事件是，例如，加入/离开一个节点或存储一个块。长者的真实性由SectionProofChain保证，SectionProofChain包含长者的群组签名，是证明一个区段有效性的公钥序列。每当长者组发生变化时，序列就会更新和签名。<br>SAFE网络的概念概述如图8所示。考虑到我们正在运行的示例，调查被划分为自加密的块，并用于生成数据地图。在完成自我认证过程后，向网络发送一个PUT请求。当负责存储块的区域中的长者同意后，数据就被存储。下载文件时，需要数据图。数据映射用于GET请求，以获取经过模糊处理的加密块。下载公共数据不需要认证。在获得这些块之后，可以在数据映射的帮助下重新创建文件。<br>在SAFE网络中，存储数据需要使用该网络自身的货币，即Safecoin。客户的安全币平衡由客户经理监控，并在外管局的共识机制的帮助下被批准/拒绝。节点可以通过耕种(即向请求者提供内容)赚取Safecoin。<br>讨论:自我认证、自我加密和网络组织给了用户对其数据的高度控制。中心组件的缺失减少了单点故障。此外，隐私和在一定程度上匿名是SAFE网络的关键特征。网络中仅存储数据时需要鉴权。检索数据通过客户端选择的代理进行中介，该代理提供了匿名通信。Safecoin旨在提供一个激励层，确保网络的可用性和可靠性。<br>Paul等人[84]在2014年首次对SAFE进行了安全分析，涉及机密性、完整性和可用性以及可能的攻击。2015年，Jacob等人[85]从真实性、完整性、保密性、可用性和匿名性等方面分析了网络的安全性。作者解释了如何利用自我认证和去中心化特性来揭示单个实体的个人数据。</p><h3 id="D-Storj"><a href="#D-Storj" class="headerlink" title="D. Storj"></a>D. Storj</h3><p>Storj[18]是一个P2P存储网络。下面我们引用的是3.0版本。它专注于数据的高持久性、低延迟以及存储数据的高安全性和私密性。支持对通信、文件位置和文件进行端到端加密。为了文件的高持久性或换句话说，文件在网络中更好的可用性，Storj使用了擦除码。此外，低带宽消耗也是设计的主要目标之一。该协议假设对象大小为4𝑀𝐵或更多，虽然支持较小的对象大小，但存储过程的效率可能较低。在Storj中，去中心化被解释为没有一个操作者单独负责系统的操作。在一个分散的系统中，信任和拜占庭式的失败假设是重要的。Storj假设没有利他的，总是表现良好的节点，大多数理性节点，只有在盈利时表现出恶意，还有少数拜占庭式恶意节点。<br>Storj的目标是成为去中心化的云存储。Storj Labs Inc.希望为集中式存储提供商提供另一种选择。为此，Storj提供了与Amazon S3应用程序编程接口的兼容性，以提高总体接受度并简化新用户的迁移。由于Storj提供了云存储，用户可以存储和检索数据，以及删除、移动和复制数据。<br>Storj网络由三种节点类型组成:卫星节点、存储节点和上行节点。卫星节点管理文件的存储过程和维护。对元数据甚至文件路径的加密增加了对元数据的额外保护。上行节点是终端用户，需要存储和访问文件。存储节点用于存储数据。存储和上行节点选择与哪些卫星节点合作。这导致了一个类似于BitTorrent的网络，其中卫星成为中心部分。<br>Storj的概念概述如图9所示。为了上传调查论文，作者需要将其分割成片段，然后对片段进行加密。作者要求卫星存储一个片段。卫星检查存储节点的容量并返回足够的候选存储列表。然后，片段被分割成条状，这些条状被擦除编码并排列成片段。然后，这些片段被并行上传至存储节点。</p><p>对于擦除编码，Storj使用Reed-Solomon擦除码[86]。对于erasure code，数据编码为(𝑘，𝑛)erasure code。这意味着，一个对象被编码为𝑛片段，以这种方式只需要𝑘片段就可以重新创建对象。Storj为每个对象选择四个值:𝑘、𝑚、𝑜和𝑛。𝑘表示重建数据所需的最小块数，𝑚是用于修复的缓冲区，𝑜是用于churn的缓冲区，𝑛是总块数。与多次存储数据块相比，Erasure code提供了更高的冗余，开销更小。此外，由于检索文件只需要𝑘片段，因此可以减少文件可用前的延迟。<br>上传完成后，一个包含片段元数据的指针(例如片段的哈希值、存储位置、擦除编码方案)被返回给卫星。对每个部分重复这个步骤，最后一个部分包含关于调查的额外元数据。如需下载调查报告，请提供各部分的指针。这些片段是由存储节点并行请求的。一旦收集到足够多的片段，就可以阅读调查报告了。<br>为了保证理性节点之间的合作，Storj提供了激励机制。奖励系统奖励存储节点存储和提供内容。通过审计和声誉系统对节点进行监控和评估。Storj的一个目标是低延迟，从而避免依赖区块链的激励机制。<br>讨论:与其他P2P数据网络相比，Storj使用了一些独特的概念。特别是，Amazon S3的兼容性可能会促进Storj成为去中心化的存储系统。擦除码增加了存储文件的开销，但在检索文件时，只需要下载必要数量的片段。通过擦除码的存储去中心化，以及足够的存储节点选择和声誉系统的帮助，增加了对数据泄露的保护。<br>卫星节点是网络的重要组成部分，并对网络进行分区，因为在一颗卫星上可用的文件在另一颗卫星上不可用。这促进了卫星形式的集中化。虽然由于加密，卫星无法与可能的第三方共享元数据，但仍然有可能泄露访问模式。<br>虽然已经部署了Storj，并且确实可以使用，但关于该主题的应用程序和研究相当少。De Figueiredo等人[87]分析了Storj网络，并将卫星节点识别为拒绝服务攻击的可能向量。他们修改了存储节点连接处理的实现，在测试环境中成功拿下了一个卫星节点，使得支付和文件检索在一段时间内无法实现。但是，生产系统应该能够抵抗这种攻击。另一项研究也显示了对数据网络的另一种攻击。Zhang等人[88]指出，在Storj v2.0中，可以将未加密的数据上传到存储节点，用于框架存储节点的所有者。尽管如此，Storj提供了隐私保障、弹性、可获取的元数据或每个人都可以部署不同节点的可能性，这些都可以为云存储提供有价值的见解。</p><h3 id="E-Arweave"><a href="#E-Arweave" class="headerlink" title="E. Arweave"></a>E. Arweave</h3><p>Arweave协议[19]利用了一种类似区块链的结构(称为blockweave)，为永久的链上数据存储以及存储支付提供了一种机制。在块组织中，一个块指向直接前一个块和召回块，召回块是基于前一个块的信息确定地选择的。虽然编织是不可改变的，并提供了对其数据的审查阻力，但每个节点都可以决定拒绝接受内容。通过足够多的节点拒绝内容可以防止包含不需要的内容。<br>Arweave使用了一种类似于BitTorrent的“tit-for-tat”的协议Wildfire来为同行排名。通过Wildfire，每个节点维护一个节点列表，并根据节点的响应能力(如响应请求或发送事务)进行评分和排名。这个分数基本上是由最近请求的平均每秒接收字节数决定的。级别高(因此性能最好)的对等点首先并行地接收消息，然后依次接收其余的消息。定期修剪连接到低等级对等体的连接。这激励节点自身高度响应，以尽可能快的速度接收消息。优化节点的资源利用率，减少通信时间。<br>Arweave的核心是基于区块链的网络。虽然野火引入了一个有利于某些连接的排名，但它仍然是一个非结构化的P2P网络。图10给出了Arweave的概念概述以及如何归档/检索文件。为了在Arweave中存档调查论文，有必要将交易发送到网络上。对等点通过将该交易包含在一个块中来确认该交易。如果有人想要阅读调查，网络被要求。如果一个对等点存储了包含调查的块，它可以被返回，调查可以被读取。</p><p><img src="/images/distributed_storage/image-20220428173237462.png" alt="image-20220428173237462">Arweave的目标是提供数据的永久存储，以一种不可变的方式保存和时间戳信息。数据存储在区块组织的链上，因此，是不可变的，只有通过分叉组织才能移除。blockweave为永久网络提供了去中心化存储。<br>blockweave及其数据的存储和维护通过Arweave的加密货币:Arweave代币来确保。代币用于奖励矿工和支付发送交易。<br>讨论:Arweave协议在类似区块链的结构上提供链上存储。这使得存储具有与区块链类似的优点和缺点。Arweave提供时间戳、透明度、激励机制和不可变存储。数据是通过提供匿名数据作者的事务存储的。<br>区块链最大的问题之一是可扩展性。Arweave试图通过区块阴影(一种类似于紧凑块的机制，在比特币改进提案152[89]中有解释)和野火(用于快速块传播，减少分叉概率)来减少这些问题。此外，使用块哈希列表和钱包列表可以降低初始参与成本。在2.0版本中，Arweave引入了一个硬分叉来提高可伸缩性，将数据与事务分离。在事务中不包括数据，而是包括数据的Merkle根。这提高了事务传播速度，因为转发事务不再需要数据。<br>由于存在伪随机召回块，为了使挖掘收益最大化，节点被激励存储大量的块。这增加了数据的复制。然而，并不是每个节点都必须存储每个块或内容，每个节点根据内容过滤器为自己决定存储哪些数据。请求内容可能会变得复杂，因为节点是随机请求的，希望它们存储内容。<br>对Arweave的直接研究很少。然而，这可以解释为新兴的基于区块链的协议的广泛范围和区块链的研究至少可以部分应用于Arweave。</p><h3 id="F-Honorable-Mentions-and-Related-Concepts"><a href="#F-Honorable-Mentions-and-Related-Concepts" class="headerlink" title="F. Honorable Mentions and Related Concepts"></a>F. Honorable Mentions and Related Concepts</h3><p>在我们对选定的P2P数据网络的详细概述之后，我们提供了有关当前一代P2P数据网络的其他系统和概念的其他文献。特别是，一些论文概念为P2P内容共享提供了不同的、复杂的想法。<br>Sia[90]的目标是成为去中心化的云存储平台。一个文件被分割成多个块，这些块被加密，然后通过擦除编码存储在多个存储节点上。块的位置存储为元数据。Sia使用区块链来激励数据的存储和检索。数据存储的条件和持续时间在存储合同中是固定的。数据所有者负责文件运行状况。<br>OSN (Open Storage Network)[91]是一个用于传输和共享研究数据的分布式网络。它可以与专注于大量研究数据的分布式云服务相媲美。数据存储在中央监控和维护的吊舱中。这些OSN吊舱是专门配置的服务器机架，需要高带宽互联网连接。想要为这个网络做出贡献的机构可以安置豆荚。因此，研究人员可以在OSN网络中存储和共享他们的研究数据。OSN吊舱的连接性应保证数据的快速访问。数据可以与选定的参与者共享，也可以通过开放获取。对pods的集中管理和严格的条件将OSN与现有的其他数据网络区分开来，分散和任意参与是这些数据网络的一个关键特征。<br>Fukumitsu等人[92]提出了一种点对点类型的存储系统，在该系统中，即使是重构所存储文件所需的元数据也存储在网络中，可以通过ID、密码和时间戳来检索。作者假设一个非结构化的P2P网络，其中每个节点可以提供不同的服务。节点定期广播有关自身的必要信息，例如提供的服务及其IP地址。该方案的一个重要组成部分是存储在区块链上的存储节点列表。存储节点列表是随机选取的提供存储服务的节点列表。数据按部分存储，存储过程分为两个阶段:存储用户数据和存储重构用户数据所需的数据。用户数据被加密，分成部分，存储在当前可用的存储节点中选择的节点上。可以使用恢复键请求部件。为了重构用户数据，需要解密密钥、存储节点对和恢复密钥。因此，需要将数据复制到其他节点。用户创建ID、密码对，并选择存储列表。数据通过ID、密码和存储列表的散列进行加密。存储节点是从存储列表中确定选择的。部件的恢复键是存储列表的散列和块索引的散列，即ID和密码。该方案允许获取数据，而无需将信息存储在用户设备上。<br>Jia等人[93]提出了一种实现健忘RAM隐藏数据访问模式的机制——oblvp2p。虽然作者提到他们的机制适用于其他点对点系统，但他们关注的是带有跟踪器的类似BitTorrent的系统。<br>Qian等人[94]提出了Garlic Cast，一种改善覆盖网络中匿名性的机制。对等点不直接请求和搜索内容。相反，对等体搜索代理，代理交换和请求内容。对等体及其代理之间的消息是通过安全增强的信息分散算法(IDA)交换的。rda是一种擦除编码形式，其中𝑘的𝑛片段足以重建对象。安全增强的IDA首先对消息进行加密，使用𝑘-threshold IDA将消息和密钥分割为𝑛片段，然后发送cloves，即包含密钥和消息片段的消息。通过随机游走发现代理:丁香被发送给它的邻居，请求对等点作为一个具有随机丁香序列号的代理，每个邻居随机转发丁香，并维护继承者和前任的状态。具有两个具有相同序列号的丁香的对等体可以恢复请求，如果它自愿成为对等体，它将返回一个回复给请求者。<br>其他论文概念利用区块链进行访问控制，并存储数据位置，而不是作为激励机制的补充，如Blockstack[95]，它在区块链上维护元数据，并依赖外部数据存储来实际存储数据。也有使用分布式账本技术进行访问控制的概念。<br>Calypso[96]，它使用基于跳链的身份和访问管理，允许可审计的数据共享。然而，这些系统和仅集中于通过区块链出售数据的系统不在本次调查的范围之内。</p><h2 id="V-DISCUSSION-OF-BUILDING-BLOCKS"><a href="#V-DISCUSSION-OF-BUILDING-BLOCKS" class="headerlink" title="V. DISCUSSION OF BUILDING BLOCKS"></a>V. DISCUSSION OF BUILDING BLOCKS</h2><p><img src="/images/distributed_storage/image-20220428171303982.png" alt="image-20220428171303982"></p><h3 id="A-Performance"><a href="#A-Performance" class="headerlink" title="A. Performance"></a>A. Performance</h3><p>系统性能的研究已经成为一些研究者所追求的研究方向。通过模拟或测试来调查性能、读/写时间、存储开销、文件查找、抗churn阻力，可以用来识别新的用例，并巩固一个系统可能取代集中式系统的断言。IPFS开发人员开发了“Testground”[103]，用于大规模测试和基准测试P2P系统。从这个意义上说，Testground的性能及其对真实系统的复制能力也是一个值得研究的领域。也有其他分析IPFS性能的研究，如读写时延[28,31]，使用IPFS集群进行物联网数据共享[29]，改进系统[30,36]，或分析网络[34,35,37]。Heinisuo等人[32]表明，由于高网络流量消耗电池，IPFS需要改进才能在移动设备上使用。关于IPFS竞争对手的研究还很缺乏。此外，Naik和Keshavamurthy[41]关注的主题是P2P网络的流失。此外，考虑到研究数据的增加，需要研究在Tera-和Petabytes范围内建立大型单一数据集的数据网络的可行性。</p><h3 id="B-Confidentiality-and-Access-Control"><a href="#B-Confidentiality-and-Access-Control" class="headerlink" title="B. Confidentiality and Access Control"></a>B. Confidentiality and Access Control</h3><p>过去和现在的数据网络提供了一些机密性和访问控制，但这些系统是为公共数据而不是为私有数据设计的。需要研究节点在存储数据时所获得的知识。这不仅涉及数据内容的信息，还涉及元数据(如访问模式)。现有的访问控制系统的安全性有待进一步研究。有研究建议使用区块链进行访问控制[22 - 25,64]，但区块链的不变性使得这对于私人和个人数据来说存在问题。关于私有数据的另一个方面是删除数据。虽然防止删除数据有助于抵制审查，但删除个人、恶意或非法数据的可能性可能提高对数据网络的接受程度。例如，Politou等人[102]提出了一种IPFS中删除内容的机制。调查和改进现有系统可以增加对数据网络的信任。增强对机密性的信任和防止未经授权的访问可以打开这些系统来存储私人和个人数据。</p><h3 id="C-Security"><a href="#C-Security" class="headerlink" title="C. Security"></a>C. Security</h3><p>对于安全研究来说，这一领域的工作通常是在发现和修复新的漏洞之间反复进行。此外，研究还涉及利用P2P数据网络与恶意软件交换数据的恶意活动<br>在安全漏洞方面，Prünster等人[33]披露了对IPFS的eclipse攻击，De Figueiredo等人[87]披露了对Storj的测试网络的拒绝服务攻击。此外，不仅需要研究已知的攻击向量，还需要研究新的攻击向量的存在。例如，Storj承认存在“Honest Geppetto”攻击的可能性，即攻击者(诚实地)长时间地操作许多存储节点，有效地控制大部分存储能力。这种控制允许将数据作为“人质”或一般地取下数据，使数据网络无法操作。另一个例子是Frameup[88]，其中未加密的数据存储在存储节点上，这可能会导致法律问题。存储任意数据也可能给存储设备带来风险。安全是研究领域，我们观察IPFS以外的研究。</p><h3 id="D-Anonymity"><a href="#D-Anonymity" class="headerlink" title="D. Anonymity"></a>D. Anonymity</h3><p>除涉及数据安全和隐私的机密性外，保护个人隐私是另一个相关的方面;特别是匿名性，它描述的是无法在一群个体中识别一个个体，即不可链接性[104]。<br>在匿名方面，数据网络中可以保护各种实体:内容创建者、存储节点和请求内容的用户。在上一代数据网络中，特别是Freenet[2]和GNUnet[105]着重于保护不同实体的身份。Balduf等人[70]已经表明，IPFS通过监控数据请求识别内容请求者，从而继续存在隐私问题。<br>由于激励机制和由此产生的个人指控，很难保证匿名，因为至少需要假名。一旦使用了激励机制，有关请求者的信息就得到了。记录交易的分布式分类账，例如Filecoin、Ethereum Swarm、Arweave，可以揭示额外的信息，因此参与者是匿名的。当一个中心组件授权请求和处理激励时，例如Storj中的卫星节点，请求者、存储节点和中心组件相互认识。在激励请求的情况下，显示请求节点和存储节点。请求者的身份可以通过转发策略或代理(如Swarm、SAFE)部分地得到保护。<br>第一代有像Freenet这样的系统，旨在匿名和抵制审查。这一代的匿名性似乎落后于第一代。尽管使用mixnet或Tor进行匿名通信取得了进展[106]，但还没有数据网络提供强匿名性。总之，提供的匿名保证和进一步的增强需要调查。这包括匿名实用程序的权衡和对不同攻击者模型的分析。匿名不仅对保护个人隐私很重要，而且对保证声称的抵制审查也很重要。如果可以很容易地推断出存储节点的身份，那么即使网络保护不被删除，执法部门也有可能执行<br>审查。这是一个值得关注的问题，特别是对于像Swarm这样的系统，存储块的位置是预先确定的，节点身份是与以太坊假名相连的</p><h3 id="E-Naming"><a href="#E-Naming" class="headerlink" title="E. Naming"></a>E. Naming</h3><p>命名，特别是在分布式系统中提供人类可读的名称，是一个已知的挑战。Zooko ‘s Triangle[107]捕捉到了这个问题及其邻近的挑战。它描述了构建分布式命名空间的困难，分布式命名空间是分布式的(没有中央权威)、安全的(清晰的解析)和人类可读的。<br>在所有系统中，数据的寻址要么缺乏分布性(基于跟踪器的BitTorrent和Storj)，要么缺乏人类可读性(无跟踪器的BitTorrent、Hypercore、IPFS、Swarm和SAFE)。BitTorrent是一个很好的例子，跟踪器是一个中央权威，在无跟踪的BitTorrent的情况下，人类可读的种子是用不太可读的信息哈希(种子的哈希)解决的。在Storj的3.0版本中，卫星是一个中心组件。<br>缺乏可读性是自认证数据的结果，其中数据决定了数据的地址或名称。数据变更后，地址也随之变更。因此，通过不同的机制(独立于内容的命名)来支持人类的可读性。Hy- percore是一个例外。在Hypercore中，数据组被绑定到公钥，并且通过版本控制来保护组内的可变性。<br>提供人类可读性的一个解决方案是名称解析。名称解析允许将密钥映射到自我认证的内容。名称解析可以提供人类的可读性，并提供对文件版本控制的支持。然而，由于更新值的可能性和传播的延迟，即使密钥是唯一的，人们也会认为安全性被破坏了。名称解析独立于Zooko ‘s Triangle，宣布内容，并给出模棱两可的字符串含义，应该只用于公共数据，除非名称解析提供访问控制。<br>为此，IPFS、Swarm和SAFE提供了某种命名服务。实际上，IPFS提供了两种命名服务:IPNS和DNSLink，用于不同的目的。IPNS用于将公钥的哈希映射到IPFS CID，允许可变数据。DNSLink使用DNS TXT记录实现域名到IPFS地址的映射。<br>Swarm还提供了两种命名系统:single-owner chunk和ENS[79]。单所有者块提供了基于所有者和标识符的数据标识，提供了一个安全的、非人类可读的键和一个可更新的值。以太坊名称系统类似于DNS，其中一条记录被映射到一个地址。<br>Swartz[108]认为，基于区块链的名称服务提供了Zooko三角形的所有三个属性。任何人都可以在提供去中心化的区块链上注册名称，名称可以是任何提供人类可读性的名称，而防篡改分类帐确保提供安全性的唯一名称。根据这一论点，像Name- coin、Blockstack[95]和ENS这样的系统被开发出来，它们采用了基于区块链的名称系统的思想。虽然这些系统的存在，除了带有ENS的群系统，似乎没有一个系统能解决Zooko的三角形问题。然而，由于缺乏交易最终性和可能的区块链分叉，可以认为基于区块链的系统违反了强大的安全方面，只提供最终安全性。</p><h2 id="VII-CONCLUSION-AND-LESSONS-LEARNED"><a href="#VII-CONCLUSION-AND-LESSONS-LEARNED" class="headerlink" title="VII. CONCLUSION AND LESSONS LEARNED"></a>VII. CONCLUSION AND LESSONS LEARNED</h2><p>第一代P2P数据网络告诉我们，P2P驱动的文件交换是可行的，并且有一些主要的优势，例如，自扩展性。这项技术持续存在的另一个指标是BitTorrent的持续存在和广泛的用户基础。然而，第一代也教会了我们弱点，例如，缺乏长期可用性。下一代数据网络建立在上一代数据网络的基础上并加以改进，利用技术进步和概念来解决弱点。</p><p>在这篇调查论文中，我们研究了新兴的新一代P2P数据网络。特别地，我们调查了新的发展和技术构件。从我们的定性比较中，我们可以得出结论，除了覆盖结构之外，各种数据网络在文件管理、可用性和激励方面探索了不同的解决方案。最值得注意的是，显性激励机制，如使用加密货币或某种代币，似乎无处不在，以确保长期可用性和参与者的参与。我们还看到了不同的度量方法，以确保在面对拒绝服务攻击或超越激励机制的流失时的可用性，即复制、擦除码，甚至两者的结合。此外，由于许多系统在分布式体系结构中结合了命名服务和内容寻址，它们有可能像Zooko的三角形那样协调人类的可读性、安全性和分散性等系统属性。<br>现在一个重要的开放任务是调查和评估各种构建块。特别是，激励机制的设计是出了名的困难。在某种程度上，我们可以将P2P数据网络的不同部署视为一个大型现场测试，在那里我们可以观察某些设计决策的影响。总的来说，无论是作为其他应用的基础，还是作为研究对象本身，P2P数据网络已经成为研究议程的一部分。<br>然而，许多挑战和开放的研究问题仍然存在，例如，调查匿名性，参与者的隐私和访问控制，开放P2P数据网络到更广泛的可能的用例。因此，我们相信新一代的P2P数据网络为未来的研究提供了许多令人兴奋的机会。</p><p>推荐阅读：</p><ol><li><a href="https://www.youtube.com/watch?v=jp0bF9Qu2Jw">Vol 075 别再问我什么叫 BT 种子</a></li><li>原论文链接：<a href="https://ieeexplore.ieee.org/abstract/document/9684521">https://ieeexplore.ieee.org/abstract/document/9684521</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在本文中，我们将对下一代数据网络进行技术概述。我们使用选定的数据网络来介绍一般概念和强调新的发展。具体来说，我们提供了IPFS的更深层次的概</summary>
      
    
    
    
    
    <category term="Distributed Storage" scheme="https://zhangzhishun.github.io/tags/Distributed-Storage/"/>
    
  </entry>
  
  <entry>
    <title>基于Ubuntu20.04搭建单机Fabric2.3.0Raft共识测试网络</title>
    <link href="https://zhangzhishun.github.io/2022/04/17/blockchain/fabric/%E5%9F%BA%E4%BA%8ERaft%E5%85%B1%E8%AF%86%E6%90%AD%E5%BB%BA%E5%8D%95%E6%9C%BAFabric2.3%E7%BD%91%E7%BB%9C/"/>
    <id>https://zhangzhishun.github.io/2022/04/17/blockchain/fabric/%E5%9F%BA%E4%BA%8ERaft%E5%85%B1%E8%AF%86%E6%90%AD%E5%BB%BA%E5%8D%95%E6%9C%BAFabric2.3%E7%BD%91%E7%BB%9C/</id>
    <published>2022-04-17T13:00:00.000Z</published>
    <updated>2022-04-27T02:35:55.482Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Enter the password to read.">    <label for="pass">Enter the password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">The article has been encrypted, please enter your password to view.&lt;br&gt;</summary>
    
    
    
    
    <category term="部署文档" scheme="https://zhangzhishun.github.io/tags/%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/"/>
    
    <category term="Fabric" scheme="https://zhangzhishun.github.io/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Arweave – 一种类区块链的区块编织结构（Lightpaper）</title>
    <link href="https://zhangzhishun.github.io/2022/04/12/blockchain/arweave/Arweave_%E4%B8%80%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%8C%BA%E5%9D%97%E7%BC%96%E7%BB%87%E7%BB%93%E6%9E%84(Lightpaper)/"/>
    <id>https://zhangzhishun.github.io/2022/04/12/blockchain/arweave/Arweave_%E4%B8%80%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%8C%BA%E5%9D%97%E7%BC%96%E7%BB%87%E7%BB%93%E6%9E%84(Lightpaper)/</id>
    <published>2022-04-12T03:20:30.000Z</published>
    <updated>2022-04-27T02:35:55.473Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="http://ipfsdrop.com/docs/whitepaper/arweave-lightpaper/">http://ipfsdrop.com/docs/whitepaper/arweave-lightpaper/</a></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>经典的区块链在数据存储方面存在几个众所周知的主要问题。这些问题需要将新的第三方协议集成到现有区块链的上层，因为费用太高，无法进行链上存储。因此，对于经典的区块链来说，访问内容始终会产生成本，而且内容永远不会永久存储­。随着对数据存储的需求呈指数增长，对可扩展的分布式低成本数据存储协议的需求是必要的。</p><p>在这项工作中，我们介绍Arweave——一种类区块链的区块编织结构。区块编织是一个平台­，致力于首次以经济高效的方式提供可扩展的链上存储。随着系统中存储的数据量的增加，达成共识所需的哈希值减少，从而降低了存储数据的成本。该协议现有的REST API使得在区块编织上层构建去中心化的应用程序­十分简单，反映了Arweave对开发者社区的关注及其推动采用新兴和新颖协议的能力。</p><p>在本文中，我们还介绍了新颖的概念­诸如「区块阴影（block-shadowing）」——一种灵活的交易区块分配算法——­改进了其他区块链的现有“分片”技术­优化网络拓扑，并带来新的共识机制，称为访问证明（Proof of Access）。</p><h2 id="1-导语（Introduction）"><a href="#1-导语（Introduction）" class="headerlink" title="1. 导语（Introduction）"></a>1. 导语（Introduction）</h2><p>在这个信息时代，我们常常屈服于一种幻想，即信息被读取­可用，它永远不会被更改或丢失。从根本上讲这是不正确的[7]。在互联网上，我们建立了一个巨大的去中心化信息传播系统­信息，我们还没有建立一个对应的­永久知识存储系统。现代历史有非常多的例子——­从图书馆和档案馆的大火[9，10，3，8]到专制国家的书籍燃烧（焚书坑儒）[12，11]，重要信息的构建和丢失。当我们在互联网上查询信息时­，我们依赖于被允许访问被集中存储的该数据。­拥有此信息的服务器的访问­所有者可以随时撤消该许可。同样，由于在Internet上提供信息需要支付服务器费用和维护费用，因此当资金不足时，网站通常会轻易地消失。</p><p>更进一步，许多政府正在采取越来越多的步骤来审查和删除对互联网上政治敏感信息的访问[13、5、4]。与媒体和新闻机构一样，我们曾经拥有实体和不可撤销的副本，现在我们­单纯地访问信息，然后将其丢弃。随着时间的推移，媒体组织更新其文章的内容已变得司空见惯。虽然这提供了一些­与以前的系统相比，它具有许多优点，最显着的是，它可以传播有关展开情况的实时更新，还可以使重要的上下文丢失或变得模糊。</p><h2 id="2-背景（Background）"><a href="#2-背景（Background）" class="headerlink" title="2. 背景（Background）"></a>2. 背景（Background）</h2><p>所有区块链创新都站在巨人的肩膀上，包括比特币本身，数据结构交响曲，分布式网络工作和密码学。我们也试图扩大空间，解决现有区块链网络的特定缺点，即存储，并采用一种新颖的交易速度方法。如今，大多数区块链技术都坚持认为，“全节点”必须维护整个区块链的副本以验证未来的交易，而使之成为可能的Merkle数据结构本身就是一项了不起的壮举，并增加了无与伦比的安全性，我们认为围绕此过程的一些性能增强可以减轻整个节点的同步负担，在第4节中介绍了解决块，节点和钱包同步的几种技术。</p><p>当涉及到存储数据时，完整的区块链要求可能甚至是现有区块链技术的障碍。在以太坊（一种去中心化的世界计算机）的情况下，使用其本机令牌的存储成本令人难以置信。 Arweave的主要动机是以与以太坊中表示的方式相同的方式实现永久，不变的存储。但是，高昂的费用使这种存储变得越来越不切实际。虽然可以在以太坊上存储数据，但是由于数据存储成本，先前的尝试是不切实际的。</p><p>其他区块链技术专注于改善节点之间的共识算法，特别是Stellar Lumens和APo和Neo等dPos架构。尽管这可以提高事务处理速度，但存储负担仍然是许多此类网络将面临的长期障碍。通过首先专注于解决存储问题，我们体验了一些性能增强功能，这些性能增强功能可用于促进高吞吐量货币交易。</p><h2 id="3-激励（Motivation）"><a href="#3-激励（Motivation）" class="headerlink" title="3. 激励（Motivation）"></a>3. 激励（Motivation）</h2><p>我们已经设计并实现了一个区块链网络，其中永久性的低成本存储已成为现实。将存储访问权纳入共识，并结合新颖的交易捆绑方法和任意大小的块，可创建高吞吐量的加密货币，该加密货币将比其他加密货币（如比特币[10]和以太坊[12]）有所改善。过去，档案（互联网或其他方式）通常由单个机构（甚至是个人）维护，因此容易受到两种主要形式的操纵。首先是通过在文档存储过程中修改文档[2]。第二个问题是，文档在进入存储之前可能已经被伪造或修改过[1]。例如，许多归因于苏格拉底的作品被认为是他的门徒们写的[6]。 Arweave解决了这两个问题。一旦将文档存储在组织上，就将其与组织上的每个其他块加密链接。这确保了任何尝试更改文档内容的尝试都会被网络检测到并拒绝。以这种方式，不可能破坏组织上的信息。 Arweave是Internet上可浏览的姊妹网络，可提供Internet迫切需要但目前缺乏的长期，永久数据存储功能。</p><p>Arweave系统的关键组件旨在让开发人员轻松构建与网络数据交互，创建和使用的应用程序。这些使用与语言无关的REST API构建的应用程序将充当网络中侦听网络的节点。这些应用程序的功能将是广泛而多样的，从分散和不变的社交网络到讨论网站和新闻聚合器。为了向编织提交信息，将需要少量令牌。这些代币将用于支付矿工在维护组织和网络方面的工作，以及抑制垃圾邮件的传播。这代表了对典型集中式存储系统的极大改进。同样，它使个人有能力确保自己关心的信息能够长期存在。随着网络和文档将增强令牌的价值，维持织法的动机也会增加。随着这些影响的加剧，我们期望Arweave代币将成为信息时代的宝贵资产。与大量重要文件密不可分且内在联系。</p><h2 id="4-技术（Technology）"><a href="#4-技术（Technology）" class="headerlink" title="4. 技术（Technology）"></a>4. 技术（Technology）</h2><p>Arweave建立在四项核心技术的基础上，这些技术可以共同在新的区块链上创建低成本，高吞吐量的永久存储。 这些创新是：</p><ul><li>区块编织（Blockweave）</li><li>访问证明（Proof of Access）</li><li>野火（Wildfire）</li><li>区块阴影（Blockshadows）</li></ul><p>虽然这些技术相互交织，但是每种技术在创建适用于快速事务处理和低成本永久性存储的新型网络方面都发挥着关键作用。</p><h3 id="4-1-区块编织（Blockweave）"><a href="#4-1-区块编织（Blockweave）" class="headerlink" title="4.1 区块编织（Blockweave）"></a>4.1 区块编织（Blockweave）</h3><p>大多数区块链的一个众所周知的特性是，必须存储每个区块以作为“完整节点”参与验证交易。 Arweave并非如此。</p><p>取而代之的是，Arweave引入了两个新概念，这些概念允许节点在不拥有整个链条的情况下完成关键的网络功能。这些概念中的第一个是块哈希列表，它是所有先前块的哈希的列表。这样可以验证旧块，并有效评估潜在的新块。这些概念的第二个是钱包列表，这是系统中所有活动钱包的列表。这样就可以在不占用最后一次交易使用的区块的情况下验证交易。使用这些由网络同步并可以由矿工下载的区块链列表和钱包列表，节点几乎可以立即加入网络并参与对组织的挖掘。</p><p>此外，Arweave使用“持续验证”系统，而不是让每个矿工在进入网络时都验证从基因块到当前块的整个块结构。当矿工加入Arweave网络时，他们将下载当前区块并从当前区块中检索区块哈希和钱包列表。由于这些区块链和钱包列表已通过每个区块的持续进行进行了连续验证，因此新矿工可以立即开始参与，而无需验证整个组织。当然，完全编织验证可用于希望执行该验证的任何节点。通过这种方式，矿工无需查找与钱包相关联的先前交易即可验证新交易。取而代之的是，矿工将只需要验证交易是否已由钱包拥有者的私钥正确签名。为了防止召回块伪造攻击，块哈希表的哈希将与每个新块一起分发。</p><p>Arweave - 一种类区块链的区块编织结构（Lightpaper）</p><p><img src="/images/arweave/image-20220412232151857.png" alt="image-20220412232151857">图1：blockweave数据结构的示意图，展示了到前一个区块和回调区块的链接。</p><h3 id="4-2-访问证明（Proof-of-Access）"><a href="#4-2-访问证明（Proof-of-Access）" class="headerlink" title="4.2 访问证明（Proof of Access）"></a>4.2 访问证明（Proof of Access）</h3><p>Arweaves共识机制基于访问证明（PoA）和工作证明（PoW）。虽然典型的PoW系统仅依赖于前一个块才能生成每个连续的块，但PoA算法会合并来自随机选择的前一个块的数据。结合区块编织数据结构，矿工不需要存储所有区块（形成一个区块链），而是可以存储任何先前的区块（由PoA和野火推动），从而形成区块编织，即区块编织。通过获取当前块的哈希值并计算其相对于当前块高度的模数，可以选择要合并到下一个块中的“调用块”。</p><p>调用块中的事务与在当前块中找到的事务一起进行哈希处理，以生成下一个块。当矿工找到合适的哈希后，他们会将新块与回调区块一起分发给网络的其他成员。这使网络的其他成员，即使没有自己的回调区块副本的那些成员，也可以独立地验证新块是否有效。</p><h3 id="4-3-野火（Wildfire）"><a href="#4-3-野火（Wildfire）" class="headerlink" title="4.3 野火（Wildfire）"></a>4.3 野火（Wildfire）</h3><p>作为数据存储系统，Arweave不仅需要存储大量信息的能力，而且还需要以最方便的方式提供对该数据的访问。此外，Arweave系统的重要组成部分是在请求时对数据进行无成本的访问。随后，Arweave增加了一层激励措施，以鼓励矿工自由共享数据。</p><p>Wildfire是一种系统，它通过使网络上数据请求的快速满足成为参与的必要部分，从而解决了分散式网络中数据共享的问题。 Wildfire通过在每个节点本地创建一个排名系统来进行工作，该排名系统确定新块和事务向对等对象分发的速度如何，基于它们对请求进行响应并接受来自其他对象的数据的速度。对等体按其等级顺序服务，而性能不佳的对等体则被从网络中黑名单中删除。从经济上激励同伴，使他们在彼此的排名中保持良好的位置，以便他们可以花费最大的时间进行有效的挖掘。</p><p>Arweave - 一种类区块链的区块编织结构（Lightpaper）</p><p><img src="/images/arweave/image-20220412232319579.png" alt="image-20220412232319579"></p><p>图2：野火系统示意图。 每个节点根据这些对等点之前对它们的表现进行评估，对其对等点进行排名。<br>这极大地鼓励系统中的节点以对其他对等方尽可能最友好的方式运行，而不会给正在接收数据的人，甚至可能是一次性请求的那些人带来代价。 更进一步，它创建了一种网络拓扑，该拓扑适合于最有效的全局路由，因为首选了允许在系统中快速传输新数据的连接。 实际上，野火机制构建了一个网络拓扑，该拓扑映射了Internet的底层物理连接基础，以适应其架构随时间的变化。 总体而言，野火系统可确保新块的高速分发，并以较短的延迟保持数据可用。</p><h3 id="4-4-区块阴影（Blockshadows）"><a href="#4-4-区块阴影（Blockshadows）" class="headerlink" title="4.4 区块阴影（Blockshadows）"></a>4.4 区块阴影（Blockshadows）</h3><p>在传统的区块链系统中，当挖掘一个新块时，无论一个节点已经拥有多少块数据，每个完整的块都会分配到网络中的每个节点。这不仅浪费大量数据，而且极大地降低了网络就块达成共识的速度。因此，Arweave引入了一种新技术，即块影子，它不仅可以最大程度地减少数据浪费，而且可以实现快速的块共识和巨大的事务吞吐量。</p><p>Blockshadowing的工作原理是部分取消来自块的事务，并且仅在节点之间发送最小的块“影子”，该影子允许对等方重建完整的块，而不是传输完整的块本身。这些区块影子专门包含钱包列表和哈希列表的哈希，并且代替区块内的交易，仅包含交易哈希的列表。根据这一信息（可能只有几千字节），一个已经在该区块中拥有所有交易的节点以及一个最新的哈希和钱包列表可以重建几乎任意大小的整个区块。为了促进这一点，节点还将立即彼此共享事务，但是只有在它们高度确定网络中的其他节点也具有事务处理后，才尝试将事务放置在一个块中。</p><p>这个区块集散系统的结果是一个快速，灵活的区块分配系统，该系统可以使交易以尽可能快的速度在网络上分布，并且可以以接近网络的速度达成共识。此外，该系统可确保当网络使用率很高时，交易费用不会显着增加，并且乐观的100mbps网络上的交易吞吐量的理论限制为每秒约5000笔交易。</p><h3 id="4-5-民主内容政策（Democratic-Content-Policy）"><a href="#4-5-民主内容政策（Democratic-Content-Policy）" class="headerlink" title="4.5 民主内容政策（Democratic Content Policy）"></a>4.5 民主内容政策（Democratic Content Policy）</h3><p>为了支持网络中各个参与者的自由以控制他们存储的内容，并允许整个网络以民主方式拒绝受到广泛谴责的内容，Arweave软件提供了一个黑名单系统。每个节点主节点都有一个（可选）黑名单，其中包含例如它不希望存储的某些数据的哈希值或子字符串，并且永远不会写入与此匹配的磁盘内容。这些黑名单可以由个人建立，也可以通过协作建立，也可以从其他来源导入。</p><p>在本地级别，这些黑名单允许节点控制自己的内容，但是这些本地拒绝的总和也会创建网络范围的内容拒绝。超过一半以上的网络拒绝的内容不仅会被这些单个节点中的每一个拒绝，而且还将被整个网络整体拒绝。这创建了一个民主的全网络内容拒绝系统，该系统可以将各种文化和观点中的黑名单合并为一个普遍删除的微小的特定内容黑名单。这个接近普遍，民主的黑名单使网络不受少数行为者的干扰，同时仍允许其以民主方式保护自己的自由。</p><h2 id="4-6-讨论（Discussion）"><a href="#4-6-讨论（Discussion）" class="headerlink" title="4.6 讨论（Discussion）"></a>4.6 讨论（Discussion）</h2><h3 id="4-6-1-存储池（Storage-Pools）"><a href="#4-6-1-存储池（Storage-Pools）" class="headerlink" title="4.6.1 存储池（Storage Pools）"></a>4.6.1 存储池（Storage Pools）</h3><p>对Arweave的一种潜在的理论攻击已经变得非常大，那就是矿工可能会合作维护一个组织的单个副本，他们都可以使用这些副本来检索召回块。 虽然这种行为乍看起来似乎是问题，但事实并非如此。 如果此类“存储池”被大部分矿工雇用，那么其他矿工存储稀有矿块的动机就会增加。 这是因为，如果集中存储区不可用，则当将来该稀有块成为撤回块时，具有稀有块副本的矿工将很可能获得奖励。 这种自私的行为为网络提供了风险抵销功能，该功能会随着数据丢失（由集中存储池引起）的可能性增长而扩展。</p><h2 id="5-构建App（Building-Apps）"><a href="#5-构建App（Building-Apps）" class="headerlink" title="5. 构建App（Building Apps）"></a>5. 构建App（Building Apps）</h2><p>可以使用简单的REST API构建使用组织的应用程序。 REST端点是HTTP，可以直接访问网络，因此任何Arweave钱包都可以读取和写入数据。 客户只需要通过Chrome扩展程序或具有Arweave钱包集成功能的本机应用程序将其Arweave钱包带入网站，即可从网络读取数据或向网络写入数据。 可以在组织之上构建几种体系结构。</p><h3 id="5-1-客户端-服务器架构（Client-Server-Architecture）"><a href="#5-1-客户端-服务器架构（Client-Server-Architecture）" class="headerlink" title="5.1 客户端-服务器架构（Client-Server Architecture）"></a>5.1 客户端-服务器架构（Client-Server Architecture）</h3><p>传统的Web或本机应用程序具有客户端-服务器体系结构。在云上运行的服务器将被“启用Arweave”，与一个或多个Arweave节点进行交互，代表客户端读取和写入数据。这些服务可以是将客户端作为访问者的网站，也可以是将客户端请求传递给开发人员操作的服务器的本机应用程序。这些服务器将需要维护AR令牌的浮动，以确保可以处理写入数据的请求。使用该架构从编织读取数据仍然是免费的。</p><p>该架构的获利潜力很简单。开发人员将需要通过广告，每月订阅或直接付款来获得更大的价值，而不是使用其为存储提供动力的AR令牌数量。永久性不可变存储有许多应用。例如，存储抗量子，加密的法律案例文件，身份或医疗记录。尽管某些法规需要适应敏感信息的存储，地理范围和被遗忘的权利，但也可以通过加密和密钥管理来缓解这种情况。几个创收模型可以在组织的顶部分层，其主要价值主张是链上永久不可变的存储。</p><h3 id="5-2-无服务器架构（Serverless-Architecture）"><a href="#5-2-无服务器架构（Serverless-Architecture）" class="headerlink" title="5.2 无服务器架构（Serverless Architecture）"></a>5.2 无服务器架构（Serverless Architecture）</h3><p>客户端可以通过启用Arweave的浏览器访问应用程序，而应用程序可以自身运行。由于浏览器的普及和Web技术的普及，使用HTML / CSS / JS将这些应用程序存储为标准前端Web应用程序是最有意义的。但是，如果客户端的本机应用程序包含针对不同语言（例如LLVM字节码）或脚本语言（如Python）的解释器/解析器，则它们可以在客户端上运行，并且可能会受益于Web应用程序中的相同可升级性。</p><p>开发人员不仅可以将无服务器的应用程序部署到Arweave，而且这些应用程序还可以将持久性和可证明状态写入网络。由于Arweave没有施加特定的数据结构，因此开发人员可以自由地以对他们来说最有意义的格式存储数据。如果该应用程序最好通过高度优化的Merkle结构（例如以太坊虚拟机（EVM）中找到的结构）来满足，则可以轻松地将其实现。如果开发人员正在寻找更多的文本Blob样式存储，那么这也是微不足道的。</p><p>无服务器应用程序非常有趣，因为它们可以写入自己的数据。例如，基于分布式计算将允许训练神经网络存储其结果，并可能与其他网络共享其结果模型。</p><h3 id="5-3-基于事件的（Event-Based）"><a href="#5-3-基于事件的（Event-Based）" class="headerlink" title="5.3 基于事件的（Event Based）"></a>5.3 基于事件的（Event Based）</h3><p>在Twitter成立之初，便有了蓬勃发展的家庭手工业应用程序生态系统，而开发人员则在“ firehost” API的基础上开发，这些API将推文流化为任何愿意付费访问的人。 情况已不再如此，在Facebook Cambridge Analytica惨败之后，这些向客户提供数据分析的服务的许多“可信赖的合作伙伴”都被任意关闭。</p><p>Arweave是一个分散的公共数据网络，因此，除了被民主拒绝的内容外，它永远不会审查数据访问或数据本身。 这意味着开发人员可以自由地在Arweave之上进行构建，并且可以使用REST API侦听传入的数据。 触发事件后，侦听器将触发订阅了这些事件的客户端的相应函数调用。 开发人员不必担心会受到限制或关闭，因为网络受到激励以向他们提供对数据馈送的可靠访问。</p><h3 id="5-4-无信任和可证明（Trustless-and-Provable）"><a href="#5-4-无信任和可证明（Trustless-and-Provable）" class="headerlink" title="5.4 无信任和可证明（Trustless and Provable）"></a>5.4 无信任和可证明（Trustless and Provable）</h3><p>可以对应用程序体系结构进行设计，以便轻松实现需要存储并保证防篡改的信息。 此外，可证明公平的运行时代码可以存储在组织上，并由客户端直接解释。 客户端使用内容的事务ID，可以在计算之前验证编织中的有效负载，并确保它们运行的代码既不受信任又可以证明是公平的，即与其他客户端运行的代码相同。 这为服务于其他区块链网络的无信任随机数生成器和其他基于oracle的服务开辟了有趣的可能性。</p><h2 id="6-用例（Use-Cases）"><a href="#6-用例（Use-Cases）" class="headerlink" title="6. 用例（Use Cases）"></a>6. 用例（Use Cases）</h2><p>永久存储有几个用例。 具体而言，法规要求将文件存档长达一定年限。 可证明的媒体报道，学术研究和不变的记录在我们回声室和假新闻泛滥的现代世界中变得越来越重要。</p><h3 id="6-1-真实性（Authenticity）"><a href="#6-1-真实性（Authenticity）" class="headerlink" title="6.1 真实性（Authenticity）"></a>6.1 真实性（Authenticity）</h3><p>法律体系常常与文件真实性的诉讼纠缠在一起。 Arweave通过提供来自作者的任何数字内容的不确定且可验证的存储来解决此问题。 2017年，特拉华州裁定在法院诉讼程序中可以接受区块链证据。 这些记录可能会大大加快有关艺术归属和知识财产之争的争议。 对于创意经济而言，效果是双重的，使艺术家可以将自己的作品立即转让给他人，并避免琐碎的诉讼。</p><h2 id="7-结论（Conclusion）"><a href="#7-结论（Conclusion）" class="headerlink" title="7. 结论（Conclusion）"></a>7. 结论（Conclusion）</h2><p>我们提出了一个新的区块链网络，该网络支持低成本的不可变数据存储和高吞吐量的加密货币。通过使用一种称为blockweave的类似于区块链的新数据结构，可以实现Arweave协议。通过区块隐藏灵活的大小交易区块分配；一种新的共识机制，即减少对工作证明的依赖度，称为访问证明；以及称为Wildfire的自我优化网络拓扑。就像比特币网络一样，我们在隔离方面的技术进步并不是十分复杂。但是，当结合起来形成整个网络时，紧急行为非常强大。从测试网的结果可以看出，在公共的，无许可的和分散的网络协议上，安全，可靠和不变的数据存储是可能的。除了数据存储期限外，任意大小的块都使安全的高吞吐量加密货币成为可能，而无需诉诸复杂的共识机制，例如dBFT或dPoS。</p><p>Arweave通过其REST API紧密地连接到Internet的结构中，并且正在使用Arweave主网建立一些创收业务。 Arweave与其他流行的加密货币之间的桥梁，安全的计算和智能合约协议将使低成本和永久性的数据存储轻松集成到分散式应用程序的技术堆栈中。一个全面全球化的信息和金融交流世界需要永久记录。通过结合加密技术和分布式系统，我们为这些永久记录提供了基础。我们希望Arweave将成为现有互联网协议（例如，万维网）的必要伴侣。与他人合作，建立更加开放和透明的未来。</p><h2 id="8-引用（Reference）"><a href="#8-引用（Reference）" class="headerlink" title="8. 引用（Reference）"></a>8. 引用（Reference）</h2><ol><li>Aweave白皮书地址：<a href="https://www.arweave.org/files/arweave-lightpaper.pdf">https://www.arweave.org/files/arweave-lightpaper.pdf</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载：&lt;a href=&quot;http://ipfsdrop.com/docs/whitepaper/arweave-lightpaper/&quot;&gt;http://ipfsdrop.com/docs/whitepaper/arweave-lightpaper/&lt;/a&gt;&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    
    <category term="Arweave" scheme="https://zhangzhishun.github.io/tags/Arweave/"/>
    
  </entry>
  
  <entry>
    <title>常用密码学库</title>
    <link href="https://zhangzhishun.github.io/2022/03/28/cryptography/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <id>https://zhangzhishun.github.io/2022/03/28/cryptography/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%93%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-28T15:29:15.000Z</published>
    <updated>2022-05-05T09:57:56.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><p><a href="https://pkg.go.dev/golang.org/x/crypto/bn256">Go官方</a> 已经不维护bn256.go包了，推荐使用<a href="https://github.com/cloudflare/bn256">cloudflare/bn256</a> ，但是也有安全漏洞.</p><p>CP-ABE实验中使用的包为<a href="https://github.com/fentec-project/bn256">fentec-project/bn256</a> ,此包是从 cloudflare/bn256 fork过来的，只是加了HashG1、HashG2方法</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><a href="https://github.com/JHUISI/charm">Charm</a></p><p>Charm 是一个用于快速制作高级密码系统原型的框架。它基于 Python 语言，从头开始设计，以最大限度地减少开发时间和代码复杂性，同时促进组件的重用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go&quot;&gt;&lt;a href=&quot;#Go&quot; class=&quot;headerlink&quot; title=&quot;Go&quot;&gt;&lt;/a&gt;Go&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pkg.go.dev/golang.org/x/crypto/bn256&quot;&gt;Go官方&lt;/a&gt; 已经不维护b</summary>
      
    
    
    
    
    <category term="密码学" scheme="https://zhangzhishun.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>30分钟创建一条区块链(二)</title>
    <link href="https://zhangzhishun.github.io/2022/03/05/blockchain/other/30%E5%88%86%E9%92%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%BA%8C)/"/>
    <id>https://zhangzhishun.github.io/2022/03/05/blockchain/other/30%E5%88%86%E9%92%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%BA%8C)/</id>
    <published>2022-03-05T12:57:53.000Z</published>
    <updated>2022-04-27T02:35:55.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将区块链API化"><a href="#将区块链API化" class="headerlink" title="将区块链API化"></a>将区块链API化</h2><p>在这个区块链中，我们想要实现三个API，分别是</p><ul><li>/api/mine：节点使用这个方法来挖掘新的区块</li><li>/api/transactions/new: 账户使用这个方法来建立新的交易</li><li>/api/chain: 返回当前的区块链</li></ul><p>为了复用我们在上篇写好的代码，我们首先安装express.js，并创建一个新文件 app.js。express是一个基于node的http框架，它可以允许我们接受通过http协议传输的节点信息。我们还需要body-parser帮助我们解码节点发送过来的信息。</p><h2 id="实现分布式共识"><a href="#实现分布式共识" class="headerlink" title="实现分布式共识"></a>实现分布式共识</h2><p>以上我们已经实现了一个单机版的区块链了，但区块链之所以有用，是因为它能被部署到多个节点上去，并且所有节点都能够相互更新，实现分布式的共识。这样的机制保证了我们能够抵御double spending attack以及确保只有一条区块链在运行。</p><p>为了实现我们的分布式共识，我们首先需要知道网络上其他的节点在哪里。仿照Ethereum的 Node Discovery Protocol，我们可以做一个类似的搜索节点的功能和节点注册功能</p><pre><code class="javascript">_app.post('/api/nodes/register', (req, res) =&gt; {    // 注册节点    let newNode = _.pick(req.body, ['ip', 'port']);    neighbors.push(newNode);    console.log('new node detected. Node info: ' + JSON.stringify(newNode));    res.send({        message: 'Node ' + newNode.ip + ':' + newNode.port + ' is added to my network'    });});</code></pre><h3 id="共识实现-解决冲突链"><a href="#共识实现-解决冲突链" class="headerlink" title="共识实现: 解决冲突链"></a>共识实现: 解决冲突链</h3><p>知道了附近的节点在哪，我们就可以开始实现我们的共识算法。共识算法的第一部分需要我们能够辨别出最长且有效的链，我们可以通过在之前写的区块链模型里加入新的函数实现。</p><p>在 <code>app.js</code>中，我们可以在每次挖矿之后都向附近的节点广播，以解决冲突链。首先我们需要建立一个新的端点 <code>/api/nodes/resolve</code>。建立好端点之后我们需要在挖矿之后对所有的邻居进行广播。</p><p>这样setup之后，我们的节点在每一次挖矿的时候都会对附近的邻居进行广播并寻求consensus。当然，我们还可以设定定时任务来更高频的进行广播。另外，我们也没有对收到的chain进行电子验证，没有动态化的寻找相邻节点，没有将每一个transaction广播，以及一系列可以完善的地方，不过在这篇教程当中我们就不继续下去了。</p><pre><code class="javascript">_app.get('/api/mine', (req, res) =&gt; {    // 挖矿    myChain.createBlock();    let p = new Promise((resolve) =&gt; resolve());    for (let i of neighbors) {        let resolveUri = 'http://' + i.ip + ':' + i.port + '/api/nodes/resolve';        console.log("send resolve to: " + resolveUri);        p.then(() =&gt; rp({            uri: resolveUri,            method: 'POST',            json: true,            body: {'chain': myChain}        })).then((res) =&gt; {            // 同步最长链            myChain.resolveChain(JSON.parse(res.body)["chain"]);        });    }    p.then(() =&gt; {        res.send({            message: 'A new block is mined, and conflict is resolved',            content: myChain.lastBlock()        });    });});</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上我们实现了一个简单的区块链，虽然这个区块链简陋且不安全，但是我们能够成功将它部署到多个节点上，实现了最基本的区块链的功能。</p><p>完整代码：<a href="https://github.com/zhangzhishun/sugar-blockchain-js">代码</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mp.weixin.qq.com/s/6jwIj_m86dpGk62biEJyIA">30分钟自己写一条区块链(一)</a></li><li><a href="https://mp.weixin.qq.com/s/UbLx2mHEb9OyPeJBwP2bvg">30分钟自己写一条区块链(二)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;将区块链API化&quot;&gt;&lt;a href=&quot;#将区块链API化&quot; class=&quot;headerlink&quot; title=&quot;将区块链API化&quot;&gt;&lt;/a&gt;将区块链API化&lt;/h2&gt;&lt;p&gt;在这个区块链中，我们想要实现三个API，分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/api/mine</summary>
      
    
    
    
    
    <category term="部署文档" scheme="https://zhangzhishun.github.io/tags/%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/"/>
    
    <category term="Other" scheme="https://zhangzhishun.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>30分钟创建一条区块链(一)</title>
    <link href="https://zhangzhishun.github.io/2022/02/28/blockchain/other/30%E5%88%86%E9%92%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%B8%80)/"/>
    <id>https://zhangzhishun.github.io/2022/02/28/blockchain/other/30%E5%88%86%E9%92%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9D%A1%E5%8C%BA%E5%9D%97%E9%93%BE(%E4%B8%80)/</id>
    <published>2022-02-28T01:10:53.000Z</published>
    <updated>2022-04-27T02:35:55.483Z</updated>
    
    <content type="html"><![CDATA[<p>如何从技术上实现一条区块链？<br>首先，这里假定读者有基本的编程能力，虽然本文用了Javascript来写，但掌握任意一门编程语言的读者阅读起来应该不会有任何难度。</p><h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>我们首先需要安装最新版的Node.js</p><h2 id="第一步，搭建区块链模型"><a href="#第一步，搭建区块链模型" class="headerlink" title="第一步，搭建区块链模型"></a>第一步，搭建区块链模型</h2><p>我们首先来搭一个能够新建区块，创建交易的区块链的模型。</p><pre><code class="javascript">'use strict';//定义一个class，叫BlockChain，每一个区块链都是这个class的实例class BlockChain {    constructor() {        this.chain = []; // 储存所有区块        this.difficulty = 4; // 挖矿的难度    }    isProofValid(tentativeBlock) {        // 这里我们判断newProof是不是一个合法的proof的方法是    }    createBlock(transaction, previousHash = undefined) {        // 创造一个新区块    }    createTransaction(sender, receiver, value) {        // 创建一个交易    }    static hash(block) {        // 对一个区块进行哈希:    }    lastBlock() {        // 取得链上的最后一个区块    }    miner() {        // 挖矿程序    }}</code></pre><p>这里要解释一下区块(block)和交易(transaction)各自长什么样，虽然不同区块链的区块模型有很大差异，但最基本的一些元素都是相通的。一个最基本的区块大概长下面这样：</p><pre><code class="javascript">var block = {       timestamp: 1516245715528,     id: 0,    proof: 786453290000,    previousBlockHash: "12f79cda4fb3f084531de2034e6b4acf",    transactions: [{        sender: "0xca35b7d915458ef540ade6068dfe2f44e8fa733c",        receiver: "0x14723a09acff6d2a60dcdf7aa4aff308fddc160c",        value: 100    }]}</code></pre><p>可以看到，一个区块包含了它被挖出来的时间戳(timestamp)，它在区块链里的位置(id)，它的证明(proof, 更多的会在之后讲到)，前一个区块的整体哈希值(previousBlockHash)，包含的交易(transactions)。 作为一个最基本的交易模型，每一个交易只包含了发送者的地址(sender)，接受者的地址(receiver)，以及这次交易的价值(value)。</p><h2 id="第二步，实现基本功能"><a href="#第二步，实现基本功能" class="headerlink" title="第二步，实现基本功能"></a>第二步，实现基本功能</h2><p>工具函数<br>这里我们首先实现一个工具函数Hash(block), 它会帮助我们将一个区块进行哈希。这个函数会在我们进行挖矿(发掘新区块)的时候用到。</p><pre><code class="javascript">static hash(block) {    // 对一个区块进行哈希:    // 现将block 转换成base64    // 将得到的结果进行SHA哈希    const blockStr = JSON.stringify(block);    const blockB64 = new Buffer(blockStr).toString("base64");    const newHash = crypto.createHash("sha256");    newHash.update(blockB64);    return newHash.digest("hex");}</code></pre><p>这个函数将一个区块，也就是一个Javascript object，哈希成一段字符串。我们使用了crypto这个工具，在最新版的Node.js里面已经是内置了，所以我们并不需要安装它。</p><p>创建一个新交易<br>下一步，我们实现创建新交易的方法。</p><pre><code class="javascript">createTransaction(sender, receiver, value) {    // 创建一个交易    // 根据提供的sender, receiver地址，以及转账的价值，建立一个交易    // 并把它加入到我们的区块链里    const transaction = {        sender: sender,        receiver: receiver,        value: value    };    this._packTransactions.push(transaction);    return this.miner();}</code></pre><p>非常直观，我们只是创建了一个object，加入到区块链里并返回而已。</p><p>创建一个新区块<br>我们现在来实现创建一个区块的代码。当我们的区块链连一个区块也没有的时候，我们需要建立第一个区块(genesis block)，这一点我们在constructor里面实现。</p><pre><code class="javascript">constructor() {    this.chain = []; // 储存所有区块    this.difficulty = 4; // 挖矿的难度    this.createBlock(["Genesis Block"], 1); // 创建第一个区块    this._packTransactions = []; // 当前需要打包的数据}createBlock(transaction, previousHash = undefined) {    // 创造一个新区块    // 一开始的proof是0，不一定是有效的，所以我们需要mineProof来找到有效的proof    let block = {        timestamp: Date.now(),        id: this.chain.length,        proof: 0,        previousBlockHash: previousHash || this.constructor.hash(this.lastBlock()),        transactions: transaction    };    const hash = this.mineProof(block);    this.chain.push(block);    return hash;}</code></pre><p>在创建一个新区块的时候，我们用了当前时间的时间戳，以现在区块链的长度作为id，初始的proof设置为0(proof会在下一步详细讲到)，并将上一个区块整体进行哈希并赋值给previousBlockHash。在创建genesis 区块的时候，我们将previousBlockHash设置为1。 为了便于理解，我们建立新区块的时候没有附上任何交易，实际的情况是矿工可以自主选择包含哪些交易，并需要对这些交易进行处理得到一个默克尔树。</p><h2 id="理解挖矿：找到有效的Proof"><a href="#理解挖矿：找到有效的Proof" class="headerlink" title="理解挖矿：找到有效的Proof"></a>理解挖矿：找到有效的Proof</h2><p>读者朋友们应该都听说过工作量证明(Proof of Work)，POW是区块链中用来创造区块的核心算法或者机制。POW本身的目的是为了找到一个数字来解决一个数学问题，而找到这个数字的难度是越来越高的，但一旦找到之后，要证明它解决了这个数学问题又是非常容易的，任何人都能很快做到。 当然除了Proof of Work之外，我们还有Proof of Space, Proof of Stake，在代码里我们就用proof来代表找到的这个数字。 那么这个数学问题到底是什么呢？我们用一个例子来回答。</p><p>给定一个数字A，我们想找到数字B，使得Hash(A<em>B)的结果C的最后1位等于0。也就是说，C可以是Hash(A</em>B)=2ba83…6d0，因为它的最后一位是0。</p><h2 id="实现挖矿"><a href="#实现挖矿" class="headerlink" title="实现挖矿"></a>实现挖矿</h2><p>知道了如何挖矿之后，我们将上面的代码融合到我们的区块链模型里。</p><pre><code class="javascript">    isProofValid(tentativeBlock) {        // 这里我们判断newProof是不是一个合法的proof的方法是        // 将整个区块进行哈希        // 如果得到的散列值指的最后n位都是0，那么这是一个valid proof        // 其中，n = difficulty        const result = this.constructor.hash(tentativeBlock);        return result.substr(result.length - this.difficulty) === '0'.repeat(this.difficulty);    }    mineProof(tentativeBlock) {        console.log("miner block start: " + JSON.stringify(tentativeBlock));        while (!this.isProofValid(tentativeBlock)) {            tentativeBlock.proof += 1; // 如果不是可用的proof，我们就接着枚举        }        const hash = this.constructor.hash(tentativeBlock);        console.log("miner block success. Hash: " + hash);        return hash;    }    createBlock(transaction, previousHash = undefined) {        // 创造一个新区块        // 一开始的proof是0，不一定是有效的，所以我们需要mineProof来找到有效的proof        let block = {            timestamp: Date.now(),            id: this.chain.length,            proof: 0,            previousBlockHash: previousHash || this.constructor.hash(this.lastBlock()),            transactions: transaction        };        const hash = this.mineProof(block);        this.chain.push(block);        return hash;    }    miner() {        // 挖矿程序        if (this._packTransactions.length &gt; 0) {            const hash = this.createBlock([this._packTransactions[this._packTransactions.length - 1]]);            if (hash) {                this._packTransactions.pop();                return hash            }        }    }</code></pre><p>完整代码：<a href="https://github.com/zhangzhishun/sugar-blockchain-js/blob/master/blockchain.js">blockchain</a></p><p>参考：</p><ol><li><a href="https://mp.weixin.qq.com/s/6jwIj_m86dpGk62biEJyIA">30分钟自己写一条区块链(一)</a></li><li><a href="https://mp.weixin.qq.com/s/UbLx2mHEb9OyPeJBwP2bvg">30分钟自己写一条区块链(二)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何从技术上实现一条区块链？&lt;br&gt;首先，这里假定读者有基本的编程能力，虽然本文用了Javascript来写，但掌握任意一门编程语言的读者阅读起来应该不会有任何难度。&lt;/p&gt;
&lt;h2 id=&quot;开发准备&quot;&gt;&lt;a href=&quot;#开发准备&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="部署文档" scheme="https://zhangzhishun.github.io/tags/%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/"/>
    
    <category term="Other" scheme="https://zhangzhishun.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>NFT框架 OpenZeppelin ERC721源码分析</title>
    <link href="https://zhangzhishun.github.io/2022/02/26/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelinERC721%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://zhangzhishun.github.io/2022/02/26/blockchain/nft/NFT%E6%A1%86%E6%9E%B6-OpenZeppelinERC721%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-02-26T02:25:11.000Z</published>
    <updated>2022-04-27T02:35:55.483Z</updated>
    
    <content type="html"><![CDATA[<p>ERC721官方简介是：A standard interface for non-fungible tokens, also known as deeds.也叫非同质代币，或者不可置换代币（NFTs）。提到ERC721，一个好理解的例子就是<a href="https://link.segmentfault.com/?enc=C1N3804jiPfa4j/kbVqQeA==.qKJ3FJzSnC5Qcs2rB15IvrOOttPxdU0dtue8Pk75gJ0=">CryptoKitties迷恋猫</a> ,每一只猫都是独一无二的拥有不同基因，有收藏价值属性。ERC721对于虚拟资产收藏品领域会有很好的应用价值和市场需求。</p><p>ERC721是以太坊和 Wanchain 区块链的<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md">ERC-721不可替代令牌标准的完整参考实现。</a>它还与其他 EVM 兼容链兼容，如 Binance Smart Chain (BSC)、Avalanche (AVAX) 等。这是一个开源项目，完成了<a href="https://hardhat.org/">Hardhat</a>测试。</p><p>此项目的目的是为任何想要在以太坊和 Wanchain 区块链上使用和开发不可替代代币的人提供一个良好的起点。您可以使用经过多次审核的代码，而不是自己重新实现 ERC-721，此实现比 ERC-721 标准更具限制性，因为它不支持<code>payable</code>开箱即用的函数调用。但是，您可以自己添加它。</p><p>合约列表：</p><ul><li><a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token.sol"><code>nf-token.sol</code></a>：这是基本的 ERC-721 token实现（支持 ERC-165）。</li><li><a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token-metadata.sol"><code>nf-token-metadata.sol</code></a>：这为代币合约实现了可选的 ERC-721 元数据功能。它实现了一个token名称、一个符号和一个指向公开暴露的 ERC-721 JSON 元数据文件的不同 URI。</li><li><a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token-enumerable.sol"><code>nf-token-enumerable.sol</code></a>：这实现了对枚举的可选 ERC-721 支持。如果您想知道代币的总供应量、按索引查询代币等，这很有用</li></ul><p>合约类、接口之间的继承关系：</p><p><img src="/images/open-zeppelin-erc721/image-20220226171652608.png" alt="image-20220226171652608"></p><h2 id="1-SupportsInterface"><a href="#1-SupportsInterface" class="headerlink" title="1. SupportsInterface"></a>1. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/utils/supports-interface.sol">SupportsInterface</a></h2><p>实现检测智能合约接口的标准。</p><p>例如在合约的构造函数定义如下内容指定检测标准：</p><pre><code class="javascript">supportedInterfaces[0x01ffc9a7] = true; // ERC165supportedInterfaces[0x780e9d63] = true; // ERC721EnumerablesupportedInterfaces[0x5b5e139f] = true; // ERC721MetadatasupportedInterfaces[0x80ac58cd] = true; // ERC721</code></pre><p>源码：</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./erc165.sol";/** * @dev Implementation of standard for detect smart contract interfaces. */contract SupportsInterface is  ERC165{  /**   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.   */  mapping(bytes4 =&gt; bool) internal supportedInterfaces;  /**   * @dev Contract constructor.   */  constructor()  {    supportedInterfaces[0x01ffc9a7] = true; // ERC165  }  /**   * @dev Function to check which interfaces are suported by this contract.   * @param _interfaceID Id of the interface.   * @return True if _interfaceID is supported, false otherwise.   */  function supportsInterface(    bytes4 _interfaceID  )    external    override    view    returns (bool)  {    return supportedInterfaces[_interfaceID];  }}</code></pre><h2 id="2-ERC721"><a href="#2-ERC721" class="headerlink" title="2. ERC721"></a>2. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/erc721.sol">ERC721</a></h2><p>ERC721合约定义了基本的接口方法：</p><ul><li><p>safeTransferFrom：转移代币所有权</p></li><li><p>transferFrom：转移代币所有权</p></li><li><p>setApprovalForAll：授权operator具有所有代币的控制权</p></li><li><p>balanceOf：返回owner的代币数量</p></li><li><p>ownerOf：根据tokenId返回代币持有者address</p></li><li><p>getApproved：查询tokenId的授权人operator address</p></li><li><p>approve 授权tokenId给地址to</p></li><li><p>isApprovedForAll：查询一个地址是否为另一个地址的授权操作者。</p></li></ul><p>源码：</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/** * @dev ERC-721 non-fungible token standard. * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md. */interface ERC721{  /**   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any   * number of NFTs may be created and assigned without emitting Transfer. At the time of any   * transfer, the approved address for that NFT (if any) is reset to none.   */  event Transfer(    address indexed _from,    address indexed _to,    uint256 indexed _tokenId  );  /**   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero   * address indicates there is no approved address. When a Transfer event emits, this also   * indicates that the approved address for that NFT (if any) is reset to none.   */  event Approval(    address indexed _owner,    address indexed _approved,    uint256 indexed _tokenId  );  /**   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage   * all NFTs of the owner.   */  event ApprovalForAll(    address indexed _owner,    address indexed _operator,    bool _approved  );  /**   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this   * function checks if `_to` is a smart contract (code size &gt; 0). If so, it calls   * `onERC721Received` on `_to` and throws if the return value is not   * `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.   * @dev Transfers the ownership of an NFT from one address to another address. This function can   * be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   * @param _data Additional data with no specified format, sent in call to `_to`.   */  function safeTransferFrom(    address _from,    address _to,    uint256 _tokenId,    bytes calldata _data  )    external;  /**   * @notice This works identically to the other function with an extra data parameter, except this   * function just sets data to ""   * @dev Transfers the ownership of an NFT from one address to another address. This function can   * be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   */  function safeTransferFrom(    address _from,    address _to,    uint256 _tokenId  )    external;  /**   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else   * they may be permanently lost.   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero   * address. Throws if `_tokenId` is not a valid NFT.  This function can be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   */  function transferFrom(    address _from,    address _to,    uint256 _tokenId  )    external;  /**   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is   * the current NFT owner, or an authorized operator of the current owner.   * @param _approved The new approved NFT controller.   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.   * @param _tokenId The NFT to approve.   */  function approve(    address _approved,    uint256 _tokenId  )    external;  /**   * @notice The contract MUST allow multiple operators per owner.   * @dev Enables or disables approval for a third party ("operator") to manage all of   * `msg.sender`'s assets. It also emits the ApprovalForAll event.   * @param _operator Address to add to the set of authorized operators.   * @param _approved True if the operators is approved, false to revoke approval.   */  function setApprovalForAll(    address _operator,    bool _approved  )    external;  /**   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are   * considered invalid, and this function throws for queries about the zero address.   * @notice Count all NFTs assigned to an owner.   * @param _owner Address for whom to query the balance.   * @return Balance of _owner.   */  function balanceOf(    address _owner  )    external    view    returns (uint256);  /**   * @notice Find the owner of an NFT.   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are   * considered invalid, and queries about them do throw.   * @param _tokenId The identifier for an NFT.   * @return Address of _tokenId owner.   */  function ownerOf(    uint256 _tokenId  )    external    view    returns (address);  /**   * @notice Throws if `_tokenId` is not a valid NFT.   * @dev Get the approved address for a single NFT.   * @param _tokenId The NFT to find the approved address for.   * @return Address that _tokenId is approved for.   */  function getApproved(    uint256 _tokenId  )    external    view    returns (address);  /**   * @notice Query if an address is an authorized operator for another address.   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.   * @param _owner The address that owns the NFTs.   * @param _operator The address that acts on behalf of the owner.   * @return True if approved for all, false otherwise.   */  function isApprovedForAll(    address _owner,    address _operator  )    external    view    returns (bool);}</code></pre><h2 id="3-ERC721Metadata"><a href="#3-ERC721Metadata" class="headerlink" title="3. ERC721Metadata"></a>3. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/erc721-metadata.sol">ERC721Metadata</a></h2><p>ERC-721不可替代令牌标准的可选元数据扩展。</p><p>主要方法：</p><ul><li>name：返回NFT的描述性名称</li><li>symbol：返回NFT的缩写名称</li><li>tokenURI：返回_tokenId对应的资源URI</li></ul><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/** * @dev Optional metadata extension for ERC-721 non-fungible token standard. * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md. */interface ERC721Metadata{  /**   * @dev Returns a descriptive name for a collection of NFTs in this contract.   * @return _name Representing name.   */  function name()    external    view    returns (string memory _name);  /**   * @dev Returns a abbreviated name for a collection of NFTs in this contract.   * @return _symbol Representing symbol.   */  function symbol()    external    view    returns (string memory _symbol);  /**   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file   * that conforms to the "ERC721 Metadata JSON Schema".   * @return URI of _tokenId.   */  function tokenURI(uint256 _tokenId)    external    view    returns (string memory);}</code></pre><h2 id="4-ERC721Enumerable"><a href="#4-ERC721Enumerable" class="headerlink" title="4. ERC721Enumerable"></a>4. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/erc721-enumerable.sol">ERC721Enumerable</a></h2><p>ERC-721不可替代令牌标准的可选枚举扩展。</p><p>主要方法：</p><ul><li>totalSupply：返回由此契约跟踪的有效nft的计数（代币总量），其中每个nft都有一个分配的、可查询的所有者，且所有者不等于零地址</li><li>tokenByIndex：返回第index的NFT的tokenId。没有指定排序顺序。</li><li>tokenOfOwnerByIndex：返回分配给指定人的第index的NFT的tokenId。没有指定排序顺序</li></ul><p>源码：</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/** * @dev Optional enumeration extension for ERC-721 non-fungible token standard. * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md. */interface ERC721Enumerable{  /**   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an   * assigned and queryable owner not equal to the zero address.   * @return Total supply of NFTs.   */  function totalSupply()    external    view    returns (uint256);  /**   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.   * @param _index A counter less than `totalSupply()`.   * @return Token id.   */  function tokenByIndex(    uint256 _index  )    external    view    returns (uint256);  /**   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is   * not specified. It throws if `_index` &gt;= `balanceOf(_owner)` or if `_owner` is the zero address,   * representing invalid NFTs.   * @param _owner An address where we are interested in NFTs owned by them.   * @param _index A counter less than `balanceOf(_owner)`.   * @return Token id.   */  function tokenOfOwnerByIndex(    address _owner,    uint256 _index  )    external    view    returns (uint256);}</code></pre><h2 id="5-NFToken"><a href="#5-NFToken" class="headerlink" title="5. NFToken"></a>5. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token.sol">NFToken</a></h2><p>ERC721 标准基本实现</p><p>主要方法：</p><ul><li>safeTransferFrom：将NFT的所有权从一个地址转移到另一个地址。此功能可更改为payable</li><li>transferFrom：将指定的token所有权转移给另外一个地址，不鼓励使用这个方法，尽量使用<code>safeTransferFrom</code></li><li>approve：批准另一个人address来交易指定的代币，0 address 表示没有授权的地址，给定的时间内，一个token只能有一个批准的地址，只有token的持有者或者授权的操作人才可以调用。此功能可更改为payable</li><li>setApprovalForAll：设置或者取消对操作人的授权，一个操作人可以代表他们转让发送者的所有token</li><li>balanceOf：获取持有者的代币总数</li><li>ownerOf：根据token ID获取持有者</li><li>getApproved：获取token被授权的地址，如果没有设置地址则为0</li><li>isApprovedForAll：查询是否操作人被指定的持有者授权，要查询的授权人地址，要查询的授权操作人地址</li></ul><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./erc721.sol";import "./erc721-token-receiver.sol";import "../utils/supports-interface.sol";import "../utils/address-utils.sol";/** * @dev Implementation of ERC-721 non-fungible token standard. */contract NFToken is  ERC721,  SupportsInterface{  using AddressUtils for address;  /**   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.   * Based on 0xcert framework error codes.   */  string constant ZERO_ADDRESS = "003001";  string constant NOT_VALID_NFT = "003002";  string constant NOT_OWNER_OR_OPERATOR = "003003";  string constant NOT_OWNER_APPROVED_OR_OPERATOR = "003004";  string constant NOT_ABLE_TO_RECEIVE_NFT = "003005";  string constant NFT_ALREADY_EXISTS = "003006";  string constant NOT_OWNER = "003007";  string constant IS_OWNER = "003008";  /**   * @dev Magic value of a smart contract that can receive NFT.   * Equal to: bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")).   */  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;  /**   * @dev A mapping from NFT ID to the address that owns it.   */  mapping (uint256 =&gt; address) internal idToOwner;  /**   * @dev Mapping from NFT ID to approved address.   */  mapping (uint256 =&gt; address) internal idToApproval;   /**   * @dev Mapping from owner address to count of their tokens.   */  mapping (address =&gt; uint256) private ownerToNFTokenCount;  /**   * @dev Mapping from owner address to mapping of operator addresses.   */  mapping (address =&gt; mapping (address =&gt; bool)) internal ownerToOperators;  /**   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.   * @param _tokenId ID of the NFT to validate.   */  modifier canOperate(    uint256 _tokenId  )  {    address tokenOwner = idToOwner[_tokenId];    require(      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],      NOT_OWNER_OR_OPERATOR    );    _;  }  /**   * @dev Guarantees that the msg.sender is allowed to transfer NFT.   * @param _tokenId ID of the NFT to transfer.   */  modifier canTransfer(    uint256 _tokenId  )  {    address tokenOwner = idToOwner[_tokenId];    require(      tokenOwner == msg.sender      || idToApproval[_tokenId] == msg.sender      || ownerToOperators[tokenOwner][msg.sender],      NOT_OWNER_APPROVED_OR_OPERATOR    );    _;  }  /**   * @dev Guarantees that _tokenId is a valid Token.   * @param _tokenId ID of the NFT to validate.   */  modifier validNFToken(    uint256 _tokenId  )  {    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);    _;  }  /**   * @dev Contract constructor.   */  constructor()  {    supportedInterfaces[0x80ac58cd] = true; // ERC721  }  /**   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this   * function checks if `_to` is a smart contract (code size &gt; 0). If so, it calls   * `onERC721Received` on `_to` and throws if the return value is not   * `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.   * @dev Transfers the ownership of an NFT from one address to another address. This function can   * be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   * @param _data Additional data with no specified format, sent in call to `_to`.   */  function safeTransferFrom(    address _from,    address _to,    uint256 _tokenId,    bytes calldata _data  )    external    override  {    _safeTransferFrom(_from, _to, _tokenId, _data);  }  /**   * @notice This works identically to the other function with an extra data parameter, except this   * function just sets data to "".   * @dev Transfers the ownership of an NFT from one address to another address. This function can   * be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   */  function safeTransferFrom(    address _from,    address _to,    uint256 _tokenId  )    external    override  {    _safeTransferFrom(_from, _to, _tokenId, "");  }  /**   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else   * they may be permanently lost.   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero   * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   */  function transferFrom(    address _from,    address _to,    uint256 _tokenId  )    external    override    canTransfer(_tokenId)    validNFToken(_tokenId)  {    address tokenOwner = idToOwner[_tokenId];    require(tokenOwner == _from, NOT_OWNER);    require(_to != address(0), ZERO_ADDRESS);    _transfer(_to, _tokenId);  }  /**   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is   * the current NFT owner, or an authorized operator of the current owner.   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.   * @param _approved Address to be approved for the given NFT ID.   * @param _tokenId ID of the token to be approved.   */  function approve(    address _approved,    uint256 _tokenId  )    external    override    canOperate(_tokenId)    validNFToken(_tokenId)  {    address tokenOwner = idToOwner[_tokenId];    require(_approved != tokenOwner, IS_OWNER);    idToApproval[_tokenId] = _approved;    emit Approval(tokenOwner, _approved, _tokenId);  }  /**   * @notice This works even if sender doesn't own any tokens at the time.   * @dev Enables or disables approval for a third party ("operator") to manage all of   * `msg.sender`'s assets. It also emits the ApprovalForAll event.   * @param _operator Address to add to the set of authorized operators.   * @param _approved True if the operators is approved, false to revoke approval.   */  function setApprovalForAll(    address _operator,    bool _approved  )    external    override  {    ownerToOperators[msg.sender][_operator] = _approved;    emit ApprovalForAll(msg.sender, _operator, _approved);  }  /**   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are   * considered invalid, and this function throws for queries about the zero address.   * @param _owner Address for whom to query the balance.   * @return Balance of _owner.   */  function balanceOf(    address _owner  )    external    override    view    returns (uint256)  {    require(_owner != address(0), ZERO_ADDRESS);    return _getOwnerNFTCount(_owner);  }  /**   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are   * considered invalid, and queries about them do throw.   * @param _tokenId The identifier for an NFT.   * @return _owner Address of _tokenId owner.   */  function ownerOf(    uint256 _tokenId  )    external    override    view    returns (address _owner)  {    _owner = idToOwner[_tokenId];    require(_owner != address(0), NOT_VALID_NFT);  }  /**   * @notice Throws if `_tokenId` is not a valid NFT.   * @dev Get the approved address for a single NFT.   * @param _tokenId ID of the NFT to query the approval of.   * @return Address that _tokenId is approved for.   */  function getApproved(    uint256 _tokenId  )    external    override    view    validNFToken(_tokenId)    returns (address)  {    return idToApproval[_tokenId];  }  /**   * @dev Checks if `_operator` is an approved operator for `_owner`.   * @param _owner The address that owns the NFTs.   * @param _operator The address that acts on behalf of the owner.   * @return True if approved for all, false otherwise.   */  function isApprovedForAll(    address _owner,    address _operator  )    external    override    view    returns (bool)  {    return ownerToOperators[_owner][_operator];  }  /**   * @notice Does NO checks.   * @dev Actually performs the transfer.   * @param _to Address of a new owner.   * @param _tokenId The NFT that is being transferred.   */  function _transfer(    address _to,    uint256 _tokenId  )    internal    virtual  {    address from = idToOwner[_tokenId];    _clearApproval(_tokenId);    _removeNFToken(from, _tokenId);    _addNFToken(_to, _tokenId);    emit Transfer(from, _to, _tokenId);  }  /**   * @notice This is an internal function which should be called from user-implemented external   * mint function. Its purpose is to show and properly initialize data structures when using this   * implementation.   * @dev Mints a new NFT.   * @param _to The address that will own the minted NFT.   * @param _tokenId of the NFT to be minted by the msg.sender.   */  function _mint(    address _to,    uint256 _tokenId  )    internal    virtual  {    require(_to != address(0), ZERO_ADDRESS);    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);    _addNFToken(_to, _tokenId);    emit Transfer(address(0), _to, _tokenId);  }  /**   * @notice This is an internal function which should be called from user-implemented external burn   * function. Its purpose is to show and properly initialize data structures when using this   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned   * NFT.   * @dev Burns a NFT.   * @param _tokenId ID of the NFT to be burned.   */  function _burn(    uint256 _tokenId  )    internal    virtual    validNFToken(_tokenId)  {    address tokenOwner = idToOwner[_tokenId];    _clearApproval(_tokenId);    _removeNFToken(tokenOwner, _tokenId);    emit Transfer(tokenOwner, address(0), _tokenId);  }  /**   * @notice Use and override this function with caution. Wrong usage can have serious consequences.   * @dev Removes a NFT from owner.   * @param _from Address from which we want to remove the NFT.   * @param _tokenId Which NFT we want to remove.   */  function _removeNFToken(    address _from,    uint256 _tokenId  )    internal    virtual  {    require(idToOwner[_tokenId] == _from, NOT_OWNER);    ownerToNFTokenCount[_from] -= 1;    delete idToOwner[_tokenId];  }  /**   * @notice Use and override this function with caution. Wrong usage can have serious consequences.   * @dev Assigns a new NFT to owner.   * @param _to Address to which we want to add the NFT.   * @param _tokenId Which NFT we want to add.   */  function _addNFToken(    address _to,    uint256 _tokenId  )    internal    virtual  {    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);    idToOwner[_tokenId] = _to;    ownerToNFTokenCount[_to] += 1;  }  /**   *&nbsp;@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable   * extension to remove double storage (gas optimization) of owner NFT count.   * @param _owner Address for whom to query the count.   * @return Number of _owner NFTs.   */  function _getOwnerNFTCount(    address _owner  )    internal    virtual    view    returns (uint256)  {    return ownerToNFTokenCount[_owner];  }  /**   * @dev Actually perform the safeTransferFrom.   * @param _from The current owner of the NFT.   * @param _to The new owner.   * @param _tokenId The NFT to transfer.   * @param _data Additional data with no specified format, sent in call to `_to`.   */  function _safeTransferFrom(    address _from,    address _to,    uint256 _tokenId,    bytes memory _data  )    private    canTransfer(_tokenId)    validNFToken(_tokenId)  {    address tokenOwner = idToOwner[_tokenId];    require(tokenOwner == _from, NOT_OWNER);    require(_to != address(0), ZERO_ADDRESS);    _transfer(_to, _tokenId);    if (_to.isContract())    {      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);    }  }  /**   * @dev Clears the current approval of a given NFT ID.   * @param _tokenId ID of the NFT to be transferred.   */  function _clearApproval(    uint256 _tokenId  )    private  {    delete idToApproval[_tokenId];  }}</code></pre><h2 id="6-NFTokenMetadata"><a href="#6-NFTokenMetadata" class="headerlink" title="6. NFTokenMetadata"></a>6. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token-metadata.sol">NFTokenMetadata</a></h2><p>ERC-721不可替代令牌标准的可选元数据实现，继承NFToken并实现了ERC721Metadata接口</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./nf-token.sol";import "./erc721-metadata.sol";/** * @dev Optional metadata implementation for ERC-721 non-fungible token standard. */contract NFTokenMetadata is  NFToken,  ERC721Metadata{  /**   * @dev A descriptive name for a collection of NFTs.   */  string internal nftName;  /**   * @dev An abbreviated name for NFTokens.   */  string internal nftSymbol;  /**   * @dev Mapping from NFT ID to metadata uri.   */  mapping (uint256 =&gt; string) internal idToUri;  /**   * @notice When implementing this contract don't forget to set nftName and nftSymbol.   * @dev Contract constructor.   */  constructor()  {    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata  }  /**   * @dev Returns a descriptive name for a collection of NFTokens.   * @return _name Representing name.   */  function name()    external    override    view    returns (string memory _name)  {    _name = nftName;  }  /**   * @dev Returns an abbreviated name for NFTokens.   * @return _symbol Representing symbol.   */  function symbol()    external    override    view    returns (string memory _symbol)  {    _symbol = nftSymbol;  }  /**   * @dev A distinct URI (RFC 3986) for a given NFT.   * @param _tokenId Id for which we want uri.   * @return URI of _tokenId.   */  function tokenURI(    uint256 _tokenId  )    external    override    view    validNFToken(_tokenId)    returns (string memory)  {    return _tokenURI(_tokenId);  }  /**   * @notice This is an internal function that can be overriden if you want to implement a different   * way to generate token URI.   * @param _tokenId Id for which we want uri.   * @return URI of _tokenId.   */  function _tokenURI(    uint256 _tokenId  )    internal    virtual    view    returns (string memory)  {    return idToUri[_tokenId];  }  /**   * @notice This is an internal function which should be called from user-implemented external   * burn function. Its purpose is to show and properly initialize data structures when using this   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned   * NFT.   * @dev Burns a NFT.   * @param _tokenId ID of the NFT to be burned.   */  function _burn(    uint256 _tokenId  )    internal    override    virtual  {    super._burn(_tokenId);    delete idToUri[_tokenId];  }  /**   * @notice This is an internal function which should be called from user-implemented external   * function. Its purpose is to show and properly initialize data structures when using this   * implementation.   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.   * @param _tokenId Id for which we want URI.   * @param _uri String representing RFC 3986 URI.   */  function _setTokenUri(    uint256 _tokenId,    string memory _uri  )    internal    validNFToken(_tokenId)  {    idToUri[_tokenId] = _uri;  }}</code></pre><h2 id="7-NFTokenEnumerable"><a href="#7-NFTokenEnumerable" class="headerlink" title="7. NFTokenEnumerable"></a>7. <a href="https://github.com/nibbstack/erc721/blob/2.6.1/src/contracts/tokens/nf-token-enumerable.sol">NFTokenEnumerable</a></h2><p>ERC-721不可替代令牌标准的可选枚举实现，继承NFToken并实现了ERC721Enumerable接口</p><pre><code class="javascript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./nf-token.sol";import "./erc721-enumerable.sol";/** * @dev Optional enumeration implementation for ERC-721 non-fungible token standard. */contract NFTokenEnumerable is  NFToken,  ERC721Enumerable{  /**   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.   * Based on 0xcert framework error codes.   */  string constant INVALID_INDEX = "005007";  /**   * @dev Array of all NFT IDs.   */  uint256[] internal tokens;  /**   * @dev Mapping from token ID to its index in global tokens array.   */  mapping(uint256 =&gt; uint256) internal idToIndex;  /**   * @dev Mapping from owner to list of owned NFT IDs.   */  mapping(address =&gt; uint256[]) internal ownerToIds;  /**   * @dev Mapping from NFT ID to its index in the owner tokens list.   */  mapping(uint256 =&gt; uint256) internal idToOwnerIndex;  /**   * @dev Contract constructor.   */  constructor()  {    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable  }  /**   * @dev Returns the count of all existing NFTokens.   * @return Total supply of NFTs.   */  function totalSupply()    external    override    view    returns (uint256)  {    return tokens.length;  }  /**   * @dev Returns NFT ID by its index.   * @param _index A counter less than `totalSupply()`.   * @return Token id.   */  function tokenByIndex(    uint256 _index  )    external    override    view    returns (uint256)  {    require(_index &lt; tokens.length, INVALID_INDEX);    return tokens[_index];  }  /**   * @dev returns the n-th NFT ID from a list of owner's tokens.   * @param _owner Token owner's address.   * @param _index Index number representing n-th token in owner's list of tokens.   * @return Token id.   */  function tokenOfOwnerByIndex(    address _owner,    uint256 _index  )    external    override    view    returns (uint256)  {    require(_index &lt; ownerToIds[_owner].length, INVALID_INDEX);    return ownerToIds[_owner][_index];  }  /**   * @notice This is an internal function which should be called from user-implemented external   * mint function. Its purpose is to show and properly initialize data structures when using this   * implementation.   * @dev Mints a new NFT.   * @param _to The address that will own the minted NFT.   * @param _tokenId of the NFT to be minted by the msg.sender.   */  function _mint(    address _to,    uint256 _tokenId  )    internal    override    virtual  {    super._mint(_to, _tokenId);    tokens.push(_tokenId);    idToIndex[_tokenId] = tokens.length - 1;  }  /**   * @notice This is an internal function which should be called from user-implemented external   * burn function. Its purpose is to show and properly initialize data structures when using this   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned   * NFT.   * @dev Burns a NFT.   * @param _tokenId ID of the NFT to be burned.   */  function _burn(    uint256 _tokenId  )    internal    override    virtual  {    super._burn(_tokenId);    uint256 tokenIndex = idToIndex[_tokenId];    uint256 lastTokenIndex = tokens.length - 1;    uint256 lastToken = tokens[lastTokenIndex];    tokens[tokenIndex] = lastToken;    tokens.pop();    // This wastes gas if you are burning the last token but saves a little gas if you are not.    idToIndex[lastToken] = tokenIndex;    idToIndex[_tokenId] = 0;  }  /**   * @notice Use and override this function with caution. Wrong usage can have serious consequences.   * @dev Removes a NFT from an address.   * @param _from Address from wich we want to remove the NFT.   * @param _tokenId Which NFT we want to remove.   */  function _removeNFToken(    address _from,    uint256 _tokenId  )    internal    override    virtual  {    require(idToOwner[_tokenId] == _from, NOT_OWNER);    delete idToOwner[_tokenId];    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];    uint256 lastTokenIndex = ownerToIds[_from].length - 1;    if (lastTokenIndex != tokenToRemoveIndex)    {      uint256 lastToken = ownerToIds[_from][lastTokenIndex];      ownerToIds[_from][tokenToRemoveIndex] = lastToken;      idToOwnerIndex[lastToken] = tokenToRemoveIndex;    }    ownerToIds[_from].pop();  }  /**   * @notice Use and override this function with caution. Wrong usage can have serious consequences.   * @dev Assigns a new NFT to an address.   * @param _to Address to wich we want to add the NFT.   * @param _tokenId Which NFT we want to add.   */  function _addNFToken(    address _to,    uint256 _tokenId  )    internal    override    virtual  {    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);    idToOwner[_tokenId] = _to;    ownerToIds[_to].push(_tokenId);    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;  }  /**   *&nbsp;@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable   * extension to remove double storage(gas optimization) of owner NFT count.   * @param _owner Address for whom to query the count.   * @return Number of _owner NFTs.   */  function _getOwnerNFTCount(    address _owner  )    internal    override    virtual    view    returns (uint256)  {    return ownerToIds[_owner].length;  }}</code></pre><h2 id="8-Ownable"><a href="#8-Ownable" class="headerlink" title="8. Ownable"></a>8. <a href="https://github.com/nibbstack/erc721/blob/master/src/contracts/ownership/ownable.sol">Ownable</a></h2><p>合同有一个所有者地址，并提供基本的授权控制，简化了用户权限的实现。此合同基于以下源代码: <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/access/Ownable.sol">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/access/Ownable.sol</a></p><pre><code class="javascriptscript">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/** * @dev The contract has an owner address, and provides basic authorization control whitch * simplifies the implementation of user permissions. This contract is based on the source code at: * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol */contract Ownable{  /**   * @dev Error constants.   */  string public constant NOT_CURRENT_OWNER = "018001";  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = "018002";  /**   * @dev Current owner address.   */  address public owner;  /**   * @dev An event which is triggered when the owner is changed.   * @param previousOwner The address of the previous owner.   * @param newOwner The address of the new owner.   */  event OwnershipTransferred(    address indexed previousOwner,    address indexed newOwner  );  /**   * @dev The constructor sets the original `owner` of the contract to the sender account.   */  constructor()  {    owner = msg.sender;  }  /**   * @dev Throws if called by any account other than the owner.   */  modifier onlyOwner()  {    require(msg.sender == owner, NOT_CURRENT_OWNER);    _;  }  /**   * @dev Allows the current owner to transfer control of the contract to a newOwner.   * @param _newOwner The address to transfer ownership to.   */  function transferOwnership(    address _newOwner  )    public    onlyOwner  {    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);    emit OwnershipTransferred(owner, _newOwner);    owner = _newOwner;  }}</code></pre><p>OpenZeppelin ERC721源码分析到这里就结束了。</p><p>参考：</p><ol><li><a href="https://github.com/nibbstack/erc721/tree/2.6.1">ERC721源码v2.6.1</a></li><li><a href="https://segmentfault.com/a/1190000016070774">ERC721源码分析</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ERC721官方简介是：A standard interface for non-fungible tokens, also known as deeds.也叫非同质代币，或者不可置换代币（NFTs）。提到ERC721，一个好理解的例子就是&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="Ethereum" scheme="https://zhangzhishun.github.io/tags/Ethereum/"/>
    
    <category term="NFT" scheme="https://zhangzhishun.github.io/tags/NFT/"/>
    
  </entry>
  
  <entry>
    <title>基于以太坊的战艇游戏(Layer2)源码解析</title>
    <link href="https://zhangzhishun.github.io/2022/02/24/blockchain/layer2/%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%88%98%E8%89%87%E6%B8%B8%E6%88%8F(Layer2)/"/>
    <id>https://zhangzhishun.github.io/2022/02/24/blockchain/layer2/%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%88%98%E8%89%87%E6%B8%B8%E6%88%8F(Layer2)/</id>
    <published>2022-02-24T03:20:30.000Z</published>
    <updated>2022-04-27T02:35:55.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于以太坊的战艇游戏-Layer2-源码解析"><a href="#基于以太坊的战艇游戏-Layer2-源码解析" class="headerlink" title="基于以太坊的战艇游戏(Layer2)源码解析"></a>基于以太坊的战艇游戏(Layer2)源码解析</h1><h2 id="一、游戏介绍"><a href="#一、游戏介绍" class="headerlink" title="一、游戏介绍"></a>一、游戏介绍</h2><p>每一个玩家都可以看到上图所示的页面。该页面分为两部分，下面部分表示当前玩家的棋盘信息，开始的时候，该玩家随机选择两个格子，用于放置两个战舰；上面部分显示对方玩家的棋盘信息，除了对方玩家的战舰位置。开始的时候，上面部分的棋盘是空的。游戏开始之后，两个玩家轮流猜测对方的战舰的位置，每一次只能猜一个方格。如果对方的战舰不在所猜测的方格中，那么就会在对应位置显示一个水花的图像；反之，则出现一团火的图像。因为双方看不到对方的棋盘，因此，每一次都需要对方玩家回复“所猜测的方格是否有战舰”（我们可以采用密码学的技术检测出对方是否撒谎）。当某一个玩家率先猜中了对方两个战舰的位置，该玩家就赢了，并可以收取自己和对方的赌注。</p><h2 id="二、涉及技术"><a href="#二、涉及技术" class="headerlink" title="二、涉及技术"></a>二、涉及技术</h2><p>使用的编程技术有：</p><ul><li>HTML； Javascript; CCS; (网页前端)</li><li>Web3 （提供了调用智能合约的js接口）</li><li>ganache-cli （在本地模拟以太坊节点）</li><li>remix （以太坊智能合约的IDE）</li><li>Solidity （智能合约编程语言）</li></ul><h2 id="三、技术概括"><a href="#三、技术概括" class="headerlink" title="三、技术概括"></a>三、技术概括</h2><p>下图显示，如果使用layer1的区块链技术，每走一步棋都需要向区块链发布一个交易。</p><p><img src="/images/battle-ship-layer2/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5neWlodWFp,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>下图所示的正是我们使用的方式。</p><p><img src="/images/battle-ship-layer2/watermark,type_W5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5neWlodWFp,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>一个问题：如何检测对方玩家撒谎？<br>具体为，每一个玩家在游戏开始前都需要随机指定两个格子，表示两个战舰的位置，如果某玩家中途变卦，不承认自己所指定的那两个格子呢？再者，当前玩家猜测对方玩家战舰所在的方格位置，对方玩家需要回复该方格下是否有战舰，如果对方玩家不诚信呢？我们使用了Merkle<br>tree进行commit（承诺）。介绍merkle tree（形如下图）不属于本文的范围。</p><p>根据密码学中的hash函数的特点，任意一个节点的变化都会导致根节点变化。并且，我们能够很容易证明某一个节点是否属于该merkle tree。</p><p><img src="/images/battle-ship-layer2/watermark,type_oZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5neWlodWFp,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>这里，我们对两位玩家的所有的游戏方格分别生成两棵merkle tree，叶子节点表示方格的编号。这里为了保密性，在编号后面合并一个随机数（合并后的数据作为hash函数的输入）。</p><p>因此，解决方法是，在玩家指定两个战舰的位置之后，需要生成一棵merkle<br>tree，并向对方发送根节点。该根节点便是对方的承诺，且它不会泄露战舰的位置信息。在游戏过程中，如果要揭露某一个方格下是否存在战舰，需要将对应编号的叶子节点和从该节点到根节点的路径信息发送给对方。若对方能够构造出相同的根节点，证明该玩家是诚信的。（这里涉及到了密码学hash函数的知识）。</p><p>另一个问题：如果一个玩家a中途离开，怎么办？ 当前实现的功能：需要玩家b向智能合约中提交一个控告。为了回应该控告，玩家a要在一分钟之内调用智能合约，取消掉该控告。如果一分钟之后玩家a不回复，那么玩家b就可以取走所有的赌注。</p><h2 id="四、区块链和智能合约的作用"><a href="#四、区块链和智能合约的作用" class="headerlink" title="四、区块链和智能合约的作用"></a>四、区块链和智能合约的作用</h2><p>在这个游戏中，智能合约充当了裁判的角色：若某个玩家撒谎或者中途离开，那么智能合约就会把赌注给另一个玩家。因此，本质上区块链中的智能合约解决了信用问题，并且，重要的是，不需要依赖任何可信的第三方。游戏玩家不需要相信任何人：不用担心对方不诚信，不用担心游戏平台和对方玩家勾结；不用担心自己的赌注莫名奇妙就被取走；不用担心游戏平台宕机。</p><p>下图表示的是智能合约的fields，也即是智能合约需要保存的数据。我们保存了两个玩家的地址，赌注的数量，游戏状态，最终赢家的地址，两个merkle tree的跟节点，超时不回复的数据等等。</p><p>该项目还实现了下述功能：</p><ul><li>Forfeit Game，表示当前玩家放弃该游戏，包括赌注。（已实现）</li><li>Claim Win，在当前玩家猜中对方两个战舰之后，点击该按钮就可以取走所有的赌注。（已实现）</li><li>Accuse<br>Cheating，原本的功能是当发现对方玩家撒谎时，将撒谎的数据发布到智能合约中，让智能合约裁决。如果读者想要实现该功能，需要注意，某一个玩家在向对方发送数据前，需要对该数据签名，以避免耍赖。因此，当某一个玩家要求智能合约裁决时，智能合约需要验证相关签名。（未实现）</li><li>Accuse Timeout，控告对方玩家中途离开；（已实现）</li><li>Respond to Accusation， 当当前玩家被控告时，该玩家需要在一分钟内点击该按钮，表示自己在线，来回复控告。（已实现）</li><li>claim timeout winnings，如果被告人没有在一分钟之内回复，就可以点击该按钮来取走所有的赌注。（已实现）</li></ul><h2 id="五、源码分析"><a href="#五、源码分析" class="headerlink" title="五、源码分析"></a>五、源码分析</h2><h3 id="1-构造Merkle树"><a href="#1-构造Merkle树" class="headerlink" title="1. 构造Merkle树"></a>1. 构造Merkle树</h3><p>使用JavaScript代码实现构造树，首先计算每个位置否存在舰艇+随机数组合后取sha3，作为每个位置的hash，然后每两个页节点取一次hash，循环最终形成一个根节点。</p><p><img src="/images/battle-ship-layer2/merkle.png" alt="img"></p><p>最终构造后的merkle树为5层，每层节点数为1、2、4、8、16</p><p>内容如下：</p><p><img src="/images/battle-ship-layer2/image-20220223205315073.png" alt="image-20220223205315073"></p><p>JS代码：</p><pre><code class="javascript">/* build_merkle  builds a Merkle Tree from the given initial_board and nonces  \args:    initial_board - [[]] - 初始化甲板作为矩阵传递，二维数组，对应横纵坐标，值为是否含有舰艇（bool）    nonces - [[Uint32]] - 随机值矩阵*/function build_merkle(initial_board, nonces) {    check_correct_sizes(initial_board, nonces);    let merkle = [[]];    // add all leaf nodes    for (let i = 0; i &lt; BOARD_LEN; i++) {        for (let j = 0; j &lt; BOARD_LEN; j++) {            merkle[0].push(                web3.utils.keccak256(                    web3.utils.fromAscii(JSON.stringify(initial_board[i][j]) + JSON.stringify(nonces[i][j]))                )            );        }    }    // build tree from leaves    // while, current level of merkle has length &gt; 1, add more levels    let curr_level = 0;    while (merkle[curr_level].length &gt; 1) {        merkle.push([]);        curr_level += 1;        // build new layer of tree        for (let i = 0; i + 1 &lt; merkle[curr_level - 1].length; i += 2) {            // have new_node represent another node in the Merkle tree            let new_node = web3.utils.keccak256(merkle[curr_level - 1][i] + merkle[curr_level - 1][i + 1].substring(2), {encoding: 'hex'});            // finalize finally computes the hash for every argument passed in update            merkle[curr_level].push(new_node);        }        // if this most recent merkle level has an odd length, we need        // to just hoist the last element into the next level        if (merkle[curr_level - 1].length % 2 !== 0) {            merkle[curr_level].push(merkle[curr_level - 1][merkle[curr_level - 1].length - 1]);        }    }    return merkle;}</code></pre><h3 id="2-猜测舰艇位置"><a href="#2-猜测舰艇位置" class="headerlink" title="2. 猜测舰艇位置"></a>2. 猜测舰艇位置</h3><p>首先发送猜测给对手，对手回应是否猜中，如果猜中了猜测者发起合约验证。</p><p>JS代码：</p><pre><code class="javascript">// function called when a user guesses a squareasync function guess_square(i, j, player, opponent, callback) {    // 签名    let signed_guess = await player.build_guess(i, j);    // 发送签名和猜测给对手获取对手回应是否猜中、随机数、merkle验证使用的节点数组    let [opening, nonce, proof] = await opponent.respond_to_guess(i, j, signed_guess);    // 更新页面    $('#' + opponent.my_name + ' &gt; .my-board #' + i + '-' + j)        .css('background-image', 'url(' + (opening ? EXPLOSION_IMG : SPLASH_IMG) + ')');    // interpret response    await player.receive_response_to_guess(i, j, [opening, nonce, proof]);    // return if the guess hit a ship    callback(opening);}</code></pre><p>respond_to_guess方法获取nonce, proof方法，JS代码：</p><pre><code class="javascript">/* 获取零知识证明需要的节点hash  /args:    initial_board - matrix representing my-board state    nonces - nonces for your board    guess - [i, j] - guess building proof for*/function get_proof_for_board_guess(initial_board, nonces, guess) {    let merkle_tree = build_merkle(initial_board, nonces);    let index_in_merkle = guess[0] * BOARD_LEN + guess[1];    let proof = [];    for (let i = 0; i &lt; merkle_tree.length - 1; i++) {        let merkle_group = Math.floor(index_in_merkle / Math.pow(2, i)); // goodod        let index_in_group = merkle_group % 2;        let sibling = Math.min(merkle_group - index_in_group + (index_in_group + 1) % 2, merkle_tree[i].length - 1);        if (sibling == merkle_group) continue;        proof.push(merkle_tree[i][sibling]);    }    return proof;}</code></pre><p>验证是否击中，Solidity代码：</p><pre><code class="solidity">// 验证单个单板上的单个点的证明// args:// - opening_nonce - 对应于web3.utils.fromAscii(JSON.stringify(open) + JSON.stringify(nonce)));// - proof - sha256哈希表，对应于 get_proof_for_board_guess()的输出// - guess - [i, j] - guess开口对应（guess that opening corresponds to）// - commit - board的默克尔根function verify_opening(bytes memory opening_nonce, bytes32[] memory proof, uint guess_leaf_index, bytes32 commit) public pure returns (bool result) {    bytes32 curr_commit = keccak256(opening_nonce); // see if this changes hash    uint index_in_leaves = guess_leaf_index;    uint curr_proof_index = 0;    uint i = 0;    while (curr_proof_index &lt; proof.length) {        // 对于默克尔树的当前层级，猜测的节点在哪个组的索引(相当于默克尔树下一层级parent的索引)        // index of which group the guess is in for the current level of Merkle tree        // (equivalent to index of parent in next level of Merkle tree)        uint group_in_level_of_merkle = index_in_leaves / (2**i);        // Merkle分组（两个为一组分组）索引数，只有(0, 1)        uint index_in_group = group_in_level_of_merkle % 2;        // 当前默克尔层级的最大节点索引        uint max_node_index = ((BOARD_LEN * BOARD_LEN + (2**i) - 1) / (2**i)) - 1;        // curr_commit的同级索引        uint sibling = group_in_level_of_merkle - index_in_group + (index_in_group + 1) % 2;        i++;        if (sibling &gt; max_node_index) continue;        if (index_in_group % 2 == 0) {            curr_commit = keccak256(merge_bytes32(curr_commit, proof[curr_proof_index]));            curr_proof_index++;        } else {            curr_commit = keccak256(merge_bytes32(proof[curr_proof_index], curr_commit));            curr_proof_index++;        }    }    return (curr_commit == commit);}</code></pre><h3 id="3-判定赢"><a href="#3-判定赢" class="headerlink" title="3. 判定赢"></a>3. 判定赢</h3><p>leaf_index_check_p2中记录着已经击中了多少舰艇</p><p>Solidity代码：</p><pre><code class="solidity">// 宣布你赢了比赛// 如果你击中了2个舰艇，然后这个函数会转移赢钱给你和结束游戏。function claim_win() public{    assert(msg.sender == p1 || msg.sender == p2);    bool    isP1Win = true;    if (msg.sender == p2) {        isP1Win = false;    }    if (isP1Win) {        require(leaf_index_check_p2.length &gt;= 2);        winner = p1;    } else {        require(leaf_index_check_p1.length &gt;= 2);        winner = p2;    }    // transfer all the tokens from this contract to the winner (i.e., msg sender)    msg.sender.transfer(address(this).balance);    state = 2;}</code></pre><h3 id="4-控告对手作弊"><a href="#4-控告对手作弊" class="headerlink" title="4. 控告对手作弊"></a>4. 控告对手作弊</h3><p>调用上面的verify_opening方法验证是否满足Merkle树，不满足说明对方作弊。</p><p>Solidity代码：</p><pre><code class="solidity">// 控告对手作弊 — 如果是真的，你就赢了。// opening_nonce - 对应于JS中的web3.utils.fromAscii(JSON.stringify(opening) + JSON.stringify(nonce))// proof - 一个sha256哈希列表，你可以从get_proof_for_board_guess(这是发送者认为是一个谎言)// guess_leaf_index - 猜测船只位置的索引// owner - 这艘船所在的board的所有者的地址function accuse_cheating (    bytes memory opening_nonce,    bytes32[] memory proof,    uint256 guess_leaf_index,    address owner) public returns (bool result) {    assert((msg.sender == p1 &amp;&amp; owner == p2) || (msg.sender == p2 &amp;&amp; owner == p1));    bytes32 com = merkle_root_p1;    if(owner == p2){        com = merkle_root_p2;    }    if(!verify_opening(opening_nonce, proof, guess_leaf_index, com)){        msg.sender.transfer(address(this).balance);        state = 2;        winner = msg.sender;        return true;    }    return false;}</code></pre><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ol><li>源代码提供：<a href="https://blog.csdn.net/liangyihuai/article/details/116459829">https://blog.csdn.net/liangyihuai/article/details/116459829</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于以太坊的战艇游戏-Layer2-源码解析&quot;&gt;&lt;a href=&quot;#基于以太坊的战艇游戏-Layer2-源码解析&quot; class=&quot;headerlink&quot; title=&quot;基于以太坊的战艇游戏(Layer2)源码解析&quot;&gt;&lt;/a&gt;基于以太坊的战艇游戏(Layer2)源码</summary>
      
    
    
    
    
    <category term="Ethereum" scheme="https://zhangzhishun.github.io/tags/Ethereum/"/>
    
    <category term="Layer2" scheme="https://zhangzhishun.github.io/tags/Layer2/"/>
    
  </entry>
  
  <entry>
    <title>雪崩共识</title>
    <link href="https://zhangzhishun.github.io/2022/02/08/blockchain/avalanche/%E9%9B%AA%E5%B4%A9%E5%85%B1%E8%AF%86/"/>
    <id>https://zhangzhishun.github.io/2022/02/08/blockchain/avalanche/%E9%9B%AA%E5%B4%A9%E5%85%B1%E8%AF%86/</id>
    <published>2022-02-08T03:20:30.000Z</published>
    <updated>2022-04-27T02:35:55.474Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.引言</strong></p><p>Avalanche主网正式上线，OKEx也已经上架Avalanche原生代币AVAX，曾获得“共识协议3.0”之称的Avalanche重回大众视野，为何Avalanche一举一动受到如此大的市场关注？</p><p>这一切要从2015年5月说起，康奈尔大学出现了一篇《从“雪花”到“雪崩”：一种新型的亚稳态共识协议族》的论文，在市场上引发了雪崩式的迅速反响，成为可以和中本聪的PoW机制、以太坊智能合约相媲美的颠覆性技术创新。</p><p><strong>2.结合早期协议优点并改进缺点</strong></p><p>正如康奈尔大学教授埃米·冈·瑟勒（Emin Gun Sirer）所言：“Avalanche描述了一种新的共识协议，它将中本聪共识协议与经典共识协议相结合，这是一次重大的突破”。在此之前，经典共识协议和中本聪共识协议是早期两类解决分布式系统拜占庭问题的主要共识协议。</p><p>分布式系统中的共识问题一直是计算机科学领域的重要话题，而拜占庭将军问题则是重中之重。战争时期，在军队可能有叛徒和间谍的情况下忠诚的将军如何达成一致的意见，这便是拜占庭将军问题。经典共识协议由图灵奖得主兰伯特提出，具有强一致性、高效的特点，但也有通信成本高、节点无法自由进出的缺点。</p><p><strong>图1：经典共识协议（PBFT）工作原理</strong></p><p><img src="https://hx24.huoxing24.com/image/crawler/2020/09/28/1601261161638216.jpg" alt="拜占庭">资料来源：《区块链技术指南》，OKEx Research</p><p>而著名的中本聪共识协议则创造性地用概率保证实际运行的共识，解决了节点无法自由进出的问题，但是成本高昂问题仍未被解决。</p><p><strong>图2：中本聪共识协议工作原理</strong></p><p><img src="https://hx24.huoxing24.com/image/crawler/2020/09/28/1601261161662703.jpg" alt="拜占庭">资料来源：OKEx Research</p><p>Avalanche共识协议则结合了两类协议的优点：借鉴了中本聪协议概率性安全保障的设计，同时加入了BFT属性，增加系统的效率和安全性。</p><p><strong>3.Avalanche原理：“雪花”到“雪崩”的层层完善</strong></p><p>正如Avalanche白皮书提到的“雪花”到“雪崩”过程，Avalanche的4个子协议组成正是从最简单的Slush协议，到Snowflake、Snowball 和 Avalanch，逐步完善，形成了“雪花”到“雪崩”的质变。</p><p><strong>3.1. “雪泥”Slush 协议：万物之初</strong></p><p>Slush协议是最基础的“雪泥”，通过多次随机抽样来达成共识。为便于理解，这里我们以投票确认颜色为例。节点达成共识的步骤如下：</p><p>（1）初始状态时所有的节点均未着色；</p><p>（2）当节点A收到信息时，未着色的节点将信息颜色设为自己的颜色，并询问其他节点的颜色；</p><p>（3）未着色的节点B收到询问，将自己染成相同颜色并回复；已着色的节点C收到询问会回复自己的颜色；</p><p>（4）节点A收到多个响应后，如果大多数颜色和自己的一直，则不改变颜色，否则改变颜色，即以大多数其他节点的颜色反馈来校正自己的颜色。</p><p>Slush协议就已经解决了经典共识协议通讯成本高的问题，还用部分抽样等方式避免了中本聪共识协议高能耗的问题。后续协议的改进主要为了提升共识协议安全性。</p><p><strong>3.2. “雪花”Snowflake协议：初步改善</strong></p><p>在拜占庭节点存在的情况下，Slush不能提供强大的安全保证。为此，Snowflake作为升级版协议引入了计数器（Counter）来增加系统的安全性。</p><p>具体而言，网络中的攻击节点故意散播错误的颜色，可能导致Slush某一轮统计得到错误的颜色，而Snowflake的计数器统计了某种颜色连续出现的次数，只有某种颜色连续出现多次，节点才会改变自己的颜色。如此避免了拜占庭节点带来的干扰，确保了系统的安全性和活跃度。</p><p><strong>3.3. “雪球”Snowball协议：深入升级</strong></p><p>Snowball在Snowflake的基础上更进一步地。引入了类似信誉积分的制度——信任度，以提高安全性。</p><p>具体而言，Snowflake协议的改进如下：</p><p>（1）每成功查询一次，节点就为该颜色的信任度加1分；</p><p>（2）节点会切换为信任度较高的颜色。</p><p>Snowball协议不仅比Snowflake更难遭受攻击，而且更容易推广到多命令协议。</p><p><strong>3.4. “雪崩”Avalanche协议：量变到质变</strong></p><p>终极Boss“雪崩”——Avalanche又在Snowball的基础上增加了有向无循环图（DAG）来记录所有的交易状态。在DAG中，如果想给从创世点到某节点路径上的所有节点都投票只需要给该节点投票，大大提高了效率。其次，DAG有着类似于区块链的链式结构记录交易信息，使得过去的交易信息很难被篡改，进一步提升了安全性。</p><p>图3：DAG示意图</p><p><img src="https://hx24.huoxing24.com/image/crawler/2020/09/28/1601261161723758.jpg" alt="拜占庭">资料来源：《区块链新共识算法 Snowflake to Avalanche》，OKEx Research</p><p><strong>3.5. Avalanche协议：集前期协议之大成</strong></p><p>吸取了早期两个共识协议的优点，并经过4个协议层次递进、逐步改善，Avalanche协议具有许多优良特性。</p><p>（1）高效的可扩展性：轻量级，可扩展，低延迟；</p><p>（2）高拜占庭容错：即使网络中有超过50%的节点是拜占庭节点，网络依然是安全的;</p><p>（3）静态绿色：与PoW机制不同，Avalanche协议不会浪费任何资源;</p><p>（4）低通信成本：Avalanche协议比传统共识协议的通讯复杂度更低。</p><p><strong>4. 零确认交易与Avalanche协议</strong></p><p>Avalanche刚面世时，人们还没有发现Avalanche协议与零确认交易之间有什么关系。然而在2018年12月左右，BCH社区的技术人员Chris Pacia发表一篇文章，认为可以使用Avalanche协议来保证零确认交易的安全性，一时起千层浪，引发了市场的广泛兴趣。</p><p>Avalanche协议的确认需要多次抽样，为缩短确认时间，则抽样次数必须受到限制，这意味着，恶意节点超过一定比例后，在有限抽样里诚实节点无法达成共识。为此，Chris Pacia认为可以引入PoW机制来保护网络的安全，防止黑客的攻击节点数量太多。</p><p><strong>5. Avalanche现状：众望所归</strong></p><p>自2018年Avalanche白皮书发布以来，受到了广泛的首肯心折，许多VC相竞为之折腰。2019 年，雪崩协议Ava获得了 a16z、Polychain Capital 等机构 600 万美元融资。2020年6月，AVA Lab又完成了一笔1200万美元的代币私募融资，同年7月，又获得IOSG Ventures的战略投资，并就中国市场未来发展达成独家战略合作协议。根据最新消息，AVA的公募于7月8日开启。</p><p><strong>6. 结语</strong></p><p>Avalanche结合了早期两种共识协议的优点并改进其缺点，具有高拓展性、静态绿色以及低通信成本的优点。同时，从Slush到Avalanche层层递进、逐步完善，引入计数器、可信度、DAG等，日臻完善。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.avalabs.org/whitepapers">Avalanche writepaper</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1.引言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Avalanche主网正式上线，OKEx也已经上架Avalanche原生代币AVAX，曾获得“共识协议3.0”之称的Avalanche重回大众视野，为何Avalanche一举一动受到如此大的市场关注？&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="Avalanche" scheme="https://zhangzhishun.github.io/tags/Avalanche/"/>
    
    <category term="共识算法" scheme="https://zhangzhishun.github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s Avalanche?</title>
    <link href="https://zhangzhishun.github.io/2022/02/07/blockchain/avalanche/What&#39;s%20Avalanche/"/>
    <id>https://zhangzhishun.github.io/2022/02/07/blockchain/avalanche/What&#39;s%20Avalanche/</id>
    <published>2022-02-07T03:20:30.000Z</published>
    <updated>2022-04-27T02:35:55.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-Avalanche"><a href="#What-is-Avalanche" class="headerlink" title="What is Avalanche?"></a>What is Avalanche?</h1><p>Avalanche is an open-source platform for launching decentralized applications and enterprise blockchain deployments in one interoperable, highly scalable ecosystem. Avalanche is the first decentralized smart contracts platform built for the scale of global finance, with near-instant transaction finality. Ethereum developers can quickly build on Avalanche as Solidity works out-of-the-box.</p><p>A key difference between Avalanche and other decentralized networks is the <font color="red">consensus protocol</font>. Over time, people have come to a false understanding that blockchains have to be slow and not scalable. The Avalanche protocol employs a novel approach to consensus to achieve its <font color="red">strong safety guarantees, quick finality, and high-throughput</font> without compromising decentralization.</p><h1 id="Consensus-protocol"><a href="#Consensus-protocol" class="headerlink" title="Consensus protocol"></a>Consensus protocol</h1><p><img src="https://docs.avax.network/assets/images/Consensus-protocol-comparison-aa555b20f36947d6a5ff869d8758fa6e.png" alt="image"></p><p>Protocols in the Avalanche family operate through repeated sub-sampled voting. When a <a href="http://support.avalabs.org/en/articles/4064704-what-is-a-blockchain-validator">validator</a> is determining whether a <a href="http://support.avalabs.org/en/articles/4587384-what-is-a-transaction">transaction</a> should be accepted or rejected, it asks a small, random subset of validators whether they think the transaction should be accepted or rejected. If the queried validator thinks the transaction is invalid, has already rejected the transaction, or prefers a conflicting transaction, it replies that it thinks the transaction should be rejected. Otherwise, it replies that it thinks the transaction should be accepted.</p><p>If a sufficiently large portion (<em>alpha</em> α) of the validators sampled reply that they think the transaction should be accepted, the validator prefers to accept the transaction. That is, when it is queried about the transaction in the future, it will reply that it thinks the transaction should be accepted. Similarly, the validator will prefer to reject the transaction if a sufficiently large portion of the validators replies that they think the transaction should be rejected.</p><p>The validator repeats this sampling process until <em>alpha</em> of the validators queried reply the same way (accept or reject) for <em>beta</em> β consecutive rounds.</p><p>In the common case when a transaction has no conflicts, finalization happens very quickly. When conflicts exist, honest validators quickly cluster around conflicting transactions, entering a positive feedback loop until all correct validators prefer that transaction. This leads to the acceptance of non-conflicting transactions and the rejection of conflicting transactions.</p><p><img src="https://docs.avax.network/assets/images/howavalancheconsensusworks-a37dc2bdf67c7c2997dcbfd01ee28e64.png" alt="image"></p><p>It is guaranteed (with high probability based on system parameters) that if any honest validator accepts or rejects a transaction, all honest validators will accept or reject that transaction.</p><h2 id="Key-Features"><a href="#Key-Features" class="headerlink" title="Key Features"></a>Key Features</h2><h3 id="Speed"><a href="#Speed" class="headerlink" title="Speed"></a>Speed</h3><p>Uses a novel consensus protocol, developed by a team of Cornell computer scientists, and is able to permanently confirm transactions in under <font color="red">1 second</font>.</p><h3 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h3><p>Capable of <font color="red">4,500 transactions per second</font>–an order of magnitude greater than existing blockchains.</p><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p><font color="red">Ensures stronger security guarantees well</font>-above the 51% standard of other networks.</p><h3 id="Flexibility"><a href="#Flexibility" class="headerlink" title="Flexibility"></a>Flexibility</h3><p><font color="red">Easily</font> create custom blockchains and decentralized apps that contain almost any arbitrary logic.</p><h3 id="Sustainability"><a href="#Sustainability" class="headerlink" title="Sustainability"></a>Sustainability</h3><p>Uses energy-efficient <font color="red">proof-of-stake</font> consensus algorithm rather than proof-of-work.</p><h3 id="Smart-Contract-Support"><a href="#Smart-Contract-Support" class="headerlink" title="Smart Contract Support"></a>Smart Contract Support</h3><p>Supports the creation of <font color="red">Solidity smart contracts</font> and your favorite Ethereum tools like Remix, Metamask, Truffle, and more.</p><h3 id="Private-and-Public-Blockchains"><a href="#Private-and-Public-Blockchains" class="headerlink" title="Private and Public Blockchains"></a>Private and Public Blockchains</h3><p>Create your own public or private blockchains.</p><h3 id="Designed-for-Finance"><a href="#Designed-for-Finance" class="headerlink" title="Designed for Finance"></a>Designed for Finance</h3><p>Native support for easily creating and trading <font color="red">digital smart assets</font> with complex, custom rulesets.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><p><a href="https://docs.avax.network/">Avalanche website</a></p></li><li><p><a href="https://github.com/ava-labs/avalanchego">Avalanche source code</a></p></li><li><p><a href="https://academy.binance.com/zh/articles/what-is-avalanche-avax">What’s is Avalanche?</a></p></li><li><p><a href="https://www.avalabs.org/whitepapers">Avalanche writepaper</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;What-is-Avalanche&quot;&gt;&lt;a href=&quot;#What-is-Avalanche&quot; class=&quot;headerlink&quot; title=&quot;What is Avalanche?&quot;&gt;&lt;/a&gt;What is Avalanche?&lt;/h1&gt;&lt;p&gt;Avalanch</summary>
      
    
    
    
    
    <category term="Avalanche" scheme="https://zhangzhishun.github.io/tags/Avalanche/"/>
    
  </entry>
  
  <entry>
    <title>Docker方式搭建以太坊网络-私有链</title>
    <link href="https://zhangzhishun.github.io/2022/01/29/blockchain/ethereum/Docker%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A---%E7%A7%81%E6%9C%89%E9%93%BE/"/>
    <id>https://zhangzhishun.github.io/2022/01/29/blockchain/ethereum/Docker%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A---%E7%A7%81%E6%9C%89%E9%93%BE/</id>
    <published>2022-01-29T11:29:23.000Z</published>
    <updated>2022-04-27T02:35:55.474Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及的知识和技术有：</p><ul><li>Docker：一种时下流行的容器</li><li>geth：以太坊客户端的go实现</li><li>truffle：以太坊合约部署工具</li></ul><h2 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h2><p>此处需要补充一点的是，如果您使用的是虚拟机、云主机或者老破小机器，需要确保分配给主机的内存至少2GB。因为以太坊为了抵御比特大陆这样的ASIC矿机对算力的垄断，采用了和比特币完全不同的PoW算法——ethash。该算法的特点是算力不敏感，内存敏感。该算法目前需要在内存创建大约1GB的DAG用来做PoW运算，且DAG会随着区块的增加呈阶梯状增长，因此建议至少给挖矿节点的宿主机器分配至少2GB的内存，且保留扩大内存容量的灵活性。</p><h2 id="获取geth镜像"><a href="#获取geth镜像" class="headerlink" title="获取geth镜像"></a>获取geth镜像</h2><p>docker hub上有现成的geth镜像。直接获取：</p><pre><code class="bash">docker pull ethereum/client-go:v1.8.12</code></pre><h2 id="创建Docker网络"><a href="#创建Docker网络" class="headerlink" title="创建Docker网络"></a>创建Docker网络</h2><p>旧版本的docker容器相互之间是依靠link建立关系。<br>新版本docker推荐创建自有网路，再将需要互联的容器配置到相同的网络中。<br>于是，我们创建一个名为“ethnet“的网络。该网络配置如下：</p><ul><li>子网172.19.0.0/16<ul><li>IP段172.19.0.0</li><li>掩码255.255.0.0</li><li>IP范围172.19.0.1~172.19.255.254</li><li>IP广播172.19.255.255</li></ul></li></ul><pre><code class="bash">docker network create -d bridge --subnet=172.19.0.0/16 ethnetdocker network ls</code></pre><h1 id="配置以太坊网络"><a href="#配置以太坊网络" class="headerlink" title="配置以太坊网络"></a>配置以太坊网络</h1><p>运行如下命令进入一个容器：</p><pre><code class="bash">docker run -it --rm --network ethnet --ip 172.19.0.50 -v /opt/docker-project/eth/workspace:/workspace --entrypoint /bin/sh ethereum/client-go:v1.8.12</code></pre><blockquote><p>–network ethnet参数指定了该容器加入刚才创建的ethnet网络<br> –ip 172.19.0.50指定了一个固定IP给该容器。</p></blockquote><h2 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h2><p>首先，在容器内的/workspace目录创建目录和文件</p><p>执行以下命令：</p><pre><code class="bash">mkdir -p /workspacedappmkdir -p /workspace/dapp/minermkdir -p /workspace/dapp/datatouch /workspace/dapp/genesis.json</code></pre><p>然后运行如下命令创建账户：</p><pre><code class="bash">geth -datadir /workspace/dapp/miner/data account new</code></pre><p>输入两次password，获得地址。将地址记录下来，后面要用到。</p><blockquote><p>重复如上步骤可以创建多个账户。</p></blockquote><h2 id="创建创世区块"><a href="#创建创世区块" class="headerlink" title="创建创世区块"></a>创建创世区块</h2><p>编辑刚才创建的文件</p><pre><code class="bash">vi /workspace/dapp/data/genesis.json</code></pre><p>文件内容：</p><pre><code class="json">{  "config": {    "chainId": 88,    "homesteadBlock": 0,    "eip155Block": 0,    "eip158Block": 0  },  "alloc"      : {    "b126d89780d2221ceffe5c94efd9ca6a005a9f0c": {"balance": "100000000000000000000"},    "93415bb68da6816c581537a4fa74727ddf6f4f4d": {"balance": "1000000000000000000"},    "fa5773a704ee9e91e60ffb8fe4207e934f70619f": {"balance": "1000000000000000000"}  },  "coinbase"   : "0x0000000000000000000000000000000000000000",  "difficulty" : "0x400",  "extraData"  : "",  "gasLimit"   : "0x2fefd8",  "nonce"      : "0x0000000000000000",  "mixhash"    :  "0x0000000000000000000000000000000000000000000000000000000000000000",  "parentHash" :  "0x0000000000000000000000000000000000000000000000000000000000000000",  "timestamp"  : "0x00"}</code></pre><ul><li>genesis.json是用来创建创世区块的配置文件</li><li>加入同一私链的节点必须使用同一配置文件</li><li>chainid是私链网络的标识，可以是任意数字。</li><li>即使chainid相同，如果genesis.json配置不一样，也将是两个不兼容的网络</li><li>alloc下面列举了4个账户地址，分别是上一步创建并记录下来的地址。</li><li>balance是创世区块为每个账户分配的初始以太币。这里看似分配了很多，其实单位是wei。1eth=10^18wei。也就是除了第一个账户给了100eth外，其它几个账户分别只拥有1eth。这里给第一个账户多分点，是因为我们之后需要用它来部署合约。</li></ul><h2 id="完成以太坊网络配置"><a href="#完成以太坊网络配置" class="headerlink" title="完成以太坊网络配置"></a>完成以太坊网络配置</h2><p>此时可以退出刚才的容器。由于我们运行容器是加了–rm参数，刚才的容器会被删除，但宿主机的/workspace下的文件会被保存下来。</p><h1 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h1><p>上述步骤只是配置好了一个以太坊私有网络，并没有真正创建网络。我们知道，以太坊网络是一个分布式的网络，有了矿工，才有的网络。于是，我们首先得有一个矿工。</p><h2 id="创建“主”矿工节点"><a href="#创建“主”矿工节点" class="headerlink" title="创建“主”矿工节点"></a>创建“主”矿工节点</h2><p>我们接下来打算创建的矿工节点，成为“主”矿工，因为它需要拥有如下特性：</p><ul><li>它是一个容器，并且是持久的容器</li><li>它会自动读取genesis.json文件，并初始化以太坊网络</li><li>它能够连接其它节点（容器）</li><li>它能够接受各种rpc调用，并能够部署合约</li><li>它已经配置好挖矿账户，可以一键挖矿</li></ul><p>于是，我们按照这个要求，开始一步步创建矿工节点。</p><h3 id="创建entrypoint脚本"><a href="#创建entrypoint脚本" class="headerlink" title="创建entrypoint脚本"></a>创建entrypoint脚本</h3><p>创建一个文件：</p><pre><code class="bash">vi /opt/docker-project/eth/workspace/dapp/init.sh</code></pre><p> 文件内容如下：</p><pre><code class="bash">#!/bin/shgeth -datadir ~/data/ init /workspace/dapp/data/genesis.jsonif [  $# -lt 1 ]; then   exec "/bin/sh"else  exec /bin/sh -c "$@"fi</code></pre><blockquote><p>该脚本的功能是让以太坊节点（容器）自动初始化以太坊网络，并且接受一个自动运行脚本作为输入。</p></blockquote><h3 id="创建自动运行脚本"><a href="#创建自动运行脚本" class="headerlink" title="创建自动运行脚本"></a>创建自动运行脚本</h3><p>创建一个文件：</p><pre><code class="bash">vi /opt/docker-project/eth/workspace/dapp/mine.sh</code></pre><p>内容如下：</p><pre><code class="bash">#!/bin/shaccount='b126d89780d2221ceffe5c94efd9ca6a005a9f0c'cp -r /workspace/dapp/miner/data/keystore/* ~/data/keystore/geth -datadir ~/data/ --networkid 88 --rpc --rpcaddr "172.19.0.50" --rpcapi admin,eth,miner,web3,personal,net,txpool --unlock ${account} --etherbase ${account} console</code></pre><ul><li>第一行命令是将刚才生成的账户私钥文件拷贝到容器的home目录下。因为/workspace是宿主目录挂载的，并不是linux文件系统，直接将datadir指定到该目录会导致geth报错。</li><li>第二行命令是启动以太坊节点的命令。<ul><li>–networkid 88指定了networkid，这个必须与genesis.json内设置保持一致</li><li>–rpc –rpcaddr “172.19.0.50” –rpcapi …. 这些参数表示该节点接受rpc，并且指定了rpc的协议</li><li>–unlock “0x…” 加入该参数会需要用户输入账户密码。密码校验后会解锁该账户。账户解锁后，该节点就能使用此账户的私钥进行签名加密等动作，用以进行交易、发布合约等。</li><li>–etherbase 参数指定了挖矿收益账户</li></ul></li></ul><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><pre><code class="bash">chmod +x /opt/docker-project/eth/workspace/dapp/init.shchmod +x /opt/docker-project/eth/workspace/dapp/mine.shdocker run -it --name=miner --network ethnet --ip 172.19.0.50 --hostname node -v /opt/docker-project/eth/workspace:/workspace --entrypoint /workspace/dapp/init.sh ethereum/client-go:v1.8.12 /workspace/dapp/mine.sh</code></pre><blockquote><p>该命令会创建一个持久化的容器。容器的entrypoint和自动运行脚本指定为我们刚创建的那两个脚本。</p></blockquote><p>如果报错：</p><pre><code class="bash">Fatal: Failed to unlock account (no key for given address or file)</code></pre><p>可能原因是没有修改上面的mine.sh脚本的account参数为第一个账户地址</p><h2 id="创建“从”矿工节点"><a href="#创建“从”矿工节点" class="headerlink" title="创建“从”矿工节点"></a>创建“从”矿工节点</h2><p>只有一个节点的网络，怎么看都不像“分布式”网络。所以我们需要创建更多的节点来形成一个“分布式网络”。我们称这些节点叫做“从”矿工。<br> 这类矿工不需要交易，不需要发布合约，因此不需要unlock账户，也不需要接受rpc。它们只知道埋头挖矿。</p><h3 id="创建自动运行脚本-1"><a href="#创建自动运行脚本-1" class="headerlink" title="创建自动运行脚本"></a>创建自动运行脚本</h3><p>“从”矿工节点和“主”矿工节点共享entrypoint，以保证它们创建出完全相同的网络。<br> 只有自动运行脚本不太一样，</p><pre><code class="bash">vi /opt/docker-project/eth/workspace/dapp/node.sh</code></pre><p>文件内容：</p><pre><code class="bash">#!/bin/shcp -r /workspace/dapp/miner/data/keystore/* ~/data/keystore/geth -datadir ~/data/ --networkid 88 console </code></pre><p>创建容器:</p><pre><code class="bash">chmod +x /opt/docker-project/eth/workspace/dapp/node.shdocker run -it --name=node1 --network ethnet --ip 172.19.0.51 --hostname node1 -v /opt/docker-project/eth/workspace:/workspace --entrypoint /workspace/dapp/init.sh ethereum/client-go:v1.8.12 /workspace/dapp/node.sh</code></pre><h1 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h1><p>以上创建出了多个以太坊节点，运行在同一网络下。每个节点都可以执行如下操作。供参考。</p><h2 id="节点发现"><a href="#节点发现" class="headerlink" title="节点发现"></a>节点发现</h2><h3 id="查看节点信息"><a href="#查看节点信息" class="headerlink" title="查看节点信息"></a>查看节点信息</h3><pre><code class="bash">geth -datadir ~/data/ --networkid 88 console&gt;admin.nodeInfo.enode# 输出"enode://708b66364c83af2d3725c309f2bdc0e7d4e395c6ac7310e1a1147b9dfe084649e6c6a3ce6c483c51ab6e924f6abade647246c2b57ecc49d9a573cea896cdf0e6@[::]:30303"</code></pre><h3 id="配置静态节点文件"><a href="#配置静态节点文件" class="headerlink" title="配置静态节点文件"></a>配置静态节点文件</h3><p>~/data/geth/static-nodes.json</p><pre><code class="json">[    "enode://&lt;node public key&gt;@&lt;node IP address&gt;:&lt;node port&gt;"]</code></pre><h3 id="查看连接上的节点"><a href="#查看连接上的节点" class="headerlink" title="查看连接上的节点"></a>查看连接上的节点</h3><pre><code class="bash">geth -datadir ~/data/ --networkid 88 console&gt;admin.peers</code></pre><h3 id="动态添加节点"><a href="#动态添加节点" class="headerlink" title="动态添加节点"></a>动态添加节点</h3><pre><code class="bash">&gt;admin.addPeer("enode://&lt;node public key&gt;@&lt;node IP address&gt;:&lt;node port&gt;")</code></pre><h2 id="挖矿-1"><a href="#挖矿-1" class="headerlink" title="挖矿"></a>挖矿</h2><p>启动miner容器</p><pre><code class="bash">&gt;miner.start(1)</code></pre><ul><li>参数1指定了挖矿的线程数。</li><li>首次启动节点会消耗大约20~30分钟产生DAG</li><li>某开始挖矿后，其它节点将会收到新区块并打印</li></ul><h1 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h1><h2 id="创建truffle镜像"><a href="#创建truffle镜像" class="headerlink" title="创建truffle镜像"></a>创建truffle镜像</h2><p>由于没有找到好用的truffle镜像，我自己创建了一个。Dockerfile内容如下：</p><pre><code class="ruby">FROM alpine:3.8MAINTAINER Cary Tan hbuzzs@163.comENV PS1='[truffle@docker $PWD]\$ 'RUN echo "http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.8/main" &gt; /etc/apk/repositories \      &amp;&amp; echo "http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.8/community" &gt;&gt; /etc/apk/repositories \      &amp;&amp; apk update \          &amp;&amp; apk add curl \      &amp;&amp; apk add npm \      &amp;&amp; apk add git \      &amp;&amp; mkdir -p /workspace \      &amp;&amp; npm config set registry https://registry.npm.taobao.org \      &amp;&amp; npm install -g truffleWORKDIR /workspaceCMD /bin/sh</code></pre><p>也可使用他人上传的镜像：</p><pre><code class="bash">docker pull txcary/truffle:180806# 这个镜像没有curl 需要安装apk add curl</code></pre><h2 id="新建truffle工程"><a href="#新建truffle工程" class="headerlink" title="新建truffle工程"></a>新建truffle工程</h2><pre><code class="bash">mkdir -p /opt/docker-project/truffle/workspace/VanTokencd /opt/docker-project/truffle/workspace/VanTokengit clone https://github.com/trufflesuite/truffle-init-bare.git</code></pre><h2 id="启动truffle容器"><a href="#启动truffle容器" class="headerlink" title="启动truffle容器"></a>启动truffle容器</h2><pre><code class="bash">docker run -it --rm -v /opt/docker-project/truffle/workspace:/workspace --network ethnet txcary/truffle:180806</code></pre><h3 id="测试节点RPC"><a href="#测试节点RPC" class="headerlink" title="测试节点RPC"></a>测试节点RPC</h3><pre><code class="bash">curl 172.19.0.50:8545 -X POST --data '{"id":1,"jsonrpc":"2.0","method":"eth_accounts", "params":[]}' -H "Content-Type: application/json"curl 172.19.0.50:8545 -X POST --data '{"id":1,"jsonrpc":"2.0","method":"eth_getBalance", "params":["0x4c283287839fd441b8c8d18771321bc06a81edae","latest"]}' -H "Content-Type: application/json"</code></pre><ul><li>第一条命令获取节点上的账户</li><li>第二条命令获取账户余额</li><li>如果这两条命令成功了，说明以太坊私有网络搭建成功，并且节点rpc调用成功</li></ul><h3 id="修改truffle-js"><a href="#修改truffle-js" class="headerlink" title="修改truffle.js"></a>修改truffle.js</h3><pre><code class="javascript">module.exports = {        networks: {            development: {                host: "172.19.0.50",                port: 8545,                network_id: 88,                gas: 2900000,                gasPrice: 10000000000            }        }};</code></pre><ul><li>gas使用默认值会导致超限错误，研究半天不知道为什么。要是搞明白的可以给我留言，谢谢！</li><li>gasPrice为默认值</li></ul><h2 id="编写合约Migrations-sol（truffle内置）"><a href="#编写合约Migrations-sol（truffle内置）" class="headerlink" title="编写合约Migrations.sol（truffle内置）"></a>编写合约Migrations.sol（truffle内置）</h2><pre><code class="solidity">pragma solidity &gt;=0.4.22 &lt;0.6.0;contract Migrations {    address public owner;    uint public lastCompletedMigration;    modifier restricted() {        if (msg.sender == owner) _;    }    constructor() public {        owner = msg.sender;    }    function setCompleted(uint completed) public restricted {        lastCompletedMigration = completed;    }    function upgrade(address newAddress) public restricted {        Migrations upgraded = Migrations(newAddress);        upgraded.setCompleted(lastCompletedMigration);    }}</code></pre><h2 id="新建部署脚本"><a href="#新建部署脚本" class="headerlink" title="新建部署脚本"></a>新建部署脚本</h2><p>deploy_contracts.js</p><pre><code class="javascript">var contractsName = artifacts.require("./Storage.sol");module.exports = function(deployer) {  deployer.deploy(contractsName);};</code></pre><h2 id="编译合约"><a href="#编译合约" class="headerlink" title="编译合约"></a>编译合约</h2><pre><code class="bash">truffle compile</code></pre><h2 id="部署合约-1"><a href="#部署合约-1" class="headerlink" title="部署合约"></a>部署合约</h2><pre><code class="bash">truffle migrate --network development --verbose-rpc</code></pre><p>部署成功</p><p><img src="/images/eth_network_set_up/image-20220204103544178.png" alt="image-20220204103544178"></p><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><ul><li><a href="https://www.jianshu.com/p/7994db7a2b89?from=singlemessage">https://www.jianshu.com/p/7994db7a2b89?from=singlemessage</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文涉及的知识和技术有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker：一种时下流行的容器&lt;/li&gt;
&lt;li&gt;geth：以太坊客户端的go实现&lt;/li&gt;
&lt;li&gt;truffle：以太坊合约部署工具&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;主机配置&quot;&gt;&lt;a href=&quot;#主机配置&quot; </summary>
      
    
    
    
    
    <category term="部署文档" scheme="https://zhangzhishun.github.io/tags/%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/"/>
    
    <category term="Ethereum" scheme="https://zhangzhishun.github.io/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法分析</title>
    <link href="https://zhangzhishun.github.io/2022/01/18/data_struct_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://zhangzhishun.github.io/2022/01/18/data_struct_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2022-01-18T02:29:15.000Z</published>
    <updated>2022-04-27T02:35:55.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法分析"><a href="#数据结构与算法分析" class="headerlink" title="数据结构与算法分析"></a>数据结构与算法分析</h1><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>了解算法分析方法（第二章-13）</li><li>精通表、栈和队列（第三章-27）、树（第四章-40）、散列（第五章-36）、优先队列、堆（第六章-28）、排序（第七章-50）、不相交集类（第八章-17）</li><li>精通图论（第九章-38）、算法设计技巧（第十章-50）、红黑树（第十二章第二节-5）</li></ul><h1 id="第-2-章-算法分析方法"><a href="#第-2-章-算法分析方法" class="headerlink" title="第 2 章 算法分析方法"></a>第 2 章 算法分析方法</h1><h2 id="2-4-运行时间计算"><a href="#2-4-运行时间计算" class="headerlink" title="2.4 运行时间计算"></a>2.4 运行时间计算</h2><h3 id="2-4-1-一般法则"><a href="#2-4-1-一般法则" class="headerlink" title="2.4.1 一般法则"></a>2.4.1 一般法则</h3><ol><li>法则1 —— for循环</li></ol><p>一个for循环的运行时间至多是该for循环内部那些语句（包括测试）的运行时间乘以迭代的次数</p><ol><li>法则2 —— 嵌套的for循环</li></ol><p>在一组嵌套循环内部的一条语句的运行时间为该语句的运行时间乘以该组所有的for循环的大小的乘积</p><ol><li>法则3 —— 顺序语句</li></ol><p>将各个语句的运行时间求和即可。这意味着其中的最大值就是所得的运行时间。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled.png" alt="Untitled"></p><ol><li>法则4 —— if/else语句</li></ol><p>一个if/else语句的运行时间从不超过判断的运行时间再加上S1和S2中运行时间长者的总的运行时间。</p><h1 id="第-3-章-表、栈和队列"><a href="#第-3-章-表、栈和队列" class="headerlink" title="第 3 章 表、栈和队列"></a>第 3 章 表、栈和队列</h1><h2 id="3-1-抽象数据类型"><a href="#3-1-抽象数据类型" class="headerlink" title="3.1 抽象数据类型"></a>3.1 抽象数据类型</h2><p>抽象数据类型（ADT）是带有一组操作的一些对象的集合。</p><h2 id="3-2-表ADT"><a href="#3-2-表ADT" class="headerlink" title="3.2 表ADT"></a>3.2 表ADT</h2><p>我们称形如$A_0$$,A_1,A_2,…,A_{N-1}$的为表，该表大小为N</p><h3 id="3-2-1-表的简单数组实现"><a href="#3-2-1-表的简单数组实现" class="headerlink" title="3.2.1 表的简单数组实现"></a>3.2.1 表的简单数组实现</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%201.png" alt="Untitled"></p><h3 id="3-2-2-简单链表"><a href="#3-2-2-简单链表" class="headerlink" title="3.2.2 简单链表"></a>3.2.2 简单链表</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%202.png" alt="Untitled"></p><h2 id="3-6-栈ADT"><a href="#3-6-栈ADT" class="headerlink" title="3.6 栈ADT"></a>3.6 栈ADT</h2><h3 id="3-6-1-栈模型"><a href="#3-6-1-栈模型" class="headerlink" title="3.6.1 栈模型"></a>3.6.1 栈模型</h3><p>栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做站的顶（top）。</p><p>栈的基本操作有push（进栈）、pop（出栈）</p><p>栈有时又叫LIFO（后进先出）表</p><h3 id="3-6-3-应用"><a href="#3-6-3-应用" class="headerlink" title="3.6.3 应用"></a>3.6.3 应用</h3><ul><li>平衡符号</li><li>后缀表达式</li><li>方法调用</li></ul><h2 id="3-7-队列ADT"><a href="#3-7-队列ADT" class="headerlink" title="3.7 队列ADT"></a>3.7 队列ADT</h2><h3 id="3-7-1-队列模型"><a href="#3-7-1-队列模型" class="headerlink" title="3.7.1 队列模型"></a>3.7.1 队列模型</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%203.png" alt="Untitled"></p><h1 id="第-4-章-树"><a href="#第-4-章-树" class="headerlink" title="第 4 章 树"></a>第 4 章 树</h1><h2 id="4-1-预备知识"><a href="#4-1-预备知识" class="headerlink" title="4.1 预备知识"></a>4.1 预备知识</h2><h2 id="4-2-二叉树"><a href="#4-2-二叉树" class="headerlink" title="4.2 二叉树"></a>4.2 二叉树</h2><h2 id="4-3-查找树ADT-——-二叉查找树"><a href="#4-3-查找树ADT-——-二叉查找树" class="headerlink" title="4.3 查找树ADT ——  二叉查找树"></a>4.3 查找树ADT ——  二叉查找树</h2><h2 id="4-4-AVL树"><a href="#4-4-AVL树" class="headerlink" title="4.4 AVL树"></a>4.4 AVL树</h2><p>AVL树是带有平衡条件的二叉查找树</p><p>特点：</p><ul><li>本身首先是一棵二叉搜索树。</li><li>每个节点的左右子树的高度之差的绝对值（平衡因子）最多为1</li></ul><h3 id="4-4-1-单旋转"><a href="#4-4-1-单旋转" class="headerlink" title="4.4.1 单旋转"></a>4.4.1 单旋转</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%204.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%205.png" alt="Untitled"></p><h3 id="4-4-2-双旋转"><a href="#4-4-2-双旋转" class="headerlink" title="4.4.2 双旋转"></a>4.4.2 双旋转</h3><h2 id="4-5-伸展树"><a href="#4-5-伸展树" class="headerlink" title="4.5 伸展树"></a>4.5 伸展树</h2><p>伸展树保证从空树开始连续M次对树的操作最多花费*O(M log N)*时间</p><p>伸展树基于这样的事实：对于二叉查找树来说，每次操作最坏情形时间*O(N)*并不坏，只要它相对不常发生就行。</p><h2 id="4-6-树的遍历"><a href="#4-6-树的遍历" class="headerlink" title="4.6 树的遍历"></a>4.6 树的遍历</h2><ul><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层序遍历</li></ul><h2 id="4-7-B-树"><a href="#4-7-B-树" class="headerlink" title="4.7 B+树**"></a>4.7 B+树**</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%206.png" alt="Untitled"></p><p>阶为M的B+树的特性：</p><ul><li>数据项存储在树叶上</li><li>非叶子节点存储直到M-1个关键字以指示搜索的方向；关键字i代表子树i+1中的最小的关键字</li><li>树的根或者是一片树叶，或者其儿子数在2和M之间</li><li>除根外，所有非树叶节点的儿子数在<code>⌈M/2⌉</code>和<code>M</code>之间</li><li>所有的树叶都在相同的深度上并有<code>⌈L/2⌉</code>和<code>L</code> 之间个数据项</li></ul><p>B树与B+树不同点：</p><ul><li>单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。</li><li>所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。</li><li>所有的叶子节点形成了一个有序链表，更加便于查找。</li></ul><h1 id="第-5-章-散列"><a href="#第-5-章-散列" class="headerlink" title="第 5 章 散列"></a>第 5 章 散列</h1><h2 id="5-1-一般想法"><a href="#5-1-一般想法" class="headerlink" title="5.1 一般想法"></a>5.1 一般想法</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%207.png" alt="Untitled"></p><h2 id="5-2-散列函数"><a href="#5-2-散列函数" class="headerlink" title="5.2 散列函数"></a>5.2 散列函数</h2><p>如果关键字是整数一般合理的方法就是直接返回<em>key mod Tablesize</em></p><p>如果关键字是字符串，</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%208.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%209.png" alt="Untitled"></p><h2 id="5-3-分离链接法"><a href="#5-3-分离链接法" class="headerlink" title="5.3 分离链接法"></a>5.3 分离链接法</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2010.png" alt="Untitled"></p><p>分离链接法：其做法是将散列到同一个值的所有元素保留到一个表中</p><h2 id="5-4-不同链表的散列表"><a href="#5-4-不同链表的散列表" class="headerlink" title="5.4 不同链表的散列表"></a>5.4 不同链表的散列表</h2><h3 id="5-4-1-线性探测法"><a href="#5-4-1-线性探测法" class="headerlink" title="5.4.1 线性探测法"></a>5.4.1 线性探测法</h3><p>在线性探测法中，函数f是i的线性函数，典型情形是$f(i) = i$</p><h3 id="5-4-2-平方探测法"><a href="#5-4-2-平方探测法" class="headerlink" title="5.4.2 平方探测法"></a>5.4.2 平方探测法</h3><p>平方探测是消除线性探测中一次聚集问题的冲突解决方法。</p><p>平方探测就是冲突函数为二次的探测方法，流行的选择是$f(i)=i^2$</p><p>定理：如果使用平方探测，且表的大小是素数，那么当表至少有一半是空的时候总能够插入一个新元素</p><h3 id="5-4-3-双散列"><a href="#5-4-3-双散列" class="headerlink" title="5.4.3 双散列"></a>5.4.3 双散列</h3><p>对于双散列，一种流行的选择是$f(i)=i*hash_2(x)$</p><h2 id="5-5-再散列"><a href="#5-5-再散列" class="headerlink" title="5.5 再散列"></a>5.5 再散列</h2><p>建立另外一个大约两倍大的表（而且使用一个相关的新散列函数），扫描整个原始散列表，计算每个（未删除的）元素的新散列值并将其插入到新表中</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2011.png" alt="Untitled"></p><h2 id="5-6-标准库中的散列表"><a href="#5-6-标准库中的散列表" class="headerlink" title="5.6 标准库中的散列表"></a>5.6 标准库中的散列表</h2><h2 id="5-7-最坏情形下O-1-访问的散列表"><a href="#5-7-最坏情形下O-1-访问的散列表" class="headerlink" title="5.7 最坏情形下O(1)访问的散列表"></a>5.7 最坏情形下O(1)访问的散列表</h2><h3 id="5-7-1-完美散列"><a href="#5-7-1-完美散列" class="headerlink" title="5.7.1 完美散列"></a>5.7.1 完美散列</h3><h3 id="5-7-2-布谷鸟散列"><a href="#5-7-2-布谷鸟散列" class="headerlink" title="5.7.2 布谷鸟散列"></a>5.7.2 布谷鸟散列</h3><p>在布谷鸟散列中，假设有N个项。我们维护两个分别超过半空的表，且有两个独立的散列函数，可以把每个项分配到每个表中的一个位置。布谷鸟散列保持不变的是一个项总会被存储在这两个位置之一。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2012.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2013.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2014.png" alt="Untitled"></p><h3 id="5-7-3-跳房子散列"><a href="#5-7-3-跳房子散列" class="headerlink" title="5.7.3 跳房子散列"></a>5.7.3 跳房子散列</h3><p>跳房子散列的思路是用事先确定的、对计算机的底层体系结构而言是最优的一个常数，给探测序列的最大长度加个上界。这样做可以给出常数集的最坏查询时间，并且与布谷鸟散列一样，查询可以并行化，以同时检查可用位置的有限集。</p><h2 id="5-8-通用散列法"><a href="#5-8-通用散列法" class="headerlink" title="5.8 通用散列法"></a>5.8 通用散列法</h2><h1 id="第-6-章-优先队列（堆）"><a href="#第-6-章-优先队列（堆）" class="headerlink" title="第 6 章 优先队列（堆）"></a>第 6 章 优先队列（堆）</h1><h2 id="6-1-模型"><a href="#6-1-模型" class="headerlink" title="6.1 模型"></a>6.1 模型</h2><p>优先队列是允许至少下列两种操作的数据结构：插入和删除最小者。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2015.png" alt="Untitled"></p><h2 id="6-2-一些简单的实现"><a href="#6-2-一些简单的实现" class="headerlink" title="6.2 一些简单的实现"></a>6.2 一些简单的实现</h2><ol><li>使用简单链表</li><li>使用二叉查找树</li></ol><h2 id="6-3-二叉堆"><a href="#6-3-二叉堆" class="headerlink" title="6.3 二叉堆"></a>6.3 二叉堆</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2016.png" alt="Untitled"></p><h3 id="6-3-1-结构性质"><a href="#6-3-1-结构性质" class="headerlink" title="6.3.1 结构性质"></a>6.3.1 结构性质</h3><p>堆是一个完全二叉树</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2017.png" alt="Untitled"></p><ol><li>插入</li></ol><p>为将一个元素X插入到堆中，我们在一个可用位置创建一个空穴，否则该堆将不是完全熟，如果可以放在该空穴中而不破坏堆的序，那么插入完成。否则我们把空穴的父节点上的元素移入该空穴中，这样空穴就朝着根的方向上冒一步。继续该过程直到X能被放入空穴中为止。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2018.png" alt="Untitled"></p><ol><li>删除最小元</li></ol><p>删除最小元以类似于插入的方式处理。当删除一个最小元时，要在跟节点建立一个空穴。由于现在堆少了一个元素，因此堆中最后一个元素X必须移动到该堆的某个地方。如果X可以被放倒空穴中，那么deleteMin完成，否则我们将空穴的两个儿子中较小者移入空穴，这样就把空穴向下推了一层，重复该步骤直到X可以被放入空穴中。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2019.png" alt="Untitled"></p><h2 id="6-4-优先队列的应用"><a href="#6-4-优先队列的应用" class="headerlink" title="6.4 优先队列的应用"></a>6.4 优先队列的应用</h2><h2 id="6-5-d-堆"><a href="#6-5-d-堆" class="headerlink" title="6.5 d-堆"></a>6.5 d-堆</h2><p>d-堆是二叉堆的简单推广，就像一个二叉堆，只是所有的节点都有d个儿子（因此，二叉堆是2-堆）</p><h2 id="6-6-左式堆"><a href="#6-6-左式堆" class="headerlink" title="6.6 左式堆"></a>6.6 左式堆</h2><p>左式堆像二叉堆那样也具有结构性和有序性。左式堆具有相同的堆序性质，左式堆也是二叉树，左式堆和叉二树唯一的区别是：左式堆不是理想平衡的，而实际上趋向于非常不平衡。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2020.png" alt="Untitled"></p><h2 id="6-7-斜堆"><a href="#6-7-斜堆" class="headerlink" title="6.7 斜堆"></a>6.7 斜堆</h2><p>斜堆是左式堆的自调节形式，实现起来极其简单。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2021.png" alt="Untitled"></p><h2 id="6-8-二项队列"><a href="#6-8-二项队列" class="headerlink" title="6.8 二项队列"></a>6.8 二项队列</h2><h3 id="6-8-1-二项队列结构"><a href="#6-8-1-二项队列结构" class="headerlink" title="6.8.1 二项队列结构"></a>6.8.1 二项队列结构</h3><p>一个二项队列不是一颗堆序的树，而是堆序的树的集合，称为森林。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2022.png" alt="Untitled"></p><h1 id="第-7-章-排序"><a href="#第-7-章-排序" class="headerlink" title="第 7 章 排序"></a>第 7 章 排序</h1><h2 id="7-2-插入排序"><a href="#7-2-插入排序" class="headerlink" title="7.2 插入排序"></a>7.2 插入排序</h2><p>插入排序由N-1趟排序组成。对于p=1到N-1趟，插入排序保证从位置0到位置p上的元素为已排序状态。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2023.png" alt="Untitled"></p><p>时间复杂度：$O(N^2)$</p><p>定理：通过交换相邻元素进行排序的任何算法平均都需要$Ω(N^2)$时间</p><h2 id="7-4-希尔排序"><a href="#7-4-希尔排序" class="headerlink" title="7.4 希尔排序"></a>7.4 希尔排序</h2><p>定理：使用希尔排序最坏情形运行时间为$O(N^2)$</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2024.png" alt="Untitled"></p><h2 id="7-5-堆排序"><a href="#7-5-堆排序" class="headerlink" title="7.5 堆排序"></a>7.5 堆排序</h2><p>优先队列可以用以$O(NlogN)$时间的排序。基于该思想的算法叫做堆排序。</p><h2 id="7-6-归并排序"><a href="#7-6-归并排序" class="headerlink" title="7.6 归并排序"></a>7.6 归并排序</h2><p>归并排序以O(NlogN)最坏情形时间运行。它是递归算法一个好的实例。</p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2025.png" alt="Untitled"></p><h2 id="7-7-快速排序"><a href="#7-7-快速排序" class="headerlink" title="7.7 快速排序"></a>7.7 快速排序</h2><p>快速排序是事件中一种快速的排序算法，在C++或对Java基本类型的排序汇总特别有用。平均运行时间是$O(NlogN)$。</p><h1 id="第-9-章-图论"><a href="#第-9-章-图论" class="headerlink" title="第 9 章 图论"></a>第 9 章 图论</h1><h2 id="9-1-定义"><a href="#9-1-定义" class="headerlink" title="9.1 定义"></a>9.1 定义</h2><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2026.png" alt="Untitled"></p><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2027.png" alt="Untitled"></p><h2 id="9-2-拓扑排序"><a href="#9-2-拓扑排序" class="headerlink" title="9.2 拓扑排序"></a>9.2 拓扑排序</h2><h2 id="9-3-最短路径算法"><a href="#9-3-最短路径算法" class="headerlink" title="9.3 最短路径算法"></a>9.3 最短路径算法</h2><h3 id="9-3-1-无权最短路径"><a href="#9-3-1-无权最短路径" class="headerlink" title="9.3.1 无权最短路径"></a>9.3.1 无权最短路径</h3><p><img src="/images/data_structures_and_algorithms_analysis/Untitled%2028.png" alt="Untitled"></p><h2 id="未完"><a href="#未完" class="headerlink" title="未完"></a>未完</h2><h1 id="第-9-章-算法设计技巧"><a href="#第-9-章-算法设计技巧" class="headerlink" title="第 9 章 算法设计技巧"></a>第 9 章 算法设计技巧</h1><h2 id="10-1-贪婪算法"><a href="#10-1-贪婪算法" class="headerlink" title="10.1 贪婪算法"></a>10.1 贪婪算法</h2><p>贪婪算法分阶段地工作，在每一个阶段可以认为所做决定是好的。而不考虑将来的后果。</p><h2 id="10-2-分治算法"><a href="#10-2-分治算法" class="headerlink" title="10.2 分治算法"></a>10.2 分治算法</h2><p>分治算法由两部分组成：</p><ul><li>分：递归解决较小的问题</li><li>治：然后从子问题的解构建原问题的解</li></ul><h2 id="10-3-动态规划"><a href="#10-3-动态规划" class="headerlink" title="10.3 动态规划"></a>10.3 动态规划</h2><p>将递归算法重新写成非递归算法，让后者把那些子问题的答案系统第记录在一个表内，利用这种方法的一种技巧叫做动态规划</p><h2 id="10-4-随机数算法"><a href="#10-4-随机数算法" class="headerlink" title="10.4 随机数算法"></a>10.4 随机数算法</h2><h2 id="10-5-回溯算法"><a href="#10-5-回溯算法" class="headerlink" title="10.5 回溯算法"></a>10.5 回溯算法</h2><h1 id="第-12-章-高级数据结构及其实现"><a href="#第-12-章-高级数据结构及其实现" class="headerlink" title="第 12 章 高级数据结构及其实现"></a>第 12 章 高级数据结构及其实现</h1><h2 id="12-2-红黑树"><a href="#12-2-红黑树" class="headerlink" title="12.2 红黑树"></a>12.2 红黑树</h2><p>对红黑树的操作在最坏情形下花费O(logN)时间</p><p>红黑树是具有下列着色性质的二叉查找树：</p><ul><li>每一个节点或者着成红色，或者着成黑色</li><li>根是黑色的</li><li>如果一个节点是红色，那么它的子节点必须是黑色的</li><li>从一个节点到一个null引用的每一条路径必须包含相同数目的黑色节点</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构与算法分析&quot;&gt;&lt;a href=&quot;#数据结构与算法分析&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法分析&quot;&gt;&lt;/a&gt;数据结构与算法分析&lt;/h1&gt;&lt;h1 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="https://zhangzhishun.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>IPFS原理深入分析</title>
    <link href="https://zhangzhishun.github.io/2022/01/18/distributed_storage/IPFS%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <id>https://zhangzhishun.github.io/2022/01/18/distributed_storage/IPFS%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</id>
    <published>2022-01-18T02:29:15.000Z</published>
    <updated>2022-04-28T06:15:52.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="〇、目标"><a href="#〇、目标" class="headerlink" title="〇、目标"></a>〇、目标</h1><ol><li>熟悉IPFS概念</li><li>熟悉IPFS上传文件、下载文件过程</li></ol><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="2-BACKGROUND"><a href="#2-BACKGROUND" class="headerlink" title="2. BACKGROUND"></a>2. BACKGROUND</h2><h3 id="Distributed-Hash-Tables-DHTs"><a href="#Distributed-Hash-Tables-DHTs" class="headerlink" title="Distributed Hash Tables(DHTs)"></a>Distributed Hash Tables(DHTs)</h3><ol><li><p>Kademlia DHT</p><p> 优点</p><ul><li>【通信性能】通过大规模网络高效查找:查询平均需要通信$log_2(n)$向上取整节点。(例如，一个由10,000,000个节点组成的网络需要20个跳数)</li><li>【通信性能】低协调开销:优化了发送给其他节点的控制消息的数量</li><li>【安全】通过选择长期存在的节点来抵抗各种攻击</li><li>【应用】在对等应用程序中广泛使用，包括Gnutella和BitTorrent，形成了超过2000万个节点的网络。</li></ul></li><li><p>Coral DSHT</p><p> 优点</p><ul><li>【通信性能】Kademlia将值存储在id与键最接近(使用XOR-distance)的节点中。这并不考虑应用程序数据的局域性，忽略可能已经拥有数据的远节点，并不管最近节点是否需要这份数据而去强制它们存储数据。这浪费了大量的存储和带宽。相反，Coral在能够提供数据块的对等节点存储地址信息</li><li>【通信性能】Coral将DHT API从get_value(key)放宽为get_any_values(key) (DSHT中的“sloppy”)。这仍然工作直到Coral用户只需要一个(工作)peer，而不是完整的列表。作为交换，Coral只能将值的子集分发到最近的节点，从而避免了热点(当一个键变得流行时，会重载所有最近的节点)</li><li>【通信性能】Coral根据区域和大小组织了一个称为簇的独立DSHT层次结构。这使得节点可以首先查询其区域内的对等节点，在不查询远处节点的情况下查找附近的数据，大大减少了查找的延迟</li></ul></li><li><p>S/Kademlia DHT</p><p>S/Kademlia扩展了Kademlia以两种特别重要的方式来抵御恶意攻击:</p><ul><li>【安全】S/Kademlia提供了安全的NodeId生成方案，并防止女巫攻击。它要求节点创建一个PKI密钥对，从密钥对中获得自己的身份，并对彼此的消息进行签名。一种方案包括一个工作证明加密谜题，以使生成女巫攻击的成本很高</li><li>【安全】S/Kademlia节点在不相交的路径上查找值，以确保在网络中存在大量对手的情况下，诚实的节点可以相互连接。即使对抗分数高达一半的节点S/Kademlia实现了0.85的成功率，</li></ul></li></ol><h3 id="Block-Exchanges-BitTorrentc"><a href="#Block-Exchanges-BitTorrentc" class="headerlink" title="Block Exchanges - BitTorrentc"></a>Block Exchanges - BitTorrentc</h3><p>BitTorrent（简称BT）是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。</p><p>BitTorrent是一个广泛成功的点对点文件处理系统，它成功地协调了互不信任的点(群)网络，在相互分发文件的过程中进行合作。BitTorrent及其生态系统中IPFS设计的关键特性包括:</p><ol><li>BitTorrent的数据交换协议使用了一种类似于tit-for-tat的策略，奖励那些相互贡献的节点，惩罚那些只窃取别人资源的节点</li><li>BitTorrent同行跟踪文件片段的可用性，优先发送最罕见的片段。这减轻了种子的负担，使非种子同伴能够相互交易</li><li>BitTorrent标准的tit-for-tat易受某些利用带宽共享策略的攻击。PropShare是一种不同的对等带宽分配策略，它能更好地抵抗利用策略，并提高群的性能</li></ol><h3 id="Version-Control-Systems-Git"><a href="#Version-Control-Systems-Git" class="headerlink" title="Version Control Systems - Git"></a>Version Control Systems - Git</h3><p>版本控制系统提供了对随时间变化的文件建模的工具，并有效地分发不同的版本。流行的版本控制系统Git提供了一个功能强大的Merkle dag对象模型，它以分布式友好的方式捕获对文件系统树的更改。</p><ol><li>不可变对象代表Files (blob)、Directories (tree)和Changes (commit)</li><li>对象是内容寻址的，通过其内容的加密散列</li><li>与其他物体的链接被嵌入，形成一个默克尔DAG。这提供了许多有用的完整性和工作流属性</li><li>大多数版本化元数据(分支、标签等)都是简单的指针引用，因此创建和更新的成本很低</li><li>版本更改仅更新引用或添加对象</li><li>将版本更改分发给其他用户只是简单地传输对象和更新远程引用</li></ol><h3 id="Self-Certified-Filesystems-SFS"><a href="#Self-Certified-Filesystems-SFS" class="headerlink" title="Self-Certified Filesystems - SFS"></a>Self-Certified Filesystems - SFS</h3><p>SFS[12,11]提出了两种引人注目的实现：</p><ul><li>分布式信任链</li><li>平等共享的全局命名空间</li></ul><p>SFS引入了一种用于构建自认证文件系统的技术:</p><p>使用以下scheme：</p><p><code>/sfs/&lt;Location&gt;:&lt;HostID&gt;</code></p><p>其中Location是服务器的网络地址，并且:HostID = hash(public_key || Location)</p><p>因此SFS文件系统的名称证明了它的服务器。用户可以验证服务器提供的公钥，协商共享密钥，并确保所有流量的安全。所有SFS实例共享一个全局命名空间，其中的名称分配是加密的，不受任何集中主体的限制。</p><h2 id="3-IPFS-DESIGN"><a href="#3-IPFS-DESIGN" class="headerlink" title="3. IPFS DESIGN"></a>3. IPFS DESIGN</h2><p>IPFS协议被划分为负责不同功能的子协议堆栈</p><h3 id="3-1-身份——管理节点身份的生成和更新"><a href="#3-1-身份——管理节点身份的生成和更新" class="headerlink" title="3.1 身份——管理节点身份的生成和更新"></a>3.1 身份——管理节点身份的生成和更新</h3><p>节点由一个NodeId标识，这是一个公钥的加密哈希，是用S/Kademlia的静态加密谜题创建的。节点存储它们的公钥和私钥(使用密码短语加密)。用户可以在每次启动时自由实例化一个新的节点标识，尽管这样会损失已积累的网络利益。节点被激励保持不变</p><h3 id="3-2-网络——管理与其他对等体的连接，使用各种底层网络协议。可配置的"><a href="#3-2-网络——管理与其他对等体的连接，使用各种底层网络协议。可配置的" class="headerlink" title="3.2 网络——管理与其他对等体的连接，使用各种底层网络协议。可配置的"></a>3.2 网络——管理与其他对等体的连接，使用各种底层网络协议。可配置的</h3><p>IPFS网络栈特性:</p><ul><li>传输:IPFS可以使用任何传输协议，最适合于WebRTC数据通道(用于浏览器连接)或uTP(LEDBAT)</li><li>可靠性:如果底层网络不提供，IPFS可以使用uTP (LEDBAT[14])或SCTP[15]提供可靠性</li><li>连通性:IPFS也使用ICE NAT穿越技术</li><li>完整性:可选地使用哈希校验和检查消息的完整性</li><li>真实性:可选地检查mes- sage的真实性，通过使用发送方的特权密钥进行数字签名。</li></ul><h3 id="3-3-路由——维护定位特定对等体和对象的信息。响应本地和远程查询。默认为DHT，但可切换"><a href="#3-3-路由——维护定位特定对等体和对象的信息。响应本地和远程查询。默认为DHT，但可切换" class="headerlink" title="3.3 路由——维护定位特定对等体和对象的信息。响应本地和远程查询。默认为DHT，但可切换"></a>3.3 路由——维护定位特定对等体和对象的信息。响应本地和远程查询。默认为DHT，但可切换</h3><p>IPFS节点需要一个路由系统，它可以找到其他节点的网络地址，以及可以为特定对象服务的节点。IPFS使用S/Kademlia和Coral DSHT实现这一点。IPFS的对象大小和使用模式类似于Coral和Mainline，因此IPFS DHT根据其大小对存储的值进行区分。小值(等于或小于1KB)直接存储在DHT上。对于较大的值，DHT存储引用，这些引用是可以为块提供服务的节点的nodeid</p><h3 id="3-4-块交换——一个新的块交换协议-BitSwap-，它管理有效的块分配。以市场为模型，对数据复制的激励很弱。可切换的贸易策略"><a href="#3-4-块交换——一个新的块交换协议-BitSwap-，它管理有效的块分配。以市场为模型，对数据复制的激励很弱。可切换的贸易策略" class="headerlink" title="3.4 块交换——一个新的块交换协议(BitSwap)，它管理有效的块分配。以市场为模型，对数据复制的激励很弱。可切换的贸易策略"></a>3.4 块交换——一个新的块交换协议(BitSwap)，它管理有效的块分配。以市场为模型，对数据复制的激励很弱。可切换的贸易策略</h3><p>在IPFS中，数据分发是通过使用BitTorrent启发的协议BitSwap与对等点交换块来实现的。像BitTorrent一样，BitSwap对等体正在寻找一组块(want_list)，并有另一组块交换(have_list)。与BitTorrent不同，BitSwap并不局限于一个torrent中的区块。BitSwap操作是一个持久的市场，节点可以获取他们需要的块，而不管这些块是什么文件的一部分。这些块可以来自文件系统中完全不相关的文件。节点聚集在一起进行交易。</p><h3 id="3-5-对象——一个Merkle-DAG，由具有链接的内容定位的不可变对象组成。用于表示任意的数据结构，例如文件层次结构和通信系统"><a href="#3-5-对象——一个Merkle-DAG，由具有链接的内容定位的不可变对象组成。用于表示任意的数据结构，例如文件层次结构和通信系统" class="headerlink" title="3.5 对象——一个Merkle DAG，由具有链接的内容定位的不可变对象组成。用于表示任意的数据结构，例如文件层次结构和通信系统"></a>3.5 对象——一个Merkle DAG，由具有链接的内容定位的不可变对象组成。用于表示任意的数据结构，例如文件层次结构和通信系统</h3><p>DHT和BitSwap允许IPFS形成一个大规模的点对点系统，用于快速、可靠地存储和分发块。在这些之上，IPFS构建了一个Merkle DAG，一个有向无环图，其中对象之间的链接是嵌入源中的目标的加密散列。这是Git数据结构的一般化。</p><p>默克尔DAG为IPFS提供了许多有用的属性：</p><ol><li>内容寻址:所有内容由其多哈希校验和唯一标识，包括链接</li><li>抗篡改:所有内容都通过校验和进行验证。如果数据被篡改或损坏，IPFS会检测到它</li><li>重复数据删除:所有包含相同内容的对象都是相同的，且只存储一次。对于索引对象，如git树和提交，或数据的公共部分，这尤其有用。</li></ol><h3 id="3-6-文件——受Git启发的文件版本的文件系统层次结构"><a href="#3-6-文件——受Git启发的文件版本的文件系统层次结构" class="headerlink" title="3.6 文件——受Git启发的文件版本的文件系统层次结构"></a>3.6 文件——受Git启发的文件版本的文件系统层次结构</h3><p>IPFS还定义了一组对象，用于在Merkle DAG之上对版本化的文件系统建模。该对象模型类似于Git s:</p><ol><li>块:一个可变大小的数据块</li><li>列表:块或其他列表的集合</li><li>树:块、列表或其他树的集合</li><li>提交:树版本历史中的快照。</li></ol><h3 id="3-7-命名——一个自认证的可变名称系统"><a href="#3-7-命名——一个自认证的可变名称系统" class="headerlink" title="3.7 命名——一个自认证的可变名称系统"></a>3.7 命名——一个自认证的可变名称系统</h3><p>到目前为止，IPFS堆栈形成了一个点对点块交换，构造了一个对象的内容寻址DAG。它用于发布和检索不可变对象。它甚至可以跟踪这些对象的版本历史。但是，缺少一个关键组件:可变命名。没有它，所有新内容的通信都必须在带外进行，发送IPFS链接。需要的是在同一路径上检索可变状态的某种方法。值得说明的是，如果可变数据是必要的，我们最终努力建立一个不可变的默克尔DAG。考虑一下来自Merkle DAG的IPFS属性:对象可以(a)通过其散列检索，(b)完整性检查，(c)链接到其他对象，以及(d)无限期缓存。在某种意义上:对象是永久的。这些是高性能分布式系统的关键属性，在分布式系统中，数据跨网络链路移动的代价很高。对象内容寻址构建了一个具有(a)显著带宽优化、(b)不可信内容服务、(c)永久链接和(d)对任何对象及其引用进行完全永久备份的能力的web。Merkle DAG(不可变的内容寻址对象)和命名(指向Merkle DAG的可变指针)瞬时出现在许多成功的分布式系统中。这包括Git版本控制系统，它有不可变对象和可变引用;和Plan， UNIX的分布式继承者，及其可变的Fossil和不可变的Venti文件系统。LBFS也使用可变索引和不可变块。</p><h2 id="4-IPFS共识"><a href="#4-IPFS共识" class="headerlink" title="4. IPFS共识"></a>4. IPFS共识</h2><p>IPFS创新的采用了一种混合共识机制——复制证明（PoRep）+时空证明（PoSt）+ 预期共识(EC)</p><ol><li>复制证明：共识机制中的核心因素，尽管IPFS的网络协议、共识、其他算法都基本定型，但是复制证明仍然处于不断完善的方案中。</li><li>时空证明:（PoSt)提出了证明链（proof-chain）的数据结构，证明链把一些的挑战（challenge）和证明（proof）链接起来形成。在证明链的基础上添加上时间段，这样就得到了一段时间内的矿工存储数据的证明，这就是时空证明（Proof of Spacetime，PoSt）。PoSt可以证明在该段时间内矿工存储了特定的数据，并且利用时间戳锚定这些证明链，这样即使验证者（verifier）不在线，也可以在未来的某个时间内利用时空证明去验证该矿工生成了证明链，PoSt会被提交到链上用来产生新的Block。</li><li>预期共识:（Expected Consensus，EC）是在每一轮里面选举出来一名或者多名矿工来创建新的区块，矿工赢得选举的可能性跟矿工当前的有效存储（算力）成正比。IPFS把矿工在网络中的当前存储数据相对于整个网络的存储比例转化为矿工投票权（voting power of the miner）。无论在该周期里，选举出来的是一名还是多名矿工，被选举出来的矿工都需要创建新的区块，并把新的区块对网络进行广播。 尽管链中的区块是线性的，但是IPFS的区块数据结构采用的DAG（有向无环图），可以在同一时间产生多个区块（所以Filecoin的交易要比BTC的有效的多，这也是为什么把Filecoin叫做“可能的blockchain 3.0”的原因） </li></ol><p>Filecoin首创的混合共识机制，从根本上定义了Filecoin是一个合理高效、去中心化的系统，并体现出Filecoin的公平性、保密性和公开可验证性</p><h1 id="二、上传文件"><a href="#二、上传文件" class="headerlink" title="二、上传文件"></a>二、上传文件</h1><p><img src="/images/ipfs/upload_file.png" alt="img.png"></p><h2 id="1-生成默克尔DAG的结构"><a href="#1-生成默克尔DAG的结构" class="headerlink" title="1. 生成默克尔DAG的结构"></a>1. 生成默克尔DAG的结构</h2><p>生成的结构有两种Layout：balanced和trickle的。这里介绍默认的balanced结构，首先生成root作为根节点，然后将文件分割，默认按照256KB大小读取一个chunk，生成叶子节点，依次生成node1，node2，root节点会有Link指向挂在root节点的叶子节点node1和node2。root节点下面能够Link的叶子节点数量是有限的，IPFS中默认设置的是174个（定义的Link的总的大小是8KB，每个Link的大小是34 + 8 + 5【sha256 multihash + size + no name + protobuf framing】，默认的Link的个数为8192/47约等于174）。</p><p><img src="/images/ipfs/image-1.png" alt="/images/ipfs/image-1.png"></p><p>如下图所示，超过174个后则会新创建一个new root节点，并Link到old root，新的chunk作为node3（这里用node3简约了，实际上是第175个节点）被new root直接Link。</p><p><img src="/images/ipfs/image-4.png" alt="/images/ipfs/image-4.png"></p><p>当继续有新的chunk添加时，则会生成node34作为node3和node4的父节点，node34含有两个Link分别链接到node3和node4。</p><p><img src="/images/ipfs/image-5.png" alt="/images/ipfs/image-5.png"></p><p>IPFS在init的时候会生成.ipfs目录，如下图所示，其中blocks则为文件块存储的目录，datastore为leveldb数据库，其中存储了文件系统的根哈希等，存储相关的配置关联在.ipfs目录下面的config文件。</p><p><img src="/images/ipfs/image-6.png" alt="/images/ipfs/image-6.png"></p><h2 id="2-对块进行存储"><a href="#2-对块进行存储" class="headerlink" title="2. 对块进行存储"></a>2. 对块进行存储</h2><ul><li>如下图所示，一个Block存储时，首先由dagService（实现了DAGService接口）调用Add进行添加；</li><li>之后由blockService（实现了BlockService接口）调用AddBlock添加该Block；</li><li>再调用arccache的Put，arccache是对存储的Block做arc策略的缓存；</li><li>再之后由VerifBS调用Put进行存储，VerifyBS主要对CID的合法性进行校验，合法则进行Put；</li><li>接着blockstore（实现了Blockstore接口）调用Put进行存储，Put函数中会对CID进行转化，调用dshelp的CidToDsKey方法将CID转化成存储的Key；</li><li>再接着调用keytransform.Datastore的Put，Put函数中会将前缀拼上，这时Key加上了前缀/blocks；</li><li>然后调用measure的Put函数，measure是对mount的封装；</li><li>之后调用mount的Put函数，mount和IPFS的config配置文件中结构对应，根据key去查找对应的datastore，由于前缀是/blocks则可以找到对应的measure；</li><li>调用该measure的Put函数；</li><li>最后调用flatfs的Put函数，由Put函数调用doPut最终调用encode函数将完整的block写入的目录指定为/home/test/.ipfs/blocks/WD，其中WD来自于blocks/CIQFSQATUBIEIFDECKTNGHOKPOEE7WUPM5NNNSJCCDROMM6YHEKTWDY中的倒数第三第二个字符。这样该Block则写入了该目录下面的文件中。</li></ul><p><img src="/images/ipfs/image-7.png" alt="/images/ipfs/image-7.png"></p><p><img src="/images/ipfs/image-9.png" alt="/images/ipfs/image-9.png"></p><h1 id="三、下载文件"><a href="#三、下载文件" class="headerlink" title="三、下载文件"></a>三、下载文件</h1><p><img src="/images/ipfs/download_file.png" alt="img.png"></p><ol><li>检查本地的blockstore中是否存在请求的数据，如果存在则直接从本地返回；否则会向对等节点发送block hash列表；</li><li>对等节点通过DHT和路由层算法，找到每个block hash所在的节点，将文件返回来；</li><li>本地节点在接收block文件的同时缓存一份到本地的blockstore中</li><li>更新DHT</li><li>组装block文件，返回至用户端</li></ol><h1 id="附：资料"><a href="#附：资料" class="headerlink" title="附：资料"></a>附：资料</h1><ol><li>IPFS白皮书：<a href="https://github.com/ipfs/papers/raw/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf">https://github.com/ipfs/papers/raw/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf</a></li><li>上传/下载文件过程：<ul><li><a href="https://www.jianshu.com/p/9eb1e5f83e13">https://www.jianshu.com/p/9eb1e5f83e13</a></li><li><a href="https://www.chaindesk.cn/witbook/24/449">https://www.chaindesk.cn/witbook/24/449</a></li></ul></li><li><a href="https://www.jiabaotz.com/finance/79470.html">IPFS/Filecoin的共识机制有哪些特点？</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;〇、目标&quot;&gt;&lt;a href=&quot;#〇、目标&quot; class=&quot;headerlink&quot; title=&quot;〇、目标&quot;&gt;&lt;/a&gt;〇、目标&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;熟悉IPFS概念&lt;/li&gt;
&lt;li&gt;熟悉IPFS上传文件、下载文件过程&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;一</summary>
      
    
    
    
    
    <category term="Distributed Storage" scheme="https://zhangzhishun.github.io/tags/Distributed-Storage/"/>
    
  </entry>
  
  <entry>
    <title>Go语言核心编程</title>
    <link href="https://zhangzhishun.github.io/2022/01/17/go/Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <id>https://zhangzhishun.github.io/2022/01/17/go/Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-17T02:29:15.000Z</published>
    <updated>2022-04-27T02:35:55.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-Core-Programming"><a href="#Go-Core-Programming" class="headerlink" title="Go Core Programming"></a>Go Core Programming</h1><h1 id="第-1-章-基础知识"><a href="#第-1-章-基础知识" class="headerlink" title="第 1 章 基础知识"></a>第 1 章 基础知识</h1><h2 id="1-1-语言简介"><a href="#1-1-语言简介" class="headerlink" title="1.1 语言简介"></a>1.1 语言简介</h2><h3 id="1-1-1-Go语言的诞生背景"><a href="#1-1-1-Go语言的诞生背景" class="headerlink" title="1.1.1 Go语言的诞生背景"></a>1.1.1 Go语言的诞生背景</h3><ul><li><strong>当前编程语言对并发的支持不是很好</strong>，不能很好地发挥多核CPU的威力</li><li>程序规模越来越大，<strong>编译速度越来越慢</strong></li><li>现有的<strong>编程语言设计越来越复杂</strong>，某些特性的实现不怎么优雅</li></ul><h3 id="1-1-3-Go语言的特性"><a href="#1-1-3-Go语言的特性" class="headerlink" title="1.1.3 Go语言的特性"></a>1.1.3 Go语言的特性</h3><p><img src="/images/go_core_programming/Untitled.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%201.png" alt="Untitled"></p><h2 id="1-3-Go词法单元"><a href="#1-3-Go词法单元" class="headerlink" title="1.3 Go词法单元"></a>1.3 Go词法单元</h2><h3 id="1-3-1-token"><a href="#1-3-1-token" class="headerlink" title="1.3.1 token"></a>1.3.1 token</h3><p>token是构成源程序的基本不可再分割的单元。</p><p>编译器编译源程序的第一步就是将源程序分割成一个个独立的token，这个过程就是词法分析。</p><p>Go语言的token可以分为关键字、标识符、操作符、分隔符和字面常量</p><p><img src="/images/go_core_programming/Untitled%202.png" alt="Untitled"></p><h3 id="1-3-2-标识符"><a href="#1-3-2-标识符" class="headerlink" title="1.3.2 标识符"></a>1.3.2 标识符</h3><ol><li>标识符用来标识变量、类型、常量等语法对象的符号名称，其在语法分析时作为一个token存在。</li><li>标识符分为两类：<ul><li>语言设计者预留的标识符：语言设计者确定，包括语言的预声明标识符及保留字</li><li>编程者可以自定义的标识符：用户定义的变量名、常量名、函数名等</li></ul></li><li>标识符规则：开头一个字符必须是字母或下划线，区分大小写</li><li><strong>关键字（keywords，25个）</strong></li></ol><p><img src="/images/go_core_programming/Untitled%203.png" alt="Untitled"></p><ol><li><strong>内置数据类型标识符（20个）</strong></li></ol><p><img src="/images/go_core_programming/Untitled%204.png" alt="Untitled"></p><ol><li><strong>内置函数（15个）</strong></li></ol><p><img src="/images/go_core_programming/Untitled%205.png" alt="Untitled"></p><ol><li><strong>常量值标识符（4个）</strong></li></ol><p><img src="/images/go_core_programming/Untitled%206.png" alt="Untitled"></p><p>空白标识符： <code>_</code></p><h3 id="1-3-3-操作符（operators）和分隔符（delimiters）"><a href="#1-3-3-操作符（operators）和分隔符（delimiters）" class="headerlink" title="1.3.3 操作符（operators）和分隔符（delimiters）"></a>1.3.3 操作符（operators）和分隔符（delimiters）</h3><p>操作符包括运算符、现式的分隔符、其他语法辅助符号</p><h3 id="1-3-4-字面常量"><a href="#1-3-4-字面常量" class="headerlink" title="1.3.4 字面常量"></a>1.3.4 字面常量</h3><ol><li>Go的字面量出现在两个地方：<ul><li>用于常量和变量的初始化</li><li>用在表达式里或函数调用实参</li></ul></li><li>字面量分类：<ul><li>整型字面量</li><li>浮点型字面量</li><li>复数类型字面量</li><li>字符型字面量</li><li>字符串字面量</li></ul></li></ol><h2 id="1-4-变量和常量"><a href="#1-4-变量和常量" class="headerlink" title="1.4 变量和常量"></a>1.4 变量和常量</h2><h3 id="1-4-1-变量"><a href="#1-4-1-变量" class="headerlink" title="1.4.1 变量"></a>1.4.1 变量</h3><h3 id="1-4-2-常量"><a href="#1-4-2-常量" class="headerlink" title="1.4.2 常量"></a>1.4.2 常量</h3><h2 id="1-5-基本数据类型"><a href="#1-5-基本数据类型" class="headerlink" title="1.5 基本数据类型"></a>1.5 基本数据类型</h2><p>Go内置七类基本数据类型：</p><p><img src="/images/go_core_programming/Untitled%207.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%208.png" alt="Untitled"></p><h2 id="1-5-4-复数类型"><a href="#1-5-4-复数类型" class="headerlink" title="1.5.4 复数类型"></a>1.5.4 复数类型</h2><p>Go语言内置的复数类型有两种，分别是complex64和complex128。复数的字面量表示和数学表示法一样。</p><p><img src="/images/go_core_programming/Untitled%209.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2010.png" alt="Untitled"></p><h3 id="1-5-6-rune类型"><a href="#1-5-6-rune类型" class="headerlink" title="1.5.6 rune类型"></a>1.5.6 rune类型</h3><p>Go内置两种字符类型：</p><ul><li>bute的字节类类型（byte是uint的别名）</li><li>表示Uniocode编码的字符rune（rune是int32类型的别名）</li></ul><h2 id="1-6-复合数据类型"><a href="#1-6-复合数据类型" class="headerlink" title="1.6 复合数据类型"></a>1.6 复合数据类型</h2><ol><li>复合数据类型就是由其他类型组合而成的类型。</li><li>Go基本的复合数据类型有：<ul><li><p>指针</p></li><li><p>数据</p></li><li><p>切片</p></li><li><p>字典（map）</p></li><li><p>通道</p></li><li><p>结构</p></li><li><p>接口</p><p><img src="/images/go_core_programming/Untitled%2011.png" alt="Untitled"></p></li></ul></li></ol><h3 id="1-6-1-指针"><a href="#1-6-1-指针" class="headerlink" title="1.6.1 指针"></a>1.6.1 指针</h3><ol><li>Go支持指针，声明类型为 <code>*T</code> ，Go支持多级指针 <code>**T</code> 。通过在变量名前加 <code>&amp;</code> 获取变量的地址。</li><li>指针的特点：<ul><li>在赋值语句中，<code>*T</code> 出现在 <code>=</code> 左边表示指针声明，<code>*T</code> 出现在 <code>=</code> 右边表示取指针指向的值（varName为变量名）。示例：<pre><code class="go">var a = 11p := &amp;a // *p和a的值都是11</code></pre></li><li>结构体指针访问结构体字段仍然使用 <code>.</code> 点操作符，Go语言没有 <code>-&gt;</code> 操作符，例如：<pre><code class="go">type User struct {    name string    age int}andes := User {    name: "andes",    age: 10,}p := &amp;andesfmt.Println(p.name) // p.name通过"."操作符访问成员变量</code></pre></li><li>Go不支持指针的运算  Go由于支持垃圾回收，如果支持指针运算则会给垃圾回收的实现带来很多不便。例如：  <img src="/images/go_core_programming/Untitled%2012.png" alt="Untitled"></li><li>函数中允许返回局部变量的地址  Go编译器使用”栈逃逸“机制将这种局部变量的空间分配在堆上，例如：  <img src="/images/go_core_programming/Untitled%2013.png" alt="Untitled"></li></ul></li></ol><h3 id="1-6-2-数组"><a href="#1-6-2-数组" class="headerlink" title="1.6.2 数组"></a>1.6.2 数组</h3><ol><li>数组的类型名是<code>[n]elementType</code>，n是数组长度，elementType是数组元素类型。</li></ol><p><img src="/images/go_core_programming/Untitled%2014.png" alt="Untitled"></p><ol><li>数组的特点：<ul><li>数组创建完长度就固定了，不可以再追加元素了</li><li>数组是值类型的，数组赋值或作为函数参数都是值拷贝</li><li>数组长度是数组类型的组成部分，<code>[10]int</code>和<code>[20]int</code>是不同的类型</li><li>可以根据数组创建切片</li></ul></li><li>数组相关操作：<ul><li><p>数组元素访问</p><p><img src="/images/go_core_programming/Untitled%2015.png" alt="Untitled"></p></li><li><p>数组长度</p><p><img src="/images/go_core_programming/Untitled%2016.png" alt="Untitled"></p></li></ul></li></ol><h3 id="1-6-3-切片"><a href="#1-6-3-切片" class="headerlink" title="1.6.3 切片"></a>1.6.3 切片</h3><p>Go语言的数组的定长性和值拷贝限制了其使用场景，Gp提供了另一种数据类型slice（切片），这是一种变长数组，其数据结构中有指向数组的指针，所以是一种引用类型。</p><p>例如：</p><pre><code class="go">type slice struct {    array unsafe.Pointer    len int    cap int}</code></pre><p>Go为切片维护三个元素：</p><ul><li>指向底层数组的指针</li><li>切片的元素数量</li><li>底层数组的容量</li></ul><p><img src="/images/go_core_programming/Untitled%2017.png" alt="Untitled"></p><ol><li>切片的创建<ul><li>由数组创建：创建语法<code>array[b:e]</code> ，表示创建一个包含e-b各元素额的切片，第一个元素是<code>array[b]</code>，最后一个元素是<code>array[e-1]</code> 。例如：  <img src="/images/go_core_programming/Untitled%2018.png" alt="Untitled"></li><li>通过内置函数<code>make</code>创建切片。<code>make</code>创建的切片各元素被默认为输出华为切片元素类型的零值。  <img src="/images/go_core_programming/Untitled%2019.png" alt="Untitled">  <img src="/images/go_core_programming/Untitled%2020.png" alt="Untitled"></li></ul><ol><li>切片支持的操作<ul><li>内置函数<code>len()</code>返回切片长度</li><li>内置函数<code>cap()</code>返回切片底层数组容量</li><li>内置函数<code>append()</code>对切片追加元素</li><li>内置函数<code>copy()</code>用于复制一个切片</li></ul></li></ol></li></ol><h3 id="1-6-4-map"><a href="#1-6-4-map" class="headerlink" title="1.6.4 map"></a>1.6.4 map</h3><p>Go语言内置的字典类型叫map。</p><p><code>map</code>类型的格式是：<code>map[K]T</code> ，其中K可以是任意可以进行比较的类型，T是值类型。</p><p><code>map</code>也是一种引用类型。</p><ol><li><code>map</code>的创建<ul><li>使用字面量创建，例如：  <img src="/images/go_core_programming/Untitled%2021.png" alt="Untitled"></li><li>使用内置的make函数创建，例如  <img src="/images/go_core_programming/Untitled%2022.png" alt="Untitled">  <img src="/images/go_core_programming/Untitled%2023.png" alt="Untitled"></li></ul></li><li><code>map</code>支持的操作<ul><li><p><code>map</code>的单个键值访问格式为<code>mapName[key]</code></p></li><li><p>可以使用<code>range</code>遍历一个<code>map</code>类型的变量，但不能保证每次迭代元素的顺序</p></li><li><p>删除<code>map</code>中的某个键值，<code>delete(mapName,key)</code> 。<code>delete</code>是内置函数，用来删除<code>map</code>中的某个键值对</p></li><li><p>可以使用内置的<code>len()</code> 函数返回<code>map</code>中的键值对数量</p><p>注意：</p></li><li><p>Go内置的<code>map</code>不是并发安全的，并发安全的<code>map</code>可以使用标准包<code>sync</code>中的map</p></li><li><p>不要直接修改<code>map value</code>内某个元素的值，如果想修改<code>map</code>的某个键值，则必须整理赋值</p></li></ul></li></ol><h3 id="1-6-5-struct"><a href="#1-6-5-struct" class="headerlink" title="1.6.5 struct"></a>1.6.5 struct</h3><p>Go中的struct类型和C类似，中文翻译为结构，由多个不同类型元素组合而成。</p><ul><li>struct结构中的类型可以是任意类型</li><li>struct的存储空间是连续的，其字段按照声明时的顺序存放（注意字段值之间有对齐要求）</li></ul><p>struct有两种形式：</p><ul><li>struct类型字面量</li><li>使用type声明的自定义struct类型</li></ul><ol><li>strct类型字面量 struct类型字面量的声明格式如下： <img src="/images/go_core_programming/Untitled%2024.png" alt="Untitled"></li><li>自定义struct类型 自定义struct类型声明格式如下： <img src="/images/go_core_programming/Untitled%2025.png" alt="Untitled"></li><li>struct类型变量的初始化，示例： <img src="/images/go_core_programming/Untitled%2026.png" alt="Untitled"></li><li>其他复合类型<ul><li>接口（Interface）</li><li>通道（chan）</li></ul></li></ol><h2 id="1-7-控制结构"><a href="#1-7-控制结构" class="headerlink" title="1.7 控制结构"></a>1.7 控制结构</h2><p>程序执行从本质上来说就是两种模式：顺序和跳转</p><h3 id="1-7-1-if-语句"><a href="#1-7-1-if-语句" class="headerlink" title="1.7.1 if 语句"></a>1.7.1 if 语句</h3><h3 id="1-7-2-switch-语句"><a href="#1-7-2-switch-语句" class="headerlink" title="1.7.2 switch 语句"></a>1.7.2 switch 语句</h3><h3 id="1-7-3-for-语句"><a href="#1-7-3-for-语句" class="headerlink" title="1.7.3 for 语句"></a>1.7.3 for 语句</h3><h3 id="1-7-4-标签和跳转"><a href="#1-7-4-标签和跳转" class="headerlink" title="1.7.4 标签和跳转"></a>1.7.4 标签和跳转</h3><ol><li>标签 Go语言使用标签（Lable）来标识一个语句的位置，用于goto、break、continue语句的跳转。标签的语法是： <img src="/images/go_core_programming/Untitled%2027.png" alt="Untitled"></li><li>goto goto语句用于函数的内部跳转，需要配合标签一起使用： <img src="/images/go_core_programming/Untitled%2028.png" alt="Untitled"> goto特点：<ul><li>goto语句只能在函数内跳转</li><li>goto语句不能跳过内部变量声明语句，这些变量在goto语句的标签语句处有事可见的</li><li>goto语句只能调到同级作用域或者上层作用域，不能跳到内部作用域</li></ul></li><li>break break用于函数内跳出for、switch、select语句的执行，有两种使用格式：<ul><li>单独使用：用于跳出break当前所在的for、switch、select语句的执行</li><li>和标签一起使用：用于跳出标签所标识的for、switch、select语句的执行，可用于跳出多重循环，但标签和break必须在同一个函数内，例如：  <img src="/images/go_core_programming/Untitled%2029.png" alt="Untitled"></li></ul></li><li>continue continue用于跳出for循环的本次迭代，跳到for循环的下一次迭代的post语句处执行，有两种使用格式：<ul><li><p>单独使用：跳出continue当前所在的for循环的本次迭代</p></li><li><p>和标签一起使用：跳出标签所标示的for语句的本次迭代，但标签和continue必须在同一个函数内，例如：</p><p><img src="/images/go_core_programming/Untitled%2030.png" alt="Untitled"></p></li></ul></li><li>return和函数调用 return语句也能引发控制流程的跳转，用于函数和方法的退出。</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p><code>slice</code> 和 <code>array</code> 区别</p><ul><li>创建方式不同：数组<code>var identifier [len]type</code> ；切片<code>var slice3 = []int{}</code></li><li><code>slice</code>的<code>array</code>实际上是数组的指针，所以作为函数参数传递时不同：数组传递的是数组的副本；<code>slice</code>传递的是数组的指针</li><li>长度是否固定：数组长度固定；切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大</li></ul></li><li><p>struct能不能比较？<a href="https://juejin.cn/post/6881912621616857102">https://juejin.cn/post/6881912621616857102</a> </p></li><li><p>slice，len，cap，共享，扩容</p></li><li><p>for 循环遍历 slice 有什么问题</p><ul><li>for rang A，是对A的值拷贝，问题代码：<pre><code class="go">func TestName(t *testing.T) {    s :=[]int{1,2,3,4}    m :=make(map[int]*int)    for k,v:=range s{        m[k]= &amp;v    }    for key, value := range m {        fmt.Printf("map[%v]=%v\n", key, *value)    }    fmt.Println(m)}</code></pre>  改正：<pre><code class="go">func TestName(t *testing.T) {    s := []int{1, 2, 3, 4}    m := make(map[int]*int)    for k, v := range s {        // 这里变动        n := v        m[k] = &amp;n    }    for key, value := range m {        fmt.Printf("map[%v]=%v\n", key, *value)    }    fmt.Println(m)}</code></pre></li></ul></li><li><p>请你说说golang的CSP思想</p></li><li><p>进程，协程，线程各自的优缺点</p></li></ol><h1 id="第-2-章-函数"><a href="#第-2-章-函数" class="headerlink" title="第 2 章 函数"></a>第 2 章 函数</h1><p>Go中的函数：</p><ul><li>函数是一种类型，函数类型变量可以向其他类型变量一样使用，可以作为其它函数的参数或返回值，也可以直接调用执行</li><li>函数支持多值返回</li><li>支持闭包</li><li>函数支持可变参数</li></ul><h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><h3 id="2-1-1-函数定义"><a href="#2-1-1-函数定义" class="headerlink" title="2.1.1 函数定义"></a>2.1.1 函数定义</h3><p>包括如下几个部分：</p><ul><li>函数声明关键字func</li><li>函数名</li><li>参数列表</li><li>返回列表和函数体</li></ul><p>函数的特点：</p><ul><li>函数可以没有输入参数，也可以没有返回值（默认返回0）</li><li>多个相邻的相同类型的参数可以使用简写模式</li><li>支持有名的返回值，参数名就相当于函数体内最外层的局部变量，命名返回值变量会被初始化成类型零值</li><li>不支持默认值参数</li><li>不支持函数重载</li><li>不支持函数嵌套，严格的说是不支持命名函数的嵌套定义，但支持嵌套匿名函数</li></ul><h3 id="2-1-2-多值返回"><a href="#2-1-2-多值返回" class="headerlink" title="2.1.2 多值返回"></a>2.1.2 多值返回</h3><p>习惯用法：如果多值返回之有错误类型，则一般将错误类型作为最后一个返回值</p><h3 id="2-1-3-实参到形参的传递"><a href="#2-1-3-实参到形参的传递" class="headerlink" title="2.1.3 实参到形参的传递"></a>2.1.3 实参到形参的传递</h3><p>Go函数实参到形参的传递永远是值拷贝。有时函数调用后实参指向的值发生了变化，那是因为参数传递的是指针值的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本，二者指向同一地址。</p><h3 id="2-1-4-不定参数"><a href="#2-1-4-不定参数" class="headerlink" title="2.1.4 不定参数"></a>2.1.4 不定参数</h3><p>Go支持不定数据的形式参数，声明使用<code>param ...type</code> .</p><p>不定参数特点：</p><ul><li>所有的不定参数类型必须是相同的</li><li>不定参数必须是函数的最后一个参数</li><li>不定参数在函数体内相当于切片，对切片的操作同样适合对不定参数的操作</li><li>切片可以作为参数传递给不定参数，切片名后要加上”…”</li><li>形参为不定参数的函数和形参为切片的函数类型不相同</li></ul><h2 id="2-2-函数签名和匿名函数"><a href="#2-2-函数签名和匿名函数" class="headerlink" title="2.2 函数签名和匿名函数"></a>2.2 函数签名和匿名函数</h2><h3 id="2-2-1-函数签名"><a href="#2-2-1-函数签名" class="headerlink" title="2.2.1 函数签名"></a>2.2.1 函数签名</h3><p>函数类型又叫函数签名，可以使用fmt.Printf的%T格式化参数打印函数的类型</p><h3 id="2-2-2-匿名函数"><a href="#2-2-2-匿名函数" class="headerlink" title="2.2.2 匿名函数"></a>2.2.2 匿名函数</h3><p>Go提供两种函数：有名函数和匿名函数</p><p>匿名函数可以直接复制给函数变量，可以当做实参，也可以作为返回值，还可以直接被调用。</p><h2 id="2-3-defer"><a href="#2-3-defer" class="headerlink" title="2.3 defer"></a>2.3 defer</h2><p>Go提供了defer关键字，可以注册多个延迟调用，这些调用以先进后出的顺序在函数返回前被执行。这有点类似于Java语言中异常处理的finaly语句。</p><p>defer常用语保证一些资源最终一定能够得到回收和释放。</p><p>特点：</p><ul><li>defer后面必须是函数或方法的调用，不能是语句</li><li>defer函数的实参在注册时通过值拷贝传递进去</li><li>defer语句必须先注册后才能执行</li></ul><p>优势：可以在一定程度上避免资源泄露</p><p>缺点：</p><ul><li>defer会推迟资源的释放</li><li>defer不要写在循环语句里面</li><li>defer最好不要对有名返回值参数进行操作</li></ul><h2 id="2-4-闭包"><a href="#2-4-闭包" class="headerlink" title="2.4 闭包"></a>2.4 闭包</h2><p>闭包是由函数及其相关引用环境组合而成的实体。</p><p><code>闭包 = 函数 + 引用环境</code></p><ol><li>闭包对闭包外的环境引入是直接引用，编译器检测到闭包会将闭包引用的外部变量分配到堆上</li><li>如果函数返回的闭包引用了该函数的局部变量（参数或函数内部变量）<ol><li>多次调用该函数返回的多个闭包所引用的外部变量是多个副本，原因是每次调用函数都会为局部变量分配内存</li><li>用一个闭包函数多次，如果该闭包修改了其引用的外部变量，则每一次调用该闭包对该外包变量都有影响，因为闭包函数共享外部引用</li></ol></li></ol><h3 id="2-4-2-闭包的价值"><a href="#2-4-2-闭包的价值" class="headerlink" title="2.4.2 闭包的价值"></a>2.4.2 闭包的价值</h3><p>对象是附有行为的数据，闭包是附有数据的行为。</p><h2 id="2-5-panic和recover"><a href="#2-5-panic和recover" class="headerlink" title="2.5 panic和recover"></a>2.5 panic和recover</h2><p>panic用来主动抛出错误</p><p>recover用来捕获panic抛出的错误</p><h3 id="2-5-1-基本概念"><a href="#2-5-1-基本概念" class="headerlink" title="2.5.1 基本概念"></a>2.5.1 基本概念</h3><p><img src="/images/go_core_programming/Untitled%2031.png" alt="Untitled"></p><p>引发panic的情况：</p><ul><li>程序主动调用panic函数</li><li>程序产生运行时错误，由运行时检测并抛出</li></ul><p>recover用来捕获panic，阻止panic继续向上传递</p><h3 id="2-5-2-使用场景"><a href="#2-5-2-使用场景" class="headerlink" title="2.5.2 使用场景"></a>2.5.2 使用场景</h3><ul><li>程序遇到了无法正常执行下去的错误，主动调用panic函数结束程序运行</li><li>在调试程序时，通过主动调用panic实现快速退出，panic打印出的堆栈能够更快的定位错误</li></ul><h2 id="2-6-错误处理"><a href="#2-6-错误处理" class="headerlink" title="2.6 错误处理"></a>2.6 错误处理</h2><h3 id="2-6-1-error"><a href="#2-6-1-error" class="headerlink" title="2.6.1 error"></a>2.6.1 error</h3><p>Go语言内置错误接口类型error</p><p>错误处理的最佳实践：</p><ul><li>在多个返回值的函数中，error通常作为函数最后一个返回值</li><li>如果一个函数返回error类型变量，则先用if语句处理<code>error != nil</code> 的异常场景，正常逻辑放到if语句块后面保持代码平坦</li><li>defer语句应该放到err判断的后面，不然有可能产生panic</li><li>在错误逐级向上传递的过程中，错误信息应该不断地丰富和完善，而不是简单抛出下层调用的错误</li></ul><pre><code class="go">func deferDemo() error {    err := createResource1()    if err != nil {        return ERR_CREATE_RESOURCE1_FAILED    }    defer func() {        if err != nil {            destroyResource1()        }    }()}</code></pre><h3 id="2-6-2-错误和异常"><a href="#2-6-2-错误和异常" class="headerlink" title="2.6.2 错误和异常"></a>2.6.2 错误和异常</h3><p>Go程序需要处理的错误类型：</p><ul><li>运行时错误：无法避免，可以recover这些panic</li><li>程序逻辑错误</li></ul><p>error和panic应该遵循如下原则：</p><ul><li>程序发生的错误导致程序不能容错继续执行，此时程序应该主动调用panic或由运行时抛出panic</li><li>程序虽然发生错误，但是程序能够容错继续执行，此时应该使用错误返回值的方式处理错误，或者在可能发生运行时错误的非关键分支上使用recover捕获panic</li></ul><pre><code class="go">func TestName(t *testing.T) {    height := []int{2,3,4,5,18,17,6}    defer func() {        if err := recover(); err != nil {            fmt.Println(err)        }    }()    print(height[10])}</code></pre><h2 id="2-7-底层实现"><a href="#2-7-底层实现" class="headerlink" title="2.7 底层实现"></a>2.7 底层实现</h2><h1 id="第-3-章-类型系统"><a href="#第-3-章-类型系统" class="headerlink" title="第 3 章 类型系统"></a>第 3 章 类型系统</h1><h2 id="3-1-类型简介"><a href="#3-1-类型简介" class="headerlink" title="3.1 类型简介"></a>3.1 类型简介</h2><h3 id="3-1-1-命名类型和未命名类型"><a href="#3-1-1-命名类型和未命名类型" class="headerlink" title="3.1.1 命名类型和未命名类型"></a>3.1.1 命名类型和未命名类型</h3><p>命名类型：可以通过标识符来表示（3.2节详细介绍）</p><p>未命名类型：一个类型由预声明类型、关键字和操作符组合而成，又称为类型字面量。例如：数组（array）、切片（slice）、字典（map）、通道（channel）、指针（pointer）、函数字面量（function）、结构（struct）和接口（interface）都属于类型字面量</p><h3 id="3-1-2-底层类型"><a href="#3-1-2-底层类型" class="headerlink" title="3.1.2 底层类型"></a>3.1.2 底层类型</h3><p>所有“类型”都有一个underlying type（底层类型）。底层类型的规则如下：</p><ul><li>预声明类型（Pre-declared types）和类型字面量（type literals）的底层类型是他们自身</li><li>自定义类型type newtype oldtype中的newtype的底层是逐层递归向下查找的，知道查到的oldtype是预声明类型（Pre-declared types）或类型字面量（type literals）为止。</li></ul><h3 id="3-1-3-类型相同和类型赋值"><a href="#3-1-3-类型相同和类型赋值" class="headerlink" title="3.1.3 类型相同和类型赋值"></a>3.1.3 类型相同和类型赋值</h3><p><strong>类型相同</strong></p><p>Go是强类型的语言，编译器在编译时会进行严格的类型校验。两个命名类型是否相同的判断：</p><ul><li>两个命名类型相同的条件是两个类型声明的语句完全相同</li><li>命名类型和未命令类型永远不相同</li><li>两个未命名类型相同的条件是他们的类型声明字面量的结构相同，并且内部元素的类型相同</li><li>通过类型别名语句声明的两个类型相同</li></ul><p><strong>类型可直接赋值</strong></p><p>类型为T1的变量a可以赋值给类型为T2的变量b，称为类型T1可以赋值给类型T2，伪代码：</p><pre><code class="go">var b T2 = a</code></pre><p>a可以赋值给变量b必须要满足如下条件中的一个：</p><ul><li>T1和T2的类型相同</li><li>T1和T2具有相同的底层类型，并且T1和T2里面至少有一个是未命名类型</li><li>T2是接口类型，T1是具体类型，T1的方法集是T2方法集的超级</li><li>T1和T2都是通道类型，他们拥有相同的元素类型，并且T1和T2至少有一个是未命名类型</li><li>a是预声明标识符nil，T2是pointer、function、slice、map、channel、interface类型中的一个</li><li>a是一个字面常量值，可以用来表示类型T的值</li></ul><h3 id="3-1-4-类型强制转换"><a href="#3-1-4-类型强制转换" class="headerlink" title="3.1.4 类型强制转换"></a>3.1.4 类型强制转换</h3><p>由于Go是强类型的语言，如果不满足自动转换的条件，则必须进行强制类型转换。</p><p>非常量类型的变量x可以强制转化并传递给类型T，需要满足如下任一条件：</p><ul><li>x可以直接赋值给T类型变量</li><li>x类型和T具有相同的底层类型</li><li>x的类型和T都是未命名的指针类型，并且指针指向的类型具有相同的底层类型</li><li>x的类型和T都是整型或者都是浮点型</li><li>x的类型和T都是复数类型</li><li>x是整数值或[]byte类型的值，T是string类型</li><li>x是一个字符串，T是[]byte或[]rune</li></ul><h2 id="3-2-类型方法"><a href="#3-2-类型方法" class="headerlink" title="3.2 类型方法"></a>3.2 类型方法</h2><h3 id="3-2-1-自定义类型"><a href="#3-2-1-自定义类型" class="headerlink" title="3.2.1 自定义类型"></a>3.2.1 自定义类型</h3><p>自定义类型都是命名类型</p><p><img src="/images/go_core_programming/Untitled%2032.png" alt="Untitled"></p><p>自定义struct类型</p><h3 id="3-2-2-方法"><a href="#3-2-2-方法" class="headerlink" title="3.2.2 方法"></a>3.2.2 方法</h3><p><img src="/images/go_core_programming/Untitled%2033.png" alt="Untitled"></p><p>类型方法有如下特点：</p><ul><li>可以为命名类型增加方法（除了接口），非命名类型不能自定义方法</li><li>为类型增加方法有一个限制，就是方法的定义必须和类型的定义在同一个包中</li><li>方法的命名空间可见性和变量一样，大写开头的方法可也在包外被访问，否则只能在包内可见</li><li>使用type定义的自定义类型是一个新类型，新类型不能调用原有类型的方法，但是底层类型支持的运算可以被新类型继承</li></ul><p><img src="/images/go_core_programming/Untitled%2034.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2035.png" alt="Untitled"></p><h2 id="3-3-方法调用"><a href="#3-3-方法调用" class="headerlink" title="3.3 方法调用"></a>3.3 方法调用</h2><h3 id="3-3-1-一般调用"><a href="#3-3-1-一般调用" class="headerlink" title="3.3.1 一般调用"></a>3.3.1 一般调用</h3><p><img src="/images/go_core_programming/Untitled%2036.png" alt="Untitled"></p><h3 id="3-3-2-方法值"><a href="#3-3-2-方法值" class="headerlink" title="3.3.2 方法值"></a>3.3.2 方法值</h3><p><img src="/images/go_core_programming/Untitled%2037.png" alt="Untitled"></p><h3 id="3-3-3-方法表达式"><a href="#3-3-3-方法表达式" class="headerlink" title="3.3.3 方法表达式"></a>3.3.3 方法表达式</h3><p>方法表达式相当于提供一种语法将类型方法调用显示第转换为函数调用，接受者必须显示地传递进去。</p><h3 id="3-3-4-方法集"><a href="#3-3-4-方法集" class="headerlink" title="3.3.4 方法集"></a>3.3.4 方法集</h3><p>命名类型方法接受者有两种类型，一个是值类型，另一个是指针类型，这个和函数是一样的，前者的形参是值类型，后者的形参是指针类型。</p><p>无论接受者是什么类型，方法和函数的实参传递都是值拷贝，如果接受者是值类型，则传递的是值的副本；如果接受者是指针类型，则传递的是指针的副本</p><h3 id="3-3-5-值调用和表达式调用的方法集"><a href="#3-3-5-值调用和表达式调用的方法集" class="headerlink" title="3.3.5 值调用和表达式调用的方法集"></a>3.3.5 值调用和表达式调用的方法集</h3><h2 id="3-4-组合和方法集"><a href="#3-4-组合和方法集" class="headerlink" title="3.4 组合和方法集"></a>3.4 组合和方法集</h2><p>结构类型为Go提供了强大的类型扩展，主要体现在两个方面：</p><ul><li>struct可以嵌入任意其他类型的字段</li><li>struct可以嵌套自身的指针类型的字段</li></ul><h3 id="3-4-1-组合"><a href="#3-4-1-组合" class="headerlink" title="3.4.1 组合"></a>3.4.1 组合</h3><p>因为Go没有继承的语义，结构和字段之间是“has a”的关系而不是“is a”的关系，没有父子概念，仅仅是整体和局部的概念，所以后续统称这种嵌套的结构和字段的关系为组合</p><h3 id="3-4-2-组合的方法集"><a href="#3-4-2-组合的方法集" class="headerlink" title="3.4.2 组合的方法集"></a>3.4.2 组合的方法集</h3><h2 id="3-5-函数类型"><a href="#3-5-函数类型" class="headerlink" title="3.5 函数类型"></a>3.5 函数类型</h2><h1 id="第-4-章-接口（未看）"><a href="#第-4-章-接口（未看）" class="headerlink" title="第 4 章 接口（未看）"></a>第 4 章 接口（未看）</h1><h1 id="第-5-章-并发"><a href="#第-5-章-并发" class="headerlink" title="第 5 章 并发"></a>第 5 章 并发</h1><h2 id="5-1-并发基础"><a href="#5-1-并发基础" class="headerlink" title="5.1 并发基础"></a>5.1 并发基础</h2><h3 id="5-1-1-并发和并行"><a href="#5-1-1-并发和并行" class="headerlink" title="5.1.1 并发和并行"></a>5.1.1 并发和并行</h3><ol><li>并行就是在任一粒度的时间内都具备同时执行的能力：例如多机</li><li>并发是在规定的时间内多个请求都得到执行和处理，强调的是给外界的感受，实际上内部可能是分时操作的</li></ol><h3 id="5-1-2-goroutine"><a href="#5-1-2-goroutine" class="headerlink" title="5.1.2 goroutine"></a>5.1.2 goroutine</h3><p>Go语言的并发执行体称为goroutine，通过go关键字来启动一个goroutine。</p><p>goroutine特性：</p><ul><li>go的执行是非阻塞的，不会等待</li><li>go后面的函数的返回值会被忽略</li><li>调度器不能保证多个goroutine的执行次序</li><li>没有父子goroutine的概念，所有goroutne是平等地被调用和执行的</li><li>Go程序在执行时会单独为main函数创建一个goroutine，遇到其他go关键字时再去创建其他的goroutinue</li><li>Go没有暴露goroutine id给用户，所以不能在一个goroutine里面显式地操作另一个goroutine，不过runtime包提供了一些函数访问和设置goroutine的相关信息</li></ul><ol><li>func GOMAXPROCS</li></ol><p>设置或查询可以并发执行的goroutine数目</p><pre><code class="go">package goroutine_testimport (    "runtime"    "testing")func TestName(t *testing.T) {    // 获取GOMAXPROCS    println("GOMAXPROCS=",runtime.GOMAXPROCS(0))    // 设置GOMAXPROCS    runtime.GOMAXPROCS(2)    // 获取GOMAXPROCS    println("GOMAXPROCS=",runtime.GOMAXPROCS(0))}</code></pre><ol><li>func Goexit</li></ol><p>结束当前goroutinue的运行。Goexit不会产生panic。</p><ol><li>fun Gosched</li></ol><p>放弃当前调度执行机会，将当前goroutinue放到队列中等待下次被调度</p><h3 id="5-1-3-chan"><a href="#5-1-3-chan" class="headerlink" title="5.1.3 chan"></a>5.1.3 chan</h3><ol><li>chan是Go语言里面的一个关键字，是channel的简写，通道。通道是Go通过通信来共享内容的载体。</li><li>通道类型：<ul><li><p>有缓冲的通道：主要用于通信</p></li><li><p>无缓冲的通道：既可以用于通信，也可以用于两个goroutinue的同步</p><p><img src="/images/go_core_programming/Untitled%2038.png" alt="Untitled"></p><pre><code class="go">func TestName(t *testing.T) {  println("NumGoroutinue=", runtime.NumGoroutine())  c := make(chan struct{})  ci := make(chan int, 100)  go func(i chan struct{}, j chan int) {      for i := 0; i &lt; 10; i++ {          ci &lt;- i      }      close(ci)      // 写通道      c &lt;- struct{}{}  }(c, ci)  // NumGoroutinue可以返回当前程序的goroutinue数目  println("NumGoroutinue=", runtime.NumGoroutine())  // 读通道c，通过通道进行同步等待  &lt;-c  // 此时ci通道已经关闭，匿名函数启动的goroutinue已经退出  println("NumGoroutinue=", runtime.NumGoroutine())  for v := range ci {      println(v)  }}</code></pre></li></ul></li><li>操作不同状态的chan会引发三种行为<ul><li>panic<ul><li>向已经关闭的通道写数据会导致panic。由写入者关闭通道能最大程度地避免向已经关闭的通道写数据而导致panic</li><li>重复关闭的通道会导致panic</li></ul></li><li>阻塞<ul><li>向未初始化的通道写数据或读数据都会导致当前goroutine的永久阻塞</li><li>向缓冲区已满的通道写入数据会导致goroutinue阻塞</li><li>通道中没有数据，读取该通道会导致goroutinue阻塞</li></ul></li><li>非阻塞<ul><li>读者已经关闭的通道不会引发阻塞而是立即返回通道元素类型的零值，可以使用comma，ok语法判断通道是否已经关闭</li><li>向有缓冲且没有满的通道读/写不会引发阻塞</li></ul></li></ul></li></ol><h3 id="5-1-4-WaitGroup"><a href="#5-1-4-WaitGroup" class="headerlink" title="5.1.4 WaitGroup"></a>5.1.4 WaitGroup</h3><p>sync包提供了多个goroutine同步的机制，主要是通过WaitGroup实现的。</p><h3 id="5-1-5-select"><a href="#5-1-5-select" class="headerlink" title="5.1.5 select"></a>5.1.5 select</h3><p>select用于多路监听多个通道</p><ul><li>当监听的通道没有状态是可读或可写的，select是阻塞的</li><li>监听的通道中有一个状态是可读或可写的，则select就不会阻塞，而是进入处理就绪通道的分支流程</li><li>如果监听的通道有多个可读或可写的状态，则select随机选取一个处理</li></ul><pre><code class="go">import "testing"func TestName(t *testing.T) {    ch := make(chan int, 2)    go func(chan int) {        for {            select {            case ch &lt;- 0:            case ch &lt;- 1:            }        }    }(ch)    for i := 0; i &lt; 10; i++ {        println(&lt;-ch)    }}</code></pre><h3 id="5-1-6-扇入（Fan-in）和扇出（Fan-out）"><a href="#5-1-6-扇入（Fan-in）和扇出（Fan-out）" class="headerlink" title="5.1.6 扇入（Fan in）和扇出（Fan out）"></a>5.1.6 扇入（Fan in）和扇出（Fan out）</h3><p>扇入：将多路通道聚合到一条通道中处理，Go最简单的扇入就是使用select聚合多条通道服务</p><p>扇出：将一条通道发散到多条通道中处理，Go语言里面具体实现就是使用go关键字启动多个goroutine并发处理 </p><pre><code class="go">import (    "fmt"    "sync"    "testing")var wg sync.WaitGroupfunc TestWaitGroup(t *testing.T) {    for i := 0; i &lt; 10; i++ {        wg.Add(1)        go func(i int) {            defer wg.Done()            fmt.Printf("go func: %d\n", i)        }(i)    }    wg.Wait()    println("success!")}</code></pre><h3 id="5-1-7-通知退出机制"><a href="#5-1-7-通知退出机制" class="headerlink" title="5.1.7 通知退出机制"></a>5.1.7 通知退出机制</h3><p>读取已经关闭的通道不会引起阻塞，也不会导致panic，而是立即返回该通道存储类型的零值。</p><p>关闭select监听的某个通道能使select立即感知这种通知，然后进行相应的处理，这就是所谓的退出通知机制。</p><p>下面通过一个随机数生成器的示例掩饰退出通知机制，下游的消费者不需要随机数时显式地通知生产者停止生产：</p><pre><code class="go">import (    "fmt"    "math/rand"    "runtime"    "testing")func GenerateIntA(done chan struct{}) chan int {    ch := make(chan int)    go func() {    Lable:        for {            select {            case ch &lt;- rand.Int():            case &lt;-done:                break Lable            }        }        close(ch)    }()    return ch}func TestNotiExit(t *testing.T) {    println("NumGoroutine=", runtime.NumGoroutine())    done := make(chan struct{})    ch := GenerateIntA(done)    println("NumGoroutine=", runtime.NumGoroutine())    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    close(done)    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    println("NumGoroutine=", runtime.NumGoroutine())}</code></pre><h2 id="5-2-并发范式"><a href="#5-2-并发范式" class="headerlink" title="5.2 并发范式"></a>5.2 并发范式</h2><h3 id="5-2-1-生成器"><a href="#5-2-1-生成器" class="headerlink" title="5.2.1 生成器"></a>5.2.1 生成器</h3><ol><li>最简单的带缓冲的生成器</li></ol><pre><code class="go">import (    "fmt"    "math/rand"    "testing")func GenerateInt() chan int {    ch := make(chan int, 3)    go func() {        for {            ch &lt;- rand.Int()        }    }()    return ch}func TestGenerateInt(t *testing.T) {    ch := GenerateInt()    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)}</code></pre><ol><li>多个goroutinue增强型生成器</li></ol><p><img src="/images/go_core_programming/Untitled%2039.png" alt="Untitled"></p><ol><li>有时希望生成器能够自动退出，可以借助Go通道的退出通知机制实现，例如：</li></ol><p><img src="/images/go_core_programming/Untitled%2040.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2041.png" alt="Untitled"></p><ol><li>融合并发、缓冲、退出通知等多重特性的生成器</li></ol><pre><code class="go">package genericimport (    "fmt"    "math/rand"    "testing")func GenerateIntA(done chan struct{}) chan int {    fmt.Println("GenerateIntA")    ch := make(chan int, 5)    go func() {    Lable:        for {            select {            case ch &lt;- rand.Int():            case &lt;-done:                break Lable            }        }        close(ch)    }()    return ch}func GenerateIntB(done chan struct{}) chan int {    fmt.Println("GenerateIntB")    ch := make(chan int, 5)    go func() {    Lable:        for {            select {            case ch &lt;- rand.Int():            case &lt;-done:                break Lable            }        }        close(ch)    }()    return ch}func GenerateInt(done chan struct{}) chan int {    ch := make(chan int)    send := make(chan struct{})    go func() {    Lable:        for {            select {            case ch &lt;- &lt;-GenerateIntA(send):            case ch &lt;- &lt;-GenerateIntB(send):            case &lt;-done:                send &lt;- struct{}{}                send &lt;- struct{}{}                break Lable            }        }        close(ch)    }()    return ch}func Test(t *testing.T)  {    done := make(chan struct{})    ch := GenerateInt(done)    for i := 0; i &lt; 10; i++ {        fmt.Println(&lt;-ch)    }    done &lt;- struct{}{}    fmt.Println("stop generate")}</code></pre><h3 id="5-2-2-管道"><a href="#5-2-2-管道" class="headerlink" title="5.2.2 管道"></a>5.2.2 管道</h3><p>通道可以分为两个方向，一个是读另一个是写，加入一个函数的输入参数和输出参数都是相同的chan类型，则该函数可以调用自己，最终形成一个调用链。这很像UNIX系统的管道，是一个有类型的管道</p><h3 id="5-2-3-每个请求一个goroutine"><a href="#5-2-3-每个请求一个goroutine" class="headerlink" title="5.2.3 每个请求一个goroutine"></a>5.2.3 每个请求一个goroutine</h3><p>来一个请求或任务就启动一个goroutine去处理，典型的就是Go中的HTTP server服务。</p><h3 id="5-2-4-固定worker工作池"><a href="#5-2-4-固定worker工作池" class="headerlink" title="5.2.4 固定worker工作池"></a>5.2.4 固定worker工作池</h3><p>程序中除了主要的main goroutine，还开启了如下几类goroutine：</p><ul><li>初始化任务的goroutine</li><li>分发任务的goroutine</li><li>等待所有worker结束通知，然后关闭结果通道的goroutine</li></ul><p>程序采用三个通道，分别是：</p><ul><li>传递task任务的通道</li><li>传递task结果的通道</li><li>接收worker处理完任务后所发送通知的通道</li></ul><p>计算多个整数的和样例代码：</p><pre><code class="go">package mainimport (    "fmt"    "math/rand"    "time")// 工作池的goroutine数目const NUMBER = 10// 工作任务type task struct {    // 存放数据    data int    // 任务结果    result chan&lt;- int}// 任务处理：计算begin和end的和// 执行结果写入结果chan resultfunc (t *task) do() {    // 模拟计算耗时    r := rand.Intn(1000)    fmt.Println("Sleep:", r, "ms")    time.Sleep(time.Duration(r) * time.Millisecond)    // 模拟任务结果就是任务数据    t.result &lt;- t.data}func main() {    workers := NUMBER    taskChan := make(chan task, 10)    resultChan := make(chan int, 10)    done := make(chan struct{}, 10)    // 初始化task的goroutine    go InitTask(taskChan, resultChan, 100)    // 分发任务到NUMBER个goroutine池    DistributeTask(taskChan, workers, done)    // 获取各个goroutine处理完任务的通知并关闭结果通道    go CloseResult(done, resultChan, workers)    // 通过结果通道获取结果并汇总    sum := ProcessResult(resultChan)    fmt.Println("sum=", sum)}// 初始化待处理task chanfunc InitTask(taskChan chan&lt;- task, r chan int, p int) {    for i := 0; i &lt;= p; i++ {        taskChan &lt;- task{            data:   i,            result: r,        }    }    close(taskChan)}// 读取task chan并分发到worker goroutine处理，总的数量是workersfunc DistributeTask(taskChan &lt;-chan task, works int, done chan struct{}) {    for i := 0; i &lt; works; i++ {        go ProcessTask(taskChan, done)    }}// 工作goroutine处理具体工作，并将处理结果发送到结果chanfunc ProcessTask(taskChan &lt;-chan task, done chan struct{}) {    for t := range taskChan {        t.do()    }    done &lt;- struct{}{}}// 通过done channel同步等待所有工作goroutine的结束，然后关闭结果chanfunc CloseResult(done chan struct{}, resultChan chan int, workers int) {    for i := 0; i &lt; workers; i++ {        &lt;-done    }    close(done)    close(resultChan)}// 读取结果通道，汇总结果func ProcessResult(resultChan chan int) int {    sum := 0    for r := range resultChan {        sum += r    }    return sum}</code></pre><p><img src="/images/go_core_programming/Untitled%2042.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2043.png" alt="Untitled"></p><h3 id="5-2-5-future模式"><a href="#5-2-5-future模式" class="headerlink" title="5.2.5 future模式"></a>5.2.5 future模式</h3><p>用处：子调用相互之间没有依赖，如果串行调用则耗时会很长，此时可以使用Go并发编程中的future模式</p><p>工作原理：</p><ol><li>使用chan作为函数参数</li><li>启动goroutine调用安徽省农户</li><li>通过chan传递如参数</li><li>做其他可以并行处理的事情</li><li>通过chan异步获取结果</li></ol><pre><code class="go">package mainimport (    "fmt"    "time")// 一个查询结构体// 这里的sql和result是一个简单的抽象，具体的应用可能是更复杂的数据类型type query struct {    // 参数Channel    sql chan string    // 结果Channel    result chan string}// 执行Queryfunc execQuery(q query) {    // 启动协程    go func() {        // 获取输入        sql := &lt;-q.sql        // 访问数据库        // 输出结果通道        q.result &lt;- "result from " + sql    }()}func main() {    // 初始化Query    q := query{make(chan string, 1), make(chan string, 1)}    // 执行Query，注意执行的时候无需准备参数    go execQuery(q)    // 发送参数    q.sql &lt;- "select * from table"    // 做其他事情    time.Sleep(1 * time.Second)    // 获取结果    fmt.Println(&lt;-q.result)}</code></pre><p><img src="/images/go_core_programming/Untitled%2044.png" alt="Untitled"></p><h2 id="5-3-context标准库"><a href="#5-3-context标准库" class="headerlink" title="5.3 context标准库"></a>5.3 context标准库</h2><p>Go中的goroutine之间没有父与子的关系，没有所谓的子进程退出后的通知机制，goroutine之间平行地被调度，多个goroutine如何协作工作设计通信、同步、通知和退出四个方面</p><ul><li>通信：chan通道是goroutine之间通信的基础（通信指程序的数据通道）</li><li>同步：不带缓冲的chan提供了一个天然的同步等待机制；sync.WaitGroup也为多个goroutine协同工作提供一种同步等待机制</li><li>通知：这个通知和上面通信的数据不一样，通知不是业务数据，而是管理、控制流数据。在输入端绑定两个chan，一个用于业务流数据，另一个用于异常通知数据，然后使用select收敛进行处理</li><li>退出：借助通道和select的广播机制实现退出</li></ul><h3 id="5-3-1-context的设计目的"><a href="#5-3-1-context的设计目的" class="headerlink" title="5.3.1 context的设计目的"></a>5.3.1 context的设计目的</h3><ul><li>退出通知机制：通知可以传递给整个goroutine调用树上的每一个goroutine</li><li>数据传递：数据可以传递给整个goroutine调用树上的每一个goroutine</li></ul><h3 id="5-3-2-基本数据结构"><a href="#5-3-2-基本数据结构" class="headerlink" title="5.3.2 基本数据结构"></a>5.3.2 基本数据结构</h3><p>context工作机制：第一个创建 Context goroutine被称为 root 节点。 root 节点负责创建一个实现context接口的具体对象，并将该对象作为参数传递到其新拉起的goroutine，下游的 goroutine 继续封装该对象，再传递到更下游的goroutine，Context 对象在传递的过程中最终形成一个树状的数据结构，这样通过位于 root 节点（树的根节点） Context 对象就能遍历整个 Context 对象树，通知和消息就可以通过 root 节点传递出去，实现了上游 goroutine 下游 goroutine 的消息传递。</p><p><strong>Context接口</strong></p><p>Context作为参数传递</p><p><img src="/images/go_core_programming/Untitled%2045.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2046.png" alt="Untitled"></p><p><strong>canceler接口</strong></p><p>conceler规定了取消通知的Context具体类型需要实现的接口</p><p><img src="/images/go_core_programming/Untitled%2047.png" alt="Untitled"></p><p><strong>empty Context结构</strong></p><p>实现了Context接口但不具备任何功能，其存在的目的是作为Context对象树的根（root节点）</p><p><strong>cancelCtx</strong></p><p>cancelCtx是一个实现了Context耳机口的具体类型，同时实现了conceler接口</p><p><strong>timerCtx</strong></p><p>timerCtx是一个实现了Context接口的具体类型，内部封装cancelCtx类型实例，同时有一个deadlinebianl,yonglaishixian定时退出通知</p><p><strong>valueCtx</strong></p><p>valueCtx是一个实现了Context接口的具体类型，内部封装了Context接口类型，同时封装了一个k/v的存储遍历，valueCtx可以用来传递通知信息</p><p><img src="/images/go_core_programming/Untitled%2048.png" alt="Untitled"></p><h3 id="5-3-3-API函数"><a href="#5-3-3-API函数" class="headerlink" title="5.3.3 API函数"></a>5.3.3 API函数</h3><p>以下两个函数是构造Context取消树的根节点对象，根节点对象用作后续With包装函数的实参：</p><ul><li>func Background() Context</li><li>func TODO() Context</li></ul><h3 id="5-3-6-使用Context传递数据的争议"><a href="#5-3-6-使用Context传递数据的争议" class="headerlink" title="5.3.6 使用Context传递数据的争议"></a>5.3.6 使用Context传递数据的争议</h3><p>使用context传递数据的坏处：</p><ul><li>传递的都是interface{}类型的值，编译器不能进行严格的类型校验</li><li>从interface{}到具体类型需要使用类型断言和接口查询，有一定的运行期开销和性能损失</li><li>值在传递过程中有可能被后续的服务覆盖且不易被发现</li><li>传递信息不简明。较晦涩；不能通过代码或文档一眼看到传递的是什么，不利于后续维护</li></ul><p>context应该传递什么数据：</p><ul><li>日志信息</li><li>调低是信息</li><li>不影响业务主逻辑的可选数据</li></ul><h2 id="5-4-并发模型"><a href="#5-4-并发模型" class="headerlink" title="5.4 并发模型"></a>5.4 并发模型</h2><h3 id="5-4-1-CSP简介"><a href="#5-4-1-CSP简介" class="headerlink" title="5.4.1 CSP简介"></a>5.4.1 CSP简介</h3><p>CSP基本思想：将并发系统抽象为Channel和Process两部分，Channel用来传递消息，Process用于执行，Channel和Process之间相互独立，没有从属关系，消息的发送和接收有严格的时序限制。</p><p>Go中Channel就是通道，Process就是goroutine</p><h3 id="5-4-2-调度模型"><a href="#5-4-2-调度模型" class="headerlink" title="5.4.2 调度模型"></a>5.4.2 调度模型</h3><p>协程是一种用户态的轻量级线程，写成的调度完全由用户态程序控制，协程拥有自己的寄存器上下文和栈。</p><p>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候恢复先前保存的寄存器上下文和栈，每个内核线程可以对应多个用户协程，当一个协程执行体阻塞了，调度器会调度另一个携程执行，最大效率地利用操作系统分给系统线程的时间片。</p><p>好处：</p><ul><li>控制了系统线程数，保证每个线程的运行时间片充足</li><li>调度层能进行用户态的切换，不会导致单个协程阻塞整个程序的情况，尽量减少上下文切换，提升运行效率</li></ul><p>由此可见，协程是一种非常高效、理想的执行模型。Go的并发执行模型就是一种变种的协程模型。</p><h3 id="5-4-3-并发和调度"><a href="#5-4-3-并发和调度" class="headerlink" title="5.4.3 并发和调度"></a>5.4.3 并发和调度</h3><p>goroutine好处：</p><ul><li>goroutine可以在用户空间调度，避免了内核态和用户态的切换导致的成本</li><li>goroutine是语言原生支持的，提供了非常简洁的语法，屏蔽了大部分复杂底层实现</li><li>goroutine更小的占空间允许用户创建成千上万的实例</li></ul><p>goroutinue调度模型：</p><ol><li>实体G（Goroutine）</li></ol><p>G是Go运行时对goroutine的抽象描述，G中存放并发执行的代码入口地址、上下文、运行环境（关联的P和M）、运行栈等执行相关的元信息</p><ol><li>实体M（Machine）</li></ol><p>M代表OS内核线程，是操作系统层面调度和执行的实体。M仅负责执行，M不停地被唤醒或创建，然后执行。M启动时进入的是运行时的管理代码，有这段代码获取G和P资源，然后执行调度。另外Go</p><p>语言运行时会单独创建一个监控线程，负责对程序的内存、调度等信息进行监控和控制</p><ol><li>实体P（Processor）</li></ol><p>P代表M运行G所需的资源，是对资源的一种抽象和管理，P不是一段代码实体，而是一个管理的数据结构，P主要是降低M管理调度G的复杂性，增加一个简洁的控制层数据结构。</p><p><img src="/images/go_core_programming/Untitled%2049.png" alt="Untitled"></p><p><strong>m0和g0</strong></p><p>m0和g0是启动程序后的主线程，这个m对应的信息会存放在全局变量m0种，m0负责执行初始化操作和启动第一个g，之后m0就和其他m一样了。</p><p><img src="/images/go_core_programming/Untitled%2050.png" alt="Untitled"></p><h1 id="第-7-章-语言陷阱"><a href="#第-7-章-语言陷阱" class="headerlink" title="第 7 章 语言陷阱"></a>第 7 章 语言陷阱</h1><h2 id="7-1-多值赋值和短变量声明"><a href="#7-1-多值赋值和短变量声明" class="headerlink" title="7.1 多值赋值和短变量声明"></a>7.1 多值赋值和短变量声明</h2><h3 id="7-1-1-多值赋值"><a href="#7-1-1-多值赋值" class="headerlink" title="7.1.1 多值赋值"></a>7.1.1 多值赋值</h3><p>非法：</p><p><img src="/images/go_core_programming/Untitled%2051.png" alt="Untitled"></p><p>多值赋值语义：</p><ul><li>对左侧操作数中的表达式、索引值进行计算和确定，首先确定左侧的操作数的地址，然后对右侧的赋值表达式进行计算，如果发现右侧的表达式计算引用了左侧的变量，则创建临时变量进行值拷贝，最后完成计算</li><li>从左到右的顺序依次赋值</li></ul><p>示例：</p><pre><code class="go">import (    "fmt"    "testing")func Test(t *testing.T) {    x := []int{1, 2, 3}    i := 0    i, x[i] = 1, 2    fmt.Println(i, x) // 1 [2 2 3]    x = []int{1, 2, 3}    i = 0    x[i], i = 2, 1    fmt.Println(i, x) // 1 [2 2 3]    x = []int{1, 2, 3}    i = 0    x[i], i = 2, x[i] // set tmp=x[0],x[0]=2,i=tmp ==&gt; i=1    fmt.Println(i, x) // 1 [2 2 3]    x[0], x[0] = 1, 2    fmt.Println(x[0]) // 2}</code></pre><h3 id="7-1-2-短变量的声明和赋值"><a href="#7-1-2-短变量的声明和赋值" class="headerlink" title="7.1.2 短变量的声明和赋值"></a>7.1.2 短变量的声明和赋值</h3><p>约定：</p><ul><li>使用“:=”操作符，变量的定义和初始化同时完成</li><li>变量名后不要跟任何类型名，Go编译器完全靠右边的值进行推导</li><li>支持多值短变量声明赋值</li><li>只能用在函数和类型方法的内部</li></ul><p><img src="/images/go_core_programming/Untitled%2052.png" alt="Untitled"></p><p><img src="/images/go_core_programming/Untitled%2053.png" alt="Untitled"></p><h2 id="7-2-range复用临时变量"><a href="#7-2-range复用临时变量" class="headerlink" title="7.2 range复用临时变量"></a>7.2 range复用临时变量</h2><p><img src="/images/go_core_programming/Untitled%2054.png" alt="Untitled"></p><p>结果打印的都是9，原因：</p><ul><li>for range下的迭代变量i的值是共用的</li><li>main函数所在的goiroutinue和后续启动的goroutines存在竞争关系</li></ul><p>正确写法：</p><p><img src="/images/go_core_programming/Untitled%2055.png" alt="Untitled"></p><h2 id="7-3-defer陷阱"><a href="#7-3-defer陷阱" class="headerlink" title="7.3 defer陷阱"></a>7.3 defer陷阱</h2><p>对带defer的函数返回整体上有三个步骤</p><ul><li>执行return的值拷贝，将return语句返回的值复制到函数返回值栈区（如果只有一个return，不带任何变量或值，则此步骤不做任何动作）</li><li>执行defer语句，多个defer按照FILO顺序执行</li><li>执行调整RET指令</li></ul><h2 id="7-4-切片困惑"><a href="#7-4-切片困惑" class="headerlink" title="7.4 切片困惑"></a>7.4 切片困惑</h2><h3 id="7-4-1-数组"><a href="#7-4-1-数组" class="headerlink" title="7.4.1 数组"></a>7.4.1 数组</h3><p>Go的数组是有固定个相同类型元素的数据结构，底层采用连续的内存空间存放，数组一旦声明后大小就不可改变了。</p><p>Go中的数组是一种基本类型。数组的类型不仅包括其元素类型，也包括其大小，[2]int和[5]int是两个完全不同的数组类型</p><p><img src="/images/go_core_programming/Untitled%2056.png" alt="Untitled"></p><p>数组名无论作为函数实参还是作为struct嵌入字段，或者数组之间的直接赋值都是值拷贝</p><h3 id="7-4-2-切片"><a href="#7-4-2-切片" class="headerlink" title="7.4.2 切片"></a>7.4.2 切片</h3><p><strong>切片创建</strong></p><ol><li>通过数组创建</li></ol><p>array[b:e]创建一个包括e-b个元素的切片，包含b，不包含e</p><ol><li>make</li></ol><p>make([]T, len, cap)中的T是切片元素类型，len是长度，cap是底层数组的容量。cap是可选参数</p><ol><li>直接声明</li></ol><p><img src="/images/go_core_programming/Untitled%2057.png" alt="Untitled"></p><p>切片数据结构</p><p><img src="/images/go_core_programming/Untitled%2058.png" alt="Untitled"></p><p>多个切片共享一个底层数组，其中一个切片的append操作可能引发如下两种情况：</p><ul><li>append追加的元素没有超过底层数组的容量，此种append操作会直接操作共享的底层数组，如果其他切片有引用数组被覆盖的原色，则会导致其他切片的值也会隐式地发生变化</li><li>append追加的元素加上原来的元素如果超出底层数组的容量，则此种append操作会重新申请新数组，并将原来数组的值复制到新数组</li></ul><p>由于有这种二义性，所以在使用切片过程中应该尽量避免多个切面共享底层数组，可以使用copy进行显式的复制</p><h2 id="7-5-值、指针和引用"><a href="#7-5-值、指针和引用" class="headerlink" title="7.5 值、指针和引用"></a>7.5 值、指针和引用</h2><h3 id="7-5-1-传值还是传引用"><a href="#7-5-1-传值还是传引用" class="headerlink" title="7.5.1 传值还是传引用"></a>7.5.1 传值还是传引用</h3><p>Go只有一种参数传递规则：值拷贝，含义：</p><ul><li>函数参数传递时使用的是值拷贝</li><li>实例赋值给接口变量，接口对实例的引用是值拷贝</li></ul><p>有时在明明是值拷贝的地方结果却修改了变量的内容，有以下两种情况：</p><ul><li>直接传递的是指针，指针传递同样是值拷贝，但指针和指针副本的值指向的地址是同一地方，所以能修改实参值</li><li>参数是负荷数据类型，这些复合数据类型内部有指针类型的元素，此时参数的值bi拷贝并不影响指针的指向</li></ul><h3 id="7-5-2-函数名的意义"><a href="#7-5-2-函数名的意义" class="headerlink" title="7.5.2 函数名的意义"></a>7.5.2 函数名的意义</h3><ul><li>类型信息</li><li>函数的执行代码的起始位置</li><li>可以通过函数名进行函数调用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go-Core-Programming&quot;&gt;&lt;a href=&quot;#Go-Core-Programming&quot; class=&quot;headerlink&quot; title=&quot;Go Core Programming&quot;&gt;&lt;/a&gt;Go Core Programming&lt;/h1&gt;&lt;h1 i</summary>
      
    
    
    
    
    <category term="Go" scheme="https://zhangzhishun.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go面试题手写内容</title>
    <link href="https://zhangzhishun.github.io/2022/01/16/go/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%8B%E5%86%99/"/>
    <id>https://zhangzhishun.github.io/2022/01/16/go/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%8B%E5%86%99/</id>
    <published>2022-01-16T02:29:15.000Z</published>
    <updated>2022-04-27T02:35:55.484Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/go_interview/GO-r-01.jpg" alt="img"><br><img src="/images/go_interview/GO-r-02.jpg" alt="img"><br><img src="/images/go_interview/GO-r-03.jpg" alt="img"><br><img src="/images/go_interview/GO-r-04.jpg" alt="img"><br><img src="/images/go_interview/GO-r-05.jpg" alt="img"><br><img src="/images/go_interview/GO-r-06.jpg" alt="img"><br><img src="/images/go_interview/GO-r-07.jpg" alt="img"><br><img src="/images/go_interview/GO-r-08.jpg" alt="img"><br><img src="/images/go_interview/GO-r-09.jpg" alt="img"><br><img src="/images/go_interview/GO-r-10.jpg" alt="img"><br><img src="/images/go_interview/GO-r-11.jpg" alt="img"><br><img src="/images/go_interview/GO-r-12.jpg" alt="img"><br><img src="/images/go_interview/GO-r-13.jpg" alt="img"><br><img src="/images/go_interview/GO-r-14.jpg" alt="img"><br><img src="/images/go_interview/GO-r-15.jpg" alt="img"><br><img src="/images/go_interview/GO-r-16.jpg" alt="img"><br><img src="/images/go_interview/GO-r-17.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/go_interview/GO-r-01.jpg&quot; alt=&quot;img&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/go_interview/GO-r-02.jpg&quot; alt=&quot;img&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/go_</summary>
      
    
    
    
    
    <category term="Go" scheme="https://zhangzhishun.github.io/tags/Go/"/>
    
    <category term="面试题" scheme="https://zhangzhishun.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Go面试题</title>
    <link href="https://zhangzhishun.github.io/2022/01/16/go/Go%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://zhangzhishun.github.io/2022/01/16/go/Go%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-01-16T02:29:15.000Z</published>
    <updated>2022-04-27T02:35:55.484Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://geektutu.com/post/qa-golang.html">参考链接</a></p><h1 id="一、Go-语言笔试面试题-基础语法"><a href="#一、Go-语言笔试面试题-基础语法" class="headerlink" title="一、Go 语言笔试面试题(基础语法)"></a>一、Go 语言笔试面试题(基础语法)</h1><h2 id="1-和-的区别？"><a href="#1-和-的区别？" class="headerlink" title="1. = 和 := 的区别？"></a>1. = 和 := 的区别？</h2><p>答案<br>:= 声明+赋值<br>= 仅赋值</p><pre><code class="go">var foo intfoo = 10// 等价于foo := 10</code></pre><h2 id="2-指针的作用？"><a href="#2-指针的作用？" class="headerlink" title="2. 指针的作用？"></a>2. 指针的作用？</h2><p>答案<br>指针用来保存变量的地址。<br>例如</p><pre><code class="go">var x =  5var p *int = &amp;xfmt.Printf("x = %d",  *p) // x 可以用 *p 访问</code></pre><ul><li>运算符，也称为解引用运算符，用于访问地址中的值。<br>＆运算符，也称为地址运算符，用于返回变量的地址。<br>Q3 Go 允许多个返回值吗？<br>答案<br>允许<pre><code>func swap(x, y string) (string, string) { return y, x}</code></pre></li></ul><p>func main() {<br>   a, b := swap(“A”, “B”)<br>   fmt.Println(a, b) // B A<br>}</p><pre><code>## 4. Go 有异常类型吗？答案Go 没有异常类型，只有错误类型（Error），通常使用返回值来表示异常状态。```gof, err := os.Open("test.txt")if err != nil {    log.Fatal(err)}</code></pre><h2 id="5-什么是协程（Goroutine）"><a href="#5-什么是协程（Goroutine）" class="headerlink" title="5. 什么是协程（Goroutine）"></a>5. 什么是协程（Goroutine）</h2><p>答案<br>Goroutine 是与其他函数或方法同时运行的函数或方法。 Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p><h2 id="6-如何高效地拼接字符串"><a href="#6-如何高效地拼接字符串" class="headerlink" title="6. 如何高效地拼接字符串"></a>6. 如何高效地拼接字符串</h2><p>答案<br>Go 语言中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。如果需要拼接多次，应使用 strings.Builder，最小化内存拷贝次数。</p><pre><code class="go">var str strings.Builderfor i := 0; i &lt; 1000; i++ {    str.WriteString("a")}fmt.Println(str.String())</code></pre><h2 id="7-什么是-rune-类型"><a href="#7-什么是-rune-类型" class="headerlink" title="7. 什么是 rune 类型"></a>7. 什么是 rune 类型</h2><p>答案<br>ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。<br>Go 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。例如下面的例子中 语 和 言 使用 UTF-8 编码后各占 3 个 byte，因此 len(“Go语言”) 等于 8，当然我们也可以将字符串转换为 rune 序列。</p><pre><code class="go">fmt.Println(len("Go语言")) // 8fmt.Println(len([]rune("Go语言"))) // 4</code></pre><h2 id="8-如何判断-map-中是否包含某个-key-？"><a href="#8-如何判断-map-中是否包含某个-key-？" class="headerlink" title="8. 如何判断 map 中是否包含某个 key ？"></a>8. 如何判断 map 中是否包含某个 key ？</h2><p>答案</p><pre><code class="go">if val, ok := dict["foo"]; ok {    //do something here}</code></pre><p>dict[“foo”] 有 2 个返回值，val 和 ok，如果 ok 等于 true，则说明 dict 包含 key “foo”，val 将被赋予 “foo” 对应的值。</p><h2 id="9-Go-支持默认参数或可选参数吗？"><a href="#9-Go-支持默认参数或可选参数吗？" class="headerlink" title="9. Go 支持默认参数或可选参数吗？"></a>9. Go 支持默认参数或可选参数吗？</h2><p>答案<br>Go 语言不支持可选参数（python 支持），也不支持方法重载（java支持）。</p><h2 id="10-defer-的执行顺序"><a href="#10-defer-的执行顺序" class="headerlink" title="10. defer 的执行顺序"></a>10. defer 的执行顺序</h2><p>答案<br>多个 defer 语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的 defer 语句，最先得到执行。<br>defer 在 return 语句之后执行，但在函数退出之前，defer 可以修改返回值。<br>例如：</p><pre><code class="go">func test() int {    i := 0    defer func() {        fmt.Println("defer1")    }()    defer func() {        i += 1        fmt.Println("defer2")    }()    return i}func main() {    fmt.Println("return", test())}// defer2// defer1// return 0</code></pre><p>这个例子中，可以看到 defer 的执行顺序：后进先出。但是返回值并没有被修改，这是由于 Go 的返回机制决定的，执行 return 语句后，Go 会创建一个临时变量保存返回值，因此，defer 语句修改了局部变量 i，并没有修改返回值。那如果是有名的返回值呢？</p><pre><code class="go">func test() (i int) {    i = 0    defer func() {        i += 1        fmt.Println("defer2")    }()    return i}func main() {    fmt.Println("return", test())}// defer2// return 1</code></pre><p>这个例子中，返回值被修改了。对于有名返回值的函数，执行 return 语句时，并不会再创建临时变量保存，因此，defer 语句修改了 i，即对返回值产生了影响。<br>Q11 如何交换 2 个变量的值？<br>答案</p><pre><code class="go">a, b := "A", "B"a, b = b, afmt.Println(a, b) // B A</code></pre><h2 id="12-Go-语言-tag-的用处？"><a href="#12-Go-语言-tag-的用处？" class="headerlink" title="12. Go 语言 tag 的用处？"></a>12. Go 语言 tag 的用处？</h2><p>答案<br>tag 可以理解为 struct 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性。<br>例如：</p><pre><code class="go">package mainimport "fmt"import "encoding/json"type Stu struct {    Name string `json:"stu_name"`    ID   string `json:"stu_id"`    Age  int    `json:"-"`}func main() {    buf, _ := json.Marshal(Stu{"Tom", "t001", 18})    fmt.Printf("%s\n", buf)}</code></pre><p>这个例子使用 tag 定义了结构体字段与 json 字段的转换关系，Name -&gt; stu_name, ID -&gt; stu_id，忽略 Age 字段。很方便地实现了 Go 结构体与不同规范的 json 文本之间的转换。</p><h2 id="13-如何判断-2-个字符串切片（slice-是相等的？"><a href="#13-如何判断-2-个字符串切片（slice-是相等的？" class="headerlink" title="13. 如何判断 2 个字符串切片（slice) 是相等的？"></a>13. 如何判断 2 个字符串切片（slice) 是相等的？</h2><p>答案<br>go 语言中可以使用反射 reflect.DeepEqual(a, b) 判断 a、b 两个切片是否相等，但是通常不推荐这么做，使用反射非常影响性能。<br>通常采用的方式如下，遍历比较切片中的每一个元素（注意处理越界的情况）。</p><pre><code class="go">func StringSliceEqualBCE(a, b []string) bool {    if len(a) != len(b) {        return false    }    if (a == nil) != (b == nil) {        return false    }    b = b[:len(a)]    for i, v := range a {        if v != b[i] {            return false        }    }    return true}</code></pre><h2 id="14-字符串打印时，-v-和-v-的区别"><a href="#14-字符串打印时，-v-和-v-的区别" class="headerlink" title="14. 字符串打印时，%v 和 %+v 的区别"></a>14. 字符串打印时，%v 和 %+v 的区别</h2><p>答案<br>%v 和 %+v 都可以用来打印 struct 的值，区别在于 %v 仅打印各个字段的值，%+v 还会打印各个字段的名称。</p><pre><code class="go">type Stu struct {    Name string}func main() {    fmt.Printf("%v\n", Stu{"Tom"}) // {Tom}    fmt.Printf("%+v\n", Stu{"Tom"}) // {Name:Tom}}</code></pre><p>但如果结构体定义了 String() 方法，%v 和 %+v 都会调用 String() 覆盖默认值。</p><h2 id="15-Go-语言中如何表示枚举值-enums"><a href="#15-Go-语言中如何表示枚举值-enums" class="headerlink" title="15. Go 语言中如何表示枚举值(enums)"></a>15. Go 语言中如何表示枚举值(enums)</h2><p>答案<br>通常使用常量(const) 来表示枚举值。</p><pre><code class="go">type StuType int32const (    Type1 StuType = iota    Type2    Type3    Type4)func main() {    fmt.Println(Type1, Type2, Type3, Type4) // 0, 1, 2, 3}</code></pre><p>参考 What is an idiomatic way of representing enums in Go? - StackOverflow</p><h2 id="16-空-struct-的用途"><a href="#16-空-struct-的用途" class="headerlink" title="16. 空 struct{} 的用途"></a>16. 空 struct{} 的用途</h2><p>答案<br>使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。</p><pre><code class="go">fmt.Println(unsafe.Sizeof(struct{}{})) // 0</code></pre><p>比如使用 map 表示集合时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。</p><pre><code class="go">type Set map[string]struct{}func main() {    set := make(Set)    for _, item := range []string{"A", "A", "B", "C"} {        set[item] = struct{}{}    }    fmt.Println(len(set)) // 3    if _, ok := set["A"]; ok {        fmt.Println("A exists") // A exists    }}</code></pre><p>再比如，使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。</p><pre><code class="go">func main() {    ch := make(chan struct{}, 1)    go func() {        &lt;-ch        // do something    }()    ch &lt;- struct{}{}    // ...}</code></pre><p>再比如，声明只包含方法的结构体。</p><pre><code class="go">type Lamp struct{}func (l Lamp) On() {        println("On")}func (l Lamp) Off() {        println("Off")}</code></pre><h1 id="二、Go-语言笔试面试题-实现原理"><a href="#二、Go-语言笔试面试题-实现原理" class="headerlink" title="二、Go 语言笔试面试题(实现原理)"></a>二、Go 语言笔试面试题(实现原理)</h1><h2 id="1-init-函数是什么时候执行的？"><a href="#1-init-函数是什么时候执行的？" class="headerlink" title="1. init() 函数是什么时候执行的？"></a>1. init() 函数是什么时候执行的？</h2><p>答案<br>init() 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。<br>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 init() 函数。同一个包，甚至是同一个源文件可以有多个 init() 函数。init() 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 init() 函数的执行顺序不作保证。<br>一句话总结： import –&gt; const –&gt; var –&gt; init() –&gt; main()<br>示例：</p><pre><code class="go">package mainimport "fmt"func init()  {    fmt.Println("init1:", a)}func init()  {    fmt.Println("init2:", a)}var a = 10const b = 100func main() {    fmt.Println("main:", a)}// 执行结果// init1: 10// init2: 10// main: 10</code></pre><h2 id="2-Go-语言的局部变量分配在栈上还是堆上？"><a href="#2-Go-语言的局部变量分配在栈上还是堆上？" class="headerlink" title="2. Go 语言的局部变量分配在栈上还是堆上？"></a>2. Go 语言的局部变量分配在栈上还是堆上？</h2><p>答案<br>由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。</p><pre><code class="go">func foo() *int {    v := 11    return &amp;v}func main() {    m := foo()    println(*m) // 11}</code></pre><p>foo() 函数中，如果 v 分配在栈上，foo 函数返回时，&amp;v 就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 foo 的作用域，会将其分配在堆上。因此，main 函数中仍能够正常访问该值。</p><h2 id="3-2-个-interface-可以比较吗？"><a href="#3-2-个-interface-可以比较吗？" class="headerlink" title="3. 2 个 interface 可以比较吗？"></a>3. 2 个 interface 可以比较吗？</h2><p>答案<br>Go 语言中，interface 的内部实现包含了 2 个字段，类型 T 和 值 V，interface 可以使用 == 或 != 比较。2 个 interface 相等有以下 2 种情况<br>两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）<br>类型 T 相同，且对应的值 V 相等。<br>看下面的例子：</p><pre><code class="go">type Stu struct {    Name string}type StuInt interface{}func main() {    var stu1, stu2 StuInt = &amp;Stu{"Tom"}, &amp;Stu{"Tom"}    var stu3, stu4 StuInt = Stu{"Tom"}, Stu{"Tom"}    fmt.Println(stu1 == stu2) // false    fmt.Println(stu3 == stu4) // true}</code></pre><p>stu1 和 stu2 对应的类型是 *Stu，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。<br>stu3 和 stu4 对应的类型是 Stu，值是 Stu 结构体，且各字段相等，因此结果为 true。</p><h2 id="4-两个-nil-可能不相等吗？"><a href="#4-两个-nil-可能不相等吗？" class="headerlink" title="4. 两个 nil 可能不相等吗？"></a>4. 两个 nil 可能不相等吗？</h2><p>答案<br>可能。<br>接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 T 和 值 V。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。<br>两个接口值比较时，会先比较 T，再比较 V。<br>接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。</p><pre><code class="go">func main() {    var p *int = nil    var i interface{} = p    fmt.Println(i == p) // true    fmt.Println(p == nil) // true    fmt.Println(i == nil) // false}</code></pre><p>上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为(T=*int, V=nil)，i 与 p 作比较时，将 p 转换为接口后再比较，因此 i == p，p 与 nil 比较，直接比较值，所以 p == nil。<br>但是当 i 与 nil 比较时，会将 nil 转换为接口 (T=nil, V=nil)，与i (T=*int, V=nil) 不相等，因此 i != nil。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。</p><h2 id="5-简述-Go-语言GC-垃圾回收-的工作原理"><a href="#5-简述-Go-语言GC-垃圾回收-的工作原理" class="headerlink" title="5. 简述 Go 语言GC(垃圾回收)的工作原理"></a>5. 简述 Go 语言GC(垃圾回收)的工作原理</h2><p>答案<br>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。<br>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：<br>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；<br>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。<br>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。<br>三色标记算法将程序中的对象分成白色、黑色和灰色三类。<br>白色：不确定对象。<br>灰色：存活对象，子对象待处理。<br>黑色：存活对象。<br>标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。<br>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。<br>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p><pre><code>A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)</code></pre><p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p><pre><code>A (黑) -&gt; B (灰) -&gt; C (白)   ↓ D (白)</code></pre><p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。<br>一次完整的 GC 分为四个阶段：<br>1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)<br>2）使用三色标记法标记（Marking, 并发）<br>3）标记结束(Mark Termination，需 STW)，关闭写屏障。<br>4）清理(Sweeping, 并发)<br>参考 fullstack</p><h2 id="6-函数返回局部变量的指针是否安全？"><a href="#6-函数返回局部变量的指针是否安全？" class="headerlink" title="6. 函数返回局部变量的指针是否安全？"></a>6. 函数返回局部变量的指针是否安全？</h2><p>答案<br>这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。</p><h2 id="7-非接口非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？"><a href="#7-非接口非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？" class="headerlink" title="7. 非接口非接口的任意类型 T() 都能够调用 *T 的方法吗？反过来呢？"></a>7. 非接口非接口的任意类型 T() 都能够调用 *T 的方法吗？反过来呢？</h2><p>答案<br>一个T类型的值可以调用为<em>T类型声明的方法，但是仅当此T的值是可寻址(addressable) 的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型</em>T声明的方法。<br>反过来，一个<em>T类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 T 声明的方法，编译器都会为类型</em>T自动隐式声明一个同名和同签名的方法。<br>哪些值是不可寻址的呢？<br>字符串中的字节；<br>map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）；<br>常量；<br>包级别的函数等。<br>举一个例子，定义类型 T，并为类型 *T 声明一个方法 hello()，变量 t1 可以调用该方法，但是常量 t2 调用该方法时，会产生编译错误。</p><pre><code class="go">type T stringfunc (t *T) hello() {    fmt.Println("hello")}func main() {    var t1 T = "ABC"    t1.hello() // hello    const t2 T = "ABC"    t2.hello() // error: cannot call pointer method on t}</code></pre><h1 id="三、Go-语言笔试面试题-并发编程"><a href="#三、Go-语言笔试面试题-并发编程" class="headerlink" title="三、Go 语言笔试面试题(并发编程)"></a>三、Go 语言笔试面试题(并发编程)</h1><h2 id="1-无缓冲的-channel-和-有缓冲的-channel-的区别？"><a href="#1-无缓冲的-channel-和-有缓冲的-channel-的区别？" class="headerlink" title="1. 无缓冲的 channel 和 有缓冲的 channel 的区别？"></a>1. 无缓冲的 channel 和 有缓冲的 channel 的区别？</h2><p>答案<br>对于无缓冲的 channel，发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。<br>对于有缓存的 channel，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。<br>例如:</p><pre><code class="go">func main() {    st := time.Now()    ch := make(chan bool)    go func ()  {        time.Sleep(time.Second * 2)        &lt;-ch    }()    ch &lt;- true  // 无缓冲，发送方阻塞直到接收方接收到数据。    fmt.Printf("cost %.1f s\n", time.Now().Sub(st).Seconds())    time.Sleep(time.Second * 5)}</code></pre><pre><code class="go">func main() {    st := time.Now()    ch := make(chan bool, 2)    go func ()  {        time.Sleep(time.Second * 2)        &lt;-ch    }()    ch &lt;- true    ch &lt;- true // 缓冲区为 2，发送方不阻塞，继续往下执行    fmt.Printf("cost %.1f s\n", time.Now().Sub(st).Seconds()) // cost 0.0 s    ch &lt;- true // 缓冲区使用完，发送方阻塞，2s 后接收方接收到数据，释放一个插槽，继续往下执行    fmt.Printf("cost %.1f s\n", time.Now().Sub(st).Seconds()) // cost 2.0 s    time.Sleep(time.Second * 5)}</code></pre><h2 id="2-什么是协程泄露-Goroutine-Leak-？"><a href="#2-什么是协程泄露-Goroutine-Leak-？" class="headerlink" title="2. 什么是协程泄露(Goroutine Leak)？"></a>2. 什么是协程泄露(Goroutine Leak)？</h2><p>答案<br>协程泄露是指协程创建后，长时间得不到释放，并且还在不断地创建新的协程，最终导致内存耗尽，程序崩溃。常见的导致协程泄露的场景有以下几种：<br>缺少接收器，导致发送阻塞<br>这个例子中，每执行一次 query，则启动1000个协程向信道 ch 发送数字 0，但只接收了一次，导致 999 个协程被阻塞，不能退出。</p><pre><code class="go">func query() int {    ch := make(chan int)    for i := 0; i &lt; 1000; i++ {        go func() { ch &lt;- 0 }()    }    return &lt;-ch}func main() {    for i := 0; i &lt; 4; i++ {        query()        fmt.Printf("goroutines: %d\n", runtime.NumGoroutine())    }}// goroutines: 1001// goroutines: 2000// goroutines: 2999// goroutines: 3998</code></pre><p>缺少发送器，导致接收阻塞<br>那同样的，如果启动 1000 个协程接收信道的信息，但信道并不会发送那么多次的信息，也会导致接收协程被阻塞，不能退出。<br>死锁(dead lock)<br>两个或两个以上的协程在执行过程中，由于竞争资源或者由于彼此通信而造成阻塞，这种情况下，也会导致协程被阻塞，不能退出。<br>无限循环(infinite loops)<br>这个例子中，为了避免网络等问题，采用了无限重试的方式，发送 HTTP 请求，直到获取到数据。那如果 HTTP 服务宕机，永远不可达，导致协程不能退出，发生泄漏。</p><pre><code class="go">func request(url string, wg *sync.WaitGroup) {    i := 0    for {        if _, err := http.Get(url); err == nil {            // write to db            break        }        i++        if i &gt;= 3 {            break        }        time.Sleep(time.Second)    }    wg.Done()}func main() {    var wg sync.WaitGroup    for i := 0; i &lt; 1000; i++ {        wg.Add(1)        go request(fmt.Sprintf("https://127.0.0.1:8080/%d", i), &amp;wg)    }    wg.Wait()}</code></pre><h2 id="3-Go-可以限制运行时操作系统线程的数量吗？"><a href="#3-Go-可以限制运行时操作系统线程的数量吗？" class="headerlink" title="3. Go 可以限制运行时操作系统线程的数量吗？"></a>3. Go 可以限制运行时操作系统线程的数量吗？</h2><p>答案<br>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit.<br>可以使用环境变量 GOMAXPROCS 或 runtime.GOMAXPROCS(num int) 设置，例如：</p><pre><code class="go">runtime.GOMAXPROCS(1) // 限制同时执行Go代码的操作系统线程数为 1</code></pre><p>从官方文档的解释可以看到，GOMAXPROCS 限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。GOMAXPROCS 的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I/O 密集型应用，适当地调大该值，可以提高 I/O 吞吐率。</p><h1 id="三、Go-语言笔试面试题-代码输出"><a href="#三、Go-语言笔试面试题-代码输出" class="headerlink" title="三、Go 语言笔试面试题(代码输出)"></a>三、Go 语言笔试面试题(代码输出)</h1><h2 id="1-常量与变量"><a href="#1-常量与变量" class="headerlink" title="1. 常量与变量"></a>1. 常量与变量</h2><h3 id="1-1-下列代码的输出是："><a href="#1-1-下列代码的输出是：" class="headerlink" title="1.1 下列代码的输出是："></a>1.1 下列代码的输出是：</h3><pre><code class="go">func main() {    const (        a, b = "golang", 100        d, e        f bool = true        g    )    fmt.Println(d, e, g)}</code></pre><p>答案<br>golang 100 true<br>在同一个 const group 中，如果常量定义与前一行的定义一致，则可以省略类型和值。编译时，会按照前一行的定义自动补全。即等价于</p><pre><code class="go">func main() {    const (        a, b = "golang", 100        d, e = "golang", 100        f bool = true        g bool = true    )    fmt.Println(d, e, g)}</code></pre><h3 id="1-2-下列代码的输出是："><a href="#1-2-下列代码的输出是：" class="headerlink" title="1.2 下列代码的输出是："></a>1.2 下列代码的输出是：</h3><pre><code class="go">func main() {    const N = 100    var x int = N    const M int32 = 100    var y int = M    fmt.Println(x, y)}</code></pre><p>答案<br>编译失败：cannot use M (type int32) as type int in assignment<br>Go 语言中，常量分为无类型常量和有类型常量两种，const N = 100，属于无类型常量，赋值给其他变量时，如果字面量能够转换为对应类型的变量，则赋值成功，例如，var x int = N。但是对于有类型的常量 const M int32 = 100，赋值给其他变量时，需要类型匹配才能成功，所以显示地类型转换：</p><pre><code class="go">var y int = int(M)</code></pre><h3 id="1-3-下列代码的输出是："><a href="#1-3-下列代码的输出是：" class="headerlink" title="1.3 下列代码的输出是："></a>1.3 下列代码的输出是：</h3><pre><code class="go">func main() {    var a int8 = -1    var b int8 = -128 / a    fmt.Println(b)}</code></pre><p>答案<br>-128<br>int8 能表示的数字的范围是 [-2^7, 2^7-1]，即 [-128, 127]。-128 是无类型常量，转换为 int8，再除以变量 -1，结果为 128，常量除以变量，结果是一个变量。变量转换时允许溢出，符号位变为1，转为补码后恰好等于 -128。<br>对于有符号整型，最高位是是符号位，计算机用补码表示负数。补码 = 原码取反加一。<br>例如：</p><pre><code>-1 :  1111111100000001(原码)    11111110(取反)    11111111(加一)-128：    10000000(原码)    01111111(取反)    10000000(加一)-1 + 1 = 011111111 + 00000001 = 00000000(最高位溢出省略)-128 + 127 = -110000000 + 01111111 = 11111111</code></pre><h3 id="1-4-下列代码的输出是："><a href="#1-4-下列代码的输出是：" class="headerlink" title="1.4 下列代码的输出是："></a>1.4 下列代码的输出是：</h3><pre><code class="go">func main() {    const a int8 = -1    var b int8 = -128 / a    fmt.Println(b)}</code></pre><p>答案<br>编译失败：constant 128 overflows int8<br>-128 和 a 都是常量，在编译时求值，-128 / a = 128，两个常量相除，结果也是一个常量，常量类型转换时不允许溢出，因而编译失败。</p><h2 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h2><h3 id="2-1-下列代码的输出是："><a href="#2-1-下列代码的输出是：" class="headerlink" title="2.1 下列代码的输出是："></a>2.1 下列代码的输出是：</h3><pre><code class="go">func main() {    var err error    if err == nil {        err := fmt.Errorf("err")        fmt.Println(1, err)    }    if err != nil {        fmt.Println(2, err)    }}</code></pre><p>答案<br>1 err<br>:= 表示声明并赋值，= 表示仅赋值。<br>变量的作用域是大括号，因此在第一个 if 语句 if err == nil 内部重新声明且赋值了与外部变量同名的局部变量 err。对该局部变量的赋值不会影响到外部的 err。因此第二个 if 语句 if err != nil 不成立。所以只打印了 1 err。</p><h2 id="3-defer-延迟调用"><a href="#3-defer-延迟调用" class="headerlink" title="3. defer 延迟调用"></a>3. defer 延迟调用</h2><h3 id="3-1-下列代码的输出是："><a href="#3-1-下列代码的输出是：" class="headerlink" title="3.1 下列代码的输出是："></a>3.1 下列代码的输出是：</h3><pre><code class="go">type T struct{}func (t T) f(n int) T {    fmt.Print(n)    return t}func main() {    var t T    defer t.f(1).f(2)    fmt.Print(3)}</code></pre><p>答案<br>132<br>defer 延迟调用时，需要保存函数指针和参数，因此链式调用的情况下，除了最后一个函数/方法外的函数/方法都会在调用时直接执行。也就是说 t.f(1) 直接执行，然后执行 fmt.Print(3)，最后函数返回时再执行 .f(2)，因此输出是 132。</p><h3 id="3-2-下列代码的输出是："><a href="#3-2-下列代码的输出是：" class="headerlink" title="3.2 下列代码的输出是："></a>3.2 下列代码的输出是：</h3><pre><code class="go">func f(n int) {    defer fmt.Println(n)    n += 100}func main() {    f(1)}</code></pre><p>答案<br>1<br>打印 1 而不是 101。defer 语句执行时，会将需要延迟调用的函数和参数保存起来，也就是说，执行到 defer 时，参数 n(此时等于1) 已经被保存了。因此后面对 n 的改动并不会影响延迟函数调用的结果。</p><h3 id="3-3-下列代码的输出是："><a href="#3-3-下列代码的输出是：" class="headerlink" title="3.3 下列代码的输出是："></a>3.3 下列代码的输出是：</h3><pre><code class="go">func main() {    n := 1    defer func() {        fmt.Println(n)    }()    n += 100}</code></pre><p>答案<br>101<br>匿名函数没有通过传参的方式将 n 传入，因此匿名函数内的 n 和函数外部的 n 是同一个，延迟执行时，已经被改变为 101。</p><h3 id="3-4-下列代码的输出是："><a href="#3-4-下列代码的输出是：" class="headerlink" title="3.4 下列代码的输出是："></a>3.4 下列代码的输出是：</h3><pre><code class="go">func main() {    n := 1    if n == 1 {        defer fmt.Println(n)        n += 100    }    fmt.Println(n)}</code></pre><p>答案<br>1<br>2<br>101<br>1<br>先打印 101，再打印 1。defer 的作用域是函数，而不是代码块，因此 if 语句退出时，defer 不会执行，而是等 101 打印后，整个函数返回时，才会执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://geektutu.com/post/qa-golang.html&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、Go-语言笔试面试题-基础语法&quot;&gt;&lt;a href=&quot;#一、Go-语言笔试面试题-基础语法&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="Go" scheme="https://zhangzhishun.github.io/tags/Go/"/>
    
    <category term="面试题" scheme="https://zhangzhishun.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>论文下载</title>
    <link href="https://zhangzhishun.github.io/2022/01/12/other/%E8%AE%BA%E6%96%87%E4%B8%8B%E8%BD%BD/"/>
    <id>https://zhangzhishun.github.io/2022/01/12/other/%E8%AE%BA%E6%96%87%E4%B8%8B%E8%BD%BD/</id>
    <published>2022-01-12T02:25:11.000Z</published>
    <updated>2022-04-27T02:35:55.484Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="https://www.scidown.cn/">scidown</a></li><li><a href="https://doi.qqsci.com/">企鹅论文</a></li><li><a href="https://tool.yovisun.com/scihub/">sci-hub</a></li><li><a href="http://www.5638.org/">科研宝库</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.scidown.cn/&quot;&gt;scidown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doi.qqsci.com/&quot;&gt;企鹅论文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tool.yov</summary>
      
    
    
    
    
    <category term="Other" scheme="https://zhangzhishun.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>论文翻译</title>
    <link href="https://zhangzhishun.github.io/2022/01/12/other/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    <id>https://zhangzhishun.github.io/2022/01/12/other/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</id>
    <published>2022-01-12T02:25:11.000Z</published>
    <updated>2022-04-27T02:35:55.484Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="https://www.onlinedoctranslator.com/">DocTranslator</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.onlinedoctranslator.com/&quot;&gt;DocTranslator&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    
    <category term="Other" scheme="https://zhangzhishun.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>共识算法</title>
    <link href="https://zhangzhishun.github.io/2022/01/08/blockchain/consensus/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://zhangzhishun.github.io/2022/01/08/blockchain/consensus/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-08T06:25:01.000Z</published>
    <updated>2022-04-28T06:15:52.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ol><li>拜占庭将军问题概述</li><li>共识算法定义(作用)</li><li>共识算法种类</li><li>共识算法优缺点对比以及应用</li></ol><h1 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h1><p>莱斯利·兰波特在其论文中描述了如下问题：</p><blockquote><p>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</p></blockquote><p>系统的问题在于，可能将军中出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。</p><p>上述的故事映射到计算机系统里便是：</p><p>在分布式系统中存在恶意的计算机节点，这些节点会选择性响应某些请求或篡改系统中的数据。 那么<font color="red">在上述不可靠的信道上，系统中所有非恶意节点如何通过消息传递达成共识？</font></p><h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><h2 id="定义-作用"><a href="#定义-作用" class="headerlink" title="定义(作用)"></a>定义(作用)</h2><p>共识算法<font color="red">使高度分散且彼此不信任的网络环境中的节点就某个事务达成一致且不分叉</font></p><p>按拜占庭容错性分类：</p><ol><li><p>容忍非拜占庭错误（CTF）：容忍网络环境中存在故障节点但不存在恶意节点</p></li><li><p>容忍拜占庭错误（BFT）：容忍网络环境中同时存在故障节点和恶意节点</p></li></ol><h2 id="算法需满足的条件"><a href="#算法需满足的条件" class="headerlink" title="算法需满足的条件"></a>算法需满足的条件</h2><p>FLP不可能问题：在异步网络中，哪怕只有一个节点故障也不可能存在能够容忍节点故障的一致性算法。</p><p>需满足的约束条件：</p><ol><li><strong>消息安全</strong>：节点件必须采用非对称加密对消息进行签名保证消息可传递（不可用对称加密，因为信道不安全）</li><li><strong>处理FLP不可能问题</strong>：设置消息最大时延</li><li><strong>共识结论合法</strong>：结论必须是一个节点的提案</li></ol><h2 id="算法详情"><a href="#算法详情" class="headerlink" title="算法详情"></a>算法详情</h2><h3 id="Paxos（CTF）"><a href="#Paxos（CTF）" class="headerlink" title="Paxos（CTF）"></a>Paxos（CTF）</h3><ol><li><p>概念</p><p>Paxos原理基于<font color="red">“两阶段提交”</font>算法并进行泛化和扩展，通过消息传递来逐步消除系统中的不确定状态，是Raft、ZAB设计的基础</p><p>Paxos角色：</p><ul><li><strong>提案者（Proposer）</strong>：提出一个提案等待大家批准为结案（value）</li><li><strong>接受者（Acceptor）</strong>：对提案进行投票，接受提案</li><li><strong>学习者（Learner）</strong>：获取批准结果，不参与投票</li></ul></li><li><p>共识过程</p><p><img src="/images/consensus/paxos_flow_chart.png" alt="img.png"><br>pok：收到提议请求； aok：收到提交请求；最大提案编号：MaxN；AcceptN：接收到的提案编号； AcceptV：接收到的提案值；</p></li><li><p>举例说明 假设集群中有2个Proposer、3个Acceptor、1个Learner</p><ul><li>有两个Proposer，两个都提出 prepare request。来自 Proposer A的 request 先于Proposer B 的 request 到达 Acceptor X和 Acceptor Y， 但来自Proposer B的 request 首先到达 Proposer Z.<br><img src="/images/consensus/paxos_prepare1.png" alt="img.png"></li><li>如果接收（accept）prepare request 的 Acceptor 之前没有看到其他的提议，则 Acceptor 以 prepare response 作出响应， 该 prepare response承诺永远不接受具有较低提议编号的另一提议。<br><img src="/images/consensus/paxos_prepare2.png" alt="img.png"></li><li>Acceptor Z收到了 Proposer A 的 request ，Acceptor X和 Acceptor Y收到了 Proposer B的 request 。 如果 Proposer 之前已经看到具有更高提议号的request ，则忽略晚到的 request，如Acceptor Z将忽略 Proposer A的 request（因为2&lt;4）。 如果 Proposer 之前没有看到更高编号的 request，它再次承诺忽略具有较低提议编号的任何请求，并发回其已接受的编号最高的提议以及该提议的值。 如 Acceptor X和Y 对Proposer B的 request 的做法。<br><img src="/images/consensus/paxos_prepare3.png" alt="img.png"></li><li>一旦 Proposer 收到大多数 Acceptor 的准备响应，它就可以发出接受请求<ul><li>对于Proposer A：由于 Proposer A仅收到表明没有先前提案的答复， 因此它向每个具有与其初始提案相同的提议编号和值的 Acceptor 发送 accept request（n = 2，v = 8）。然而，这些 request 都将被忽略，因为目标 Acceptor 都承诺不接受的提议编号低于4 的 request（这是对 Proposer B 的承诺）</li><li>对于Proposer B：Proposer B 向每个 Acceptor 发送 accept request ， 该 request 包含先前使用的提议号（n = 4）以及与其接收的准备响应消息中的最高提议号相关联的值（v = 8）。 请注意，这不是 Proposer B 最初提出的值，而是它看到的 prepare response 消息中的最高值。<br><img src="/images/consensus/paxos_accept1.png" alt="img.png"></li></ul></li><li>如果 Acceptor accept 的 accept request 的 编号 比其已经看到的更高或相等，则它会 accept 并向每个 Learner 节点发送通知。 当 Learner 发现大多数 Acceptor已接受某个值时，Paxos算法会选择该值<br><img src="/images/consensus/paxos_sync1.png" alt="img.png"></li><li>一旦Paxos选择了一个值，与其他 Proposer 的进一步沟通就无法改变这个值。 如果另一个 Proposer（如 Proposer C）发送的 request 的 提案号比之前看到的提案号更高，并且具有不同的值（例如，n= 6，v = 7）， 则每个接受者都会使用之前的最高提案进行响应（n = 4，v = 8）。这要求提议者C发送包含[n = 6，v = 8] 的接受请求，该请求仅确认已经选择的值。此外，如果一些少数接受者还没有选择一个价值，这个过程可以确保他们最终就同一价值达成共识。 （批注，这个过程总是成立的，具体论证过程见上）</li></ul></li></ol><h3 id="Raft（CTF）"><a href="#Raft（CTF）" class="headerlink" title="Raft（CTF）"></a>Raft（CTF）</h3><ol><li><p>概念</p><p>Raft相比Paxos是一种旨在<font color="red">易于理解</font>的共识算法。</p><p>Raft角色：</p><ul><li><strong>领导者（Leader）</strong></li><li><strong>候选领导者（Candidate）</strong></li><li><strong>跟随者（Follower）</strong></li></ul></li><li><p>共识过程</p><p><a href="http://www.kailing.pub/raft/index.html">Raft演示地址</a></p><p>主要阶段：</p><ul><li><strong>Leader选举</strong></li><li><strong>同步日志</strong></li></ul></li></ol><h3 id="PoW（BFT）"><a href="#PoW（BFT）" class="headerlink" title="PoW（BFT）"></a>PoW（BFT）</h3><ol><li><p>概念</p><p>POW <font color="red">工作量证明共识机制</font>，系统通过让所有节点公平地去计算一个随机数，最先寻找到随机数的节点即拥有记账权</p></li><li><p>比特币共识过程</p><ul><li>客户端发起交易广播到网络中等待确认</li><li>网络中的用户将所有等待确认的交易打包到一个区块链中</li><li><strong>不断修改区块头中的Nonce值以使该区块头的hash值小于一个特定的目标值</strong></li><li>计算出Nonce后向全网广播</li><li>网络中收到提案区块的节点对Nonce进行验证，验证合法交易被确认，该块加入链</li></ul></li></ol><h3 id="PoS（BFT）"><a href="#PoS（BFT）" class="headerlink" title="PoS（BFT）"></a>PoS（BFT）</h3><p>权益证明机制，是为解决PoW算法大量浪费资源问题而提出的一种替代算法，该算法中区块的记账权<font color="red">由权益最高的节点获得</font></p><h3 id="DPoS（BFT）"><a href="#DPoS（BFT）" class="headerlink" title="DPoS（BFT）"></a>DPoS（BFT）</h3><ol><li><p>概念</p><p>股份授权证明机制，是PoS的一种衍生算法，算法的思想是<font color="red">系统中持有权益的节点投票选举出一部分代表，再由这些代表轮流获取区块链记账权</font>，类似于股份制公司的“董事会”</p></li><li><p>共识过程</p><ul><li>每个节点将自己持有的权益转换为选票投给自己信任的节点</li><li>选票最多的N个节点当选为见证人（Witness），即代表</li><li>见证人在一个规定时间内随机排列并轮流对交易打包，生成新区块连接到最长链，见证人收获m％的交易手续费</li></ul></li></ol><h3 id="PBFT（BFT）"><a href="#PBFT（BFT）" class="headerlink" title="PBFT（BFT）"></a>PBFT（BFT）</h3><ol><li><p>概念</p><p><font color="red">PBFT在保证可用性和安全性的前提下，提供了(n-1)/3的容错性</font>，意思就是如果系统内有n个节点，那么系统最多能容忍的作恶/故障节点为(n-1)/3个。（作恶节点可以不响应或者回应错误的信息）</p></li><li><p>共识过程</p><p>​    <img src="/images/consensus/pbft_flow_chart.png" alt="共识算法系列：PBFT算法关键点综述、优缺点总结"></p><p>定义：</p><ul><li><p>f：恶意节点</p></li><li><p>Digest(m)：消息摘要</p></li></ul><p>过程：</p><ul><li><strong>预准备阶段</strong>：发送原本的消息m，让每个节点都获取原始消息</li><li><strong>准备阶段</strong>：用Digest(m)去发送，如果一个节点收到<strong>2f+1</strong>个prepare消息，就认为准备阶段结束，说明已经有大部分节点认同了这个m</li><li><strong>提交阶段</strong>：用Digest(m)去发送，如果一个节点收到<strong>2f+1</strong>个commit，那么就可以认为，就说明已经有大多数节点“执行”了这些m，这个阶段主要是为了View Change服务</li><li><strong>回执阶段</strong>：提交结束后将结果返回给客户端，客户端收到至少<strong>f+1</strong>个消息即可确认</li></ul></li></ol><h3 id="DBFT（BFT）"><a href="#DBFT（BFT）" class="headerlink" title="DBFT（BFT）"></a>DBFT（BFT）</h3><ol><li><p>概念</p><p>授权拜占庭容错，系统中的代币持有者<font color="red">通过投票选举出自己所支持的共识节点，这些选出来的共识节点再通过BFT来达成共识并生成区块</font></p></li><li><p>共识过程</p><p><img src="/images/consensus/dbft_flow_chart.png" alt="image-20220108234438067"></p><p>过程：</p><ul><li>节点<strong>投票</strong>选出一定数量的共识节点</li><li>议长设置视图并广播提案<code>&lt;PrepareRequest&gt;</code>消息</li><li>议员收到提案对其验证，验证通过后议员向全网发送<code>&lt;PrepareResponse&gt;</code>消息</li><li>当收到n-f条<code>&lt;PrepareResponse&gt;</code>消息时，议员们发布一个新的区块，对区块签名，发送给其他节点进行同步<code>&lt;Synchronization&gt;</code></li><li>其他节点收到完整区块后达到相同的区块高度，清除本地内存中所存储的当前视图交易数据，准备下一次共识</li></ul></li></ol><h2 id="算法优缺点与应用"><a href="#算法优缺点与应用" class="headerlink" title="算法优缺点与应用"></a>算法优缺点与应用</h2><table><thead><tr><th>算法</th><th>优点</th><th>缺点</th><th>应用</th></tr></thead><tbody><tr><td>Paxos</td><td>- 容忍非拜占庭错误节点能力高<br>- 性能高</td><td>- 算法难以理解<br>- 不能容忍拜占庭错误节点</td><td>ZooKeeper、GoogleChubby</td></tr><tr><td>Raft</td><td>- 算法容忍非拜占庭错误节点能力高<br>- 性能高<br>- 易于理解和实现</td><td>- 不能容忍拜占庭错误节点</td><td>IPFS Private Cluster、R3 CodaQuorum</td></tr><tr><td>Pow</td><td>- 算法逻辑简单<br>- 安全性高<br>- 容错性高</td><td>- 资源消耗过高<br>- 系统吞吐量低</td><td>Bitcoin、Ethereum、Dogcoin、Litecoin、Zcash</td></tr><tr><td>PoS</td><td>- 缓解PoW资源浪费问题<br>- 相对PoW提高了出块速度</td><td>- 易出现持币人屯币现象，造成寡头优势</td><td>Blackcoin、ADA、Peercoin、Casper、Nxt</td></tr><tr><td>DPoS</td><td>- 解决了PoW资源浪费问题<br>- 性能较高<br>- 出块速度较快</td><td>- 相比其他算法该算法趋于中心化<br>- 投票无门槛，权益余额大票数越大，易造成联合选举行为</td><td>EOS、Bitshares、Steemit、Lisk、Ark、GXChain、ASCH</td></tr><tr><td>PBFT</td><td>- 无代币<br>- 性能效率高<br>- 安全性高</td><td>- 确认流程过多，通信开销大<br>- 无法避免恶意节点担任主节点<br>- 节点不可进行动态增删<br>- 无法承受大规模节点</td><td>Fabric</td></tr><tr><td>DBFT</td><td>- 借鉴DPoS，参与共识节点数量较少，因此提高了性能</td><td>- 相比其他算法该算法趋于中心化</td><td>NEO</td></tr></tbody></table><h1 id="引发思考"><a href="#引发思考" class="headerlink" title="引发思考"></a>引发思考</h1><ol><li><p>PBFT在节点数超过100后性能继续下降，如何缓解？</p><ul><li><p>方法一：带宽优化：</p><ul><li>客户端将请求发给任意节点，而不是只发给主节点，然后节点直接将请求广播给所有节点</li><li>设计共享交易池，预先进行交易的广播，仅共识交易哈希值主节点打包交易hash，广播包含hash的提案消息，而不是广播交易数据</li><li>从节点在提交之前主动向主节点获取可能缺失的交易，最终提交之前确认交易合法性</li></ul><p><img src="/images/consensus/pbft_bandwidth_optimization.png" alt="image-20220109102820146"></p></li><li><p>方法二：BFT问题转换成CFT问题，即规避拜占庭行为</p><p><img src="/images/consensus/fast_bft_flow_chart.png" alt="image-20220109104150146"></p></li><li><p>方法三：点对点网络转换为星型网络</p><p><img src="/images/consensus/hot_stuff_flow_chart.png" alt="image-20220109104400275"></p></li></ul></li><li><p>PBFT无法动态增删节点，如何解决？</p><p>先请求分布式CA，再通过配置交易的方式，准入与删除共识节点</p><p><img src="/images/consensus/pbft_add_delete_node.png" alt="image-20220109103818671"></p></li><li><p>PBFT中prepare和commit阶段为何都要2f+1个节点反馈确认?（这2f+1节点反馈的结果并不一定是相同的）</p><p>对于prepare和commit来说，节点需要在2f+1个状态复制机的沟通内就要做出决定，这是刚好可以保证一致性的，考虑最坏的情况：我们假设收到的有f个是正常节点发过来的，也有f个是恶意节点发过来的，那么，第2f+1个只可能是正常节点发过来的。（因为我们限制了最多只有f个恶意节点）由此可知，“大多数”正常的节点还是可以让系统工作下去的。所以2f+1这个参数和n&gt;3f+1的要求是逻辑自洽的。</p></li><li><p>PBFT中client为何只需要f+1个相同的回复就可确认？</p><p>之前我们说，prepare和commit阶段为何都要2f+1个节点反馈，才能确认。client只需要f+1个相同的reply就可以了呢？我们还是来考虑最坏的情况，我们假设这f+1个相同的reply中，有f个都是恶意节点。</p><p>所以至少有一个rely是正常节点发出来的，因为在prepare阶段，这个正常的节点已经可以保证prepared(m,v,n,i)为真，所以已经能代表大多数的意见，所以，client只需要f+1个相同的reply就能保证他拿到的是整个系统内“大多数正常节点“的意见，从而达到一致性。</p></li><li><p>PBFT中如果primary是恶意节点呢？</p><p>对于一致性，我们可以这么看：如果prepared(m，v，n，i)为真，那么prepared(m’，v，n，j)一定是错误的，因为对于同一个提案我们不可能有两种结果，从而保证整个系统的一致性。</p><p>假设primary节点是恶意的，那么意味着在replicas节点中⾄多有f-1个恶意的节点，prepared(m，v，n，i)为真，则证明有f+1个善意节点达成了了⼀致，prepared(m’，v，n，j)为真，意味着另外f+1个善意节点达成了一致，因为系统中只有2f+1个善意节点，因此最少有⼀个善意节点发送了两个冲突的prepare消息，这是不可能的。所以prepared(m，v，n，i)为真，那么prepared(m’，v，n，j)是错误的。</p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://b23.tv/c2IGPiA">李永乐老师讲解拜占庭将军问题</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">维基百科对拜占庭将军问题的解释</a></li><li><a href="https://blog.csdn.net/alinyua/article/details/86153013">Paxos学习笔记及图解</a></li><li><a href="https://pmg.csail.mit.edu/papers/osdi99.pdf">PBFT提出者论文《Practical Byzantine Fault Tolerance》</a></li><li><a href="https://zhuanlan.zhihu.com/p/53897982">共识算法系列：PBFT算法关键点综述、优缺点总结</a></li><li><a href="http://www.jsjkx.com/CN/article/openArticlePDF.jsp?id=19169">区块链共识算法对比研究</a></li><li><a href="https://www.modb.pro/doc/42136">联盟区块链共识算法的实践与挑战 - 端豪 杭州趣链科技架构师</a></li><li><a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf">Paxos论文</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;拜占庭将军问题概述&lt;/li&gt;
&lt;li&gt;共识算法定义(作用)&lt;/li&gt;
&lt;li&gt;共识算法种类&lt;/li&gt;
&lt;li&gt;共</summary>
      
    
    
    
    
    <category term="共识算法" scheme="https://zhangzhishun.github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
